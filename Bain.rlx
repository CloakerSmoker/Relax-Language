DllImport i64 GetCurrentProcess() {Kernel32.dll, GetCurrentProcess}
DllImport void TerminateProcess(i64, i32) {Kernel32.dll, TerminateProcess}

define void Exit(i32 ExitCode) {
	TerminateProcess(GetCurrentProcess(), ExitCode)
}

#Include Memory.rlx
#Include String.rlx
#Include Console.rlx
#Include SafeString.rlx
#Include HashMap.rlx

declare i16* OpenAndRead(i16*, i32*)

#Include Lexer.rlx
#Include Parser.rlx

DllImport i32 GetLastError() {Kernel32.dll, GetLastError}
DllImport i8 CloseHandle(i64) {Kernel32.dll, CloseHandle}

#Include PEBuilder.rlx
#Include ELFBuilder.rlx
#Include Compiler.rlx

DllImport i64 CreateFile(i16*, i32, i32, void*, i32, i32, i64) {Kernel32.dll, CreateFileW}
DllImport i32 GetFileSize(i64, void) {Kernel32.dll, GetFileSize}
DllImport i8 ReadFile(i64, void*, i32, i32*, void) {Kernel32.dll, ReadFile}

define i16* OpenAndRead(i16* FilePath, i32* OutFileSize) {
	i64 GENERIC_READ := 0x80000000
	i8 FILE_SHARE_READ := 1
	i8 FILE_SHARE_WRITE := 2
	i8 OPEN_EXISTING := 3
	i16 FILE_ATTRIBUTE_NORMAL := 128
	
	i64 FileHandle := CreateFile(FilePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)
	
	if (FileHandle = -1) {
		SwapOutputStream()
		AWrite("Could not open file: ")
		WriteLine(FilePath)
		
		AWrite("Error code: ")
		IWriteLine(GetLastError())
		
		AWriteLine("Aborting")
		Exit(1)
	}
	
	i32 FileSize := GetFileSize(FileHandle, 0)
	
	if (OutFileSize != 0) {
		OutFileSize[0] := FileSize
	}
	
	void* FileBuffer := Alloc(FileSize)
	
	i32 ReadFileBytesRead := 0
	i8 ReadFileSuccess := ReadFile(FileHandle, FileBuffer, FileSize, &ReadFileBytesRead, 0)
	
	if (!(ReadFileSuccess) || ReadFileBytesRead != FileSize) {
		SwapOutputStream()
		AWrite("Could not read file: ")
		WriteLine(FilePath)
		
		AWrite("Error code: ")
		IWriteLine(GetLastError())
		
		AWriteLine("Aborting")
		Exit(1)
	}
	
	i16* Source := AToW(FileBuffer As i8*, FileSize)
	
	Free(FileBuffer)
	CloseHandle(FileHandle)
	
	return Source
}

DllImport i16* GetCommandLineW() {Kernel32.dll, GetCommandLineW}
DllImport i16** CommandLineToArgvW(i16*, i64*) {Shell32.dll, CommandLineToArgvW}

define i32 Main() {
	i64 ArgC := 0
	i16* CommandLine := GetCommandLineW()
	i16** ArgV := CommandLineToArgvW(CommandLine, &ArgC)
	
	if (ArgC < 3) {
		SwapOutputStream()
		AWriteLine("No input+output file, aborting")
		Exit(1)
	}
	
	i8 OutputELF := false
	
	if (ArgC = 4) {
		OutputELF := true
	}
	
	i16* InputFilePath := ArgV[1]
	i16* OutputFilePath := ArgV[2]
	
	AWrite("Input File: ")
	WriteLine(InputFilePath)
	
	AWrite("Output File: ")
	WriteLine(OutputFilePath)
	
	i32 SourceLength := 0
	i16* Source := OpenAndRead(InputFilePath, &SourceLength)
	
	SafeWideString SourcePath
	SourcePath.Buffer := InputFilePath
	SourcePath.Length := WLen(InputFilePath)
	
	ParserState* P := ParserStart(NewTokenizer(&SourcePath, Source, SourceLength), OutputELF)
	CompilerStart(P, OutputFilePath, OutputELF)
}