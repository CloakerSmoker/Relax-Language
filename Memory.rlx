DllImport i64 GetProcessHeap() {Kernel32.dll, GetProcessHeap}
DllImport void* HeapAlloc(i64, i32, i64) {Kernel32.dll, HeapAlloc}
DllImport void* HeapReAlloc(i64, i32, void*, i64) {Kernel32.dll, HeapReAlloc}
DllImport i8 HeapFree(i64, i32, void*) {Kernel32.dll, HeapFree}

i64 ProcessHeap := GetProcessHeap()
i32 HEAP_ZERO_MEMORY := 0x00000008
i32 HEAP_REALLOC_IN_PLACE_ONLY := 0x00000010

define void* Alloc(i64 Size) {
	return HeapAlloc(ProcessHeap, HEAP_ZERO_MEMORY, Size)
}

define void* ReAlloc(void* Memory, i64 NewSize) {
	return HeapReAlloc(ProcessHeap, HEAP_ZERO_MEMORY, Memory, NewSize)
}
define void* ReAllocInPlace(void* Memory, i64 NewSize) {
	return HeapReAlloc(ProcessHeap, HEAP_ZERO_MEMORY | HEAP_REALLOC_IN_PLACE_ONLY, Memory, NewSize)
}

define i8 Free(void* Memory) {
	return HeapFree(ProcessHeap, 0, Memory)
}




struct ExpandArray {
	i32 ElementSize,
	i32 Capacity	
}

define void* AllocArray(i16 ElementSize, i16 InitialCapacity) {
	void* Buffer := Alloc((ExpandArray.Size) + (ElementSize * InitialCapacity))
	ExpandArray* NewArray := Buffer
	
	NewArray->ElementSize := ElementSize
	NewArray->Capacity := InitialCapacity
	
	return Buffer + (ExpandArray.Size)
}

define void* ReAllocArray(void* ArrayBuffer, i32 AdditionalCapacity) {
	ExpandArray* Array := ArrayBuffer - (ExpandArray.Size)
	
	i32 ElementSize := Array->ElementSize
	i32 OldCapacity := Array->Capacity
	i32 NewCapacity := OldCapacity + AdditionalCapacity
	
	Array->Capacity := NewCapacity
	
	i32 NewSize := (ExpandArray.Size) + (ElementSize * NewCapacity)
	
	return ReAlloc(Array, NewSize) + (ExpandArray.Size)
}

define i32 GetArrayLength(void* ArrayBuffer) {
	return ((ArrayBuffer - 8) As ExpandArray*)->Capacity
}

define void FreeArray(void* ArrayBuffer) {
	Free(ArrayBuffer - (ExpandArray.Size))
}