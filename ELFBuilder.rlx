DllImport i64 GetCurrentProcess() {Kernel32.dll, GetCurrentProcess}
DllImport void TerminateProcess(i64, i32) {Kernel32.dll, TerminateProcess}
DllImport i32 GetLastError() {Kernel32.dll, GetLastError}
DllImport i8 CloseHandle(i64) {Kernel32.dll, CloseHandle}
DllImport i64 CreateFile(i16*, i32, i32, void*, i32, i32, i64) {Kernel32.dll, CreateFileW}
DllImport i32 GetFileSize(i64, void) {Kernel32.dll, GetFileSize}
DllImport i8 ReadFile(i64, void*, i32, i32*, void) {Kernel32.dll, ReadFile}
DllImport i8 WriteFile(i64, i8*, i32, i32*, i64) {Kernel32.dll, WriteFile}

define void Exit(i32 ExitCode) {
	TerminateProcess(GetCurrentProcess(), ExitCode)
}

#Include Memory.rlx

define i32 ALen(i8* AString) {
	for (i32 Length := 0, AString[Length] != 0, Length += 1) {}
	
	return Length
}

struct ELFHeader unaligned {
	i32 Magic,
	i8 Bitness,
	i8 Endianness,
	i8 UseCurrentVersion,
	i8 TargetABI,
	
	union {
		/* This byte is followed by 7 unused ones, so this union takes up the used byte plus 7, keeping the offsets intact */
		i8 ABIVersion,
		i64 Unused
	},
	
	i16 FileType,
	i16 MachineType,
	
	i32 ELFVersion,
	i64 EntryPoint,
	i64 ProgramHeadersOffset,
	i64 SectionHeadersOffset,
	i32 Flags,
	i16 HeaderSize,
	i16 ProgramHeadersSize,
	i16 ProgramHeaderEntryCount,
	i16 SectionHeadersSize,
	i16 SectionHeaderEntryCount,
	i16 SectionNameHeaderIndex
}

i32 SEGMENT_EXECUTE := 1
i32 SEGMENT_WRITE := 2
i32 SEGMENT_READ := 4

i32 SEGMENT_TYPE_LOAD := 0x01

struct ELFProgramHeader {
	i32 SegmentType,
	i32 Flags,
	i64 FileOffset,
	i64 VirtualAddress,
	i64 PhysicalAddress,
	i64 FileSize,
	i64 MemorySize,
	i64 Alignment
}

i32 SECTION_EXECUTE := 1
i32 SECTION_WRITE := 2
i32 SECTION_READ := 4

i32 SECTION_STRING_TABLE := 0x03

i64 SECTION_FLAGS_STRINGS := 0x20

struct ELFSectionHeader {
	i32 NameOffset,
	i32 SectionType,
	i64 SectionFlags,
	i64 VirtualAddress,
	i64 FileOffset,
	i64 FileSize,
	i32 AssociatedSectionIndex,
	i32 ExtraInfo,
	i64 Alignment,
	i64 EntrySize
}

struct ELFBuilder {
	void* Buffer,
	i64 BufferSize,
	
	ELFProgramHeader* PHDR, /* Segment which contains the segment headers */
	ELFProgramHeader* LoadPHDR, /* Segment which loads the segment containing the segment headers */
	ELFSectionHeader* StringSection, /* Section which holds section names (Fuck this format) */
	i8* StringBuffer,
	
	ELFProgramHeader** ProgramHeaders,
	ELFSectionHeader** SectionHeaders,
	
	ELFHeader* ELF
}

i8 ABI_SYSTEMV := 0x00
i16 FILETYPE_EXEC := 0x02
i16 FILETYPE_DYN := 0x03
i16 MACHINE_AMD64 := 0x3E

define void WriteELFHeader(void* IntoBuffer) {
	ELFHeader* NewHeader := IntoBuffer As ELFHeader*
	
	NewHeader->Magic := 0x464C457F /* 0x7f ELF magic */
	NewHeader->Bitness := 2 /* 1 = 32 bit, 2 = 64 bit */
	NewHeader->Endianness := 1 /* 1 = little endian */
	NewHeader->UseCurrentVersion := 1 /* Not well documented, 0 = invalid */
	NewHeader->TargetABI := ABI_SYSTEMV
	NewHeader->ABIVersion := 0 /* Unused? */
	NewHeader->FileType := FILETYPE_EXEC /* An executable file */
	NewHeader->MachineType := MACHINE_AMD64
	NewHeader->ELFVersion := 1 /* Use original version of ELF */
	NewHeader->HeaderSize := 64 /* 64 bytes of headers */
	NewHeader->ProgramHeadersSize := ELFProgramHeader.Size
	NewHeader->SectionHeadersSize := ELFSectionHeader.Size
	NewHeader->SectionNameHeaderIndex := 1
}

define ELFProgramHeader* AppendProgramHeader(ELFBuilder* ToBuilder) {
	ELFHeader* Header := ToBuilder->ELF
	
	i32 NextIndex := Header->ProgramHeaderEntryCount
	Header->ProgramHeaderEntryCount += 1
	ToBuilder->ProgramHeaders := ReAlloc(ToBuilder->ProgramHeaders, (NextIndex + 1) * 8)
	
	ELFProgramHeader* Result := Alloc(ELFProgramHeader.Size)
	
	ToBuilder->ProgramHeaders[NextIndex] := Result
	
	return Result
}
define ELFSectionHeader* AppendSectionHeader(ELFBuilder* ToBuilder) {
	ELFHeader* Header := ToBuilder->ELF
	
	i32 NextIndex := Header->SectionHeaderEntryCount
	Header->SectionHeaderEntryCount += 1
	ToBuilder->SectionHeaders := ReAlloc(ToBuilder->SectionHeaders, (NextIndex + 1) * 8)
	
	ELFSectionHeader* Result := Alloc(ELFSectionHeader.Size)
	
	ToBuilder->SectionHeaders[NextIndex] := Result
	
	return Result
}
define void AppendString(ELFBuilder* ToBuilder, i8* Text) {
	i64 StartingIndex := ToBuilder->StringSection->FileSize
	i32 TextLength := ALen(Text)
	i32 NewSize := StartingIndex + TextLength + 1
	
	ToBuilder->StringBuffer := ReAlloc(ToBuilder->StringBuffer, NewSize)
	ToBuilder->StringSection->FileSize := NewSize
	
	for (i32 Index := 0, Index < TextLength, Index += 1) {
		ToBuilder->StringBuffer[StartingIndex + Index] := Text[Index]
	}
	
	return StartingIndex
}
define ELFSectionHeader* AppendSection(ELFBuilder* ToBuilder, i8* WithName) {
	ELFSectionHeader* NewSection := AppendSectionHeader(ToBuilder)
	
	NewSection->NameOffset := AppendString(ToBuilder, WithName)
	
	return NewSection
}

define void* AllocateELFBuffer() {
	return Alloc(ELFHeader.Size)
}
define void ReAllocELFBuffer(ELFBuilder* ForBuilder, i32 NewSize) {
	ForBuilder->Buffer := ReAlloc(ForBuilder->Buffer, NewSize)
	ForBuilder->BufferSize := NewSize
	
	ForBuilder->ELF := ForBuilder->Buffer
}

define ELFBuilder* BuildELFBuilder() {
	ELFBuilder* NewBuilder := Alloc(ELFBuilder.Size)
	NewBuilder->Buffer := AllocateELFBuffer()
	NewBuilder->BufferSize := ELFHeader.Size
	
	NewBuilder->ProgramHeaders := Alloc(8)
	NewBuilder->SectionHeaders := Alloc(8)
	
	WriteELFHeader(NewBuilder->Buffer)
	
	NewBuilder->ELF := NewBuilder->Buffer
	
	ELFProgramHeader* PHDR := AppendProgramHeader(NewBuilder)
	NewBuilder->PHDR := PHDR
	
	PHDR->SegmentType := 0x00000006 /* PT_PHDR */
	PHDR->Flags := SEGMENT_READ
	PHDR->Alignment := 0x08
	PHDR->FileOffset := 0x40
	PHDR->VirtualAddress := 0x40
	
	ELFProgramHeader* LoadPHDR := AppendProgramHeader(NewBuilder)
	NewBuilder->LoadPHDR := LoadPHDR
	
	LoadPHDR->SegmentType := SEGMENT_TYPE_LOAD
	LoadPHDR->Flags := SEGMENT_READ | SEGMENT_EXECUTE
	LoadPHDR->Alignment := 0x01
	LoadPHDR->FileOffset := 0x00
	LoadPHDR->VirtualAddress := 0x00
	
	ELFSectionHeader* NullSection := AppendSectionHeader(NewBuilder)
	
	ELFSectionHeader* StringSection := AppendSectionHeader(NewBuilder)
	NewBuilder->StringSection := StringSection
	
	StringSection->SectionType := SECTION_STRING_TABLE
	StringSection->Alignment := 0x01
	
	NewBuilder->StringBuffer := Alloc(8)
	StringSection->FileSize := 1
	
	StringSection->NameOffset := AppendString(NewBuilder, ".strtab")
	
	return NewBuilder
}

define void FinalizeELFBuilder(ELFBuilder* TargetBuilder) {
	i32 ProgramHeadersSize := TargetBuilder->ELF->ProgramHeaderEntryCount * ELFProgramHeader.Size
	i32 SectionHeadersSize := TargetBuilder->ELF->SectionHeaderEntryCount * ELFSectionHeader.Size
	i32 StringSectionSize := TargetBuilder->StringSection->FileSize
	
	i64 PHDRSize := ProgramHeadersSize + SectionHeadersSize
	i64 FinalSize := ELFHeader.Size + PHDRSize + StringSectionSize
	
	ReAllocELFBuffer(TargetBuilder, FinalSize)
	
	void* Buffer := TargetBuilder->Buffer
	i8* ByteBuffer := Buffer As i8*
	
	/* Update the ELF header to contain the program/section header offsets */
	TargetBuilder->ELF->ProgramHeadersOffset := 64
	TargetBuilder->ELF->SectionHeadersOffset := 64 + ProgramHeadersSize
	
	/* Update the PHDR segment to contain the headers we are writing */
	TargetBuilder->PHDR->FileSize := PHDRSize
	TargetBuilder->PHDR->MemorySize := PHDRSize
	
	/* These fields are reused to hold the ProgramHeaders/SectionHeaders buffer sizes, but need to be set to their true values */
	TargetBuilder->ELF->ProgramHeadersSize := ELFProgramHeader.Size
	TargetBuilder->ELF->SectionHeadersSize := ELFSectionHeader.Size
	
	/* Fuck you Linus */
	TargetBuilder->LoadPHDR->FileSize := FinalSize
	TargetBuilder->LoadPHDR->MemorySize := FinalSize
	
	/* Double fuck you Linus */
	TargetBuilder->StringSection->FileOffset := 64 + PHDRSize
	
	/* Copy the bytes of all the program/section headers into the ELF buffer after the ELF header
		(Which will line up with the offsets written into the header above)
	*/
	i32 ProgramHeaderCount := TargetBuilder->ELF->ProgramHeaderEntryCount
	i32 SectionHeaderCount := TargetBuilder->ELF->SectionHeaderEntryCount
	i8* StringBufferBytes := TargetBuilder->StringBuffer
	
	for (i32 Index := 0, Index < ProgramHeaderCount, Index += 1) {
		i8* NextProgramHeader := TargetBuilder->ProgramHeaders[Index] As i8*
		
		for (i32 NestedIndex := 0, NestedIndex < ELFProgramHeader.Size, NestedIndex += 1) {
			ByteBuffer[64 + NestedIndex + (Index * ELFProgramHeader.Size)] := NextProgramHeader[NestedIndex]
		}	
	}
	for (Index := 0, Index < SectionHeaderCount, Index += 1) {
		i8* NextSectionHeader := TargetBuilder->SectionHeaders[Index] As i8*
		
		for (NestedIndex := 0, NestedIndex < ELFSectionHeader.Size, NestedIndex += 1) {
			ByteBuffer[64 + ProgramHeadersSize + NestedIndex + (Index * ELFSectionHeader.Size)] := NextSectionHeader[NestedIndex]
		}	
	}
	for (Index := 0, Index < StringSectionSize, Index += 1) {
		ByteBuffer[64 + Index + ProgramHeadersSize + SectionHeadersSize] := StringBufferBytes[Index]
	}
	
}

declare void WriteELFBuilder(ELFBuilder*, i8*)

define i32 Main() {
	ELFBuilder* E := BuildELFBuilder()
	
	ELFProgramHeader* Test := AppendProgramHeader(E)
	Test->SegmentType := 0x69696969
	
	ELFSectionHeader* Test2 := AppendSection(E, ".fuck")
	
	FinalizeELFBuilder(E)
	
	WriteELFBuilder(E, "out.elf")
	
	return 0
}

DllImport i64 CreateFileA(i8*, i32, i32, void*, i32, i32, i64) {Kernel32.dll, CreateFileA}

define void WriteELFBuilder(ELFBuilder* Builder, i8* ToFile) {
	i32 GENERIC_WRITE := 0x40000000
	i8 FILE_SHARE_READ := 1
	i8 FILE_SHARE_WRITE := 2
	i8 CREATE_ALWAYS := 2
	i16 FILE_ATTRIBUTE_NORMAL := 128
	
	i64 OutputFileHandle := CreateFileA(ToFile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0)
	
	if (OutputFileHandle = -1) {
		Exit(GetLastError())
	}
	
	i32 BytesWritten := 0
	
	i8 Result := WriteFile(OutputFileHandle, Builder->Buffer, Builder->BufferSize, &BytesWritten, 0)
	
	if (Result = 0 || (BytesWritten != (Builder->BufferSize))) {
		Exit(GetLastError())
	}
	
	CloseHandle(OutputFileHandle)
}