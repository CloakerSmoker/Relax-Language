DllImport i64 GetCurrentProcess() {Kernel32.dll, GetCurrentProcess}
DllImport void TerminateProcess(i64, i32) {Kernel32.dll, TerminateProcess}
DllImport i32 GetLastError() {Kernel32.dll, GetLastError}
DllImport i8 CloseHandle(i64) {Kernel32.dll, CloseHandle}
DllImport i64 CreateFile(i16*, i32, i32, void*, i32, i32, i64) {Kernel32.dll, CreateFileW}
DllImport i32 GetFileSize(i64, void) {Kernel32.dll, GetFileSize}
DllImport i8 ReadFile(i64, void*, i32, i32*, void) {Kernel32.dll, ReadFile}
DllImport i8 WriteFile(i64, i8*, i32, i32*, i64) {Kernel32.dll, WriteFile}

define void Exit(i32 ExitCode) {
	TerminateProcess(GetCurrentProcess(), ExitCode)
}

#Include Memory.rlx

struct ELFHeader unaligned {
	i32 Magic,
	i8 Bitness,
	i8 Endianness,
	i8 UseCurrentVersion,
	i8 TargetABI,
	
	union {
		/* This byte is followed by 7 unused ones, so this union takes up the used byte plus 7, keeping the offsets intact */
		i8 ABIVersion,
		i64 Unused
	},
	
	i16 FileType,
	i16 MachineType,
	
	i32 ELFVersion,
	i64 EntryPoint,
	i64 ProgramHeadersOffset,
	i64 SectionHeadersOffset,
	i32 Flags,
	i16 HeaderSize,
	i16 ProgramHeadersSize,
	i16 ProgramHeaderEntryCount,
	i16 SectionHeadersSize,
	i16 SectionHeaderEntryCount,
	i16 SectionNameHeaderIndex
}

struct ELFProgramHeader {
	i32 SegmentType,
	i32 Flags,
	i64 FileOffset,
	i64 VirtualAddress,
	i64 PhysicalAddress,
	i64 FileSize,
	i64 MemorySize,
	i64 Alignment
}

struct ELFSectionHeader {
	i32 NameOffset,
	i32 SectionType,
	i64 SectionFlags,
	i64 VirtualAddress,
	i64 FileOffset,
	i64 FileSize,
	i32 AssociatedSectionIndex,
	i32 ExtraInfo,
	i64 Alignment,
	i64 EntrySize
}

struct ELFBuilder {
	void* Buffer,
	i64 BufferSize,
	
	ELFProgramHeader* ProgramHeaders,
	ELFSectionHeader* SectionHeaders,
	
	ELFHeader* ELF
}

i8 ABI_SYSTEMV := 0x00
i16 FILETYPE_EXEC := 0x02
i16 FILETYPE_DYN := 0x03
i16 MACHINE_AMD64 := 0x3E

define void WriteELFHeader(void* IntoBuffer) {
	ELFHeader* NewHeader := IntoBuffer As ELFHeader*
	
	NewHeader->Magic := 0x464C457F /* 0x7f ELF magic */
	NewHeader->Bitness := 2 /* 1 = 32 bit, 2 = 64 bit */
	NewHeader->Endianness := 1 /* 1 = little endian */
	NewHeader->UseCurrentVersion := 1 /* Not well documented, 0 = invalid */
	NewHeader->TargetABI := ABI_SYSTEMV
	NewHeader->ABIVersion := 0 /* Unused? */
	NewHeader->FileType := FILETYPE_EXEC /* An executable file */
	NewHeader->MachineType := MACHINE_AMD64
	NewHeader->ELFVersion := 1 /* Use original version of ELF */
	NewHeader->HeaderSize := 64 /* 64 bytes of headers */
}

define ELFProgramHeader* AppendProgramHeader(ELFBuilder* ToBuilder) {
	ELFHeader* Header := ToBuilder->ELF
	
	i32 NextIndex := Header->ProgramHeaderEntryCount
	Header->ProgramHeaderEntryCount += 1
	Header->ProgramHeadersSize += ELFProgramHeader.Size
	ToBuilder->ProgramHeaders := ReAlloc(ToBuilder->ProgramHeaders, Header->ProgramHeadersSize)
	
	return &ToBuilder->ProgramHeaders[NextIndex]
}

define ELFSectionHeader* AppendSectionHeader(ELFBuilder* ToBuilder) {
	ELFHeader* Header := ToBuilder->ELF
	
	i32 NextIndex := Header->SectionHeaderEntryCount
	Header->SectionHeaderEntryCount += 1
	Header->SectionHeadersSize += ELFSectionHeader.Size
	ToBuilder->SectionHeaders := ReAlloc(ToBuilder->SectionHeaders, Header->SectionHeadersSize)
	
	return &ToBuilder->SectionHeaders[NextIndex]
}

define void* AllocateELFBuffer() {
	return Alloc(ELFHeader.Size)
}
define void ReAllocELFBuffer(ELFBuilder* ForBuilder, i32 NewSize) {
	ForBuilder->Buffer := ReAlloc(ForBuilder->Buffer, NewSize)
	ForBuilder->BufferSize := NewSize
	
	ForBuilder->ELF := ForBuilder->Buffer
}

define ELFBuilder* BuildELFBuilder() {
	ELFBuilder* NewBuilder := Alloc(ELFBuilder.Size)
	NewBuilder->Buffer := AllocateELFBuffer()
	NewBuilder->BufferSize := ELFHeader.Size
	
	NewBuilder->ProgramHeaders := Alloc(8)
	NewBuilder->SectionHeaders := Alloc(8)
	
	WriteELFHeader(NewBuilder->Buffer)
	
	NewBuilder->ELF := NewBuilder->Buffer
	
	return NewBuilder
}

define void FinalizeELFBuilder(ELFBuilder* TargetBuilder) {
	i32 ProgramHeadersSize := TargetBuilder->ELF->ProgramHeadersSize
	i32 SectionHeadersSize := TargetBuilder->ELF->SectionHeadersSize
	
	i64 FinalSize := ELFHeader.Size + ProgramHeadersSize + SectionHeadersSize
	
	ReAllocELFBuffer(TargetBuilder, FinalSize)
	
	void* Buffer := TargetBuilder->Buffer
	i8* ByteBuffer := Buffer As i8*
	
	/* Update the ELF header to contain the program/section header offsets */
	TargetBuilder->ELF->ProgramHeadersOffset := 64
	TargetBuilder->ELF->SectionHeadersOffset := 64 + ProgramHeadersSize
	
	/* Copy the bytes of all the program/section headers into the ELF buffer after the ELF header
		(Which will line up with the offsets written into the header above)
	*/
	i8* ProgramHeadersBytes := TargetBuilder->ProgramHeaders
	i8* SectionHeadersBytes := TargetBuilder->SectionHeaders
	
	for (i32 Index := 0, Index < ProgramHeadersSize, Index += 1) {
		ByteBuffer[64 + Index] := ProgramHeadersBytes[Index]
	}
	for (Index := 0, Index < SectionHeadersSize, Index += 1) {
		ByteBuffer[64 + Index + ProgramHeadersSize] := SectionHeadersBytes[Index]
	}
}

declare void WriteELFBuilder(ELFBuilder*, i8*)

define i32 Main() {
	ELFBuilder* E := BuildELFBuilder()
	
	ELFProgramHeader* Test := AppendProgramHeader(E)
	Test->SegmentType := 0x69696969
	
	ELFSectionHeader* Test2 := AppendSectionHeader(E)
	Test2->NameOffset := 0x34343434
	
	FinalizeELFBuilder(E)
	
	WriteELFBuilder(E, "out.elf")
	
	return 0
}

DllImport i64 CreateFileA(i8*, i32, i32, void*, i32, i32, i64) {Kernel32.dll, CreateFileA}

define void WriteELFBuilder(ELFBuilder* Builder, i8* ToFile) {
	i32 GENERIC_WRITE := 0x40000000
	i8 FILE_SHARE_READ := 1
	i8 FILE_SHARE_WRITE := 2
	i8 CREATE_ALWAYS := 2
	i16 FILE_ATTRIBUTE_NORMAL := 128
	
	i64 OutputFileHandle := CreateFileA(ToFile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0)
	
	if (OutputFileHandle = -1) {
		Exit(GetLastError())
	}
	
	i32 BytesWritten := 0
	
	i8 Result := WriteFile(OutputFileHandle, Builder->Buffer, Builder->BufferSize, &BytesWritten, 0)
	
	if (Result = 0 || (BytesWritten != (Builder->BufferSize))) {
		Exit(GetLastError())
	}
	
	CloseHandle(OutputFileHandle)
}