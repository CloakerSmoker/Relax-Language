<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Basic syntax - Relax Docs</title>
    <link href="../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../js/jquery-3.2.1.min.js"></script>
    <script src="../js/bootstrap-3.3.7.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "The basic syntax", url: "#_top", children: [
              {title: "Types", url: "#types" },
              {title: "Type checking", url: "#type-checking" },
              {title: "General Things", url: "#general-things" },
              {title: "Assignment operators", url: "#assignment-operators" },
              {title: "Binary operators", url: "#binary-operators" },
              {title: "Unary operators", url: "#unary-operators" },
              {title: "Casting", url: "#casting" },
              {title: "Array-access", url: "#array-access" },
              {title: "Struct-access", url: "#struct-access" },
          ]},
          {title: "What next?", url: "#what-next", children: [
          ]},
        ];

    </script>
    <script src="../js/base.js"></script>
      <script src="../search/main.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../basic-tutorial/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../basic-tutorial/" class="btn btn-xs btn-link">
        Basic tutorial
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href=".." class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href=".." class="btn btn-xs btn-link">
        Relax
      </a>
    </div>
    
  </div>

    

    <h2 id="the-basic-syntax">The basic syntax</h2>
<p>It looks like C, it is written like C, but it <em>is not</em> C.</p>
<h4 id="types">Types</h4>
<p>Instead of long historic names, Relax uses shortened type names:</p>
<p>Integer types:</p>
<table>
<thead>
<tr>
<th>Precision</th>
<th>C Name</th>
<th>(LanguageName) Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>8 bits</td>
<td><code>char</code></td>
<td><code>i8</code></td>
</tr>
<tr>
<td>16 bits</td>
<td><code>short</code></td>
<td><code>i16</code></td>
</tr>
<tr>
<td>32 bits</td>
<td><code>long</code></td>
<td><code>i32</code></td>
</tr>
<tr>
<td>64 bits</td>
<td><code>long long</code>/<code>__int64</code></td>
<td><code>i64</code></td>
</tr>
</tbody>
</table>
<p>Additionally, there is the <code>void</code> type, which is exactly what you'd expect it to be: a 64 bit integer (I can't remember why I made it this way).</p>
<p>Of course, there are also pointer types, which follow C syntax of <code>TypeName*</code>.</p>
<p>Additionally, you can define a structure type with the <code>struct</code> keyword, which can then be pointed-to like any other type.</p>
<h4 id="type-checking">Type checking</h4>
<p>Type checking is done in the parser, so globals/locals/functions/structs must (usually) be defined above where they are used.</p>
<p>To avoid circular references being impossible to compile, the <code>declare</code> statement can be used to state a function's parameters/return type before defining it.</p>
<p>Additionally, undefined types can be used as long as they only used in pointer types, and do not have and fields referenced.</p>
<h4 id="general-things">General Things</h4>
<p>String literals are supported, and are replaced with an <code>i8*</code> to the given string. This <code>i8*</code> will point into the stack, so <strong>DO NOT</strong> try to free this memory. You can alter it, but poking at the memory around it is a terrible idea.</p>
<p><br></p>
<p>If a function does not have a return in it, the return value is undefined. However, functions are not required to have a <code>return</code>, and will still run.</p>
<p><br></p>
<p>The magic entry-point function is named <code>Main</code>, which is not expected to follow any prototype. This is to avoid having to include additional runtime code to support ArgV/ArgC. If a program requires ArgC/ArgV, this snippet will provide it:</p>
<pre><code class="py">DllImport i16* GetCommandLineW() {Kernel32.dll, GetCommandLineW}
DllImport i16** CommandLineToArgvW(i16*, i64*) {Shell32.dll, CommandLineToArgvW}

define i32 Main() {
    i64 ArgC := 0
    i16* CommandLine := GetCommandLineW()
    i16** ArgV := CommandLineToArgvW(CommandLine, &amp;ArgC)

    ...
}
</code></pre>

<p>The return value of <code>Main</code> is considered the program's exit code.</p>
<p><br></p>
<p>This is the list of reserved names:</p>
<ul>
<li><code>if</code>, <code>else</code></li>
<li><code>return</code></li>
<li><code>continue</code>, <code>break</code></li>
<li><code>struct</code>, <code>union</code></li>
<li><code>define</code>, <code>declare</code>, <code>dllimport</code> </li>
<li><code>for</code>, <code>while</code>, <code>loop</code></li>
<li><code>as</code></li>
</ul>
<h4 id="assignment-operators">Assignment operators</h4>
<p>The left side of each assignment operator can be any of the following:</p>
<ul>
<li>A variable, such as <code>A</code></li>
<li>An array access, such as <code>String[Index]</code></li>
<li>A struct access, such as <code>Something.Field</code> or <code>SomethingPointer-&gt;Field</code></li>
</ul>
<p>The assignment operators are:</p>
<ul>
<li><code>:=</code> </li>
<li><code>+=</code></li>
<li><code>-=</code></li>
</ul>
<h4 id="binary-operators">Binary operators</h4>
<p>Note: <code>&amp;&amp;</code> and <code>||</code> both short-circuit, <code>%</code> is modulo, <code>.</code> is local struct field access, <code>-&gt;</code> is pointer struct field access.
<code>As</code> is explained further <a href="#casting">here</a></p>
<ul>
<li><code>+</code>, <code>-</code></li>
<li><code>*</code>, <code>/</code>, <code>%</code></li>
<li><code>=</code>, <code>!=</code></li>
<li><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
<li><code>&amp;</code>, <code>|</code>, <code>^</code></li>
<li><code>&amp;&amp;</code>, <code>||</code></li>
<li><code>.</code>, <code>-&gt;</code></li>
<li><code>as</code></li>
</ul>
<h4 id="unary-operators">Unary operators</h4>
<p>Note: <code>&amp;</code> is 'address of', and <code>*</code> is dereference, <code>-</code> is negation.</p>
<ul>
<li><code>&amp;</code>, <code>*</code></li>
<li><code>-</code>, <code>!</code></li>
</ul>
<p><code>++</code> and <code>--</code> have been deliberately excluded, as they are a pain to parse.</p>
<h4 id="casting">Casting</h4>
<p>Casting between types is usually implicit, but if you want to explicitly cast between two obviously incompatible types, the <code>As</code> operator does it.
The format is <code>Operand As TypeName</code>.</p>
<h4 id="array-access">Array-access</h4>
<p>Array accesses are really just pointer syntax sugar, but god do they make things easier.</p>
<p><code>Pointer[Index]</code> will do the same operation as <code>*(Pointer + (SizeOfPointedToType(Pointer) * Index))</code>, with much less code generated.</p>
<p>Instead of evaluating a bunch of expressions manually, the addition and multiplication steps are both done by the CPU directly, which should be a speed up.</p>
<h4 id="struct-access">Struct-access</h4>
<p>Struct accesses are technically also syntax sugar, but allow for much higher level code.</p>
<p>A struct access will automatically calculate the offset of a field inside of a structure, and encode that offset directly into an instruction.
Additionally, since struct fields have names, cryptic code such as <code>*(SomeStruct + 8 As i8*)</code> can be written as <code>SomeStruct-&gt;Field</code>.</p>
<p>The operators <code>.</code> and <code>-&gt;</code> are mostly interchangeable, however, <code>.</code> only works for local structs, and <code>-&gt;</code> only works for pointers to structs.</p>
<h2 id="what-next">What next?</h2>
<p>For a full writeup of the syntax, see <a href="../full-syntax/">the full syntax page</a>.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../basic-tutorial/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../basic-tutorial/" class="btn btn-xs btn-link">
        Basic tutorial
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href=".." class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href=".." class="btn btn-xs btn-link">
        Relax
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="">Windmill Dark</a> theme by None (noraj).</p>
</footer>

</body>
</html>