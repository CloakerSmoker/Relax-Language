/*
==========================================
	aaaaaaaaaaaaa
==========================================
*/


struct Label {
	i32 LabelNumber,
	i32 OffsetToReplace,
	i8 IsPlaceholder
}

struct CompilerState {
	i8* CodeBuffer,
	i32 CodeBufferSize,
	i32 Index,
	
	LabelPlaceholder** Labels,
	i32 LabelCount,
	i32 LabelBufferCapacity,
	
	i32 LabelIndex,
	
	Type* CurrentFunctionReturnType,
	i32 CurrentFunctionReturnLabel,
	i32 LastReturnOffset,
	
	i8 RegisterStackIndex
}

/*
==========================================
	aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
==========================================
*/

define void CompilerStart(FunctionDefine* StartFunction) {
	CompilerState C
	C.CodeBuffer := Alloc(100) As i8*
	C.CodeBufferSize := 100
	C.Index := 0
	
	C.Labels := Alloc(80) As Label**
	C.LabelCount := 0
	C.LabelBufferCapacity := 10
	
	C.LabelIndex := 0
	C.RegisterStackIndex := 0
	
	CompileFunction(&C, StartFunction)
}

define i8 PushRegisterStack(CompilerState* cState) {
	i8 Result := (cState->RegisterStackIndex) + 8
	
	cState->RegisterStackIndex += 1
	
	return Result
}
define i8 TopOfRegisterStack(CompilerState* cState) {
	return (cState->RegisterStackIndex) + 8
}

define i8 PopRegisterStack(CompilerState* cState) {
	cState->RegisterStackIndex -= 1
	
	return (cState->RegisterStackIndex) + 8
}

/*
==========================================
	Variable helpers
==========================================
*/

define void GetVariableValue(CompilerState* cState, VariableInfo* TargetVariable, i8 ResultRegister) {
	PrintSafeString(TargetVariable->Name)
	WriteCharacter(':')
	IWriteLine(TargetVariable->StackOffset)
	
	if (TargetVariable->Type->PointerDepth = 0 && TargetVariable->Type->TrueType->IsStructType) {
		/* If GetVariableValue is called on a struct, then we should actually result in a pointer to that struct
			So Compile(Get|Set)StructField can depending on getting a pointer, and never the struct as a number
			Any time this could be abused *should* be caught by type checking 
		*/
		
		GetVariableAddress(cState, TargetVariable, ResultRegister)
	}
	else {
		EmitMove_RX_RX_DISPX(cState, ResultRegister, RBP, -(TargetVariable->StackOffset), TargetVariable->Type->Size)
	}
}
define void GetVariableAddress(CompilerState* cState, VariableInfo* TargetVariable, i8 ResultRegister) {
	PrintSafeString(TargetVariable->Name)
	WriteCharacter(':')
	IWriteLine(TargetVariable->StackOffset)
	
	EmitLea_R64_R64_DISPX(cState, ResultRegister, RBP, -(TargetVariable->StackOffset))
}
define void SetVariableValue(CompilerState* cState, VariableInfo* TargetVariable, i8 SourceRegister) {
	PrintSafeString(TargetVariable->Name)
	WriteCharacter(':')
	IWriteLine(TargetVariable->StackOffset)
	
	EmitMove_RX_DISPX_RX(cState, RBP, SourceRegister, -(TargetVariable->StackOffset), TargetVariable->Type->Size)
}


/*
==========================================
	Actual compile functions
==========================================
*/

define void Cast(CompilerState* cState, i8 Register, i8 Size) {
	EmitMove_R64_RX(cState, Register, Register, Size)
}

define void CompileFunction(CompilerState* cState, FunctionDefine* FunctionToCompile) {
	/* Compiles a single function */
	
	/* Allocates a label to be the return position, and updates the current return label */
	i32 ReturnLabel := NextLabel(cState)
	cState->CurrentFunctionReturnLabel := ReturnLabel
	
	/* Store the current return type so return can cast values to it */
	
	cState->CurrentFunctionReturnType := FunctionToCompile->ReturnType
	
	/* Assume 4 register parameters, and 0 stack parameters */
	i8 RegisterParameterCount := 4
	i16 StackParameterCount := 0
	
	if (FunctionToCompile->ParameterCount < 4) {
		/* If there are less than 4 parameters, then the number of register parameters is just the number of parameters */
		
		RegisterParameterCount := (FunctionToCompile->ParameterCount) As i8
	}
	else if (FunctionToCompile->ParameterCount >= 5) {
		/* Else if there are 5+ parameters, the stack parameter count is (TotalParamCount - 4) */
		
		StackParameterCount := (FunctionToCompile->ParameterCount) - 4
		
		/* Also, store RSP in RBX for extracting the stack parameters with smaller offsets */
		EmitMove_R64_R64(cState, RBX, RSP)
	}
	
	/* Set up the stack frame for this function */
	EmitEnter_I16(cState, FunctionToCompile->LocalOffset)
	
	for (i8 RegisterParameterIndex := 0, RegisterParameterIndex < RegisterParameterCount, RegisterParameterIndex += 1) {
		/* For each register parameter */
		
		/* Get the VariableInfo structure for the parameter */
		VariableInfo* NextParameter := (FunctionToCompile->Parameters)[RegisterParameterIndex]
		
		/* And which register it is in (RCX/RDX/R8/R9) */
		i8 NextParameterRegister := RegisterParameterIndex + 1
		
		if (NextParameterRegister > 2) {
			NextParameterRegister += 5
		}
		
		/* And write the parameter register's value into the parameter's stack space */
		SetVariableValue(cState, NextParameter, NextParameterRegister)
	}
	
	for (i16 StackParameterIndex := 0, StackParameterIndex < StackParameterCount, StackParameterIndex += 1) {
		/* For each stack parameter */
		
		/* Get the VariableInfo structure for the parameter */
		VariableInfo* NextStackParameter := (FunctionToCompile->Parameters)[StackParameterIndex + 4]
		
		/* Load RAX with the parameter's value (using RBX as a base) */
		EmitMove_RX_RX_DISP8(cState, RAX, RBX, 0x28 + (StackParameterIndex * 8), NextStackParameter->Type->Size)
		
		/* Write RAX(/the parameter's value) into the parameter's stack space */
		SetVariableValue(cState, NextStackParameter, RAX)
	}
	
	/* Compile the body of the function */
	CompileBlock(cState, FunctionToCompile->Body)
	
	/* Set the return label to the current index */
	SetLabel(cState, ReturnLabel)
	
	/* Resolve all labels inside the function */
	ResolveAllLabels(cState)
	
	if (cState->LastReturnOffset = cState->Index) {
		/* If the last instruction was jmp ReturnLabel, then remove it (since it is useless) */
		cState->Index -= 5
	}
	
	/* Emit the leave/ret instructions for this function (the return value will be set by a return statement */
	EmitLeave(cState)
	EmitReturn(cState)
	
	PEBuilder* B := BuildBuilder()
	
	AddData(B, 0x149)
	
	AddImport(B, AToS("Kernel32"), AToS("ExitProcess"))
	AddImport(B, AToS("Kernel32"), AToS("LocalFree"))
	
	AddRelocation(B, 0x1000, 40, 1)
	
	AddCode(B, cState->CodeBuffer, 0x100)
	
	FinalizeBuilder(B)
	
	WriteBuilder(B, "C:\Users\Connor\Desktop\Valite\text.exe")
	
	/*PrintCodeBytes(cState)*/
}
define void CompileBlock(CompilerState* cState, Block* BlockToCompile) {
	/* Compiles a block of statements */
	
	for (i32 Index := 0, Index < BlockToCompile->StatementCount, Index += 1) {
		ASTNode* NextStatement := (BlockToCompile->Statements)[Index]
		
		Compile(cState, NextStatement)
	}
}
define void CompileReturn(CompilerState* cState, ASTNode* ReturnExpression) {
	/* Compiles a return statement */
	
	/* Compile the expression to return */
	CompileExpression(cState, RAX, ReturnExpression)
	
	AWrite("aaaaaaaaaaaaaaaaaaaaa ")
	IWriteLine(ReturnExpression->ValueType->Size)
	
	i16 ReturnValueSize := ReturnExpression->ValueType->Size
	i16 ReturnTypeSize := cState->CurrentFunctionReturnType->Size
	
	if (ReturnValueSize < ReturnTypeSize || ReturnValueSize < 4) {
		Cast(cState, RAX, ReturnValueSize)
	}
	
	/* And jump to this function's return label */
	EmitJump_Label(cState, cState->CurrentFunctionReturnLabel)
	
	/* Also update the LastReturnOffset so this jump can be eliminated if it is the last instruction in the function */
	cState->LastReturnOffset := cState->Index
}
define void Compile(CompilerState* cState, ASTNode* NodeToCompile) {
	/* Compiles some kind of statement */
	
	i8 NodeType := NodeToCompile->NodeType
	
	if (NodeType = NODE_TYPE_RETURN) {
		CompileReturn(cState, (NodeToCompile->TrueNode) As ASTNode*)
	}
	else if (NodeType = NODE_TYPE_EXPRESSION) {
		CompileExpression(cState, RAX, (NodeToCompile->TrueNode) As ASTNode*)
	}
}
define void CompileExpression(CompilerState* cState, i8 ResultRegister, ASTNode* ExpressionToCompile) {
	/* Compiles some kind of expression */
	
	i8 ExpressionType := ExpressionToCompile->NodeType
	Type* ResultType := ExpressionToCompile->ValueType
	
	if (ExpressionType = NODE_TYPE_INTEGER) {
		/* Simply move the integer being used into the result register */
		
		EmitMove_RX_IX(cState, ResultRegister, (ExpressionToCompile->TrueNode) As i64, ExpressionToCompile->ValueType->Size)
	}
	else if (ExpressionType = NODE_TYPE_VARIABLE) {
		VariableInfo* TargetVariable := (ExpressionToCompile->TrueNode) As VariableInfo*
		
		GetVariableValue(cState, TargetVariable, ResultRegister)
	}
	else if (ExpressionType = NODE_TYPE_UNARY) {
		UnaryExpression* UnaryNode := (ExpressionToCompile->TrueNode) As UnaryExpression*
	
		CompileUnary(cState, ResultRegister, ResultType, UnaryNode)
	}
	else if (ExpressionType = NODE_TYPE_BINARY) {
		/* Calls into CompileBinary with the correct parameters extracted from ExpressionToCompile */
		
		BinaryExpression* BinaryNode := (ExpressionToCompile->TrueNode) As BinaryExpression*
		
		CompileBinary(cState, ResultRegister, ResultType, BinaryNode)
	}
	else if (ExpressionType = NODE_TYPE_STRUCT_ACCESS) {
		StructAccessExpression* AccessNode := (ExpressionToCompile->TrueNode) As StructAccessExpression*
		
		CompileGetStructAccess(cState, ResultRegister, AccessNode)
	}

}
define void CompileUnary(CompilerState* cState, i8 ResultRegister, Type* ResultType, UnaryExpression* ExpressionToCompile) {
	/* Compiles a unary operator and operand */
	
	i8 Operator := (ExpressionToCompile->Operator->Value) As i8
	
	if (Operator = OPERATOR_AND) {
		VariableInfo* OperandVariable := (ExpressionToCompile->Operand->TrueNode) As VariableInfo*
		
		GetVariableAddress(cState, OperandVariable, ResultRegister)
	}
	else {
		/* Only compile the operand when the operator isn't `&` (since it doesn't use the operand value) */
		CompileExpression(cState, ResultRegister, ExpressionToCompile->Operand)
		
		if (Operator = OPERATOR_STAR) {
			EmitMove_RX_RIX(cState, ResultRegister, ResultRegister, ResultType->Size)
		}
	}
}

define void CompileGetStructAccess(CompilerState* cState, i8 ResultRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	i16 TargetFieldSize := TargetField->ValueType->Size
	
	/* CompileExpression will always result in a struct pointer, even for local structs (in order for this to be shorter) */
	CompileExpression(cState, ResultRegister, TargetAccess->Left)
	EmitMove_RX_RX_DISP8(cState, ResultRegister, ResultRegister, TargetField->Offset, TargetFieldSize)
}

define void CompileSetStructAccess(CompilerState* cState, i8 ValueRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	
	i8 ResultPointerRegister := PushRegisterStack(cState)
	CompileExpression(cState, ResultPointerRegister, TargetAccess->Left)
	
	EmitMove_RX_DISP8_RX(cState, ResultPointerRegister, ValueRegister, TargetField->Offset, TargetField->ValueType->Size)
	
	PopRegisterStack(cState)
}

define void CompileBinary(CompilerState* cState, i8 ResultRegister, Type* ResultType, BinaryExpression* ExpressionToCompile) {
	/* Compiles a binary expression, and both operands of the expression */
	
	ASTNode* Left := ExpressionToCompile->Left
	ASTNode* Right := ExpressionToCompile->Right
	
	i16 LeftSize := Left->ValueType->Size
	i16 RightSize := Right->ValueType->Size
	i16 ResultSize := ResultType->Size
	
	i8 LeftRegister := ResultRegister
	i8 RightRegister := 0
	
	i8 Operator := (ExpressionToCompile->Operator->Value) As i8
	
	if (Operator = OPERATOR_COLON_EQUAL) {
		/* This is an assignment, so we can reuse the result register for the side side, and ignore the left */
		
		if (Left->NodeType = NODE_TYPE_VARIABLE) {
			VariableInfo* TargetVariable := (Left->TrueNode) As VariableInfo*
			
			SetVariableValue(cState, TargetVariable, LeftRegister)
		}
		else if (Left->NodeType = NODE_TYPE_STRUCT_ACCESS) {
			CompileExpression(cState, ResultRegister, Right)
			
			CompileSetStructAccess(cState, ResultRegister, (Left->TrueNode) As StructAccessExpression*)
		}
	}
	else {
		/* As long as we're not compiling an assignment, compile the left operand into the result register */
		
		CompileExpression(cState, LeftRegister, Left)
		
		if (Operator = OPERATOR_AS) {
			/* For 'As', just compile the left operand, cast it, and return */
			Type* RightType := (Right->TrueNode) As Type*
			
			if (Left->NodeType != NODE_TYPE_INTEGER) {
				/* Only emit cast instructions for values which aren't integers, since integer casts are done at compile time */
				
				Cast(cState, LeftRegister, RightType->Size)
			}
		}
		else {
			/* Allocate a new register for the right operand */
			
			RightRegister := PushRegisterStack(cState)
			CompileExpression(cState, RightRegister, Right)
	
			/* If either operand is smaller than the result type, cast it up to the R64 (aka any possible size) */
			if (RightSize < ResultSize) {
				Cast(cState, RightRegister, ResultSize)
			}
			if (LeftSize < ResultSize) {
				Cast(cState, LeftRegister, ResultSize)
			}
			
			/* Also uses uses the correct instruction for two ResultType sized operands (casting should be done this is called) */
			
			i8 RightRegister := PopRegisterStack(cState)
			
			if (Operator = OPERATOR_PLUS) {
				EmitAdd_RX_RX(cState, LeftRegister, RightRegister, ResultType->Size)
			}
			else if (Operator = OPERATOR_MINUS) {
				EmitSub_RX_RX(cState, LeftRegister, RightRegister, ResultType->Size)
			}
			else if (Operator = OPERATOR_STAR) {
				if (ResultType->Size = 1) {
					/* Do 8 bit multiplication as 16 bit, and cast the result back down to 8 bits (since there is no imul r8, r8 instruction */
					EmitIMul_R16_R16(cState, LeftRegister, RightRegister)
					Cast(cState, LeftRegister, 1)
				}
				else {	
					EmitIMul_RX_RX(cState, LeftRegister, RightRegister, ResultType->Size)
				}
			}
		}
	}
}
/*
==========================================
	Code printing helpers
==========================================
*/

define i8 NumberToHex(i8 Number) {
	if (Number <= 9) {
		Number := Number + '0'
	}
	else {
		Number := (Number - 10) + 'A'
	}
	
	return Number
}

define void PrintByteHex(i8 NumberToPrint) {
	i8 SecondCharacter := NumberToHex(NumberToPrint & 0x0F)
	
	i8 FirstCharacter := NumberToHex((NumberToPrint / 0x10) & 0x0F)
	
	WriteCharacter(FirstCharacter)
	WriteCharacter(SecondCharacter)
}

define void PrintCodeBytes(CompilerState* cState) {
	for (i32 Index := 0, Index < (cState->Index), Index += 1) {
		PrintByteHex((cState->CodeBuffer)[Index])
		WriteCharacter(' ')
	}
}

/*
==========================================
	Label helpers
==========================================
*/

define i32 NextLabel(CompilerState* cState) {
	i32 Result := cState->LabelIndex
	cState->LabelIndex += 1
	return Result
}

define void EnsureLabelBufferCapacity(CompilerState* cState) {
	/* Ensures that cState can hold at least one more label in its label buffer */
	
	if (cState->LabelBufferCapacity <= (cState->LabelCount + 1)) {
		cState->Labels := ReAlloc((cState->Labels) As void*, (cState->LabelBufferCapacity + 10) * 8) As Label**
		cState->LabelBufferCapacity += 10
	}
}

define void UseLabel(CompilerState* cState, i32 LabelNumber) {
	/* Registers a label as being used, and writes a placeholder value into CodeBuffer for the label */
	
	EnsureLabelBufferCapacity(cState)
	
	Label* NewLabel := Alloc(Label.Size) As Label*
	
	NewLabel->LabelNumber := LabelNumber
	NewLabel->OffsetToReplace := cState->Index
	NewLabel->IsPlaceholder := true
	
	cState->Index += 4
	
	(cState->Labels)[cState->LabelCount] := NewLabel
	cState->LabelCount += 1
}

define Label* SetLabel(CompilerState* cState, i32 LabelNumber) {
	/* Creates a new label which points to the current cState->Index */
	
	EnsureLabelBufferCapacity(cState)
	
	Label* NewLabel := Alloc(Label.Size) As Label*
	
	NewLabel->LabelNumber := LabelNumber
	NewLabel->OffsetToReplace := cState->Index
	NewLabel->IsPlaceholder := false
	
	(cState->Labels)[cState->LabelCount] := NewLabel
	cState->LabelCount += 1
	
	return NewLabel
}

define void ResolveAllLabels(CompilerState* cState) {
	/* Goes through each label which is not a placeholder, but actually points to an index */
	
	for (i32 Index := 0, Index < cState->LabelCount, Index += 1) {
		Label* NextLabel := (cState->Labels)[Index]
		
		if !(NextLabel->IsPlaceholder) {
			/* And resolves each use of the label to the offset */
			ResolveLabel(cState, NextLabel->LabelNumber, NextLabel->OffsetToReplace)
		}
	}
}

define void ResolveLabel(CompilerState* cState, i32 LabelNumber, i32 Value) {
	for (i32 Index := 0, Index < cState->LabelCount, Index += 1) {
		Label* NextLabel := (cState->Labels)[Index]
		
		if (NextLabel->LabelNumber = LabelNumber && NextLabel->IsPlaceholder) {
			i32* ActualPlaceholder := ((cState->CodeBuffer) + (NextLabel->OffsetToReplace)) As i32*
			ActualPlaceholder[0] := Value - ((NextLabel->OffsetToReplace) + 4)
		}
	}
}

/*
==========================================
	Number writing helpers
==========================================
*/

define void* GetIndexAsPointer(CompilerState* cState) {
	/* Helper to get a pointer into cState->CodeBuffer */
	
	return ((cState->CodeBuffer) + (cState->Index)) As void*
}

/* Helpers which write a number into cState->CodeBuffer and increment cState->Index */

define void PushI8(CompilerState* cState, i8 NumberToPush) {
	(cState->CodeBuffer)[cState->Index] := NumberToPush
	cState->Index += 1
}
define void PushByte(CompilerState* cState, i8 NumberToPush) {
	/* Alternate name for PushI8 since I was too used to typing PushByte */
	
	PushI8(cState, NumberToPush)
}

define void PushI16(CompilerState* cState, i16 NumberToPush) {
	i16* PushLocation := GetIndexAsPointer(cState) As i16*
	PushLocation[0] := NumberToPush
	
	cState->Index += 2
}
define void PushI32(CompilerState* cState, i32 NumberToPush) {
	i32* PushLocation := GetIndexAsPointer(cState) As i32*
	PushLocation[0] := NumberToPush
	
	cState->Index += 4
}
define void PushI64(CompilerState* cState, i64 NumberToPush) {
	i64* PushLocation := GetIndexAsPointer(cState) As i64*
	PushLocation[0] := NumberToPush
	
	cState->Index += 8
}

/*
==========================================
	Register numbers/register helpers
==========================================
*/

/* Helpers to translate our R8-R15 into x64 R8-R15 */

define i8 RegisterRequiresREX(i8 RegisterNumber) {
	return RegisterNumber >= 8
}
define i8 ClampRegisterNumber(i8 RegisterNumber) {
	/* Takes a 0-15 register number and returns it as a 0-7 number (which might need a REX prefix) */
	
	if (RegisterRequiresREX(RegisterNumber)) {
		return RegisterNumber - 8
	}
	
	return RegisterNumber
}

/* Constants used while generating code */

i8 REX_BASE := 0x40

i8 REX_W := 8
i8 REX_R := 4
i8 REX_X := 2
i8 REX_B := 1

i8 NO_REGISTER := 0
i8 RAX := 0
i8 RBX := 3
i8 RCX := 1
i8 RDX := 2
i8 RSP := 4
i8 RBP := 5
i8 RSI := 6
i8 RDI := 7

/* Although R8-R15 actually have the same numbers of RAX-RDI, REX.B is encoded as bit 3 (which is removed and replaced with a REX prefix while actually encoding) */

i8 R8 := 8
i8 R9 := 9
i8 R10 := 10
i8 R11 := 11
i8 R12 := 12
i8 R13 := 13
i8 R14 := 14
i8 R15 := 15

i8 MODE_PTOR := 0
i8 MODE_PTOR_DISP8 := 1
i8 MODE_PTOR_DISP32 := 2

i8 MODE_RTOR := 3

/*
==========================================
	REX/ModRM/SIB helpers
==========================================
*/

define void EmitREX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 ExtraREX) {
	i8 Prefix := REX_BASE | ExtraREX
	
	if (RegisterRequiresREX(SourceRegister)) {
		Prefix := Prefix | REX_B
	}
	
	if (RegisterRequiresREX(DestinationRegister)) {
		Prefix := Prefix | REX_R
	}
	
	if !(Prefix = REX_BASE && ExtraREX = 0) {
		PushByte(cState, Prefix)
	}
}

define void EmitModRM(CompilerState* cState, i8 Mode, i8 DestinationRegister, i8 SourceRegister) {
	PushByte(cState, (Mode * 64) | (ClampRegisterNumber(DestinationRegister) * 8) | (ClampRegisterNumber(SourceRegister)))
}

define void EmitLegacySizePrefix(CompilerState* cState) {
	PushByte(cState, 0x66)
}

define void EmitREXOpcodeModRM(CompilerState* cState, i8 Opcode, i8 Mode, i8 DestinationRegister, i8 SourceRegister, i8 ExtraREX) {
	EmitREX(cState, DestinationRegister, SourceRegister, ExtraREX)
	PushByte(cState, Opcode)
	EmitModRM(cState, Mode, DestinationRegister, SourceRegister)
}
define void EmitREXBigOpcodeModRM(CompilerState* cState, i8 FirstOpcodeByte, i8 SecondOpcodeByte, i8 Mode, i8 DestinationRegister, i8 SourceRegister, i8 ExtraREX) {
	EmitREX(cState, DestinationRegister, SourceRegister, ExtraREX)
	PushByte(cState, FirstOpcodeByte)
	PushByte(cState, SecondOpcodeByte)
	EmitModRM(cState, Mode, DestinationRegister, SourceRegister)
}

/*
==========================================
	Jumps
==========================================
*/

define void EmitJump_Label(CompilerState* cState, i32 LabelNumber) {
	PushByte(cState, 0xE9)
	UseLabel(cState, LabelNumber)
}

/*
==========================================
	Moves
==========================================
*/


define void EmitZeroRegister(CompilerState* cState, i8 RegisterNumber) {
	if (RegisterRequiresREX(RegisterNumber)) {
		EmitREX(cState, NO_REGISTER, RegisterNumber, 0)
	}
	
	PushByte(cState, 0x33)
	EmitModRM(cState, MODE_RTOR, RegisterNumber, RegisterNumber)
}

define void EmitMove_RX_IX(CompilerState* cState, i8 RegisterNumber, i64 NumberToMove, i8 Size) {
	if (Size = 1) {
		EmitMove_R8_I8(cState, RegisterNumber, NumberToMove As i8)
	}
	else if (Size = 2) {
		EmitMove_R16_I16(cState, RegisterNumber, NumberToMove As i16)
	}
	else if (Size = 4) {
		EmitMove_R32_I32(cState, RegisterNumber, NumberToMove As i32)
	}
	else {
		EmitMove_R64_I64(cState, RegisterNumber, NumberToMove)
	}
}

define void EmitMove_R64_I64(CompilerState* cState, i8 RegisterNumber, i64 NumberToMove) {
	EmitREX(cState, NO_REGISTER, RegisterNumber, REX_W)
	PushByte(cState, 0xB8 + ClampRegisterNumber(RegisterNumber))
	PushI64(cState, NumberToMove)
}
define void EmitMove_R32_I32(CompilerState* cState, i8 RegisterNumber, i32 NumberToMove) {
	EmitREX(cState, NO_REGISTER, RegisterNumber, 0)
	PushByte(cState, 0xB8 + ClampRegisterNumber(RegisterNumber))
	PushI32(cState, NumberToMove)
}
define void EmitMove_R16_I16(CompilerState* cState, i8 RegisterNumber, i16 NumberToMove) {
	EmitLegacySizePrefix(cState)
	
	if (RegisterRequiresREX(RegisterNumber)) {
		EmitREX(cState, NO_REGISTER, RegisterNumber, 0)
	}
	
	PushByte(cState, 0xB8 + ClampRegisterNumber(RegisterNumber))
	PushI16(cState, NumberToMove)
}
define void EmitMove_R8_I8(CompilerState* cState, i8 RegisterNumber, i8 NumberToMove) {
	EmitREX(cState, NO_REGISTER, RegisterNumber, REX_BASE)
	PushByte(cState, 0xB0 + ClampRegisterNumber(RegisterNumber))
	PushI8(cState, NumberToMove)
}


define void EmitMove_RX_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitMove_R8_R8(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 2) {
		EmitMove_R16_R16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitMove_R32_R32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitMove_R64_R64(cState, DestinationRegister, SourceRegister)
	}
}
define void EmitMove_R8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x8A, MODE_RTOR, DestinationRegister, SourceRegister, REX_BASE)
}
define void EmitMove_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x8B, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitMove_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitMove_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}

define void EmitMove_R64_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitMove_R64_R8(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 2) {
		EmitMove_R64_R16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitMove_R64_R32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitMove_R64_R64(cState, DestinationRegister, SourceRegister)
	}
}

define void EmitMove_R64_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0xBE, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitMove_R64_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0xBF, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitMove_R64_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x63, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}

define void EmitMove_RX_RX_DISPX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement, i8 Size) {
	i8 DisplacementSize := GetNumberSize(Displacement As i64)
	
	if (DisplacementSize > 1) {
		EmitMove_RX_RX_DISP32(cState, DestinationRegister, SourceRegister, Displacement As i32, Size)
	}
	else {
		EmitMove_RX_RX_DISP8(cState, DestinationRegister, SourceRegister, Displacement As i8, Size)
	}
}

define void EmitMove_RX_RX_DISP32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement, i8 Size) {
	if (Size = 1) {
		EmitMove_R8_R8_DISP32(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 2) {
		EmitMove_R16_R16_DISP32(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 4) {
		EmitMove_R32_R32_DISP32(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else {
		EmitMove_R64_R64_DISP32(cState, DestinationRegister, SourceRegister, Displacement)
	}
}

define void EmitMove_R8_R8_DISP32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8A, MODE_PTOR_DISP32, DestinationRegister, SourceRegister, REX_BASE)
	PushI32(cState, Displacement)
}
define void EmitMove_R16_R16_DISP32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR_DISP32, DestinationRegister, SourceRegister, 0)
	PushI32(cState, Displacement)
}
define void EmitMove_R32_R32_DISP32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR_DISP32, DestinationRegister, SourceRegister, 0)
	PushI32(cState, Displacement)
}
define void EmitMove_R64_R64_DISP32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR_DISP32, DestinationRegister, SourceRegister, REX_W)
	PushI32(cState, Displacement)
}

define void EmitMove_RX_RX_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement, i8 Size) {
	if (Size = 1) {
		EmitMove_R8_R8_DISP8(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 2) {
		EmitMove_R16_R16_DISP8(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 4) {
		EmitMove_R32_R32_DISP8(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else {
		EmitMove_R64_R64_DISP8(cState, DestinationRegister, SourceRegister, Displacement)
	}
}

define void EmitMove_R8_R8_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8A, MODE_PTOR_DISP8, DestinationRegister, SourceRegister, REX_BASE)
	PushByte(cState, Displacement)
}
define void EmitMove_R16_R16_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR_DISP8, DestinationRegister, SourceRegister, 0)
	PushByte(cState, Displacement)
}
define void EmitMove_R32_R32_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR_DISP8, DestinationRegister, SourceRegister, 0)
	PushByte(cState, Displacement)
}
define void EmitMove_R64_R64_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR_DISP8, DestinationRegister, SourceRegister, REX_W)
	PushByte(cState, Displacement)
}

/* Move [register + displacement], register */

define void EmitMove_RX_DISPX_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement, i8 Size) {
	i8 DisplacementSize := GetNumberSize(Displacement As i64)
	
	if (DisplacementSize > 1) {
		EmitMove_RX_DISP32_RX(cState, DestinationRegister, SourceRegister, Displacement As i32, Size)
	}
	else {
		EmitMove_RX_DISP8_RX(cState, DestinationRegister, SourceRegister, Displacement As i8, Size)
	}
}

define void EmitMove_RX_DISP32_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement, i8 Size) {
	if (Size = 1) {
		EmitMove_R8_DISP32_R8(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 2) {
		EmitMove_R16_DISP32_R16(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 4) {
		EmitMove_R32_DISP32_R32(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else {
		EmitMove_R64_DISP32_R64(cState, DestinationRegister, SourceRegister, Displacement)
	}
}

/* Flipped operands due to MR encoding */

define void EmitMove_R8_DISP32_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x88, MODE_PTOR_DISP32, SourceRegister, DestinationRegister, REX_BASE)
	PushI32(cState, Displacement)
}
define void EmitMove_R16_DISP32_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x89, MODE_PTOR_DISP32, SourceRegister, DestinationRegister, 0)
	PushI32(cState, Displacement)
}
define void EmitMove_R32_DISP32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x89, MODE_PTOR_DISP32, SourceRegister, DestinationRegister, 0)
	PushI32(cState, Displacement)
}
define void EmitMove_R64_DISP32_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x89, MODE_PTOR_DISP8, SourceRegister, DestinationRegister, REX_W)
	PushI32(cState, Displacement)
}

define void EmitMove_RX_DISP8_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement, i8 Size) {
	if (Size = 1) {
		EmitMove_R8_DISP8_R8(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 2) {
		EmitMove_R16_DISP8_R16(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 4) {
		EmitMove_R32_DISP8_R32(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else {
		EmitMove_R64_DISP8_R64(cState, DestinationRegister, SourceRegister, Displacement)
	}
}

/* Flipped operands due to MR encoding */

define void EmitMove_R8_DISP8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x88, MODE_PTOR_DISP8, SourceRegister, DestinationRegister, REX_BASE)
	PushByte(cState, Displacement)
}
define void EmitMove_R16_DISP8_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x89, MODE_PTOR_DISP8, SourceRegister, DestinationRegister, 0)
	PushByte(cState, Displacement)
}
define void EmitMove_R32_DISP8_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x89, MODE_PTOR_DISP8, SourceRegister, DestinationRegister, 0)
	PushByte(cState, Displacement)
}
define void EmitMove_R64_DISP8_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x89, MODE_PTOR_DISP8, SourceRegister, DestinationRegister, REX_W)
	PushByte(cState, Displacement)
}

/*
==========================================
	Deref moves
==========================================
*/

define void EmitMove_RX_RIX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitMove_R8_RI8(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 2) {
		EmitMove_R16_RI16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitMove_R32_RI32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitMove_R64_RI64(cState, DestinationRegister, SourceRegister)
	}
}

define void EmitMove_R8_RI8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x8A, MODE_PTOR, DestinationRegister, SourceRegister, REX_BASE)
}
define void EmitMove_R16_RI16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitMove_R32_RI32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitMove_R64_RI64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR, DestinationRegister, SourceRegister, REX_W)
}

/*
==========================================
	Lea
==========================================
*/

define void EmitLea_R64_R64_DISPX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	i8 Size := GetNumberSize(Displacement)
	
	if (Size = 1) {
		EmitLea_R64_R64_DISP8(cState, DestinationRegister, SourceRegister, Displacement As i8)
	}
	else {
		EmitLea_R64_R64_DISP32(cState, DestinationRegister, SourceRegister, Displacement)
	}
}

define void EmitLea_R64_R64_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8D, MODE_PTOR_DISP8, DestinationRegister, SourceRegister, REX_W)
	PushByte(cState, Displacement)
}
define void EmitLea_R64_R64_DISP32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8D, MODE_PTOR_DISP32, DestinationRegister, SourceRegister, REX_W)
	PushI32(cState, Displacement)
}

/*
==========================================
	Adds
==========================================
*/

define void EmitAdd_RX_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitAdd_R8_R8(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 2) {
		EmitAdd_R16_R16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitAdd_R32_R32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitAdd_R64_R64(cState, DestinationRegister, SourceRegister)
	}
}


define void EmitAdd_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x03, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitAdd_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x03, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitAdd_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x03, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitAdd_R8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x02, MODE_RTOR, DestinationRegister, SourceRegister, REX_BASE)
}

/*
==========================================
	Subs
==========================================
*/

define void EmitSub_RX_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitSub_R8_R8(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 2) {
		EmitSub_R16_R16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitSub_R32_R32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitSub_R64_R64(cState, DestinationRegister, SourceRegister)
	}
}

define void EmitSub_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x2B, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitSub_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x2B, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitSub_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x2B, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitSub_R8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x2A, MODE_RTOR, DestinationRegister, SourceRegister, REX_BASE)
}

/*
==========================================
	Mul/div
==========================================
*/

define void EmitIMul_RX_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		AWriteLine("Bad size passed to EmitIMul_RX_RX")
	}
	else if (Size = 2) {
		EmitIMul_R16_R16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitIMul_R32_R32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitIMul_R64_R64(cState, DestinationRegister, SourceRegister)
	}
}

define void EmitIMul_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0xAF, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitIMul_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0xAF, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitIMul_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXBigOpcodeModRM(cState, 0x0F, 0xAF, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}

define void EmitIMul_AL_R8(CompilerState* cState, i8 SourceRegister) {
	/* Opcode entension 5 */
	
	EmitREXOpcodeModRM(cState, 0x2A, MODE_RTOR, 5, SourceRegister, 0)
}

/*
==========================================
	Push/Pop
==========================================
*/

define void EmitPush_R64(CompilerState* cState, i8 RegisterNumber) {
	EmitREX(cState, NO_REGISTER, RegisterNumber, 0)
	PushByte(cState, 0x50 + ClampRegisterNumber(RegisterNumber))
}
define void EmitPop_R64(CompilerState* cState, i8 RegisterNumber) {
	EmitREX(cState, NO_REGISTER, RegisterNumber, 0)
	PushByte(cState, 0x58 + ClampRegisterNumber(RegisterNumber))
}

/*
==========================================
	Functions
==========================================
*/

define void EmitEnter_I16(CompilerState* cState, i16 ReserveBytes) {
	PushByte(cState, 0xC8)
	PushI16(cState, ReserveBytes)
	PushByte(cState, 0)
}

define void EmitLeave(CompilerState* cState) {
	PushByte(cState, 0xC9)
}

define void EmitReturn(CompilerState* cState) {
	PushByte(cState, 0xC3)
}


