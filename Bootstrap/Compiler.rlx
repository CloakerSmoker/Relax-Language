/*
==========================================
	aaaaaaaaaaaaa
==========================================
*/


struct Label {
	i32 LabelNumber,
	i32 OffsetToReplace,
	i8 IsPlaceholder
}

struct CompilerState {
	ParserState* pState,
	
	PEBuilder* Builder,
	
	i8* CodeBuffer,
	i32 CodeBufferSize,
	i32 Index,
	
	i32* CodeRelocations,
	i32 CodeRelocationCount,
	
	LabelPlaceholder** Labels,
	i32 LabelCount,
	i32 LabelBufferCapacity,
	
	i32 LabelIndex,
	
	i32 CurrentLoopContinueLabel,
	i32 CurrentLoopBreakLabel,
	
	Type* CurrentFunctionReturnType,
	
	i32 CurrentFunctionStringBufferOffset,
	
	i8 RegisterStackIndex,
	
	i8 NoClobberCD89
}

/*
==========================================
	aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
==========================================
*/

#Include CodeGen.rlx

declare void CompileImportStub(CompilerState*, FunctionDefine*)
declare void CompileFunction(CompilerState*, FunctionDefine*, i8)

define void CompilerStart(ParserState* pState, i16* OutputFilePath) {
	CompilerState C
	
	C.pState := pState
	
	C.CodeBufferSize := 200
	C.CodeBuffer := Alloc(200) As i8*
	C.Index := 0
	
	C.CodeRelocations := Alloc(8) As i64*
	C.CodeRelocationCount := 0
	
	C.Labels := Alloc(80) As Label**
	C.LabelCount := 0
	C.LabelBufferCapacity := 10
	
	C.LabelIndex := (pState->FunctionCount) + 1
	C.RegisterStackIndex := 0
	
	C.Builder := BuildBuilder()
	C.Builder->ImportFixupBase := C.CodeBuffer
	
	i32 MainOffset := 0
	i8 FoundMain := false
	
	void* Elements := pState->Functions->Elements
	
	for (i32 ElementIndex := 0, ElementIndex < (pState->Functions->BufferMaxCount), ElementIndex += 1) {
		if (Elements[ElementIndex]) {
			HashMapElement* FoundElement := Elements[ElementIndex] As HashMapElement*
			
			while (FoundElement) {
				FunctionDefine* NextFunction := (FoundElement->Value) As FunctionDefine*
				
				IWriteHex(0x3000 + C.Index)
				AWrite(": ")
				PrintSafeString(NextFunction->Name)
				WriteNewLine()
				
				if (NextFunction->IsImported) {
					CompileImportStub(&C, NextFunction)
				}
				else if !(NextFunction->HasFullDefinition) {
					ASTNode* FakeNode := AllocateNewASTNode(NODE_TYPE_IDENTIFIER, NextFunction->Name, TYPE_NONE)
					FakeNode->SourceFilePath := NextFunction->SourceFilePath
					FakeNode->LineNumber := NextFunction->LineNumber
					
					ASTError(FakeNode, "Function is declared, but never defined.")
				}
				else {
					i8 IsMain := SafeStringEqualsAString(NextFunction->Name, "Main")
					
					if (IsMain) {
						FoundMain := true
						MainOffset := C.Index
					}
					
					CompileFunction(&C, NextFunction, IsMain)
				}
				
				/* Update the current element to be the next element in the linked list */
				FoundElement := (FoundElement->NextElement) As HashMapElement*
			}
		}
	}
	
	if !(FoundMain) {
		TokenizerError(pState->pState, "Main function not found")
	}
	
	ResolveAllLabels(&C)
	
	AWrite("global bytes ")
	IWriteLine(C.pState->GlobalOffset)
	
	AddData(C.Builder, C.pState->GlobalOffset)
	
	AddImport(C.Builder, AToS("Kernel32"), AToS("ExitProcess"), 0)
	AddImport(C.Builder, AToS("Kernel32"), AToS("LocalFree"), 0)
	
	AddCode(C.Builder, C.CodeBuffer, C.CodeBufferSize, MainOffset)
	
	for (i32 RelocationIndex := 0, RelocationIndex < (C.CodeRelocationCount), RelocationIndex += 1) {
		i32 NextRelocationOffset := (C.CodeRelocations)[RelocationIndex]
		
		i32 PageRVA := (C.Builder->NextRVA) + (NextRelocationOffset / 0x1000)
		i16 OffsetInPage := (NextRelocationOffset % 0x1000) As i16
		
		AddRelocation(C.Builder, PageRVA, OffsetInPage, true)
	}
	
	FinalizeBuilder(C.Builder)
	
	WriteBuilder(C.Builder, OutputFilePath)
	
}

define i8 PushRegisterStack(CompilerState* cState) {
	i8 Result := (cState->RegisterStackIndex) + 8
	
	cState->RegisterStackIndex += 1
	
	return Result
}
define i8 TopOfRegisterStack(CompilerState* cState) {
	return (cState->RegisterStackIndex) + 8 As i8
}

define i8 PopRegisterStack(CompilerState* cState) {
	cState->RegisterStackIndex -= 1
	
	return (cState->RegisterStackIndex) + 8 As i8
}

define void EnsureCodeBufferSize(CompilerState* cState) {
	if ((cState->Index + 0x10) >= (cState->CodeBufferSize)) {
		cState->CodeBufferSize += 0x100
		cState->CodeBuffer := ReAlloc(cState->CodeBuffer, cState->CodeBufferSize)
		cState->Builder->ImportFixupBase := cState->CodeBuffer
	}
}

define void AddCodeRelocation(CompilerState* cState, i32 Offset) {
	i32 Index := cState->CodeRelocationCount
	
	cState->CodeRelocations := ReAlloc(cState->CodeRelocations, (Index + 1) * 8)
	(cState->CodeRelocations)[Index] := Offset
	
	cState->CodeRelocationCount += 1
}


/*
==========================================
	Variable helpers
==========================================
*/

define void GetVariableAddress(CompilerState* cState, VariableInfo* TargetVariable, i8 ResultRegister) {
	if (TargetVariable->IsGlobal) {
		EmitMove_R64_I64(cState, RBX, DEFAULT_IMAGE_BASE + (cState->Builder->NextRVA) + (TargetVariable->StackOffset))
		AddCodeRelocation(cState, (cState->Index) - 8)
	}
	else {
		if (TargetVariable->StackOffset < 112) {
			EmitLea_R64_R64_DISP8(cState, ResultRegister, RBP, -(TargetVariable->StackOffset + 8))
		}
		else {
			EmitLea_R64_R64_DISP32(cState, ResultRegister, RBP, -(TargetVariable->StackOffset + 8))
		}
	}
}
define void GetVariableValue(CompilerState* cState, VariableInfo* TargetVariable, i8 ResultRegister) {
	if (TargetVariable->IsGlobal) {
		EmitMove_R64_I64(cState, RBX, DEFAULT_IMAGE_BASE + (cState->Builder->NextRVA) + (TargetVariable->StackOffset))
		AddCodeRelocation(cState, (cState->Index) - 8)
		
		EmitMove_RX_RIX(cState, ResultRegister, RBX, TargetVariable->Type->Size)
	}
	else {
		if (TargetVariable->Type->PointerDepth = 0 && TargetVariable->Type->TrueType->IsStructType) {
			/* If GetVariableValue is called on a struct, then we should actually result in a pointer to that struct
				So Compile(Get|Set)StructField can depending on getting a pointer, and never the struct as a number
				Any time this could be abused *should* be caught by type checking 
			*/
			
			GetVariableAddress(cState, TargetVariable, ResultRegister)
		}
		else {
			if (TargetVariable->StackOffset < 112) {
				EmitMove_RX_RIX_DISP8(cState, ResultRegister, RBP, -(TargetVariable->StackOffset + 8), TargetVariable->Type->Size)
			}
			else {
				EmitMove_RX_RIX_DISP32(cState, ResultRegister, RBP, -(TargetVariable->StackOffset + 8), TargetVariable->Type->Size)
			}
		}
	}
}
define void SetVariableValue(CompilerState* cState, VariableInfo* TargetVariable, i8 SourceRegister) {
	if (TargetVariable->IsGlobal) {
		EmitMove_R64_I64(cState, RBX, DEFAULT_IMAGE_BASE + (cState->Builder->NextRVA) + (TargetVariable->StackOffset))
		AddCodeRelocation(cState, (cState->Index) - 8)
		
		/* Todo: Implement encodings for Move_RIX_RX so we don't have to waste a byte with Move_RIX_DISP8_RX */
		EmitMove_RIX_DISP8_RX(cState, RBX, SourceRegister, 0, TargetVariable->Type->Size)
	}
	else {
		if (TargetVariable->StackOffset < 112) {
			EmitMove_RIX_DISP8_RX(cState, RBP, SourceRegister, -(TargetVariable->StackOffset + 8), TargetVariable->Type->Size)
		}
		else {
			EmitMove_RIX_DISP32_RX(cState, RBP, SourceRegister, -(TargetVariable->StackOffset + 8), TargetVariable->Type->Size)
		}
	}
}


/*
==========================================
	Actual compile functions
==========================================
*/

define void Cast(CompilerState* cState, i8 Register, i8 Size) {
	EmitMove_R64_RX(cState, Register, Register, Size)
}

define void CompileImportStub(CompilerState* cState, FunctionDefine* FunctionToCompile) {
	/* Compiles an imported function by emitting a jump to the actual function */
	
	SetLabel(cState, FunctionToCompile->LabelNumber)
	
	EmitMove_R64_I64(cState, RBX, 0)
	
	AddImport(cState->Builder, FunctionToCompile->ImportFileName, FunctionToCompile->ImportFunctionName, (cState->Index) - 8)
	AddCodeRelocation(cState, cState->Index - 8)
	
	EmitJump_RI64(cState, RBX)
}

declare void CompileExpression(CompilerState*, i8, ASTNode*)
declare void CompileBlock(CompilerState*, Block*)

define void CompileFunction(CompilerState* cState, FunctionDefine* FunctionToCompile, i8 IsMain) {
	/* Compiles a single function */
	
	cState->RegisterStackIndex := 0
	
	/* Store the current return type so return can cast values to it */
	
	cState->CurrentFunctionReturnType := FunctionToCompile->ReturnType
	
	SetLabel(cState, FunctionToCompile->LabelNumber)
	
	/* Assume 4 register parameters, and 0 stack parameters */
	i8 RegisterParameterCount := 4
	i16 StackParameterCount := 0
	
	if (FunctionToCompile->ParameterCount < 4) {
		/* If there are less than 4 parameters, then the number of register parameters is just the number of parameters */
		
		RegisterParameterCount := (FunctionToCompile->ParameterCount) As i8
	}
	else if (FunctionToCompile->ParameterCount >= 5) {
		/* Else if there are 5+ parameters, the stack parameter count is (TotalParamCount - 4) */
		
		StackParameterCount := (FunctionToCompile->ParameterCount) - 4
		
		/* Also, store RSP in RBX for extracting the stack parameters with smaller offsets */
		EmitMove_R64_R64(cState, RBX, RSP)
	}
	
	/* Set up the stack frame for this function */
	i16 LocalSpace := FunctionToCompile->LocalOffset
	
	if (FunctionToCompile->StringBufferSize) {
		i32 RoundedStringSize := (FunctionToCompile->StringBufferSize) As i16
		i32 StringRemainder := RoundedStringSize % 8
		
		if (StringRemainder) {
			RoundedStringSize += 8 - StringRemainder
		}
		
		LocalSpace += RoundedStringSize As i16
	}
	
	i16 LocalSpaceRemainder := LocalSpace % 16
	
	if (LocalSpaceRemainder) {
		LocalSpace += 8
	}
	
	EmitEnter_I16(cState, LocalSpace)
	
	for (i8 RegisterParameterIndex := 0, RegisterParameterIndex < RegisterParameterCount, RegisterParameterIndex += 1) {
		/* For each register parameter */
		
		/* Get the VariableInfo structure for the parameter */
		VariableInfo* NextParameter := (FunctionToCompile->Parameters)[RegisterParameterIndex]
		
		/* And which register it is in (RCX/RDX/R8/R9) */
		i8 NextParameterRegister := RegisterParameterIndex + 1
		
		if (NextParameterRegister > 2) {
			NextParameterRegister += 5
		}
		
		/* And write the parameter register's value into the parameter's stack space */
		SetVariableValue(cState, NextParameter, NextParameterRegister)
	}
	
	for (i16 StackParameterIndex := 0, StackParameterIndex < StackParameterCount, StackParameterIndex += 1) {
		/* For each stack parameter */
		
		/* Get the VariableInfo structure for the parameter */
		VariableInfo* NextStackParameter := (FunctionToCompile->Parameters)[StackParameterIndex + 4]
		
		/* Load RAX with the parameter's value (using RBX as a base) */
		EmitMove_RX_RIX_DISP8(cState, RAX, RBX, 0x28 + (StackParameterIndex * 8), NextStackParameter->Type->Size)
		
		/* Write RAX(/the parameter's value) into the parameter's stack space */
		SetVariableValue(cState, NextStackParameter, RAX)
	}
	
	if (IsMain) {
		ASTNode** GlobalDefaults := cState->pState->GlobalDefaults
		i32 Length := GetArrayLength(GlobalDefaults)
		
		for (i32 GlobalDefaultIndex := 0, GlobalDefaultIndex < Length, GlobalDefaultIndex += 1) {
			CompileExpression(cState, RAX, GlobalDefaults[GlobalDefaultIndex])
		}
	}
	
	if (FunctionToCompile->StringBufferSize) {
		i32 StringBufferOffset := FunctionToCompile->LocalOffset
		i32 StringBufferSize := FunctionToCompile->StringBufferSize
		
		i32 ChunkCount := StringBufferSize / 8
		i32 Remainder := StringBufferSize % 8
		
		if (Remainder) {
			ChunkCount += 1
		}
		
		cState->CurrentFunctionStringBufferOffset := StringBufferOffset + (ChunkCount * 8)
		i64* ChunkBuffer := (FunctionToCompile->StringBuffer) As i64*
		
		for (i32 ChunkIndex := 0, ChunkIndex < ChunkCount, ChunkIndex += 1) {
			i64 NextChunk := ChunkBuffer[ChunkIndex]
			EmitMove_R64_I64(cState, RAX, NextChunk)
			
			i32 ThisChunkOffset := StringBufferOffset + ((ChunkCount - 1 - ChunkIndex) * 8)
			
			if (ThisChunkOffset < 112) {
				EmitMove_RI64_DISP8_R64(cState, RBP, RAX, -(ThisChunkOffset + 8) As i8)
			}
			else {
				EmitMove_RI64_DISP32_R64(cState, RBP, RAX, -(ThisChunkOffset + 8) As i32)
			}
		}
	}
	
	/* Compile the body of the function */
	CompileBlock(cState, FunctionToCompile->Body)
	
	EmitLeave(cState)
	EmitReturn(cState)
}

declare void Compile(CompilerState*, ASTNode*)

define void CompileBlock(CompilerState* cState, Block* BlockToCompile) {
	/* Compiles a block of statements */
	
	for (i32 Index := 0, Index < BlockToCompile->StatementCount, Index += 1) {
		ASTNode* NextStatement := (BlockToCompile->Statements)[Index]
		
		Compile(cState, NextStatement)
	}
}

declare void CompileReturn(CompilerState*, ASTNode*)
declare void CompileIf(CompilerState*, IfGroup*)
declare void CompileFor(CompilerState*, ForLoop*)
declare void CompileLoop(CompilerState*, Block*)
declare void CompileWhile(CompilerState*, WhileLoop*)

define void Compile(CompilerState* cState, ASTNode* NodeToCompile) {
	/* Compiles some kind of statement */
	
	i8 NodeType := NodeToCompile->NodeType
	
	if (NodeType = NODE_TYPE_RETURN) {
		CompileReturn(cState, (NodeToCompile->TrueNode) As ASTNode*)
	}
	else if (NodeType = NODE_TYPE_IF) {
		CompileIf(cState, (NodeToCompile->TrueNode) As IfGroup*)
	}
	else if (NodeType = NODE_TYPE_FOR) {
		CompileFor(cState, (NodeToCompile->TrueNode) As ForLoop*)
	}
	else if (NodeType = NODE_TYPE_LOOP) {
		CompileLoop(cState, (NodeToCompile->TrueNode) As Block*)
	}
	else if (NodeType = NODE_TYPE_WHILE) {
		CompileWhile(cState, (NodeToCompile->TrueNode) As WhileLoop*)
	}
	else if (NodeType = NODE_TYPE_CONTINUEBREAK) {
		i8 IsContinue := (NodeToCompile->TrueNode) As i8
		
		if (IsContinue) {
			EmitJump_Label(cState, cState->CurrentLoopContinueLabel)
		}
		else {
			EmitJump_Label(cState, cState->CurrentLoopBreakLabel)
		}
	}
	else if (NodeType = NODE_TYPE_EXPRESSION) {
		CompileExpression(cState, RAX, (NodeToCompile->TrueNode) As ASTNode*)
	}
}

define void CompileReturn(CompilerState* cState, ASTNode* ReturnExpression) {
	/* Compiles a return statement */
	
	/* Compile the expression to return */
	CompileExpression(cState, RAX, ReturnExpression)
	
	i16 ReturnValueSize := ReturnExpression->ValueType->Size
	i16 ReturnTypeSize := cState->CurrentFunctionReturnType->Size
	
	if (ReturnValueSize < ReturnTypeSize || ReturnValueSize < 4) {
		Cast(cState, RAX, ReturnValueSize)
	}
	
	EmitLeave(cState)
	EmitReturn(cState)
}

define void CompileIf(CompilerState* cState, IfGroup* IfToCompile) {
	i32 BranchCount := IfToCompile->BranchCount
	i32 HasElse := (IfToCompile->ElseBranch) != 0
	
	i32 EndLabel := NextLabel(cState)
	i32 NextBranch := NextLabel(cState)
	
	i8 ConditionResultRegister := PushRegisterStack(cState)
	
	for (i32 BranchIndex := 0, BranchIndex < BranchCount, BranchIndex += 1) {
		SetLabel(cState, NextBranch)
		NextBranch := NextLabel(cState)
		
		ASTNode* ThisBranchCondition := (IfToCompile->Conditions)[BranchIndex]
		
		CompileExpression(cState, ConditionResultRegister, ThisBranchCondition)
		
		EmitTest_RX_RX(cState, ConditionResultRegister, ConditionResultRegister, ThisBranchCondition->ValueType->Size)
		
		EmitJEZ_Label(cState, NextBranch)
		
		CompileBlock(cState, (IfToCompile->Bodies)[BranchIndex])
		
		if (HasElse || (BranchIndex != (BranchCount - 1))) {
			/* Only emit a jump to the end label if: We have an 'else', or we are not the last branch 
				This will eliminate a single extra `jmp, endlabel` on the final 'else if' of the statement
				
			*/
			
			EmitJump_Label(cState, EndLabel)
		}
	}
	
	PopRegisterStack(cState)
	
	SetLabel(cState, NextBranch)
	
	if (IfToCompile->ElseBranch) {
		CompileBlock(cState, IfToCompile->ElseBranch)
	}
	
	SetLabel(cState, EndLabel)
}

define void CompileFor(CompilerState* cState, ForLoop* ForToCompile) {
	i32 OldContinueLabel := cState->CurrentLoopContinueLabel
	i32 OldBreakLabel := cState->CurrentLoopBreakLabel
	
	CompileExpression(cState, RAX, ForToCompile->Initializer)
	
	i32 StartLabel := NextLabel(cState)
	i32 ContinueLabel := NextLabel(cState)
	i32 EndLabel := NextLabel(cState)
	
	SetLabel(cState, StartLabel)
	
	CompileExpression(cState, RAX, ForToCompile->Condition)
	
	EmitTest_RX_RX(cState, RAX, RAX, ForToCompile->Condition->ValueType->Size)
	EmitJEZ_Label(cState, EndLabel)
	
	/* Prelude stuff done, condition is checked, so now we can compile the body */
	
	cState->CurrentLoopContinueLabel := ContinueLabel
	cState->CurrentLoopBreakLabel := EndLabel
	
	Block* ForBody := ForToCompile->Body
	
	for (i32 BodyIndex := 0, BodyIndex < (ForBody->StatementCount), BodyIndex += 1) {
		ASTNode* NextStatement := (ForBody->Statements)[BodyIndex]
		
		Compile(cState, NextStatement)
	}
	
	SetLabel(cState, ContinueLabel) /* On continue (or after the body ends naturally) execute the step, and jump to the condition check */
	CompileExpression(cState, RAX, ForToCompile->Step)
	
	EmitJump_Label(cState, StartLabel)
	
	SetLabel(cState, EndLabel) /* Jumped to on ForToCompile->Condition being false, or a break statement */
	
	cState->CurrentLoopContinueLabel := OldContinueLabel
	cState->CurrentLoopBreakLabel := OldBreakLabel
}

define void CompileLoop(CompilerState* cState, Block* LoopBody) {
	i32 OldContinueLabel := cState->CurrentLoopContinueLabel
	i32 OldBreakLabel := cState->CurrentLoopBreakLabel
	
	i32 StartLabel := NextLabel(cState)
	i32 EndLabel := NextLabel(cState)
	
	cState->CurrentLoopContinueLabel := StartLabel
	cState->CurrentLoopBreakLabel := EndLabel
	
	SetLabel(cState, StartLabel)
	
	CompileBlock(cState, LoopBody)
	
	EmitJump_Label(cState, StartLabel)
	SetLabel(cState, EndLabel)
	
	cState->CurrentLoopContinueLabel := OldContinueLabel
	cState->CurrentLoopBreakLabel := OldBreakLabel
}

define void CompileWhile(CompilerState* cState, WhileLoop* WhileToCompile) {
	i32 OldContinueLabel := cState->CurrentLoopContinueLabel
	i32 OldBreakLabel := cState->CurrentLoopBreakLabel
	
	i32 StartLabel := NextLabel(cState)
	i32 EndLabel := NextLabel(cState)
	
	cState->CurrentLoopContinueLabel := StartLabel
	cState->CurrentLoopBreakLabel := EndLabel
	
	SetLabel(cState, StartLabel)
	
	CompileExpression(cState, RDI, WhileToCompile->Condition)
	EmitTest_RX_RX(cState, RDI, RDI, WhileToCompile->Condition->ValueType->Size)
	EmitJEZ_Label(cState, EndLabel)
	
	CompileBlock(cState, WhileToCompile->Body)
	
	EmitJump_Label(cState, StartLabel)
	SetLabel(cState, EndLabel)
	
	cState->CurrentLoopContinueLabel := OldContinueLabel
	cState->CurrentLoopBreakLabel := OldBreakLabel
}

declare void CompileUnary(CompilerState*, i8, Type*, UnaryExpression*)
declare void CompileBinary(CompilerState*, i8, Type*, BinaryExpression*)
declare void CompileGetStructAccess(CompilerState*, i8, StructAccessExpression*)
declare void CompileCall(CompilerState*, i8, CallExpression*)

define void CompileExpression(CompilerState* cState, i8 ResultRegister, ASTNode* ExpressionToCompile) {
	/* Compiles some kind of expression */
	
	i8 ExpressionType := ExpressionToCompile->NodeType
	Type* ResultType := ExpressionToCompile->ValueType
	
	if (ExpressionType = NODE_TYPE_INTEGER) {
		/* Simply move the integer being used into the result register */
		
		EmitMove_RX_IX(cState, ResultRegister, (ExpressionToCompile->TrueNode) As i64, ExpressionToCompile->ValueType->Size)
	}
	else if (ExpressionType = NODE_TYPE_VARIABLE) {
		VariableInfo* TargetVariable := (ExpressionToCompile->TrueNode) As VariableInfo*
		
		GetVariableValue(cState, TargetVariable, ResultRegister)
	}
	else if (ExpressionType = NODE_TYPE_UNARY) {
		UnaryExpression* UnaryNode := (ExpressionToCompile->TrueNode) As UnaryExpression*
	
		CompileUnary(cState, ResultRegister, ResultType, UnaryNode)
	}
	else if (ExpressionType = NODE_TYPE_BINARY) {
		/* Calls into CompileBinary with the correct parameters extracted from ExpressionToCompile */
		
		BinaryExpression* BinaryNode := (ExpressionToCompile->TrueNode) As BinaryExpression*
		
		CompileBinary(cState, ResultRegister, ResultType, BinaryNode)
	}
	else if (ExpressionType = NODE_TYPE_STRUCT_ACCESS) {
		StructAccessExpression* AccessNode := (ExpressionToCompile->TrueNode) As StructAccessExpression*
		
		CompileGetStructAccess(cState, ResultRegister, AccessNode)
	}
	else if (ExpressionType = NODE_TYPE_CALL) {
		CallExpression* CallNode := (ExpressionToCompile->TrueNode) As CallExpression*
		
		CompileCall(cState, ResultRegister, CallNode)
	}
	else if (ExpressionType = NODE_TYPE_STRING) {
		i32 StringOffset := (ExpressionToCompile->TrueNode) As i32
		
		i32 RBPOffect := (cState->CurrentFunctionStringBufferOffset) - StringOffset
		
		if (RBPOffect < 112) {
			EmitLea_R64_R64_DISP8(cState, ResultRegister, RBP, -(RBPOffect) As i8)
		}
		else {
			EmitLea_R64_R64_DISP32(cState, ResultRegister, RBP, -(RBPOffect) As i32)
		}
	}
}

define void CompileCall(CompilerState* cState, i8 ResultRegister, CallExpression* CallNode) {
	FunctionDefine* TargetFunction := CallNode->TargetFunction
	
	if !(TargetFunction->IsImported || TargetFunction->HasFullDefinition) {
		ASTError(AllocateNewASTNode(NODE_TYPE_CALL, CallNode, 0), "Called function is only declared, and never defined")
	}
	
	
	/* Todo: Smart logic to save/restore volatile portions of the register stack */
	
	i32 ParameterCount := CallNode->ParameterCount
	i32 StackParameterCount := 0
	i8 ExtraPadding := false
	
	if (ParameterCount > 4) {
		StackParameterCount := ParameterCount - 4
	}
	
	if (StackParameterCount % 2) {
		EmitPush_R64(cState, RBX)
		ExtraPadding := true
	}
	
	
	cState->NoClobberCD89 := true /* Ensure none of the parameter registers are used for another operation without being saved */
	
	i8 ParameterRegister := RBX
	
	if (ParameterCount != 0) {
		for (i64 ParameterIndex := (ParameterCount - 1), ParameterIndex >= 0, ParameterIndex -= 1) {
			VariableInfo* NextParameter := (TargetFunction->Parameters)[ParameterIndex]
			ASTNode* NextParameterValue := (CallNode->Parameters)[ParameterIndex]
			
			i8 ThisParameterRegister := ParameterRegister
			
			if (ParameterIndex = 3) {ThisParameterRegister := R9}
			else if (ParameterIndex = 2) {ThisParameterRegister := R8}
			else if (ParameterIndex = 1) {ThisParameterRegister := RDX}
			else if (ParameterIndex = 0) {ThisParameterRegister := RCX}
			
			CompileExpression(cState, ThisParameterRegister, NextParameterValue)
			
			if (NextParameterValue->ValueType->Size < NextParameter->Type->Size) {
				Cast(cState, ThisParameterRegister, NextParameterValue->ValueType->Size)
			}
			
			if (ParameterIndex >= 4) {
				EmitPush_R64(cState, ThisParameterRegister)
			}
		}
	}

	cState->NoClobberCD89 := false
	
	for (i32 ShadowSpaceIndex := 0, ShadowSpaceIndex < 4, ShadowSpaceIndex += 1) {
		EmitPush_R64(cState, R8 + ShadowSpaceIndex)
	}
	
	EmitCall_Label(cState, TargetFunction->LabelNumber)
	
	for (i32 ReversedShadowSpaceIndex := 0, ReversedShadowSpaceIndex < 4, ReversedShadowSpaceIndex += 1) {
		EmitPop_R64(cState, R11 - ReversedShadowSpaceIndex)
	}
	
	if (ExtraPadding) {
		EmitPop_R64(cState, RBX)
	}
	
	EmitMove_R64_RX(cState, ResultRegister, RAX, TargetFunction->ReturnType->Size)
}

define void CompileGetStructAccessPointer(CompilerState* cState, i8 ResultRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	i16 TargetFieldSize := TargetField->ValueType->Size
	
	CompileExpression(cState, ResultRegister, TargetAccess->Left)
	EmitLea_R64_R64_DISPX(cState, ResultRegister, ResultRegister, TargetField->Offset)
}

define void CompileGetStructAccess(CompilerState* cState, i8 ResultRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	i16 TargetFieldSize := TargetField->ValueType->Size
	
	/* CompileExpression will always result in a struct pointer, even for local structs (in order for this to be shorter) */
	CompileExpression(cState, ResultRegister, TargetAccess->Left)
	EmitMove_RX_RIX_DISP8(cState, ResultRegister, ResultRegister, TargetField->Offset, TargetFieldSize)
}

define void CompileSetStructAccess(CompilerState* cState, i8 ValueRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	
	i8 ResultPointerRegister := PushRegisterStack(cState)
	CompileExpression(cState, ResultPointerRegister, TargetAccess->Left)
	
	EmitMove_RIX_DISP8_RX(cState, ResultPointerRegister, ValueRegister, TargetField->Offset, TargetField->ValueType->Size)
	
	PopRegisterStack(cState)
}

define void CompileArrayAccess(CompilerState* cState, i8 ResultRegister, ASTNode* Pointer, ASTNode* Index, i8 ValueRegister, i8 GetAddress) {
	i8 PointerRegister := ResultRegister
	CompileExpression(cState, PointerRegister, Pointer)
	
	i8 IndexRegister := PushRegisterStack(cState)
	CompileExpression(cState, IndexRegister, Index)
	
	i32 IndexSize := Index->ValueType->Size
	
	if (IndexSize < 4) {
		Cast(cState, IndexRegister, IndexSize)
	}
	
	Type* PointerType := Pointer->ValueType
	
	i8 IndexScale := 8
	
	if (PointerType->PointerDepth = 1) {
		IndexScale := (PointerType->TrueType->Size) As i8
	}
	
	i8 IsSet := (ValueRegister != 0)
	
	if (IsSet || GetAddress) {
		EmitLea_R64_SIB(cState, ResultRegister, IndexScale, IndexRegister, PointerRegister)
		
		if (IsSet) {
			EmitMove_RIX_DISP8_RX(cState, ResultRegister, ValueRegister - 1, 0, IndexScale)
		}
	}
	else {
		EmitMove_RX_SIB(cState, ResultRegister, IndexScale, IndexRegister, PointerRegister)
	}
	
	PopRegisterStack(cState)
}

define void CompileGetArrayAccess(CompilerState* cState, i8 ResultRegister, ASTNode* Pointer, ASTNode* Index, i8 GetAddress) {
	CompileArrayAccess(cState, ResultRegister, Pointer, Index, 0, GetAddress)
}
define void CompileSetArrayAccess(CompilerState* cState, i8 ResultRegister, ASTNode* Pointer, ASTNode* Index, i8 ValueRegister) {
	CompileArrayAccess(cState, ResultRegister, Pointer, Index, ValueRegister + 1, false)
}

define void CompileUnary(CompilerState* cState, i8 ResultRegister, Type* ResultType, UnaryExpression* ExpressionToCompile) {
	/* Compiles a unary operator and operand */
	
	i8 Operator := (ExpressionToCompile->Operator->Value) As i8
	i16 ResultSize := ResultType->Size
	
	if (Operator = OPERATOR_AND) {
		ASTNode* Operand := ExpressionToCompile->Operand
		i8 OperandType := Operand->NodeType
		
		if (OperandType = NODE_TYPE_VARIABLE) {
			VariableInfo* OperandVariable := (Operand->TrueNode) As VariableInfo*
			
			GetVariableAddress(cState, OperandVariable, ResultRegister)
		}
		else if (OperandType = NODE_TYPE_STRUCT_ACCESS) {
			StructAccessExpression* OperandStructAccess := (Operand->TrueNode) As StructAccessExpression*
			
			CompileGetStructAccessPointer(cState, ResultRegister, OperandStructAccess)
		}
		else if (OperandType = NODE_TYPE_BINARY) {
			BinaryExpression* OperandExpression := (Operand->TrueNode) As BinaryExpression*
			
			if (OperandExpression->Operator->Value = OPERATOR_OPEN_BRACKET) {
				CompileGetArrayAccess(cState, ResultRegister, OperandExpression->Left, OperandExpression->Right, true)
			}
		}
	}
	else {
		/* Only compile the operand when the operator isn't `&` (since it doesn't use the operand value) */
		CompileExpression(cState, ResultRegister, ExpressionToCompile->Operand)
		
		if (Operator = OPERATOR_STAR) {
			EmitMove_RX_RIX(cState, ResultRegister, ResultRegister, ResultSize)
		}
		else if (Operator = OPERATOR_MINUS) {
			EmitNeg_RX(cState, ResultRegister, ResultSize)
		}
		else if (Operator = OPERATOR_BANG) {
			EmitTest_RX_RX(cState, ResultRegister, ResultRegister, ResultSize)
			EmitSetE_R8(cState, ResultRegister)
			
			if (ResultSize > 1) {
				Cast(cState, ResultRegister, ResultSize)
			}
		}
	}
}

define void CompileBinary(CompilerState* cState, i8 ResultRegister, Type* ResultType, BinaryExpression* ExpressionToCompile) {
	/* Compiles a binary expression, and both operands of the expression */
	
	ASTNode* Left := ExpressionToCompile->Left
	ASTNode* Right := ExpressionToCompile->Right
	
	i16 LeftSize := Left->ValueType->Size
	i16 RightSize := Right->ValueType->Size
	i16 ResultSize := ResultType->Size
	
	i8 LeftRegister := ResultRegister
	
	i8 Operator := (ExpressionToCompile->Operator->Value) As i8
	
	if (OPERATOR_FIRST_ASSIGNMENT <= Operator && Operator <= OPERATOR_LAST_ASSIGNMENT) {
		/* This is an assignment, so we can reuse the result register for the side side, and ignore the left */
		
		i8 LeftType := (Left->NodeType) As i8
		
		VariableInfo* TargetVariable := (Left->TrueNode) As VariableInfo*
		StructAccessExpression* LeftAccess := (Left->TrueNode) As StructAccessExpression*
		BinaryExpression* LeftExpression := (Left->TrueNode) As BinaryExpression*
		
		if (Operator = OPERATOR_COLON_EQUAL) {
			CompileExpression(cState, ResultRegister, Right)
			
			if (RightSize < LeftSize) {
				Cast(cState, ResultRegister, RightSize)
			}
			
			if (LeftType = NODE_TYPE_VARIABLE) {
				SetVariableValue(cState, TargetVariable, ResultRegister)
			}
			else if (LeftType = NODE_TYPE_STRUCT_ACCESS) {
				CompileSetStructAccess(cState, ResultRegister, LeftAccess)
			}
			else if (LeftType = NODE_TYPE_BINARY) {
				CompileSetArrayAccess(cState, RSI, LeftExpression->Left, LeftExpression->Right, ResultRegister)
			}
		}
		else {				
			CompileExpression(cState, RSI, Right)
			
			if (RightSize < LeftSize) {
				Cast(cState, RSI, RightSize)
			}
			
			/* Prelude to get old value of all valid left side expressions */
			
			if (LeftType = NODE_TYPE_VARIABLE) {
				GetVariableValue(cState, TargetVariable, ResultRegister)
			}
			else if (LeftType = NODE_TYPE_STRUCT_ACCESS) {
				CompileGetStructAccess(cState, ResultRegister, LeftAccess)
			}
			else if (LeftType = NODE_TYPE_BINARY) {
				CompileGetArrayAccess(cState, ResultRegister, LeftExpression->Left, LeftExpression->Right, false)
			}
			
			/* Actual operator implementation */
			
			if (Operator = OPERATOR_PLUS_EQUAL) {
				EmitAdd_RX_RX(cState, ResultRegister, RSI, ResultSize)
			}
			else if (Operator = OPERATOR_MINUS_EQUAL) {
				EmitSub_RX_RX(cState, ResultRegister, RSI, ResultSize)
			}
			
			/* Epilog to store the new value for each valid left side */
			
			if (LeftType = NODE_TYPE_VARIABLE) {
				SetVariableValue(cState, TargetVariable, ResultRegister)
			}
			else if (LeftType = NODE_TYPE_STRUCT_ACCESS) {
				CompileSetStructAccess(cState, ResultRegister, LeftAccess)
			}
			else if (LeftType = NODE_TYPE_BINARY) {
				CompileSetArrayAccess(cState, RSI, LeftExpression->Left, LeftExpression->Right, ResultRegister)
			}
		}
	}
	else if (Operator = OPERATOR_OPEN_BRACKET) {
		CompileGetArrayAccess(cState, ResultRegister, Left, Right, false)
	}
	else {
		/* As long as we're not compiling an assignment, compile the left operand into the result register */
		
		CompileExpression(cState, LeftRegister, Left)
		
		if (Operator = OPERATOR_AS) {
			/* For 'As', just compile the left operand, cast it, and return */
			Type* RightType := (Right->TrueNode) As Type*
			
			if (Left->NodeType != NODE_TYPE_INTEGER) {
				/* Only emit cast instructions for values which aren't integers, since integer casts are done at compile time */
				
				Cast(cState, LeftRegister, RightType->Size)
			}
		}
		else if (OPERATOR_FIRST_SHORT_CIRCUIT <= Operator && Operator <= OPERATOR_LAST_SHORT_CIRCUIT) {
			i32 End := NextLabel(cState)
			
			EmitTest_RX_RX(cState, LeftRegister, LeftRegister, ResultSize)
			EmitSetNE_R8(cState, ResultRegister)
			
			if (Operator = OPERATOR_LOGICAL_AND) {
				EmitJEZ_Label(cState, End)
			}
			else if (Operator = OPERATOR_LOGICAL_OR) {
				EmitJNZ_Label(cState, End)
			}
			
			CompileExpression(cState, LeftRegister, Right)
				
			EmitTest_RX_RX(cState, LeftRegister, LeftRegister, ResultSize)
			EmitSetNE_R8(cState, ResultRegister)
			
			SetLabel(cState, End)
		
			if (ResultSize > 1) {
				Cast(cState, ResultRegister, ResultSize)
			}
		}
		else {
			/* Allocate a new register for the right operand */
			
			i8 RightRegister := PushRegisterStack(cState)
			CompileExpression(cState, RightRegister, Right)
			
			i8 IsComparison := (OPERATOR_FIRST_COMPARISON <= Operator && Operator <= OPERATOR_LAST_COMPARISON)
			
			if (IsComparison) {
				ResultSize := GetBinaryResultType(0 As ParserState*, Left->ValueType, Right->ValueType)->Size
			}
			
			/* If either operand is smaller than the result type, cast it up to the R64 (aka any possible size) */
			if (RightSize < ResultSize) {
				Cast(cState, RightRegister, RightSize)
			}
			if (LeftSize < ResultSize) {
				Cast(cState, LeftRegister, LeftSize)
			}
			
			if (IsComparison) {
				EmitCmp_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			
			/* Also uses uses the correct instruction for two ResultType sized operands (casting should be done this is called) */
			
			if (Operator = OPERATOR_PLUS) {
				EmitAdd_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			else if (Operator = OPERATOR_MINUS) {
				EmitSub_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			else if (Operator = OPERATOR_STAR) {
				if (ResultType->Size = 1) {
					/* Do 8 bit multiplication as 16 bit, and cast the result back down to 8 bits (since there is no imul r8, r8 instruction */
					EmitIMul_R16_R16(cState, LeftRegister, RightRegister)
					Cast(cState, LeftRegister, 1)
				}
				else {	
					EmitIMul_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
				}
			}
			else if (Operator = OPERATOR_SLASH || Operator = OPERATOR_PERCENT) {
				if (LeftRegister != RAX) {
					/* Handle the left operand not being in RAX by saving RAX into a temp register and setting RAX := Left */
					
					i8 TempRAX := PushRegisterStack(cState)
					
					EmitMove_RX_RX(cState, TempRAX, RAX, ResultSize)
					EmitMove_RX_RX(cState, RAX, LeftRegister, ResultSize)
				}
				
				if (cState->NoClobberCD89) {
					EmitPush_R64(cState, RDX)
				}
				
				if (ResultSize = 1) {
					/* Handle 8 bit division through a 16 bit operation, which will have a result casted down */
					EmitCWD(cState)
					EmitIDiv_RAX_R16(cState, RightRegister)
				}
				else {
					EmitCXX(cState, ResultSize)
					EmitIDiv_RAX_RX(cState, RightRegister, ResultSize)
				}
				
				if (Operator = OPERATOR_SLASH && ResultRegister != RAX) {
					EmitMove_RX_RX(cState, ResultRegister, RAX, ResultSize)
					EmitMove_RX_RX(cState, RAX, TempRAX, ResultSize)
					PopRegisterStack(cState)
				}
				else if (Operator = OPERATOR_PERCENT && ResultRegister != RDX) {
					EmitMove_RX_RX(cState, ResultRegister, RDX, ResultSize)
				}
				/* else {
					The result is already in the correct register
				}
				*/
				
				if (cState->NoClobberCD89) {
					EmitPop_R64(cState, RDX)
				}
				
				if (ResultSize = 1) {
					Cast(cState, ResultRegister, 1)
				}
			}
			else if (Operator = OPERATOR_EQUAL) {
				EmitSetE_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_BANG_EQUAL) {
				EmitSetNE_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_LESS) {
				EmitSetL_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_LESS_EQAUL) {
				EmitSetLE_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_GREATER) {
				EmitSetG_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_GREATER_EQAUL) {
				EmitSetGE_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_XOR) {
				EmitXor_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			else if (Operator = OPERATOR_AND) {
				EmitAnd_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			else if (Operator = OPERATOR_OR) {
				EmitOr_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			
			PopRegisterStack(cState) /* Pop the right register */
		}
	}
}