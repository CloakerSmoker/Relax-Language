/*
==========================================
	aaaaaaaaaaaaa
==========================================
*/


struct Label {
	i32 LabelNumber,
	i32 OffsetToReplace,
	i8 IsPlaceholder
}

struct CompilerState {
	i8* CodeBuffer,
	i32 CodeBufferSize,
	i32 Index,
	
	LabelPlaceholder** Labels,
	i32 LabelCount,
	i32 LabelBufferCapacity,
	
	i32 LabelIndex,
	
	Type* CurrentFunctionReturnType,
	i32 CurrentFunctionReturnLabel,
	i32 LastReturnOffset,
	
	i8 RegisterStackIndex
}

/*
==========================================
	aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
==========================================
*/

define void CompilerStart(FunctionDefine* StartFunction) {
	CompilerState C
	C.CodeBuffer := Alloc(200) As i8*
	C.CodeBufferSize := 100
	C.Index := 0
	
	C.Labels := Alloc(80) As Label**
	C.LabelCount := 0
	C.LabelBufferCapacity := 10
	
	C.LabelIndex := 0
	C.RegisterStackIndex := 0
	
	CompileFunction(&C, StartFunction)
}

define i8 PushRegisterStack(CompilerState* cState) {
	i8 Result := (cState->RegisterStackIndex) + 8
	
	cState->RegisterStackIndex += 1
	
	return Result
}
define i8 TopOfRegisterStack(CompilerState* cState) {
	return (cState->RegisterStackIndex) + 8
}

define i8 PopRegisterStack(CompilerState* cState) {
	cState->RegisterStackIndex -= 1
	
	return (cState->RegisterStackIndex) + 8
}

#Include CodeGen.rlx

/*
==========================================
	Variable helpers
==========================================
*/

define void GetVariableValue(CompilerState* cState, VariableInfo* TargetVariable, i8 ResultRegister) {
	PrintSafeString(TargetVariable->Name)
	WriteCharacter(':')
	IWriteLine(TargetVariable->StackOffset)
	
	if (TargetVariable->Type->PointerDepth = 0 && TargetVariable->Type->TrueType->IsStructType) {
		/* If GetVariableValue is called on a struct, then we should actually result in a pointer to that struct
			So Compile(Get|Set)StructField can depending on getting a pointer, and never the struct as a number
			Any time this could be abused *should* be caught by type checking 
		*/
		
		GetVariableAddress(cState, TargetVariable, ResultRegister)
	}
	else {
		EmitMove_RX_RX_DISPX(cState, ResultRegister, RBP, -(TargetVariable->StackOffset), TargetVariable->Type->Size)
	}
}
define void GetVariableAddress(CompilerState* cState, VariableInfo* TargetVariable, i8 ResultRegister) {
	PrintSafeString(TargetVariable->Name)
	WriteCharacter(':')
	IWriteLine(TargetVariable->StackOffset)
	
	EmitLea_R64_R64_DISPX(cState, ResultRegister, RBP, -(TargetVariable->StackOffset))
}
define void SetVariableValue(CompilerState* cState, VariableInfo* TargetVariable, i8 SourceRegister) {
	PrintSafeString(TargetVariable->Name)
	WriteCharacter(':')
	IWriteLine(TargetVariable->StackOffset)
	
	EmitMove_RX_DISPX_RX(cState, RBP, SourceRegister, -(TargetVariable->StackOffset), TargetVariable->Type->Size)
}


/*
==========================================
	Actual compile functions
==========================================
*/

define void Cast(CompilerState* cState, i8 Register, i8 Size) {
	EmitMove_R64_RX(cState, Register, Register, Size)
}

define void CompileFunction(CompilerState* cState, FunctionDefine* FunctionToCompile) {
	/* Compiles a single function */
	
	/* Allocates a label to be the return position, and updates the current return label */
	i32 ReturnLabel := NextLabel(cState)
	cState->CurrentFunctionReturnLabel := ReturnLabel
	
	/* Store the current return type so return can cast values to it */
	
	cState->CurrentFunctionReturnType := FunctionToCompile->ReturnType
	
	/* Assume 4 register parameters, and 0 stack parameters */
	i8 RegisterParameterCount := 4
	i16 StackParameterCount := 0
	
	if (FunctionToCompile->ParameterCount < 4) {
		/* If there are less than 4 parameters, then the number of register parameters is just the number of parameters */
		
		RegisterParameterCount := (FunctionToCompile->ParameterCount) As i8
	}
	else if (FunctionToCompile->ParameterCount >= 5) {
		/* Else if there are 5+ parameters, the stack parameter count is (TotalParamCount - 4) */
		
		StackParameterCount := (FunctionToCompile->ParameterCount) - 4
		
		/* Also, store RSP in RBX for extracting the stack parameters with smaller offsets */
		EmitMove_R64_R64(cState, RBX, RSP)
	}
	
	/* Set up the stack frame for this function */
	EmitEnter_I16(cState, FunctionToCompile->LocalOffset)
	
	for (i8 RegisterParameterIndex := 0, RegisterParameterIndex < RegisterParameterCount, RegisterParameterIndex += 1) {
		/* For each register parameter */
		
		/* Get the VariableInfo structure for the parameter */
		VariableInfo* NextParameter := (FunctionToCompile->Parameters)[RegisterParameterIndex]
		
		/* And which register it is in (RCX/RDX/R8/R9) */
		i8 NextParameterRegister := RegisterParameterIndex + 1
		
		if (NextParameterRegister > 2) {
			NextParameterRegister += 5
		}
		
		/* And write the parameter register's value into the parameter's stack space */
		SetVariableValue(cState, NextParameter, NextParameterRegister)
	}
	
	for (i16 StackParameterIndex := 0, StackParameterIndex < StackParameterCount, StackParameterIndex += 1) {
		/* For each stack parameter */
		
		/* Get the VariableInfo structure for the parameter */
		VariableInfo* NextStackParameter := (FunctionToCompile->Parameters)[StackParameterIndex + 4]
		
		/* Load RAX with the parameter's value (using RBX as a base) */
		EmitMove_RX_RX_DISP8(cState, RAX, RBX, 0x28 + (StackParameterIndex * 8), NextStackParameter->Type->Size)
		
		/* Write RAX(/the parameter's value) into the parameter's stack space */
		SetVariableValue(cState, NextStackParameter, RAX)
	}
	
	/* Compile the body of the function */
	CompileBlock(cState, FunctionToCompile->Body)
	
	/* Set the return label to the current index */
	SetLabel(cState, ReturnLabel)
	
	/* Resolve all labels inside the function */
	ResolveAllLabels(cState)
	
	if (cState->LastReturnOffset = cState->Index) {
		/* If the last instruction was jmp ReturnLabel, then remove it (since it is useless) */
		cState->Index -= 5
	}
	
	/* Emit the leave/ret instructions for this function (the return value will be set by a return statement */
	EmitLeave(cState)
	EmitReturn(cState)
	
	PEBuilder* B := BuildBuilder()
	
	AddData(B, 0x149)
	
	AddImport(B, AToS("Kernel32"), AToS("ExitProcess"))
	AddImport(B, AToS("Kernel32"), AToS("LocalFree"))
	
	AddRelocation(B, 0x1000, 40, 1)
	
	AddCode(B, cState->CodeBuffer, 0x200)
	
	FinalizeBuilder(B)
	
	WriteBuilder(B, "text.exe")
	
	/*PrintCodeBytes(cState)*/
}
define void CompileBlock(CompilerState* cState, Block* BlockToCompile) {
	/* Compiles a block of statements */
	
	for (i32 Index := 0, Index < BlockToCompile->StatementCount, Index += 1) {
		ASTNode* NextStatement := (BlockToCompile->Statements)[Index]
		
		Compile(cState, NextStatement)
	}
}
define void CompileReturn(CompilerState* cState, ASTNode* ReturnExpression) {
	/* Compiles a return statement */
	
	/* Compile the expression to return */
	CompileExpression(cState, RAX, ReturnExpression)
	
	AWrite("aaaaaaaaaaaaaaaaaaaaa ")
	IWriteLine(ReturnExpression->ValueType->Size)
	
	i16 ReturnValueSize := ReturnExpression->ValueType->Size
	i16 ReturnTypeSize := cState->CurrentFunctionReturnType->Size
	
	if (ReturnValueSize < ReturnTypeSize || ReturnValueSize < 4) {
		Cast(cState, RAX, ReturnValueSize)
	}
	
	/* And jump to this function's return label */
	EmitJump_Label(cState, cState->CurrentFunctionReturnLabel)
	
	/* Also update the LastReturnOffset so this jump can be eliminated if it is the last instruction in the function */
	cState->LastReturnOffset := cState->Index
}
define void Compile(CompilerState* cState, ASTNode* NodeToCompile) {
	/* Compiles some kind of statement */
	
	i8 NodeType := NodeToCompile->NodeType
	
	if (NodeType = NODE_TYPE_RETURN) {
		CompileReturn(cState, (NodeToCompile->TrueNode) As ASTNode*)
	}
	else if (NodeType = NODE_TYPE_IF) {
		CompileIf(cState, (NodeToCompile->TrueNode) As IfGroup*)
	}
	else if (NodeType = NODE_TYPE_EXPRESSION) {
		CompileExpression(cState, RAX, (NodeToCompile->TrueNode) As ASTNode*)
	}
}

define void CompileIf(CompilerState* cState, IfGroup* IfToCompile) {
	i32 BranchCount := IfToCompile->BranchCount
	i32 HasElse := (IfToCompile->ElseBranch) != 0
	
	i32 EndLabel := NextLabel(cState)
	i32 NextBranch := NextLabel(cState)
	
	i8 ConditionResultRegister := PushRegisterStack(cState)
	
	for (i32 BranchIndex := 0, BranchIndex < BranchCount, BranchIndex += 1) {
		SetLabel(cState, NextBranch)
		NextBranch := NextLabel(cState)
		
		ASTNode* ThisBranchCondition := (IfToCompile->Conditions)[BranchIndex]
		
		CompileExpression(cState, ConditionResultRegister, ThisBranchCondition)
		
		EmitTest_RX_RX(cState, ConditionResultRegister, ConditionResultRegister, ThisBranchCondition->ValueType->Size)
		
		EmitJEZ_Label(cState, NextBranch)
		
		CompileBlock(cState, (IfToCompile->Bodies)[BranchIndex])
		
		if (HasElse || (BranchIndex != (BranchCount - 1))) {
			EmitJump_Label(cState, EndLabel)
		}
	}
	
	PopRegisterStack(cState)
	
	SetLabel(cState, NextBranch)
	
	if (IfToCompile->ElseBranch) {
		CompileBlock(cState, IfToCompile->ElseBranch)
	}
	
	SetLabel(cState, EndLabel)
	
	cState->LastReturnOffset -= 1 /* Clobber the last return index so no code is eliminated from the body of a branch */
}


define void CompileExpression(CompilerState* cState, i8 ResultRegister, ASTNode* ExpressionToCompile) {
	/* Compiles some kind of expression */
	
	i8 ExpressionType := ExpressionToCompile->NodeType
	Type* ResultType := ExpressionToCompile->ValueType
	
	if (ExpressionType = NODE_TYPE_INTEGER) {
		/* Simply move the integer being used into the result register */
		
		EmitMove_RX_IX(cState, ResultRegister, (ExpressionToCompile->TrueNode) As i64, ExpressionToCompile->ValueType->Size)
	}
	else if (ExpressionType = NODE_TYPE_VARIABLE) {
		VariableInfo* TargetVariable := (ExpressionToCompile->TrueNode) As VariableInfo*
		
		GetVariableValue(cState, TargetVariable, ResultRegister)
	}
	else if (ExpressionType = NODE_TYPE_UNARY) {
		UnaryExpression* UnaryNode := (ExpressionToCompile->TrueNode) As UnaryExpression*
	
		CompileUnary(cState, ResultRegister, ResultType, UnaryNode)
	}
	else if (ExpressionType = NODE_TYPE_BINARY) {
		/* Calls into CompileBinary with the correct parameters extracted from ExpressionToCompile */
		
		BinaryExpression* BinaryNode := (ExpressionToCompile->TrueNode) As BinaryExpression*
		
		CompileBinary(cState, ResultRegister, ResultType, BinaryNode)
	}
	else if (ExpressionType = NODE_TYPE_STRUCT_ACCESS) {
		StructAccessExpression* AccessNode := (ExpressionToCompile->TrueNode) As StructAccessExpression*
		
		CompileGetStructAccess(cState, ResultRegister, AccessNode)
	}

}
define void CompileUnary(CompilerState* cState, i8 ResultRegister, Type* ResultType, UnaryExpression* ExpressionToCompile) {
	/* Compiles a unary operator and operand */
	
	i8 Operator := (ExpressionToCompile->Operator->Value) As i8
	
	if (Operator = OPERATOR_AND) {
		VariableInfo* OperandVariable := (ExpressionToCompile->Operand->TrueNode) As VariableInfo*
		
		GetVariableAddress(cState, OperandVariable, ResultRegister)
	}
	else {
		/* Only compile the operand when the operator isn't `&` (since it doesn't use the operand value) */
		CompileExpression(cState, ResultRegister, ExpressionToCompile->Operand)
		
		if (Operator = OPERATOR_STAR) {
			EmitMove_RX_RIX(cState, ResultRegister, ResultRegister, ResultType->Size)
		}
	}
}

define void CompileGetStructAccess(CompilerState* cState, i8 ResultRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	i16 TargetFieldSize := TargetField->ValueType->Size
	
	/* CompileExpression will always result in a struct pointer, even for local structs (in order for this to be shorter) */
	CompileExpression(cState, ResultRegister, TargetAccess->Left)
	EmitMove_RX_RX_DISP8(cState, ResultRegister, ResultRegister, TargetField->Offset, TargetFieldSize)
}

define void CompileSetStructAccess(CompilerState* cState, i8 ValueRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	
	i8 ResultPointerRegister := PushRegisterStack(cState)
	CompileExpression(cState, ResultPointerRegister, TargetAccess->Left)
	
	EmitMove_RX_DISP8_RX(cState, ResultPointerRegister, ValueRegister, TargetField->Offset, TargetField->ValueType->Size)
	
	PopRegisterStack(cState)
}

define void CompileBinary(CompilerState* cState, i8 ResultRegister, Type* ResultType, BinaryExpression* ExpressionToCompile) {
	/* Compiles a binary expression, and both operands of the expression */
	
	ASTNode* Left := ExpressionToCompile->Left
	ASTNode* Right := ExpressionToCompile->Right
	
	i16 LeftSize := Left->ValueType->Size
	i16 RightSize := Right->ValueType->Size
	i16 ResultSize := ResultType->Size
	
	i8 LeftRegister := ResultRegister
	i8 RightRegister := 0
	
	i8 Operator := (ExpressionToCompile->Operator->Value) As i8
	
	if (Operator = OPERATOR_COLON_EQUAL) {
		/* This is an assignment, so we can reuse the result register for the side side, and ignore the left */
		
		if (Left->NodeType = NODE_TYPE_VARIABLE) {
			VariableInfo* TargetVariable := (Left->TrueNode) As VariableInfo*
			
			SetVariableValue(cState, TargetVariable, LeftRegister)
		}
		else if (Left->NodeType = NODE_TYPE_STRUCT_ACCESS) {
			CompileExpression(cState, ResultRegister, Right)
			
			CompileSetStructAccess(cState, ResultRegister, (Left->TrueNode) As StructAccessExpression*)
		}
	}
	else {
		/* As long as we're not compiling an assignment, compile the left operand into the result register */
		
		CompileExpression(cState, LeftRegister, Left)
		
		if (Operator = OPERATOR_AS) {
			/* For 'As', just compile the left operand, cast it, and return */
			Type* RightType := (Right->TrueNode) As Type*
			
			if (Left->NodeType != NODE_TYPE_INTEGER) {
				/* Only emit cast instructions for values which aren't integers, since integer casts are done at compile time */
				
				Cast(cState, LeftRegister, RightType->Size)
			}
		}
		else {
			/* Allocate a new register for the right operand */
			
			RightRegister := PushRegisterStack(cState)
			CompileExpression(cState, RightRegister, Right)
			
			if (OPERATOR_FIRST_COMPARISON <= Operator && Operator <= OPERATOR_LAST_COMPARISON) {
				ResultSize := GetBinaryResultType(0 As ParserState*, Left->ValueType, Right->ValueType)->Size
				EmitCmp_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
	
			/* If either operand is smaller than the result type, cast it up to the R64 (aka any possible size) */
			if (RightSize < ResultSize) {
				Cast(cState, RightRegister, ResultSize)
			}
			if (LeftSize < ResultSize) {
				Cast(cState, LeftRegister, ResultSize)
			}
			
			/* Also uses uses the correct instruction for two ResultType sized operands (casting should be done this is called) */
			
			i8 RightRegister := PopRegisterStack(cState)
			
			if (Operator = OPERATOR_PLUS) {
				EmitAdd_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			else if (Operator = OPERATOR_MINUS) {
				EmitSub_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			else if (Operator = OPERATOR_STAR) {
				if (ResultType->Size = 1) {
					/* Do 8 bit multiplication as 16 bit, and cast the result back down to 8 bits (since there is no imul r8, r8 instruction */
					EmitIMul_R16_R16(cState, LeftRegister, RightRegister)
					Cast(cState, LeftRegister, 1)
				}
				else {	
					EmitIMul_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
				}
			}
			else if (Operator = OPERATOR_EQUAL) {
				EmitSetE_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_BANG_EQUAL) {
				EmitSetNE_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_LESS) {
				EmitSetL_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_LESS_EQAUL) {
				EmitSetLE_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_GREATER) {
				EmitSetG_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_GREATER_EQAUL) {
				EmitSetGE_R8(cState, ResultRegister)
			}
		}
	}
}