/*
==========================================
	aaaaaaaaaaaaa
==========================================
*/


struct Label {
	i32 LabelNumber,
	i32 OffsetToReplace,
	i8 IsPlaceholder
}

struct CompilerState {
	ParserState* pState,
	
	PEBuilder* Builder,
	
	i8* CodeBuffer,
	i32 CodeBufferSize,
	i32 Index,
	
	i32* CodeRelocations,
	i32 CodeRelocationCount,
	
	LabelPlaceholder** Labels,
	i32 LabelCount,
	i32 LabelBufferCapacity,
	
	i32 LabelIndex,
	
	Type* CurrentFunctionReturnType,
	
	i8 RegisterStackIndex,
	
	i8 NoClobberCD89
}

/*
==========================================
	aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
==========================================
*/

define void CompilerStart(ParserState* pState) {
	CompilerState C
	
	C.pState := pState
	
	C.CodeBuffer := Alloc(200) As i8*
	C.CodeBufferSize := 200
	C.Index := 0
	
	C.CodeRelocations := Alloc(8) As i64*
	C.CodeRelocationCount := 0
	
	C.Labels := Alloc(80) As Label**
	C.LabelCount := 0
	C.LabelBufferCapacity := 10
	
	C.LabelIndex := (pState->FunctionCount) + 1
	C.RegisterStackIndex := 0
	
	C.Builder := BuildBuilder()
	
	void* Elements := pState->Functions->Elements
			
	for (i32 ElementIndex := 0, ElementIndex < (pState->Functions->BufferMaxCount), ElementIndex += 1) {
		if (Elements[ElementIndex]) {
			HashMapElement* FoundElement := Elements[ElementIndex] As HashMapElement*
			
			while (FoundElement) {
				FunctionDefine* NextFunction := (FoundElement->Value) As FunctionDefine*
				
				AWrite("Compiling ")
				PrintSafeString(NextFunction->Name)
				WriteNewLine()
				
				if (NextFunction->IsImported) {
					CompileImportStub(&C, NextFunction)
				}
				else if !(NextFunction->HasFullDefinition) {
					TokenizerError(pState->pState, "Undefined function")
				}
				else {
					CompileFunction(&C, NextFunction)
				}
				
				/* Update the current element to be the next element in the linked list */
				FoundElement := (FoundElement->NextElement) As HashMapElement*
			}
		}
	}
	
	ResolveAllLabels(&C)
	
	AddData(C.Builder, 0x149)
	
	AddImport(C.Builder, AToS("Kernel32"), AToS("ExitProcess"), 0)
	AddImport(C.Builder, AToS("Kernel32"), AToS("LocalFree"), 0)
	
	AddCode(C.Builder, C.CodeBuffer, C.CodeBufferSize)
	
	for (i32 RelocationIndex := 0, RelocationIndex < (C.CodeRelocationCount), RelocationIndex += 1) {
		i32 NextRelocationOffset := (C.CodeRelocations)[RelocationIndex]
		
		i32 PageRVA := (C.Builder->NextRVA) + (NextRelocationOffset / 0x1000)
		i16 OffsetInPage := (NextRelocationOffset % 0x1000) As i16
		
		AddRelocation(C.Builder, PageRVA, OffsetInPage, true)
	}
	
	FinalizeBuilder(C.Builder)
	
	WriteBuilder(C.Builder, "text.exe")
	
}

define i8 PushRegisterStack(CompilerState* cState) {
	i8 Result := (cState->RegisterStackIndex) + 8
	
	cState->RegisterStackIndex += 1
	
	return Result
}
define i8 TopOfRegisterStack(CompilerState* cState) {
	return (cState->RegisterStackIndex) + 8
}

define i8 PopRegisterStack(CompilerState* cState) {
	cState->RegisterStackIndex -= 1
	
	return (cState->RegisterStackIndex) + 8
}

define void EnsureCodeBufferSize(CompilerState* cState) {
	if ((cState->Index + 0x10) >= (cState->CodeBufferSize)) {
		cState->CodeBufferSize += 0x100
		cState->CodeBuffer := ReAlloc(cState->CodeBuffer, cState->CodeBufferSize)
	}
}

#Include CodeGen.rlx

define void AddCodeRelocation(CompilerState* cState, i32 Offset) {
	i32 Index := cState->CodeRelocationCount
	
	cState->CodeRelocations := ReAlloc(cState->CodeRelocations, (Index + 1) * 8)
	(cState->CodeRelocations)[Index] := Offset
	
	cState->CodeRelocationCount += 1
}


/*
==========================================
	Variable helpers
==========================================
*/

define void GetVariableValue(CompilerState* cState, VariableInfo* TargetVariable, i8 ResultRegister) {
	PrintSafeString(TargetVariable->Name)
	WriteCharacter(':')
	IWriteLine(TargetVariable->StackOffset)
	
	if (TargetVariable->Type->PointerDepth = 0 && TargetVariable->Type->TrueType->IsStructType) {
		/* If GetVariableValue is called on a struct, then we should actually result in a pointer to that struct
			So Compile(Get|Set)StructField can depending on getting a pointer, and never the struct as a number
			Any time this could be abused *should* be caught by type checking 
		*/
		
		GetVariableAddress(cState, TargetVariable, ResultRegister)
	}
	else {
		if (TargetVariable->StackOffset < 112) {
			EmitMove_RX_RX_DISP8(cState, ResultRegister, RBP, -(TargetVariable->StackOffset + 8), TargetVariable->Type->Size)
		}
		else {
			EmitMove_RX_RX_DISP32(cState, ResultRegister, RBP, -(TargetVariable->StackOffset + 8), TargetVariable->Type->Size)
		}
	}
}
define void GetVariableAddress(CompilerState* cState, VariableInfo* TargetVariable, i8 ResultRegister) {
	PrintSafeString(TargetVariable->Name)
	WriteCharacter(':')
	IWriteLine(TargetVariable->StackOffset)
	
	if (TargetVariable->StackOffset < 112) {
		EmitLea_R64_R64_DISP8(cState, ResultRegister, RBP, -(TargetVariable->StackOffset + 8))
	}
	else {
		EmitLea_R64_R64_DISP32(cState, ResultRegister, RBP, -(TargetVariable->StackOffset + 8))
	}
}
define void SetVariableValue(CompilerState* cState, VariableInfo* TargetVariable, i8 SourceRegister) {
	PrintSafeString(TargetVariable->Name)
	WriteCharacter(':')
	IWriteLine(TargetVariable->StackOffset)
	
	if (TargetVariable->StackOffset < 112) {
		EmitMove_RX_DISP8_RX(cState, RBP, SourceRegister, -(TargetVariable->StackOffset + 8), TargetVariable->Type->Size)
	}
	else {
		EmitMove_RX_DISP32_RX(cState, RBP, SourceRegister, -(TargetVariable->StackOffset + 8), TargetVariable->Type->Size)
	}
}


/*
==========================================
	Actual compile functions
==========================================
*/

define void Cast(CompilerState* cState, i8 Register, i8 Size) {
	EmitMove_R64_RX(cState, Register, Register, Size)
}

define void CompileImportStub(CompilerState* cState, FunctionDefine* FunctionToCompile) {
	/* Compiles an imported function by emitting a jump to the actual function */
	
	SetLabel(cState, FunctionToCompile->LabelNumber)
	
	EmitMove_R64_I64(cState, RBX, 0)
	
	i64* JumpToPointerPointer := GetIndexAsPointer(cState) - 8
	AddImport(cState->Builder, FunctionToCompile->ImportFileName, FunctionToCompile->ImportFunctionName, JumpToPointerPointer)
	AddCodeRelocation(cState, cState->Index - 8)
	
	EmitJump_RI64(cState, RBX)
}


define void CompileFunction(CompilerState* cState, FunctionDefine* FunctionToCompile) {
	/* Compiles a single function */
	
	/* Store the current return type so return can cast values to it */
	
	cState->CurrentFunctionReturnType := FunctionToCompile->ReturnType
	
	SetLabel(cState, FunctionToCompile->LabelNumber)
	
	/* Assume 4 register parameters, and 0 stack parameters */
	i8 RegisterParameterCount := 4
	i16 StackParameterCount := 0
	
	if (FunctionToCompile->ParameterCount < 4) {
		/* If there are less than 4 parameters, then the number of register parameters is just the number of parameters */
		
		RegisterParameterCount := (FunctionToCompile->ParameterCount) As i8
	}
	else if (FunctionToCompile->ParameterCount >= 5) {
		/* Else if there are 5+ parameters, the stack parameter count is (TotalParamCount - 4) */
		
		StackParameterCount := (FunctionToCompile->ParameterCount) - 4
		
		/* Also, store RSP in RBX for extracting the stack parameters with smaller offsets */
		EmitMove_R64_R64(cState, RBX, RSP)
	}
	
	/* Set up the stack frame for this function */
	i16 LocalSpace := FunctionToCompile->LocalOffset
	i16 LocalSpaceRemainder := LocalSpace % 16
	
	if (LocalSpaceRemainder) {
		/* Round the space up to a multiple of 16 to keep the stack aligned */
		LocalSpace += (16 - LocalSpaceRemainder)
	}
	
	EmitEnter_I16(cState, FunctionToCompile->LocalOffset)
	
	for (i8 RegisterParameterIndex := 0, RegisterParameterIndex < RegisterParameterCount, RegisterParameterIndex += 1) {
		/* For each register parameter */
		
		/* Get the VariableInfo structure for the parameter */
		VariableInfo* NextParameter := (FunctionToCompile->Parameters)[RegisterParameterIndex]
		
		/* And which register it is in (RCX/RDX/R8/R9) */
		i8 NextParameterRegister := RegisterParameterIndex + 1
		
		if (NextParameterRegister > 2) {
			NextParameterRegister += 5
		}
		
		/* And write the parameter register's value into the parameter's stack space */
		SetVariableValue(cState, NextParameter, NextParameterRegister)
	}
	
	for (i16 StackParameterIndex := 0, StackParameterIndex < StackParameterCount, StackParameterIndex += 1) {
		/* For each stack parameter */
		
		/* Get the VariableInfo structure for the parameter */
		VariableInfo* NextStackParameter := (FunctionToCompile->Parameters)[StackParameterIndex + 4]
		
		/* Load RAX with the parameter's value (using RBX as a base) */
		EmitMove_RX_RX_DISP8(cState, RAX, RBX, 0x28 + (StackParameterIndex * 8), NextStackParameter->Type->Size)
		
		/* Write RAX(/the parameter's value) into the parameter's stack space */
		SetVariableValue(cState, NextStackParameter, RAX)
	}
	
	/* Compile the body of the function */
	CompileBlock(cState, FunctionToCompile->Body)
}
define void CompileBlock(CompilerState* cState, Block* BlockToCompile) {
	/* Compiles a block of statements */
	
	for (i32 Index := 0, Index < BlockToCompile->StatementCount, Index += 1) {
		ASTNode* NextStatement := (BlockToCompile->Statements)[Index]
		
		Compile(cState, NextStatement)
	}
}
define void CompileReturn(CompilerState* cState, ASTNode* ReturnExpression) {
	/* Compiles a return statement */
	
	/* Compile the expression to return */
	CompileExpression(cState, RAX, ReturnExpression)
	
	AWrite("aaaaaaaaaaaaaaaaaaaaa ")
	IWriteLine(ReturnExpression->ValueType->Size)
	
	i16 ReturnValueSize := ReturnExpression->ValueType->Size
	i16 ReturnTypeSize := cState->CurrentFunctionReturnType->Size
	
	if (ReturnValueSize < ReturnTypeSize || ReturnValueSize < 4) {
		Cast(cState, RAX, ReturnValueSize)
	}
	
	EmitLeave(cState)
	EmitReturn(cState)
}
define void Compile(CompilerState* cState, ASTNode* NodeToCompile) {
	/* Compiles some kind of statement */
	
	i8 NodeType := NodeToCompile->NodeType
	
	if (NodeType = NODE_TYPE_RETURN) {
		CompileReturn(cState, (NodeToCompile->TrueNode) As ASTNode*)
	}
	else if (NodeType = NODE_TYPE_IF) {
		CompileIf(cState, (NodeToCompile->TrueNode) As IfGroup*)
	}
	else if (NodeType = NODE_TYPE_EXPRESSION) {
		CompileExpression(cState, RAX, (NodeToCompile->TrueNode) As ASTNode*)
	}
}

define void CompileIf(CompilerState* cState, IfGroup* IfToCompile) {
	i32 BranchCount := IfToCompile->BranchCount
	i32 HasElse := (IfToCompile->ElseBranch) != 0
	
	i32 EndLabel := NextLabel(cState)
	i32 NextBranch := NextLabel(cState)
	
	i8 ConditionResultRegister := PushRegisterStack(cState)
	
	for (i32 BranchIndex := 0, BranchIndex < BranchCount, BranchIndex += 1) {
		SetLabel(cState, NextBranch)
		NextBranch := NextLabel(cState)
		
		ASTNode* ThisBranchCondition := (IfToCompile->Conditions)[BranchIndex]
		
		CompileExpression(cState, ConditionResultRegister, ThisBranchCondition)
		
		EmitTest_RX_RX(cState, ConditionResultRegister, ConditionResultRegister, ThisBranchCondition->ValueType->Size)
		
		EmitJEZ_Label(cState, NextBranch)
		
		CompileBlock(cState, (IfToCompile->Bodies)[BranchIndex])
		
		if (HasElse || (BranchIndex != (BranchCount - 1))) {
			/* Only emit a jump to the end label if: We have an 'else', or we are not the last branch 
				This will eliminate a single extra `jmp, endlabel` on the final 'else if' of the statement
				
			*/
			
			EmitJump_Label(cState, EndLabel)
		}
	}
	
	PopRegisterStack(cState)
	
	SetLabel(cState, NextBranch)
	
	if (IfToCompile->ElseBranch) {
		CompileBlock(cState, IfToCompile->ElseBranch)
	}
	
	SetLabel(cState, EndLabel)
}


define void CompileExpression(CompilerState* cState, i8 ResultRegister, ASTNode* ExpressionToCompile) {
	/* Compiles some kind of expression */
	
	i8 ExpressionType := ExpressionToCompile->NodeType
	Type* ResultType := ExpressionToCompile->ValueType
	
	if (ExpressionType = NODE_TYPE_INTEGER) {
		/* Simply move the integer being used into the result register */
		
		EmitMove_RX_IX(cState, ResultRegister, (ExpressionToCompile->TrueNode) As i64, ExpressionToCompile->ValueType->Size)
	}
	else if (ExpressionType = NODE_TYPE_VARIABLE) {
		VariableInfo* TargetVariable := (ExpressionToCompile->TrueNode) As VariableInfo*
		
		GetVariableValue(cState, TargetVariable, ResultRegister)
	}
	else if (ExpressionType = NODE_TYPE_UNARY) {
		UnaryExpression* UnaryNode := (ExpressionToCompile->TrueNode) As UnaryExpression*
	
		CompileUnary(cState, ResultRegister, ResultType, UnaryNode)
	}
	else if (ExpressionType = NODE_TYPE_BINARY) {
		/* Calls into CompileBinary with the correct parameters extracted from ExpressionToCompile */
		
		BinaryExpression* BinaryNode := (ExpressionToCompile->TrueNode) As BinaryExpression*
		
		CompileBinary(cState, ResultRegister, ResultType, BinaryNode)
	}
	else if (ExpressionType = NODE_TYPE_STRUCT_ACCESS) {
		StructAccessExpression* AccessNode := (ExpressionToCompile->TrueNode) As StructAccessExpression*
		
		CompileGetStructAccess(cState, ResultRegister, AccessNode)
	}
	else if (ExpressionType = NODE_TYPE_CALL) {
		CallExpression* CallNode := (ExpressionToCompile->TrueNode) As CallExpression*
		
		CompileCall(cState, ResultRegister, CallNode)
	}

}

define void CompileCall(CompilerState* cState, i8 ResultRegister, CallExpression* CallNode) {
	FunctionDefine* TargetFunction := CallNode->TargetFunction
	
	if !(TargetFunction->IsImported || TargetFunction->HasFullDefinition) {
		ASTError(AllocateNewASTNode(NODE_TYPE_CALL, CallNode, 0), "Called function is only declared, and never defined")
	}
	
	
	/* Todo: Smart logic to save/restore volatile portions of the register stack */
	
	i32 ParameterCount := CallNode->ParameterCount
	i32 StackParameterCount := 0
	i8 ExtraPadding := false
	
	if (ParameterCount > 4) {
		StackParameterCount := ParameterCount - 4
	}
	
	if (StackParameterCount % 2) {
		EmitPush_R64(cState, RBX)
		ExtraPadding := true
	}
	
	
	cState->NoClobberCD89 := true /* Ensure none of the parameter registers are used for another operation without being saved */
	
	i8 ParameterRegister := RBX
	
	if (ParameterCount != 0) {
		for (i64 ParameterIndex := (ParameterCount - 1), ParameterIndex >= 0, ParameterIndex -= 1) {
			AWrite("Compiling parameter ")
			IWrite(ParameterIndex)
			AWrite(" out of ")
			IWriteLine(ParameterCount)
			
			VariableInfo* NextParameter := (TargetFunction->Parameters)[ParameterIndex]
			ASTNode* NextParameterValue := (CallNode->Parameters)[ParameterIndex]
			
			i8 ThisParameterRegister := ParameterRegister
			
			if (ParameterIndex = 3) {ThisParameterRegister := R9}
			else if (ParameterIndex = 2) {ThisParameterRegister := R8}
			else if (ParameterIndex = 1) {ThisParameterRegister := RDX}
			else if (ParameterIndex = 0) {ThisParameterRegister := RCX}
			
			CompileExpression(cState, ThisParameterRegister, NextParameterValue)
			
			if (NextParameterValue->ValueType->Size < NextParameter->Type->Size) {
				Cast(cState, ThisParameterRegister, NextParameter->Type->Size)
			}
			
			if (ParameterIndex >= 4) {
				EmitPush_R64(cState, ThisParameterRegister)
			}
		}
	}

	cState->NoClobberCD89 := false
	
	for (i32 ShadowSpaceIndex := 0, ShadowSpaceIndex < 4, ShadowSpaceIndex += 1) {
		EmitPush_R64(cState, R8 + ShadowSpaceIndex)
	}
	
	EmitCall_Label(cState, TargetFunction->LabelNumber)
	
	for (i32 ReversedShadowSpaceIndex := 0, ReversedShadowSpaceIndex < 4, ReversedShadowSpaceIndex += 1) {
		EmitPop_R64(cState, R11 - ReversedShadowSpaceIndex)
	}
	
	if (ExtraPadding) {
		EmitPop_R64(cState, RBX)
	}
	
	EmitMove_R64_RX(cState, ResultRegister, RAX, TargetFunction->ReturnType->Size)
}


define void CompileUnary(CompilerState* cState, i8 ResultRegister, Type* ResultType, UnaryExpression* ExpressionToCompile) {
	/* Compiles a unary operator and operand */
	
	i8 Operator := (ExpressionToCompile->Operator->Value) As i8
	i16 ResultSize := ResultType->Size
	
	if (Operator = OPERATOR_AND) {
		VariableInfo* OperandVariable := (ExpressionToCompile->Operand->TrueNode) As VariableInfo*
		
		GetVariableAddress(cState, OperandVariable, ResultRegister)
	}
	else {
		/* Only compile the operand when the operator isn't `&` (since it doesn't use the operand value) */
		CompileExpression(cState, ResultRegister, ExpressionToCompile->Operand)
		
		if (Operator = OPERATOR_STAR) {
			EmitMove_RX_RIX(cState, ResultRegister, ResultRegister, ResultSize)
		}
		else if (Operator = OPERATOR_MINUS) {
			EmitNeg_RX(cState, ResultRegister, ResultSize)
		}
		else if (Operator = OPERATOR_BANG) {
			EmitTest_RX_RX(cState, ResultRegister, ResultRegister, ResultSize)
			EmitSetE_R8(cState, ResultRegister)
			
			if (ResultSize > 1) {
				Cast(cState, ResultRegister, ResultSize)
			}
		}
	}
}

define void CompileGetStructAccess(CompilerState* cState, i8 ResultRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	i16 TargetFieldSize := TargetField->ValueType->Size
	
	/* CompileExpression will always result in a struct pointer, even for local structs (in order for this to be shorter) */
	CompileExpression(cState, ResultRegister, TargetAccess->Left)
	EmitMove_RX_RX_DISP8(cState, ResultRegister, ResultRegister, TargetField->Offset, TargetFieldSize)
}

define void CompileSetStructAccess(CompilerState* cState, i8 ValueRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	
	i8 ResultPointerRegister := PushRegisterStack(cState)
	CompileExpression(cState, ResultPointerRegister, TargetAccess->Left)
	
	EmitMove_RX_DISP8_RX(cState, ResultPointerRegister, ValueRegister, TargetField->Offset, TargetField->ValueType->Size)
	
	PopRegisterStack(cState)
}

define void CompileBinary(CompilerState* cState, i8 ResultRegister, Type* ResultType, BinaryExpression* ExpressionToCompile) {
	/* Compiles a binary expression, and both operands of the expression */
	
	ASTNode* Left := ExpressionToCompile->Left
	ASTNode* Right := ExpressionToCompile->Right
	
	i16 LeftSize := Left->ValueType->Size
	i16 RightSize := Right->ValueType->Size
	i16 ResultSize := ResultType->Size
	
	i8 LeftRegister := ResultRegister
	
	i8 Operator := (ExpressionToCompile->Operator->Value) As i8
	
	if (Operator = OPERATOR_COLON_EQUAL) {
		/* This is an assignment, so we can reuse the result register for the side side, and ignore the left */
		
		CompileExpression(cState, ResultRegister, Right)
		
		if (Left->NodeType = NODE_TYPE_VARIABLE) {
			VariableInfo* TargetVariable := (Left->TrueNode) As VariableInfo*
			
			SetVariableValue(cState, TargetVariable, ResultRegister)
		}
		else if (Left->NodeType = NODE_TYPE_STRUCT_ACCESS) {
			CompileSetStructAccess(cState, ResultRegister, (Left->TrueNode) As StructAccessExpression*)
		}
	}
	else {
		/* As long as we're not compiling an assignment, compile the left operand into the result register */
		
		CompileExpression(cState, LeftRegister, Left)
		
		if (Operator = OPERATOR_AS) {
			/* For 'As', just compile the left operand, cast it, and return */
			Type* RightType := (Right->TrueNode) As Type*
			
			if (Left->NodeType != NODE_TYPE_INTEGER) {
				/* Only emit cast instructions for values which aren't integers, since integer casts are done at compile time */
				
				Cast(cState, LeftRegister, RightType->Size)
			}
		}
		else if (OPERATOR_FIRST_SHORT_CIRCUIT <= Operator && Operator <= OPERATOR_LAST_SHORT_CIRCUIT) {
			i32 End := NextLabel(cState)
			
			EmitTest_RX_RX(cState, LeftRegister, LeftRegister, ResultSize)
			EmitSetNE_R8(cState, ResultRegister)
			
			if (Operator = OPERATOR_LOGICAL_AND) {
				EmitJEZ_Label(cState, End)
			}
			else if (Operator = OPERATOR_LOGICAL_OR) {
				EmitJNZ_Label(cState, End)
			}
			
			CompileExpression(cState, LeftRegister, Right)
				
			EmitTest_RX_RX(cState, LeftRegister, LeftRegister, ResultSize)
			EmitSetNE_R8(cState, ResultRegister)
			
			SetLabel(cState, End)
		
			if (ResultSize > 1) {
				Cast(cState, ResultRegister, ResultSize)
			}
		}
		else {
			/* Allocate a new register for the right operand */
			
			i8 RightRegister := PushRegisterStack(cState)
			CompileExpression(cState, RightRegister, Right)
			
			if (OPERATOR_FIRST_COMPARISON <= Operator && Operator <= OPERATOR_LAST_COMPARISON) {
				ResultSize := GetBinaryResultType(0 As ParserState*, Left->ValueType, Right->ValueType)->Size
				EmitCmp_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
	
			/* If either operand is smaller than the result type, cast it up to the R64 (aka any possible size) */
			if (RightSize < ResultSize) {
				Cast(cState, RightRegister, ResultSize)
			}
			if (LeftSize < ResultSize) {
				Cast(cState, LeftRegister, ResultSize)
			}
			
			/* Also uses uses the correct instruction for two ResultType sized operands (casting should be done this is called) */
			
			if (Operator = OPERATOR_PLUS) {
				EmitAdd_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			else if (Operator = OPERATOR_MINUS) {
				EmitSub_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			else if (Operator = OPERATOR_STAR) {
				if (ResultType->Size = 1) {
					/* Do 8 bit multiplication as 16 bit, and cast the result back down to 8 bits (since there is no imul r8, r8 instruction */
					EmitIMul_R16_R16(cState, LeftRegister, RightRegister)
					Cast(cState, LeftRegister, 1)
				}
				else {	
					EmitIMul_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
				}
			}
			else if (Operator = OPERATOR_SLASH || Operator = OPERATOR_PERCENT) {
				if (LeftRegister != RAX) {
					/* Handle the left operand not being in RAX by saving RAX into a temp register and setting RAX := Left */
					
					i8 TempRAX := PushRegisterStack(cState)
					
					EmitMove_RX_RX(cState, TempRAX, RAX, ResultSize)
					EmitMove_RX_RX(cState, RAX, LeftRegister, ResultSize)
				}
				
				if (cState->NoClobberCD89) {
					EmitPush_R64(cState, RDX)
				}
				
				if (ResultSize = 1) {
					/* Handle 8 bit division through a 16 bit operation, which will have a result casted down */
					EmitCWD(cState)
					EmitIDiv_RAX_R16(cState, RightRegister)
				}
				else {
					EmitCXX(cState, ResultSize)
					EmitIDiv_RAX_RX(cState, RightRegister, ResultSize)
				}
				
				if (Operator = OPERATOR_SLASH && ResultRegister != RAX) {
					EmitMove_RX_RX(cState, ResultRegister, RAX, ResultSize)
					EmitMove_RX_RX(cState, RAX, TempRAX, ResultSize)
					PopRegisterStack(cState)
				}
				else if (Operator = OPERATOR_PERCENT && ResultRegister != RDX) {
					EmitMove_RX_RX(cState, ResultRegister, RDX, ResultSize)
				}
				/* else {
					The result is already in the correct register
				}
				*/
				
				if (cState->NoClobberCD89) {
					EmitPop_R64(cState, RDX)
				}
				
				if (ResultSize = 1) {
					Cast(cState, ResultRegister, 1)
				}
			}
			else if (Operator = OPERATOR_EQUAL) {
				EmitSetE_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_BANG_EQUAL) {
				EmitSetNE_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_LESS) {
				EmitSetL_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_LESS_EQAUL) {
				EmitSetLE_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_GREATER) {
				EmitSetG_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_GREATER_EQAUL) {
				EmitSetGE_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_AND) {
				EmitAnd_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			else if (Operator = OPERATOR_OR) {
				EmitOr_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			
			PopRegisterStack(cState) /* Pop the right register */
		}
	}
}