struct Token {
    void* Value,
    i16 PositionInSource,
    i16 LengthInSource,
    i8 Type
}

struct SafeWideString {
    i32 Length,
    i16* Buffer
}

struct TokenizerState {
    i16* Source,
    Token** Tokens,
    i32 SourceLength,
    i32 Index
}

Import Console

define i32 Main(i64 ArgC, i16** ArgV) {
	i16* Source := ArgV[1]
	
	TokenizerState T
	T.Source := Source
	T.SourceLength := 30
	
	Token* F := GetNextToken(&T)
	
	Console:AWrite("T:")
	Console:IWrite(F->Value)

}


i8 TOKEN_OPERATOR := 0
i8 TOKEN_IDENTIFER := 1

i8 TOKEN_COLON_EQUAL := 2

define i16 PeekNextCharacter(TokenizerState* pState) {
    return (pState->Source)[pState->Index + 1]
}
define i16 GetNextCharacter(TokenizerState* pState) {
    i16 NextCharacter := PeekNextCharacter(pState)

    pState->Index += 1
    return NextCharacter
}


define Token* GetNextToken(TokenizerState* pState) {
    while (pState->Index <= pState->SourceLength) {
        i32 StartingIndex := pState->Index
        i16 NextCharacter := GetNextCharacter(pState)
		
		Console:IWrite(NextCharacter)

        if (NextCharacter = ':' && PeekNextCharacter(pState) = '=') {
            GetNextCharacter(pState)
            return MakeToken(StartingIndex, pState->Index, TOKEN_OPERATOR, TOKEN_COLON_EQUAL)
        }
        else if (IsAlpha(NextCharacter)) {
            i16 Next := PeekNextCharacter(pState)

            while (IsAlpha(NextCharacter)) {
                Next := GetNextCharacter(pState)
            }

            return MakeToken(StartingIndex, pState->Index, TOKEN_IDENTIFER, MakeSafeString(pState, StartingIndex))
        }
    }
}

define void* MakeSafeString(TokenizerState* pState, i32 StartingIndex) {
	return 0 As void*
    //SafeWideString* NewSafeString := AllocateNewSafeString()

    //NewSafeString->Length := pState->Index - StartingIndex
    //NewSafeString->Buffer := pState->Source + (StartingIndex * 2)

    //return NewSafeString As void*
}

define Token* AllocateNewToken() {
	return Alloc(Token.Size) As Token*
}

define Token* MakeToken(i16 PositionInSource, i16 EndPositionInSource, i8 Type, void* Value) {
    Token* OutputToken := AllocateNewToken()

    OutputToken->PositionInSource := PositionInSource
    OutputToken->LengthInSource := EndPositionInSource - PositionInSource
    OutputToken->Type := Type
    OutputToken->Value := Value

    return OutputToken
}

define i8 IsAlpha(i16 Character) {
    if (Character >= 'a' && Character <= 'z') {
        return 1
    }
    else if (Character >= 'A' && Character <= 'Z') {
        return 1
    }

    return 0
}