struct HashMapElement {
	i64 Hash,
	void Value,
	void* NextElement
}

struct HashMap {
	i32 BufferMaxCount,
	void *Elements
}

define HashMap* NewHashMap() {
	HashMap* NewMap := Alloc(HashMap.Size) As HashMap*
	
	NewMap->BufferMaxCount := 50
	NewMap->Elements := Alloc(NewMap->BufferMaxCount * 8)
	
	return NewMap
}
define i64 HashString(SafeWideString* StringToHash) {
	i64 Hash := 5281
	i32 Index := 0
	
	loop (StringToHash->Length) {
		Hash := ((Hash * 32) + Hash) ^ ((StringToHash->Buffer)[Index])
		Index += 1
	}
	
	return Hash
}
define HashMapElement* HashMapFindElement(HashMap* TargetMap, i64 Hash) {
	i64 Index := Hash % (TargetMap->BufferMaxCount)
	
	HashMapElement* Node := (TargetMap->Elements)[Index]
	
	if !(Node) {
		return false As HashMapElement*
	}

	while (Node->Hash != Hash) {
		if !(Node->NextElement) {
			return Node
		}
		
		Node := (Node->NextElement) As HashMapElement*
		/* The cast is since types can't contain themselves yet */
	}
	
	return Node
}
define HashMapElement* HashMapGetValue(HashMap* TargetMap, SafeWideString* Key) {
	i64 Hash := HashString(Key)
	
	HashMapElement* Result := HashMapFindElement(TargetMap, Hash)
	
	if (Result != 0) {
		if (Result->Hash = Hash) {
			return Result
		}
	}
	
	return false As HashMapElement*
}
define void HashMapAddValue(HashMap* TargetMap, SafeWideString* Key, void Value) {
	i64 Hash := HashString(Key)
	i64 Index := Hash % (TargetMap->BufferMaxCount)
	
	HashMapElement* TailElement := HashMapFindElement(TargetMap, Hash)
	HashMapElement* NewElement := 0
	
	if (TailElement = 0) {
		/* If TailElement = 0 then:
			No linked list exists for this index
			Create one, and insert the head into the element list
		*/
		
		NewElement := Alloc(HashMapElement.Size) As HashMapElement*
		NewElement->NextElement := 0
		
		(TargetMap->Elements)[Index] := NewElement
	}
	else if (TailElement->Hash != Hash) {
		/* else if TailElement->Hash != Hash:
			Linked list exists, but doesn't contain the key yet
			Create new element, and insert it into to the list
		*/
		
		NewElement := Alloc(HashMapElement.Size) As HashMapElement*
		NewElement->NextElement := TailElement->NextElement
	
		TailElement->NextElement := NewElement
	}
	else {
		/* Else, the tail node exists, and the hash matches
			Aka this key already has an element
			So just overwrite the values in it
		*/
		
		NewElement := TailElement
		TailElement->NextElement := 0
	}
	
	NewElement->Hash := Hash
	NewElement->Value := Value
}





struct Token {
	void* Value,
	i32 PositionInSource,
	i16 LengthInSource,
	i8 Type
}

struct SafeWideString {
	i32 Length,
	i16* Buffer
}

define SafeWideString* AToS(i8* SourceString) {
	SafeWideString* NewString := Alloc(SafeWideString.Size) As SafeWideString*
	
	i32 Length := 0
	
	loop {
		i8 NextCharacter := SourceString[Length]
		
		if (NextCharacter = 0) {
			Break
		}
		
		Length += 1
	}
	
	NewString->Buffer := AToW(SourceString, Length)
	NewString->Length := Length
	
	return NewString
}

struct TokenizerState {
	i16* Source,
	Token** Tokens,
	i32 SourceLength,
	i32 Index
}

Import Console

DllImport i64 CreateFile(i16*, i32, i32, void*, i32, i32, i64) {Kernel32.dll, CreateFileW}
DllImport i32 GetFileSize(i64, void) {Kernel32.dll, GetFileSize}
DllImport i8 ReadFile(i64, void*, i32, i32*, void) {Kernel32.dll, ReadFile}
DllImport i8 CloseHandle(i64) {Kernel32.dll, CloseHandle}

DllImport i32 GetLastError() {Kernel32.dll, GetLastError}

define i32 Main(i64 ArgC, i16** ArgV) {	
	if (ArgC != 2) {
		Console:AWriteLine("No input file, aborting")
		Exit(1)
	}
	
	i16* InputFilePath := ArgV[1]
	
	i64 GENERIC_READ := 0x80000000
	i8 FILE_SHARE_READ := 1
	i8 FILE_SHARE_WRITE := 2
	i8 OPEN_EXISTING := 3
	i16 FILE_ATTRIBUTE_NORMAL := 128
	
	i64 InputFileHandle := CreateFile(InputFilePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)
	
	if (InputFileHandle = -1) {
		Console:AWrite("Could not open input file: error code ")
		Console:IWriteLine(GetLastError())
		Console:AWriteLine("Aborting")
		Exit(1)
	}
	
	Console:AWrite("Input File: ")
	Console:WriteLine(InputFilePath)
	
	i32 InputFileSize := GetFileSize(InputFileHandle, 0)
	void* FileBuffer := Alloc(InputFileSize)
	
	i32 ReadFileBytesRead := 0
	i8 ReadFileSuccess := ReadFile(InputFileHandle, FileBuffer, InputFileSize, &ReadFileBytesRead, 0)
	
	if (!(ReadFileSuccess) || ReadFileBytesRead != InputFileSize) {
		Console:AWrite("Could not open read file: error code ")
		Console:IWriteLine(GetLastError())
		Console:AWriteLine("Aborting")
		Exit(1)
	}
	
	i16* Source := AToW(FileBuffer As i8*, InputFileSize)
	
	Free(FileBuffer)
	CloseHandle(InputFileHandle)
	
	TokenizerState T
	T.Source := Source
	T.SourceLength := WideStringLength(Source) - 1
	T.Index := 0
	
	ParserStart(&T)
}

define i16* AToW(i8* AString, i32 Length) {
	i16* NewBuffer := (Alloc((Length * 2) + 2) As i16*)
	
	for (i32 Index := 0, Index < Length, Index += 1) {
		NewBuffer[Index] := AString[Index]
	}
	
	return NewBuffer
}

define i32 WideStringLength(i16* WideString) {
	i16 NextCharacter := WideString[0]
	i32 Index := 0
	
	while (NextCharacter != 0) {
		NextCharacter := WideString[Index]
		Index += 1
	}
	
	return Index
}

i8 TOKEN_TYPE_EOF := 0
i8 TOKEN_TYPE_NONE := 100
i8 TOKEN_TYPE_OPERATOR := 1
i8 TOKEN_TYPE_IDENTIFER := 2
i8 TOKEN_TYPE_INTEGER := 3
i8 TOKEN_TYPE_STRING := 4
i8 TOKEN_TYPE_PUNCTUATION := 5
i8 TOKEN_TYPE_KEYWORD := 6


i8 OPERATOR_COLON_EQUAL := 0
i8 OPERATOR_PLUS_EQUAL := 1
i8 OPERATOR_MINUS_EQUAL := 2
i8 OPERATOR_STAR_EQUAL := 3

i8 OPERATOR_PLUS := 4
i8 OPERATOR_MINUS := 5
i8 OPERATOR_STAR := 6
i8 OPERATOR_SLASH := 7
i8 OPERATOR_EQUAL := 8
i8 OPERATOR_DOT := 9

i8 OPERATOR_MINUS_GREATER := 10
i8 OPERATOR_BANG := 11

i8 OPERATOR_LOGICAL_AND := 12
i8 OPERATOR_LOGICAL_OR := 13

i8 OPERATOR_LESS := 14
i8 OPERATOR_LESS_EQAUL := 15
i8 OPERATOR_GREATER := 16
i8 OPERATOR_GREATER_EQAUL := 17

i8 OPERATOR_AND := 18
i8 OPERATOR_OR := 19

i8 OPERATOR_COLON := 20
i8 OPERATOR_AS := 21

i8 OPERATOR_BANG_EQUAL := 22
i8 OPERATOR_OPEN_BRACKET := 23


i8 PUNCTUATION_OPEN_PAREN := 0
i8 PUNCTUATION_CLOSE_PAREN := 1

i8 PUNCTUATION_OPEN_BRACE := 2
i8 PUNCTUATION_CLOSE_BRACE := 3

i8 PUNCTUATION_CLOSE_BRACKET := 4

i8 PUNCTUATION_COMMA := 5


i8 KEYWORD_DEFINE := 0
i8 KEYWORD_DLLIMPORT := 1

i8 KEYWORD_IF := 2
i8 KEYWORD_ELSE := 3

i8 KEYWORD_FOR := 4
i8 KEYWORD_WHILE := 5
i8 KEYWORD_LOOP := 6

i8 KEYWORD_CONTINUE := 7
i8 KEYWORD_BREAK := 8

i8 KEYWORD_STRUCT := 9
i8 KEYWORD_RETURN := 10

define void Backtrack(TokenizerState* pState) {
	pState->Index -= 1
}

define i16 PeekNextCharacter(TokenizerState* pState) {
	return Lower((pState->Source)[pState->Index])
}
define i16 GetNextCharacter(TokenizerState* pState) {
	i16 NextCharacter := PeekNextCharacter(pState)

	pState->Index += 1
	return NextCharacter
}
define i8 NextCharacterMatches(TokenizerState* pState, i8 CharacterToCheck) {
	if (PeekNextCharacter(pState) = CharacterToCheck) {
		GetNextCharacter(pState)
		return 1
	}
	
	return 0
}

define i8 TokenizerAtEnd(TokenizerState* pState) {
	return (pState->Index) > (pState->SourceLength)
}

define void TokenizerError(TokenizerState* pState, i8* Message) {
	Console:AWriteLine(Message)
	Console:AWrite("At: ")
	
	Backtrack(pState)
	Console:IWriteLine(pState->Index)
	Exit(1)
}


define Token* GetNextToken(TokenizerState* pState) {
	while (!TokenizerAtEnd(pState)) {
		i32 StartingIndex := pState->Index
		i16 NextCharacter := GetNextCharacter(pState)

		if (PeekNextCharacter(pState) = '=') {
			GetNextCharacter(pState)
			
			i8 NewType := TOKEN_TYPE_NONE
			
			if (NextCharacter = ':') {
				NewType := OPERATOR_COLON_EQUAL
			}
			else if (NextCharacter = '+') {
				NewType := OPERATOR_PLUS_EQUAL
			}
			else if (NextCharacter = '-') {
				NewType := OPERATOR_MINUS_EQUAL
			}
			else if (NextCharacter = '*') {
				NewType := OPERATOR_STAR_EQUAL
			}
			else if (NextCharacter = '<') {
				NewType := OPERATOR_LESS_EQAUL
			}
			else if (NextCharacter = '>') {
				NewType := OPERATOR_GREATER_EQAUL
			}
			else if (NextCharacter = '!') {
				NewType := OPERATOR_BANG_EQUAL
			}
			else {
				Backtrack(pState)
			}
			
			if (NewType != TOKEN_TYPE_NONE) {
				return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, NewType)
			}
		}
		
		if (NextCharacter = ''') {
			NextCharacter := GetNextCharacter(pState)
			
			if (GetNextCharacter(pState) != ''') {
				TokenizerError(pState, "Expected close single quote for character constant")
			}
			
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_INTEGER, NextCharacter)
		}
		else if (NextCharacter = '=') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_EQUAL)
		}
		else if (NextCharacter = '+') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_PLUS)
		}
		else if (NextCharacter = '-') {
			if (NextCharacterMatches(pState, '>')) {
				return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_MINUS_GREATER)
			}
			
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_MINUS)
		}
		else if (NextCharacter = '*') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_STAR)
		}
		else if (NextCharacter = '/') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_SLASH)
		}
		else if (NextCharacter = '.') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_DOT)
		}
		else if (NextCharacter = '<') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_LESS)
		}
		else if (NextCharacter = '>') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_GREATER)
		}
		else if (NextCharacter = '&') {
			if (NextCharacterMatches(pState, '&')) {
				return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_LOGICAL_AND)
			}
			
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_AND)
		}
		else if (NextCharacter = '|') {
			if (NextCharacterMatches(pState, '|')) {
				return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_LOGICAL_OR)
			}
			
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_OR)
		}
		else if (NextCharacter = '!') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_BANG)
		}
		else if (NextCharacter = ':') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_COLON)
		}
		else if (NextCharacter = 'a' && PeekNextCharacter(pState) = 's') {
			GetNextCharacter(pState)
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_AS)
		}
		else if (NextCharacter = '(') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)
		}
		else if (NextCharacter = ')') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)
		}
		else if (NextCharacter = '{') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)
		}
		else if (NextCharacter = '}') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)
		}
		else if (NextCharacter = '[') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET)
		}
		else if (NextCharacter = ']') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET)
		}
		else if (NextCharacter = ',') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
		}
		else if (NextCharacter = '"') {
			NextCharacter := 0
			
			while ((NextCharacter != '"') && (!TokenizerAtEnd(pState))) {
				NextCharacter := GetNextCharacter(pState)
			}
			
			if (TokenizerAtEnd(pState)) {
				TokenizerError(pState, "Expected close quote before EOF")
			}
			
			SafeWideString* FoundString := MakeSafeStringToken(pState, StartingIndex + 1) As SafeWideString*
			FoundString->Length -= 1
			
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_STRING, FoundString As void*)
		}
		else if (IsNumeric(NextCharacter)) {
			i8 NumberIsHex := false
			
			if (NextCharacterMatches(pState, 'x')) {
				NumberIsHex := true
				
				NextCharacter := PeekNextCharacter(pState)
				
				while (IsHex(NextCharacter) && (!TokenizerAtEnd(pState))) {
					NextCharacter := GetNextCharacter(pState)
				}
			}
			else {
				while (IsNumeric(NextCharacter) && (!TokenizerAtEnd(pState))) {
					NextCharacter := GetNextCharacter(pState)
				}
			}
			
			if !(TokenizerAtEnd(pState)) {
				Backtrack(pState)
			}
			
			SafeWideString* AsString := (MakeSafeStringToken(pState, StartingIndex + (NumberIsHex * 2)) As SafeWideString*)
			i8 NumberWasConverted := 0
			Token* ResultToken := MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_INTEGER, 0)
			
			if (NumberIsHex) {
				ResultToken->Value := SafeStringHexToI64(AsString, &NumberWasConverted)
			}
			else {
				ResultToken->Value := SafeStringToI64(AsString, &NumberWasConverted)
			}
			
			FreeSafeString(AsString)
			
			return ResultToken
		}
		else if (IsAlpha(NextCharacter) || NextCharacter = '_') {
			while (IsAlphaNumeric(NextCharacter) && (!TokenizerAtEnd(pState))) {
				NextCharacter := GetNextCharacter(pState)
			}
			
			if !(TokenizerAtEnd(pState)) {
				Backtrack(pState)
			}
			
			SafeWideString* TokenText := MakeSafeStringToken(pState, StartingIndex) As SafeWideString*
			
			i8 TokenAsKeyword := LookupKeyword(TokenText)
			
			if (TokenAsKeyword != TOKEN_TYPE_NONE) {
				FreeSafeString(TokenText)
				return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_KEYWORD, TokenAsKeyword)
			}
			else {		
				return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_IDENTIFER, TokenText As void*)
			}
		}
		
		if (NextCharacter = ' ' || NextCharacter = '	') {
			continue
		}
		else if (NextCharacter = 10 || NextCharacter = 13) {
			continue
		}
		else if (NextCharacter = 0) {
			continue
		}
		
		Console:WriteCharacter(NextCharacter)
		TokenizerError(pState, " - Unexpected character")
	}
	
	return MakeToken(pState->SourceLength, pState->SourceLength, TOKEN_TYPE_EOF, 0)
}

define i8 LookupKeyword(SafeWideString* PotentialKeyword) {
	if (SafeStringEqualsAString(PotentialKeyword, "define")) {
		return KEYWORD_DEFINE
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "dllimport")) {
		return KEYWORD_DLLIMPORT
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "if")) {
		return KEYWORD_IF
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "else")) {
		return KEYWORD_ELSE
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "for")) {
		return KEYWORD_FOR
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "while")) {
		return KEYWORD_WHILE
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "loop")) {
		return KEYWORD_LOOP
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "continue")) {
		return KEYWORD_CONTINUE
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "break")) {
		return KEYWORD_BREAK
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "struct")) {
		return KEYWORD_STRUCT
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "return")) {
		return KEYWORD_RETURN
	}
	
	return TOKEN_TYPE_NONE
}

define i16 Lower(i16 Character) {
	if ('A' <= Character && Character <= 'Z') {
		Character += 32
	}
	
	return Character
}

define i8 CharacterEqualsNoCase(i16 CharacterOne, i16 CharacterTwo) {
	return Lower(CharacterOne) = Lower(CharacterTwo)
}

define i8 SafeStringEqualsAString(SafeWideString* StringOne, i8* StringTwo) {
	i32 Index := 0
	
	loop {
		if (Index >= StringOne->Length) {
			if (StringTwo[Index] = 0) {
				return true
			}
			else {
				return false
			}
		}
		else if (StringTwo[Index] = 0) {
			return false
		}
		
		if !(CharacterEqualsNoCase((StringOne->Buffer)[Index], StringTwo[Index])) {
			return false
		}
		
		Index += 1
	}

	return true
}

define SafeWideString* AllocateNewSafeString() {
	return Alloc(SafeWideString.Size) As SafeWideString*
}
define void FreeSafeString(SafeWideString* StringToFree) {
	Free(StringToFree As void*)
}

define void* MakeSafeStringToken(TokenizerState* pState, i32 StartingIndex) {
	SafeWideString* NewSafeString := AllocateNewSafeString()

	NewSafeString->Length := pState->Index - StartingIndex
	NewSafeString->Buffer := pState->Source + (StartingIndex * 2)

	return NewSafeString As void*
}

define void PrintSafeString(SafeWideString* StringToPrint) {
	i32 CharactersWritten := 0
	
	Console:WriteConsole(Console:STDOUT, StringToPrint->Buffer, StringToPrint->Length, &CharactersWritten, 0)
	
	return CharactersWritten
}

define Token* AllocateNewToken() {
	return Alloc(Token.Size) As Token*
}
define void FreeToken(Token* TokenToFree) {
	if (TokenToFree->Type = TOKEN_TYPE_IDENTIFER || TokenToFree->Type = TOKEN_TYPE_STRING) {
		FreeSafeString((TokenToFree->Value) As SafeWideString*)
	}
	
	Free(TokenToFree As void*)
}
define void FreeTokenOnly(Token* TokenToFree) {
	Free(TokenToFree As void*)
}

define Token* MakeToken(i16 PositionInSource, i16 EndPositionInSource, i8 Type, void* Value) {
	Token* OutputToken := AllocateNewToken()

	OutputToken->PositionInSource := PositionInSource
	OutputToken->LengthInSource := EndPositionInSource - PositionInSource
	OutputToken->Type := Type
	OutputToken->Value := Value
	
	return OutputToken
}

define void PrintToken(Token* TokenToPrint) {
	Console:AWrite("Type: ")
	Console:IWriteLine(TokenToPrint->Type)
	
	Console:AWrite("Value")
	
	if (TokenToPrint->Type = TOKEN_TYPE_IDENTIFER) {
		Console:AWrite(" (S): ")
		
		PrintSafeString((TokenToPrint->Value) As SafeWideString*)
		
		Console:WriteNewLine()
	}
	else if (TokenToPrint->Type = TOKEN_TYPE_STRING) {
		Console:AWrite(" (S): ")
		
		Console:WriteCharacter('"')
		PrintSafeString((TokenToPrint->Value) As SafeWideString*)
		Console:WriteCharacter('"')
		
		Console:WriteNewLine()
	}
	else if (TokenToPrint->Type = TOKEN_TYPE_OPERATOR) {
		Console:AWrite(" (O): ")
		
		PrintOperator(TokenToPrint->Value)
		Console:WriteNewLine()
	}
	else if (TokenToPrint->Type = TOKEN_TYPE_PUNCTUATION) {
		Console:AWrite(" (P): ")
		
		PrintPunctuation(TokenToPrint->Value)
		Console:WriteNewLine()
	}
	else if (TokenToPrint->Type = TOKEN_TYPE_KEYWORD) {
		Console:AWrite(" (K): ")
		
		PrintKeyword(TokenToPrint->Value)
		Console:WriteNewLine()
	}
	else {
		Console:AWrite(": ")
		Console:IWriteLine(TokenToPrint->Value)
	}
	
	Console:AWrite("Position: ")
	Console:IWriteLine(TokenToPrint->PositionInSource)
	
	Console:AWrite("Length: ")
	Console:IWriteLine(TokenToPrint->LengthInSource)
}

define void PrintOperator(i8 Operator) {
	i8 FirstCharacter := 0
	i8 SecondCharacter := 0
	
	if (Operator = OPERATOR_COLON_EQUAL) {
		FirstCharacter := ':'
		SecondCharacter := '='
	}
	else if (Operator = OPERATOR_PLUS_EQUAL) {
		FirstCharacter := '+'
		SecondCharacter := '='
	}
	else if (Operator = OPERATOR_MINUS_EQUAL) {
		FirstCharacter := '-'
		SecondCharacter := '='
	}
	else if (Operator = OPERATOR_STAR_EQUAL) {
		FirstCharacter := '*'
		SecondCharacter := '='
	}
	else if (Operator = OPERATOR_LESS_EQAUL) {
		FirstCharacter := '<'
		SecondCharacter := '='
	}
	else if (Operator = OPERATOR_GREATER_EQAUL) {
		FirstCharacter := '>'
		SecondCharacter := '='
	}
	else if (Operator = OPERATOR_BANG_EQUAL) {
		FirstCharacter := '!'
		SecondCharacter := '='
	}
	else if (Operator = OPERATOR_MINUS_GREATER) {
		FirstCharacter := '-'
		SecondCharacter := '>'
	}
	else if (Operator = OPERATOR_LOGICAL_AND) {
		FirstCharacter := '&'
		SecondCharacter := '&'
	}
	else if (Operator = OPERATOR_LOGICAL_OR) {
		FirstCharacter := '|'
		SecondCharacter := '|'
	}
	else if (Operator = OPERATOR_AS) {
		FirstCharacter := 'a'
		SecondCharacter := 's'
	}
	else if (Operator = OPERATOR_OPEN_BRACKET) {
		FirstCharacter := '['
	}
	else if (Operator = OPERATOR_PLUS) {
		FirstCharacter := '+'
	}
	else if (Operator = OPERATOR_MINUS) {
		FirstCharacter := '-'
	}
	else if (Operator = OPERATOR_STAR) {
		FirstCharacter := '*'
	}
	else if (Operator = OPERATOR_SLASH) {
		FirstCharacter := '/'
	}
	else if (Operator = OPERATOR_EQUAL) {
		FirstCharacter := '='
	}
	else if (Operator = OPERATOR_DOT) {
		FirstCharacter := '.'
	}
	else if (Operator = OPERATOR_BANG) {
		FirstCharacter := '!'
	}
	else if (Operator = OPERATOR_LESS) {
		FirstCharacter := '<'
	}
	else if (Operator = OPERATOR_GREATER) {
		FirstCharacter := '>'
	}
	else if (Operator = OPERATOR_AND) {
		FirstCharacter := '&'
	}
	else if (Operator = OPERATOR_OR) {
		FirstCharacter := '|'
	}
	else if (Operator = OPERATOR_COLON) {
		FirstCharacter := ':'
	}
	
	if (FirstCharacter) {
		Console:WriteCharacter(FirstCharacter)
	}
	if (SecondCharacter) {
		Console:WriteCharacter(SecondCharacter)
	}
}

define void PrintPunctuation(i8 Punctuation) {
	i8 Character := 0
	
	if (Punctuation = PUNCTUATION_OPEN_PAREN) {
		Character := '('
	}
	else if (Punctuation = PUNCTUATION_CLOSE_PAREN) {
		Character := ')'
	}
	else if (Punctuation = PUNCTUATION_OPEN_BRACE) {
		Character := '{'
	}
	else if (Punctuation = PUNCTUATION_CLOSE_BRACE) {
		Character := '}'
	}
	else if (Punctuation = PUNCTUATION_CLOSE_BRACKET) {
		Character := ']'
	}
	else if (Punctuation = PUNCTUATION_COMMA) {
		Character := ','
	}
	
	Console:WriteCharacter(Character)
}

define void PrintKeyword(i8 Keyword) {
	if (Keyword = KEYWORD_DEFINE) {
		Console:AWrite("define")
	}
	else if (Keyword = KEYWORD_DLLIMPORT) {
		Console:AWrite("DllImport")
	}
	else if (Keyword = KEYWORD_IF) {
		Console:AWrite("if")
	}
	else if (Keyword = KEYWORD_ELSE) {
		Console:AWrite("else")
	}
	else if (Keyword = KEYWORD_FOR) {
		Console:AWrite("for")
	}
	else if (Keyword = KEYWORD_WHILE) {
		Console:AWrite("while")
	}
	else if (Keyword = KEYWORD_LOOP) {
		Console:AWrite("loop")
	}
	else if (Keyword = KEYWORD_CONTINUE) {
		Console:AWrite("continue")
	}
	else if (Keyword = KEYWORD_BREAK) {
		Console:AWrite("break")
	}
	else if (Keyword = KEYWORD_STRUCT) {
		Console:AWrite("struct")
	}
	else if (Keyword = KEYWORD_RETURN) {
		Console:AWrite("return")
	}
}


define i8 IsAlphaNumeric(i16 Character) {
	return IsAlpha(Character) || IsNumeric(Character) || Character = '_'
}

define i8 IsAlpha(i16 Character) {
	if ('a' <= Character && Character <= 'z') {
		return 1
	}
	else if ('A' <= Character && Character <= 'Z') {
		return 1
	}

	return 0
}

define i8 IsHex(i16 Character) {
	return IsNumeric(Character) || _IsHex(Character)
}
define i8 _IsHex(i16 Character) {
	if ((Character >= 'a') && (Character <= 'f')) {
		return true
	}
	else if ((Character >= 'A') && (Character <= 'F')) {
		return true
	}
	
	return false
}

define i8 IsNumeric(i16 Character) {
	return (Character >= '0') && (Character <= '9')
}

define i64 SafeStringHexToI64(SafeWideString* StringToReadFrom, i8* Success) {
	i64 Result := 0
	
	i16* WString := StringToReadFrom->Buffer
	
	i16 FirstCharacter := WString[0]
	
	if !(IsHex(FirstCharacter)) {
		Success *= 0
		return 0
	}
	
	i32 Length := StringToReadFrom->Length
	
	for (i32 Index := 0, Index < Length, Index += 1) {
		i16 NextCharacter := WString[Index]
		
		if !(IsHex(NextCharacter)) {
			Break
		}
		
		if (IsNumeric(NextCharacter)) {
			NextCharacter -= '0'
		}
		else {
			if (NextCharacter = 'a' || NextCharacter = 'A') {
				NextCharacter := 10
			}
			else if (NextCharacter = 'b' || NextCharacter = 'B') {
				NextCharacter := 11
			}
			else if (NextCharacter = 'c' || NextCharacter = 'C') {
				NextCharacter := 12
			}
			else if (NextCharacter = 'd' || NextCharacter = 'D') {
				NextCharacter := 13
			}
			else if (NextCharacter = 'e' || NextCharacter = 'E') {
				NextCharacter := 14
			}
			else if (NextCharacter = 'f' || NextCharacter = 'F') {
				NextCharacter := 15
			}
		}
		
		Result := (Result * 16) + (NextCharacter)
	}
	
	Success *= 1
	
	return Result
}


define i64 SafeStringToI64(SafeWideString* StringToReadFrom, i8* Success) {
	i64 Result := 0
	i64 Negative := 0
	
	i16* WString := StringToReadFrom->Buffer
	
	i16 FirstCharacter := WString[0]
	
	if (FirstCharacter = '-') {
		Negative := 1
		WString += 2
		FirstCharacter := WString[0]
	}
	
	if !(IsNumeric(FirstCharacter)) {
		Success *= 0
		return 0
	}
	
	i32 Length := StringToReadFrom->Length
	
	for (i32 Index := 0, Index < Length, Index += 1) {
		i16 NextCharacter := WString[Index]
		
		if !(IsNumeric(NextCharacter)) {
			Break
		}
		
		Result := (Result * 10) + (NextCharacter - '0')
	}
	
	Success *= 1
	
	if (Negative) {
		Result := -Result
	}
	
	return Result
}

/*
==========================================
	Expression parser constant lookup functions
==========================================
*/

i8 NONE_ASSOCIATIVE := 0
i8 LEFT_ASSOCIATIVE := 1
i8 RIGHT_ASSOCIATIVE := 2

define i8 GetPrecedence(Token* ForOperator) {
	i8 Operator := (ForOperator->Value) As i8
	
	if (Operator = OPERATOR_COLON_EQUAL || Operator = OPERATOR_STAR_EQUAL) {
		return 1
	}
	else if (Operator = OPERATOR_PLUS_EQUAL || Operator = OPERATOR_MINUS_EQUAL) {
		return 1
	}
	else if (Operator = OPERATOR_LOGICAL_AND || Operator = OPERATOR_LOGICAL_OR) {
		return 2
	}
	else if (Operator = OPERATOR_BANG_EQUAL || Operator = OPERATOR_EQUAL) {
		return 3
	}
	else if (Operator = OPERATOR_GREATER_EQAUL || Operator = OPERATOR_LESS_EQAUL) {
		return 3
	}
	else if (Operator = OPERATOR_GREATER || Operator = OPERATOR_LESS) {
		return 3
	}
	else if (Operator = OPERATOR_AS) {
		return 5
	}
	else if (Operator = OPERATOR_PLUS || Operator = OPERATOR_MINUS) {
		return 7
	}
	else if (Operator = OPERATOR_OPEN_BRACKET) {
		return 8
	}
	else if (Operator = OPERATOR_DOT || Operator = OPERATOR_MINUS_GREATER) {
		return 9
	}
	else if (Operator = OPERATOR_STAR || Operator = OPERATOR_SLASH) {
		return 10
	}
	else if (Operator = OPERATOR_AND || Operator = OPERATOR_OR) {
		return 12
	}
}

define i8 GetAssociation(Token* ForOperator) {
	i8 Precedence := GetPrecedence(ForOperator)
	
	if (Precedence = 1 || Precedence = 3) {
		return RIGHT_ASSOCIATIVE
	}
	else {
		return LEFT_ASSOCIATIVE
	}
}

define i8 GetPrefixPrecedence(Token* ForOperator) {
	i8 Operator := (ForOperator->Value) As i8
	
	if (Operator = OPERATOR_STAR) {
		return 4
	}
	else if (Operator = OPERATOR_BANG) {
		return 11
	}
	else if (Operator = OPERATOR_MINUS) {
		return 11
	}
	
	return 0
}

define i8 IsPrefixOperator(Token* ForOperator) {
	return GetPrefixPrecedence(ForOperator) != 0
}

/*
==========================================
	Typing helper structs
==========================================
*/

struct TypeInfo {
	SafeWideString* Name,
	StructTypeInfo* StructType,
	i16 Size,
	i8 IsStructType,
	i8 IsIncomplete
}

struct Type {
	TypeInfo* TrueType,
	i16 Size,
	i8 PointerDepth
}

struct StructField {
	SafeWideString* Name,
	i16 Offset,
	Type* ValueType
}

struct StructTypeInfo {
	SafeWideString* Name,
	StructField** Fields,
	i16 FieldCount,
	i16 Size
}

/*
==========================================
	Typing functions
==========================================
*/

define void UpdateType(TypeInfo* TargetType, SafeWideString* Name, StructTypeInfo* StructInfo, i16 Size, i8 IsStruct, i8 IsIncomplete) {
	TargetType->Name := Name
	TargetType->StructType := StructInfo
	TargetType->Size := Size
	TargetType->IsStructType := IsStruct
	TargetType->IsIncomplete := IsIncomplete
}

define TypeInfo* AddType(ParserState* pState, SafeWideString* Name, StructTypeInfo* StructInfo, i16 Size, i8 IsStruct, i8 IsIncomplete) {
	TypeInfo* NewType := Alloc(TypeInfo.Size) As TypeInfo*
	
	UpdateType(NewType, Name, StructInfo, Size, IsStruct, IsIncomplete)
	
	Console:AWrite("Adding ")
	PrintSafeString(Name)
	Console:AWrite(" at ")
	Console:IWriteLine(NewType As i64)
	
	HashMapAddValue(pState->Types, Name, NewType As void)
	Console:IWriteLine(HashMapGetValue(pState->Types, Name)->Value)
	
	return NewType
}

define void CreateDefaultTypes(ParserState* pState) {
	/* Creates all the default types, only called once */
	AddType(pState, AToS("i8"), 0, 1, 0, 0)
	AddType(pState, AToS("i16"), 0, 2, 0, 0)
	AddType(pState, AToS("i32"), 0, 4, 0, 0)
	AddType(pState, AToS("i64"), 0, 8, 0, 0)
	AddType(pState, AToS("void"), 0, 8, 0, 0)
}

define Type* GetType(ParserState* pState, SafeWideString* TypeName, i8 PointerDepth) {
	HashMapElement* FoundElement := HashMapGetValue(pState->Types, TypeName)
	TypeInfo* FoundTypeInfo := 0
	
	Console:AWrite("Found ")
	PrintSafeString(TypeName)
	Console:AWrite(" at ")
	
	if (FoundElement) {
		Console:IWriteLine((FoundElement->Value) As i64)
		FoundTypeInfo := (FoundElement->Value) As TypeInfo*
	}
	else {
		Console:IWriteLine(0)
		/*
			If we did not find a typeinfo, then this type has to be an undefined user type, which is defined somewhere else
			So, we will call AddType and add it as incomplete
		*/
		
		if (PointerDepth = 0) {
			TokenizerError(pState->pState, "Incomplete types can only be used with pointers")
		}
		
		FoundTypeInfo := AddType(pState, TypeName, 0, 0, 1, 1)
	}
	
	Type* Result := Alloc(Type.Size) As Type*
	
	Result->PointerDepth := PointerDepth
	Result->TrueType := FoundTypeInfo
	
	if (PointerDepth) {
		Result->Size := 8
	}
	else {
		Result->Size := FoundTypeInfo->Size
	}
	
	return Result
}

define void PrintType(Type* TypeToPrint) {
	PrintSafeString(TypeToPrint->TrueType->Name)
}


/*
==========================================
	Variable struct + alloc helper + hashmap helpers
==========================================
*/

struct VariableInfo {
	SafeWideString* Name,
	Type* Type,
	i16 ScopedID,
	i8 IsGlobal,
	i8 IsParameter
}

define VariableInfo* AllocateNewVariableInfo() {
	return Alloc(VariableInfo.Size) As VariableInfo*
}
define void HashMapAddVariable(HashMap* TargetMap, VariableInfo* TargetVariable) {
	HashMapAddValue(TargetMap, TargetVariable->Name, TargetVariable As void)
}
define VariableInfo* HashMapGetVariable(HashMap* TargetMap, SafeWideString* VariableName) {
	HashMapElement* Result := HashMapGetValue(TargetMap, VariableName)
	
	if (Result) {
		return (Result->Value) As VariableInfo*
	}
	
	return 0 As VariableInfo*
}

/*
==========================================
	AST Node type constants
==========================================
*/

i8 NODE_TYPE_NONE := 0
i8 NODE_TYPE_TOKEN := 1

i8 NODE_TYPE_UNARY := 2
i8 NODE_TYPE_BINARY := 3
i8 NODE_TYPE_CALL := 4
i8 NODE_TYPE_ARRAYACCESS := 5

i8 NODE_TYPE_DEFINE := 6
i8 NODE_TYPE_DLLIMPORT := 7

i8 NODE_TYPE_IF := 8

i8 NODE_TYPE_FOR := 9
i8 NODE_TYPE_WHILE := 10
i8 NODE_TYPE_LOOP := 11
i8 NODE_TYPE_CONTINUEBREAK := 12

i8 NODE_TYPE_RETURN := 13
i8 NODE_TYPE_EXPRESSION := 14

i8 NODE_TYPE_VARIABLE := 15
i8 NODE_TYPE_INTEGER := 16
i8 NODE_TYPE_STRING := 17

/*
==========================================
	AST Node definition + alloc/free helpers
==========================================
*/

struct ASTNode {
	void* TrueNode,
	i8 NodeType
}

define ASTNode* AllocateNewASTNode(i8 NewNodeType, void* NewNodeTrueNode) {
	ASTNode* NewNode := Alloc(ASTNode.Size) As ASTNode*
	
	NewNode->NodeType := NewNodeType
	NewNode->TrueNode := NewNodeTrueNode
	
	return NewNode
}
define void FreeASTNode(ASTNode* NodeToFree) {
	Free(NodeToFree As void*)
}

/*
==========================================
	True AST node types
==========================================
*/

struct UnaryExpression {
	Token* Operator,
	ASTNode* Operand
}

struct BinaryExpression {
	ASTNode* Left,
	Token* Operator,
	ASTNode* Right
}

struct CallExpression {
	SafeWideString* Name,
	ASTNode** Parameters,
	i32 ParameterCount
}

struct Block {
	ASTNode** Statements,
	i16 StatementCount
}

struct FunctionDefine {
	SafeWideString* Name,
	Block* Body,
	VariableInfo** Parameters,
	HashMap* Locals,
	Type* ReturnType,
	i16 ParameterCount,
	i16 LocalCount
}

/*
==========================================
	AST Node construction helpers
==========================================
*/

define ASTNode* MakeBinary(ASTNode* Left, Token* Operator, ASTNode* Right) {
	BinaryExpression* Result := Alloc(BinaryExpression.Size) As BinaryExpression*
	
	Result->Left := Left
	Result->Operator := Operator
	Result->Right := Right
	
	return AllocateNewASTNode(NODE_TYPE_BINARY, Result As void*)
}
define ASTNode* MakeUnary(Token* Operator, ASTNode* Operand) {
	UnaryExpression* Result := Alloc(UnaryExpression.Size) As UnaryExpression*
	
	Result->Operator := Operator
	Result->Operand := Operand
	
	return AllocateNewASTNode(NODE_TYPE_UNARY, Result As void*)
}
define ASTNode* MakeCall(SafeWideString* Name, ASTNode** Parameters, i32 ParameterCount) {
	CallExpression* Result := Alloc(CallExpression.Size) As CallExpression*
	
	Result->Name := Name
	Result->Parameters := Parameters
	Result->ParameterCount := ParameterCount
	
	return AllocateNewASTNode(NODE_TYPE_CALL, Result As void*)
}

/*
==========================================
	Backing parser type + helpers
==========================================
*/

struct ParserState {
	TokenizerState* pState,
	
	HashMap* Functions,
	i16 FunctionCount,
	
	HashMap* Globals,
	i16 GlobalCount,
	
	HashMap* Types,
	i16 TypeCount,
	
	FunctionDefine* CurrentFunction
}

define i32 FreezeParser(ParserState* pState) {
	return pState->pState->Index
}
define void UnfreezeParser(ParserState* pState, i32 Index) {
	pState->pState->Index := Index
}

define Token* ParserNextToken(ParserState* pState) {
	Token* NextToken := GetNextToken(pState->pState)
	
	return NextToken
}
define i8 TokenMatches(Token* TokenToTest, i8 TokenType, i8 TokenValue) {
	if (TokenType = TOKEN_TYPE_IDENTIFER || TokenType = TOKEN_TYPE_STRING) {
		if (TokenToTest->Type = TokenType) {
			return true
		}
	}
	
	if (TokenToTest->Type = TokenType && TokenToTest->Value = TokenValue) {
		return true
	}
	
	return false
}
define i8 ParserNextMatches(ParserState* pState, i8 TokenType, i8 TokenValue) {
	i32 FrozenState := FreezeParser(pState)
	
	Token* NextToken := ParserNextToken(pState)
	i8 Matches := TokenMatches(NextToken, TokenType, TokenValue)
	FreeToken(NextToken)
	
	if !(Matches) {
		UnfreezeParser(pState, FrozenState)
	}
	
	return Matches
}
define Token* Consume(ParserState* pState, i8 TokenType, i8 TokenValue, i8* Reason) {
	Token* NextToken := ParserNextToken(pState)
	
	if (NextToken->Type = TOKEN_TYPE_EOF) {
		TokenizerError(pState->pState, "Unexpected EOF")
	}
	
	if !(TokenMatches(NextToken, TokenType, TokenValue)) {
		TokenizerError(pState->pState, Reason)
	}
	
	return NextToken
}

define void ParserStart(TokenizerState* pState) {
	ParserState P
	P.pState := pState
	
	P.Globals := NewHashMap()
	P.GlobalCount := 0
	
	P.Functions := NewHashMap()
	P.FunctionCount := 0
	
	P.Types	:= NewHashMap()
	P.TypeCount := 0
	
	CreateDefaultTypes(&P)
	
	ParseProgram(&P)
	
	return 0
	
	PrintAST(ParseExpression(&P, 0))


}

/*
==========================================
	Actual parsing functions
==========================================
*/

define void ParseProgram(ParserState* pState) {
	loop {
		Token* NextToken := ParserNextToken(pState)
		
		if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_DEFINE)) {
			Console:AWriteLine("Found define")
			
			ParseAndAddDefine(pState)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_DLLIMPORT)) {
		
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_STRUCT)) {
			Console:AWriteLine("Found struct")
			
			ParseAndAddStruct(pState)
		}
		
		FreeToken(NextToken)
		break
	}
}

define Type* ParseTypeName(ParserState* pState) {
	Token* NameToken := Consume(pState, TOKEN_TYPE_IDENTIFER, TOKEN_TYPE_NONE, "Type names must be identifiers")
	i8 PointerDepth := 0
	
	while (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_STAR)) {
		PointerDepth += 1
	}
	
	Type* ResultType := GetType(pState, (NameToken->Value) As SafeWideString*, PointerDepth)
	
	FreeTokenOnly(NameToken)
	
	return ResultType
}

define void ParseAndAddStruct(ParserState* pState) {
	FreeToken(Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected open brace for struct body"))
	
	HashMap* Fields := NewHashMap()
	i16 FieldCount := 0
	i16 NextFieldOffset := 0
	
	loop {
		StructField* NextField := Alloc(StructField.Size) As StructField*
		
		NextField->ValueType := ParseTypeName(pState)

		Token* NameToken := Consume(pState, TOKEN_TYPE_IDENTIFER, 0, "Expected identifier for struct field name")
		
		SafeWideString* FieldName := (NameToken->Value) As SafeWideString*
		
		NextField->Name := FieldName
		HashMapAddValue(Fields, FieldName, NextField As void)
		
		FreeTokenOnly(NameToken)
		
		NextField->Offset := NextFieldOffset
		NextFieldOffset += NextField->ValueType->Size
		
		FieldCount += 1
		
		if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
			break
		}
	
	}







}

define VariableInfo* FindVariable(ParserState* pState, SafeWideString* VariableName) {
	FunctionDefine* CurrentFunction := pState->CurrentFunction
	VariableInfo* FoundVariable := 0
	
	if (CurrentFunction) {
		FoundVariable := HashMapGetVariable(CurrentFunction->Locals, VariableName)
	}
	
	if !(FoundVariable) {
		FoundVariable := HashMapGetVariable(pState->Globals, VariableName)
	}
	
	if !(FoundVariable) {
		TokenizerError(pState->pState, "Undefined variable")
	}
	
	return FoundVariable
}

define void ParserAddLocal(ParserState* pState, VariableInfo* NewLocal) {
	FunctionDefine* CurrentFunction := pState->CurrentFunction
	
	Console:AWrite("Adding local ")
	PrintSafeString(NewLocal->Name)
	Console:WriteNewLine()
	
	if !(CurrentFunction) {
		TokenizerError(pState->pState, "Unexpected local variable")
	}
	
	if (HashMapGetVariable(CurrentFunction->Locals, NewLocal->Name)) {
		TokenizerError(pState->pState, "Duplicate definition")
	}
	
	NewLocal->ScopedID := CurrentFunction->LocalCount
	CurrentFunction->LocalCount += 1
	
	HashMapAddVariable(CurrentFunction->Locals, NewLocal)
}

define ASTNode* ParseAndAddDefine(ParserState* pState) {
	FunctionDefine* NewDefine := Alloc(FunctionDefine.Size) As FunctionDefine*
	
	NewDefine->Locals := NewHashMap()
	NewDefine->LocalCount := 0
	
	pState->CurrentFunction := NewDefine
	
	NewDefine->ReturnType := ParseTypeName(pState)

	Token* NextToken := Consume(pState, TOKEN_TYPE_IDENTIFER, TOKEN_TYPE_NONE, "Function names must be identifiers")
	
	NewDefine->Name := (NextToken->Value) As SafeWideString*
	
	FreeTokenOnly(NextToken)
	NextToken := Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Function parameter lists must start with (")
	
	i8 ParameterCount := 0
	VariableInfo** ParameterList := Alloc(VariableInfo.Size * 16) As VariableInfo**
	
	loop {
		VariableInfo* NextParameter := AllocateNewVariableInfo()
		
		if (ParameterCount >= 16) {
			TokenizerError(pState->pState, "Max parameter limit reached")
		}
		
		ParameterList[ParameterCount] := NextParameter
		
		FreeTokenOnly(NextToken)
		
		NextParameter->Type := ParseTypeName(pState)
		
		NextToken := Consume(pState, TOKEN_TYPE_IDENTIFER, TOKEN_TYPE_NONE, "Parameter names must be identifiers")
		
		NextParameter->Name := (NextToken->Value) As SafeWideString*
		NextParameter->IsGlobal := false
		NextParameter->IsParameter := true
		
		ParserAddLocal(pState, NextParameter)
		
		FreeTokenOnly(NextToken)
		
		ParameterCount += 1
		NextToken := ParserNextToken(pState)
		
		if !(TokenMatches(NextToken, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
			break
		}
	}
	
	if !(TokenMatches(NextToken, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
		TokenizerError(pState->pState, "Expected closing paren for parameter list")
	}
	
	FreeToken(NextToken)
	
	Console:AWrite("Parameter Count: ")
	Console:IWriteLine(ParameterCount)
	
	NewDefine->Parameters := ParameterList
	NewDefine->ParameterCount := ParameterCount
	
	NewDefine->Body := ParseBlock(pState)
	
	PrintAST(AllocateNewASTNode(NODE_TYPE_DEFINE, NewDefine As void*))
}

define Block* ParseBlock(ParserState* pState) {
	FreeToken(Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace in block"))
	
	i16 StatementBufferSize := 8
	ASTNode** Statements := Alloc(StatementBufferSize * 8) As ASTNode**
	i16 StatementCount := 0
	
	loop {
		if (StatementCount * 8 <= StatementBufferSize) {
			Statements := ReAlloc(Statements As void*, (StatementCount + 10) * 8) As ASTNode**
			StatementBufferSize += (10 * 8)
		}
		
		Statements[StatementCount] := ParseStatement(pState)
		StatementCount += 1
		
		if (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
			break
		}
		else if (ParserNextMatches(pState, TOKEN_TYPE_EOF, 0)) {
			TokenizerError(pState->pState, "Expected close brace in block")
		}
	}
	
	Block* NewBlock := Alloc(Block.Size) As Block*
	NewBlock->Statements := Statements
	NewBlock->StatementCount := StatementCount
	
	Console:AWrite("Made new block with ")
	Console:IWrite(StatementCount)
	Console:AWriteLine(" statements")
	
	return NewBlock
}

define ASTNode* ParseStatement(ParserState* pState) {
	i32 FrozenState := FreezeParser(pState)
	
	Token* NextToken := ParserNextToken(pState)
	ASTNode* Result := 0
	
	if (NextToken->Type = TOKEN_TYPE_KEYWORD) {
		if (NextToken->Value = KEYWORD_CONTINUE) {
			Result := AllocateNewASTNode(NODE_TYPE_CONTINUEBREAK, true)
		}
		else if (NextToken->Value = KEYWORD_BREAK) {
			Result := AllocateNewASTNode(NODE_TYPE_CONTINUEBREAK, false)
		}
		else if (NextToken->Value = KEYWORD_RETURN) {
			Result := AllocateNewASTNode(NODE_TYPE_RETURN, ParseExpression(pState, 0) As void*)
		}
	}
	
	FreeToken(NextToken)
	
	if (Result = 0) {
		UnfreezeParser(pState, FrozenState)
		Result := AllocateNewASTNode(NODE_TYPE_EXPRESSION, ParseExpression(pState, 0) As void*)
	}
	
	return Result
}

define ASTNode* TranslateTokenToNode(ParserState* pState, Token* TokenToTranslate) {
	if (TokenToTranslate->Type = TOKEN_TYPE_INTEGER) {
		return AllocateNewASTNode(NODE_TYPE_INTEGER, TokenToTranslate->Value)
	}
	else if (TokenToTranslate->Type = TOKEN_TYPE_IDENTIFER) {
		VariableInfo* FoundVariable := FindVariable(pState, (TokenToTranslate->Value) As SafeWideString*)
		return AllocateNewASTNode(NODE_TYPE_VARIABLE, FoundVariable As void*)
	}
	
	return AllocateNewASTNode(NODE_TYPE_TOKEN, TokenToTranslate As void*)
}

define ASTNode* ParseExpressionOperand(ParserState* pState) {
	Token* NextToken := ParserNextToken(pState)
	ASTNode* Result := 0
	
	if (NextToken->Type = TOKEN_TYPE_PUNCTUATION && NextToken->Value = PUNCTUATION_OPEN_PAREN) {
		Result := ParseExpression(pState, 0)
		
		FreeToken(NextToken)
		NextToken := ParserNextToken(pState)
		
		if (NextToken->Type != TOKEN_TYPE_PUNCTUATION || NextToken->Value != PUNCTUATION_CLOSE_PAREN) {
			TokenizerError(pState->pState, "Expected closing paren")
		}
		
		FreeToken(NextToken)
	}
	else if (NextToken->Type = TOKEN_TYPE_IDENTIFER) {
		i32 FrozenState := FreezeParser(pState)
		
		Token* NextNextToken := ParserNextToken(pState)
		
		if (TokenMatches(NextNextToken, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)) {
			i8 ParameterIndex := 0
			ASTNode** Parameters := Alloc(8 * 10) As ASTNode**
			
			i32 AnotherFrozenState := FreezeParser(pState)
			Token* ClosingParen := ParserNextToken(pState)
			
			if (TokenMatches(ClosingParen, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
				FreeToken(NextNextToken)
				NextNextToken := ClosingParen
			}
			else {
				FreeToken(ClosingParen)
				UnfreezeParser(pState, AnotherFrozenState)
				
				while (TokenMatches(NextNextToken, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA) || ParameterIndex = 0) {
					Parameters[ParameterIndex] := ParseExpression(pState, 0)
					ParameterIndex += 1
					
					FreeToken(NextNextToken)
					NextNextToken := ParserNextToken(pState)
				}
			}
			
			if !(TokenMatches(NextNextToken, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
				TokenizerError(pState->pState, "Expected closing paren for function call")
			}
			
			Result := MakeCall((NextToken->Value) As SafeWideString*, Parameters, ParameterIndex)
		}
		else {
			UnfreezeParser(pState, FrozenState)
			Result := TranslateTokenToNode(pState, NextToken)
		}
		
		FreeToken(NextNextToken)
	}
	else if (NextToken->Type = TOKEN_TYPE_INTEGER) {	
		Result := TranslateTokenToNode(pState, NextToken)
	}
	else if (NextToken->Type = TOKEN_TYPE_OPERATOR && IsPrefixOperator(NextToken)) {
		Result := ParseExpression(pState, GetPrefixPrecedence(NextToken))
		
		Result := MakeUnary(NextToken, Result)
	}
	else {
		PrintToken(NextToken)
		TokenizerError(pState->pState, "Unexpected token in expression")
	}
	
	return Result
}

define ASTNode* ParseExpression(ParserState* pState, i8 Precedence) {
	ASTNode* Result := ParseExpressionOperand(pState)
	
	i32 FrozenState := FreezeParser(pState)
	Token* OperatorToken := ParserNextToken(pState)
	
	while (OperatorToken->Type = TOKEN_TYPE_OPERATOR && GetPrecedence(OperatorToken) >= Precedence) {
		i8 NewPrecedence := GetPrecedence(OperatorToken)
		
		if (GetAssociation(OperatorToken) = LEFT_ASSOCIATIVE) {
			NewPrecedence += 1
		}
		
		if (OperatorToken->Value = OPERATOR_OPEN_BRACKET) {
			ASTNode* Operand := ParseExpression(pState, 0)
			
			FreeToken(Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected closing bracket for array access"))
		}
		else {
			ASTNode* Operand := ParseExpression(pState, NewPrecedence)
		}
		
		Result := MakeBinary(Result, OperatorToken, Operand)
		
		FrozenState := FreezeParser(pState)
		OperatorToken := ParserNextToken(pState)
	}
	
	UnfreezeParser(pState, FrozenState)
	
	return Result
}

define void PrintAST(ASTNode* NodeToPrint) {
	i8 NodeType := NodeToPrint->NodeType
	
	if (NodeType = NODE_TYPE_UNARY) {
		UnaryExpression* UnaryNode := (NodeToPrint->TrueNode) As UnaryExpression*
		
		Console:WriteCharacter('(')
		
		PrintOperator(UnaryNode->Operator->Value)
		PrintAST(UnaryNode->Operand)
		
		Console:WriteCharacter(')')
	}
	else if (NodeType = NODE_TYPE_BINARY) {
		BinaryExpression* BinaryNode := (NodeToPrint->TrueNode) As BinaryExpression*
		
		Console:WriteCharacter('(')
		
		PrintAST(BinaryNode->Left)
		
		Console:WriteCharacter(' ')
		
		PrintOperator(BinaryNode->Operator->Value)
		
		Console:WriteCharacter(' ')
		
		PrintAST(BinaryNode->Right)
		
		Console:WriteCharacter(')')
	}
	else if (NodeType = NODE_TYPE_CALL) {
		CallExpression* CallNode := (NodeToPrint->TrueNode) As CallExpression*
		
		PrintSafeString(CallNode->Name)
		
		Console:WriteCharacter('(')
		
		i32 ParameterIndex := 0
		
		loop (CallNode->ParameterCount) {
			ASTNode* NextCallParameter := (CallNode->Parameters)[ParameterIndex]
			
			PrintAST(NextCallParameter)
			
			ParameterIndex += 1
			
			if (ParameterIndex != CallNode->ParameterCount) {
				Console:WriteCharacter(',')
				Console:WriteCharacter(' ')
			}
		}
		
		Console:WriteCharacter(')')
	}
	else if (NodeType = NODE_TYPE_TOKEN) {
		Token* TokenNode := (NodeToPrint->TrueNode) As Token*
		
		if (TokenNode->Type = TOKEN_TYPE_IDENTIFER) {
			PrintSafeString((TokenNode->Value) As SafeWideString*)
		}
		else if (TokenNode->Type = TOKEN_TYPE_INTEGER) {
			Console:IWrite(TokenNode->Value)
		}
	}
	else if (NodeType = NODE_TYPE_DEFINE) {
		FunctionDefine* DefineNode := (NodeToPrint->TrueNode) As FunctionDefine*
		
		Console:AWrite("define ")
		PrintType(DefineNode->ReturnType)
		Console:WriteCharacter(' ')
		PrintSafeString(DefineNode->Name)
		Console:WriteCharacter('(')
		
		i32 ParameterIndex := 0
		
		loop (DefineNode->ParameterCount) {
			VariableInfo* NextDefineParameter := (DefineNode->Parameters)[ParameterIndex]
			
			PrintType(NextDefineParameter->Type)
			Console:WriteCharacter(' ')
			PrintSafeString(NextDefineParameter->Name)
			
			ParameterIndex += 1
			
			if (ParameterIndex != DefineNode->ParameterCount) {
				Console:WriteCharacter(',')
				Console:WriteCharacter(' ')
			}
		}
		
		Console:AWriteLine(") {")
		
		i32 StatementIndex := 0
		
		loop (DefineNode->Body->StatementCount) {
			ASTNode* BodyStatement := (DefineNode->Body->Statements)[StatementIndex]
			
			PrintAST(BodyStatement)
			
			StatementIndex += 1
		}
		
		Console:WriteCharacter('}')
		Console:WriteNewLine()
	}
	else if (NodeType = NODE_TYPE_RETURN) {
		ASTNode* ReturnExpression := (NodeToPrint->TrueNode) As ASTNode*
		
		Console:AWrite("return ")
		PrintAST(ReturnExpression)
		Console:WriteNewLine()
	}
	else if (NodeType = NODE_TYPE_EXPRESSION) {
		ASTNode* ExpressionStatement := (NodeToPrint->TrueNode) As ASTNode*
		
		PrintAST(ExpressionStatement)
		Console:WriteNewLine()
	}
	else if (NodeType = NODE_TYPE_VARIABLE) {
		VariableInfo* TargetVariable := (NodeToPrint->TrueNode) As VariableInfo*
		
		PrintSafeString(TargetVariable->Name)
	}
	else if (NodeType = NODE_TYPE_INTEGER) {
		Console:IWrite(NodeToPrint->TrueNode)
	}
}