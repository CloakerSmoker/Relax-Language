struct Token {
	void* Value,
	i16 PositionInSource,
	i16 LengthInSource,
	i8 Type
}

struct SafeWideString {
	i32 Length,
	i16* Buffer
}

struct TokenizerState {
	i16* Source,
	Token** Tokens,
	i32 SourceLength,
	i32 Index
}

Import Console

define i32 Main(i64 ArgC, i16** ArgV) {
	i16* Source := ArgV[1]
	
	TokenizerState T
	T.Source := Source
	T.SourceLength := WideStringLength(Source)
	T.Index := 0
	
	loop 2 {
		Token* F := GetNextToken(&T)
		PrintToken(F)
	}
}

define i32 WideStringLength(i16* WideString) {
	i16 NextCharacter := WideString[0]
	i32 Index := 0
	
	while (NextCharacter != 0) {
		NextCharacter := WideString[++Index]
	}
	
	return Index
}

i8 TOKEN_TYPE_EOF := 0
i8 TOKEN_TYPE_OPERATOR := 1
i8 TOKEN_TYPE_IDENTIFER := 2
i8 TOKEN_TYPE_INTEGER := 3

i8 OPERATOR_COLON_EQUAL := 0
i8 OPERATOR_PLUS_EQUAL := 1
i8 OPERATOR_MINUS_EQUAL := 2

define i16 PeekNextCharacter(TokenizerState* pState) {
	return (pState->Source)[pState->Index]
}
define i16 GetNextCharacter(TokenizerState* pState) {
	i16 NextCharacter := PeekNextCharacter(pState)

	pState->Index += 1
	return NextCharacter
}
define i8 TokenizerAtEnd(TokenizerState* pState) {
	return (pState->Index) >= (pState->SourceLength)
}


define Token* GetNextToken(TokenizerState* pState) {
	while (!TokenizerAtEnd(pState)) {
		i32 StartingIndex := pState->Index
		i16 NextCharacter := GetNextCharacter(pState)
		
		Console:WriteCharacter(NextCharacter)
		Console:WriteNewLine()

		if (NextCharacter = ':' && PeekNextCharacter(pState) = '=') {
			GetNextCharacter(pState)
			
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)
		}
		else if (NextCharacter = "+" && PeekNextCharacter(pState) = "=") {
			GetNextCharacter(pState)
			
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_OPERATOR, OPERATOR_PLUS_EQUAL)
		}
		else if (NextCharacter = ''') {
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_INTEGER, NextCharacter)
		}
		else if (IsNumeric(NextCharacter)) {
			while (IsNumeric(NextCharacter) && (!TokenizerAtEnd(pState))) {
				NextCharacter := GetNextCharacter(pState)
			}
			
			if !(TokenizerAtEnd(pState)) {
				pState->Index -= 1
			}
			
			SafeWideString* AsString := (MakeSafeStringToken(pState, StartingIndex) As SafeWideString*)
			i8 NumberWasConverted := 0
			
			Token* ResultToken := MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_INTEGER, SafeStringToI64(AsString, &NumberWasConverted))
			
			FreeSafeString(AsString)
			
			return ResultToken
		}
		else if (IsAlpha(NextCharacter)) {
			while (IsAlphaNumeric(NextCharacter) && (!TokenizerAtEnd(pState))) {
				NextCharacter := GetNextCharacter(pState)
			}
			
			if !(TokenizerAtEnd(pState)) {
				pState->Index -= 1
			}
			
			return MakeToken(StartingIndex, pState->Index, TOKEN_TYPE_IDENTIFER, MakeSafeStringToken(pState, StartingIndex))
		}
	}
	
	return MakeToken(pState->SourceLength, pState->SourceLength, TOKEN_TYPE_EOF, 0)
}

define SafeWideString* AllocateNewSafeString() {
	return Alloc(SafeWideString.Size) As SafeWideString*
}
define void FreeSafeString(SafeWideString* StringToFree) {
	Free(StringToFree As void*)
}

define void* MakeSafeStringToken(TokenizerState* pState, i32 StartingIndex) {
	SafeWideString* NewSafeString := AllocateNewSafeString()

	NewSafeString->Length := pState->Index - StartingIndex
	NewSafeString->Buffer := pState->Source + (StartingIndex * 2)

	return NewSafeString As void*
}

define void PrintSafeString(SafeWideString* StringToPrint) {
	i32 CharactersWritten := 0
	
	Console:WriteConsole(Console:STDOUT, StringToPrint->Buffer, StringToPrint->Length, &CharactersWritten, 0)
	
	return CharactersWritten
}

define Token* AllocateNewToken() {
	return Alloc(Token.Size) As Token*
}

define Token* MakeToken(i16 PositionInSource, i16 EndPositionInSource, i8 Type, void* Value) {
	Token* OutputToken := AllocateNewToken()

	OutputToken->PositionInSource := PositionInSource
	OutputToken->LengthInSource := EndPositionInSource - PositionInSource
	OutputToken->Type := Type
	OutputToken->Value := Value
	
	return OutputToken
}

define void PrintToken(Token* TokenToPrint) {
	Console:AWrite("Type: ")
	Console:IWriteLine(TokenToPrint->Type)
	
	Console:AWrite("Value")
	
	if (TokenToPrint->Type = TOKEN_TYPE_IDENTIFER) {
		Console:AWrite(" (S): ")
		PrintSafeString((TokenToPrint->Value) As SafeWideString*)
		Console:WriteNewLine()
	}
	else {
		Console:AWrite(": ")
		Console:IWriteLine(TokenToPrint->Value)
	}
	
	Console:AWrite("Position: ")
	Console:IWriteLine(TokenToPrint->PositionInSource)
	
	Console:AWrite("Length: ")
	Console:IWriteLine(TokenToPrint->LengthInSource)
}

define i8 IsAlphaNumeric(i16 Character) {
	return IsAlpha(Character) || IsNumeric(Character)
}

define i8 IsAlpha(i16 Character) {
	if ('a' <= Character && Character <= 'z') {
		return 1
	}
	else if ('A' <= Character && Character <= 'Z') {
		return 1
	}

	return 0
}
define i8 IsNumeric(i16 Character) {
	return (Character >= '0') && (Character <= '9')
}

define i64 SafeStringToI64(SafeWideString* StringToReadFrom, i8* Success) {
	i64 Result := 0
	i64 Negative := 0
	
	i16* WString := StringToReadFrom->Buffer
	
	i16 FirstCharacter := WString[0]
	
	if (FirstCharacter = '-') {
		Negative := 1
		WString += 2
		FirstCharacter := WString[0]
	}
	
	if !(IsNumeric(FirstCharacter)) {
		Success *= 0
		return 0
	}
	
	i32 Length := StringToReadFrom->Length
	
	for (i32 Index := 0, Index < Length, Index++) {
		i16 NextCharacter := WString[Index]
		
		if !(IsNumeric(NextCharacter)) {
			Break
		}
		
		Result := (Result * 10) + (NextCharacter - '0')
	}
	
	Success *= 1
	
	if (Negative) {
		Result := -Result
	}
	
	return Result
}