struct Token {
    void* Value,
    i16 PositionInSource,
    i16 LengthInSource,
    i8 Type
}

struct SafeWideString {
    i32 Length,
    i16* Buffer
}

struct TokenizerState {
    i16* Source,
    Token** Tokens,
    i32 SourceLength,
    i32 Index
}

i8 TOKEN_OPERATOR := 0
i8 TOKEN_IDENTIFER := 1

i8 TOKEN_COLON_EQUAL := 2

define i16 PeekNextCharacter(TokenizerState* pState) {
    return pState->Source[pState->Index + 1]
}
define i16 GetNextCharacter(TokenizerState* pState) {
    i16 NextCharacter := PeekNextCharacter(pState)

    pState->Index += 1
    return NextCharacter
}


define Token* GetNextToken(TokenizerState* pState) {
    while (pState->Index <= pState->SourceLength) {
        i32 StartingIndex := pState->Index
        i16 NextCharacter := GetNextCharacter(pState)

        if (NextCharacter = ':' && PeekNextCharacter(pState) = '=') {
            GetNextCharacter(pState)
            return MakeToken(StartingIndex, pState->Index, TOKEN_OPERATOR, TOKEN_COLON_EQUAL)
        }
        else if (IsAlpha(NextCharacter)) {
            i16 Next := PeekNextCharacter()

            while (IsAlpha(NextCharacter)) {
                Next := GetNextCharacter()
            }

            return MakeToken(StartingIndex, pState->Index, TOKEN_IDENTIFER, MakeSafeString(pState, StartingIndex))
        }
    }
}

define void* MakeSafeString(TokenizerState* pState, i32 StartingIndex) {
    SafeWideString* NewSafeString := AllocateNewSafeString()

    NewSafeString->Length := pState->Index - StartingIndex
    NewSafeString->Buffer := pState->Source + (StartingIndex * 2)

    return NewSafeString As void*
}

define Token* MakeToken(i16 PositionInSource, i16 EndPositionInSource, i8 Type, void* Value) {
    Token* OutputToken := AllocateNewToken()

    OutputToken->PositionInSource := PositionInSource
    OutputToken->LengthInSource := EndPositionInSource - PositionInSource
    OutputToken->Type := Type
    OutputToken->Value := Value

    return OutputToken
}

define i8 IsAlpha(i16 Character) {
    if (Character >= 'a' && Character <= 'z') {
        return 1
    }
    else if (Character >= 'A' && Character <= 'Z') {
        return 1
    }

    return 0
}