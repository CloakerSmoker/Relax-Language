struct HashMapElement {
	i64 Hash,
	void Value,
	void* NextElement
}

struct HashMap {
	i32 BufferMaxCount,
	void *Elements
}

define HashMap* NewHashMap() {
	HashMap* NewMap := Alloc(HashMap.Size) As HashMap*
	
	NewMap->BufferMaxCount := 50
	NewMap->Elements := Alloc(NewMap->BufferMaxCount * 8)
	
	return NewMap
}
define i64 HashString(SafeWideString* StringToHash) {
	i64 Hash := 5281
	i32 Index := 0
	
	loop (StringToHash->Length) {
		Hash := ((Hash * 32) + Hash) ^ ((StringToHash->Buffer)[Index])
		Index += 1
	}
	
	return Hash
}
define HashMapElement* HashMapFindElement(HashMap* TargetMap, i64 Hash) {
	i64 Index := Hash % (TargetMap->BufferMaxCount)
	
	HashMapElement* Node := (TargetMap->Elements)[Index]
	
	if !(Node) {
		return false As HashMapElement*
	}

	while (Node->Hash != Hash) {
		if !(Node->NextElement) {
			return Node
		}
		
		Node := (Node->NextElement) As HashMapElement*
		/* The cast is since types can't contain themselves yet */
	}
	
	return Node
}
define HashMapElement* HashMapGetValue(HashMap* TargetMap, SafeWideString* Key) {
	i64 Hash := HashString(Key)
	
	HashMapElement* Result := HashMapFindElement(TargetMap, Hash)
	
	if (Result != 0) {
		if (Result->Hash = Hash) {
			return Result
		}
	}
	
	return false As HashMapElement*
}
define void HashMapAddValue(HashMap* TargetMap, SafeWideString* Key, void Value) {
	i64 Hash := HashString(Key)
	i64 Index := Hash % (TargetMap->BufferMaxCount)
	
	HashMapElement* TailElement := HashMapFindElement(TargetMap, Hash)
	HashMapElement* NewElement := 0
	
	if (TailElement = 0) {
		/* If TailElement = 0 then:
			No linked list exists for this index
			Create one, and insert the head into the element list
		*/
		
		NewElement := Alloc(HashMapElement.Size) As HashMapElement*
		NewElement->NextElement := 0
		
		(TargetMap->Elements)[Index] := NewElement
	}
	else if (TailElement->Hash != Hash) {
		/* else if TailElement->Hash != Hash:
			Linked list exists, but doesn't contain the key yet
			Create new element, and insert it into to the list
		*/
		
		NewElement := Alloc(HashMapElement.Size) As HashMapElement*
		NewElement->NextElement := TailElement->NextElement
	
		TailElement->NextElement := NewElement
	}
	else {
		/* Else, the tail node exists, and the hash matches
			Aka this key already has an element
			So just overwrite the values in it
		*/
		
		NewElement := TailElement
		TailElement->NextElement := 0
	}
	
	NewElement->Hash := Hash
	NewElement->Value := Value
}





struct Token {
	void* Value,
	i32 PositionInSource,
	i16 LengthInSource,
	i8 Type
}

struct SafeWideString {
	i32 Length,
	i16* Buffer
}

define SafeWideString* AToS(i8* SourceString) {
	SafeWideString* NewString := Alloc(SafeWideString.Size) As SafeWideString*
	
	i32 Length := 0
	
	loop {
		i8 NextCharacter := SourceString[Length]
		
		if (NextCharacter = 0) {
			Break
		}
		
		Length += 1
	}
	
	NewString->Buffer := AToW(SourceString, Length)
	NewString->Length := Length
	
	return NewString
}

struct TokenizerState {
	i16* Source,
	Token* CurrentToken,
	i32 SourceLength,
	i32 Index
}

Import Console

DllImport i64 CreateFile(i16*, i32, i32, void*, i32, i32, i64) {Kernel32.dll, CreateFileW}
DllImport i32 GetFileSize(i64, void) {Kernel32.dll, GetFileSize}
DllImport i8 ReadFile(i64, void*, i32, i32*, void) {Kernel32.dll, ReadFile}
DllImport i8 CloseHandle(i64) {Kernel32.dll, CloseHandle}

DllImport i32 GetLastError() {Kernel32.dll, GetLastError}

define i32 Main(i64 ArgC, i16** ArgV) {
	if (ArgC != 2) {
		Console:AWriteLine("No input file, aborting")
		Exit(1)
	}
	
	i16* InputFilePath := ArgV[1]
	
	i64 GENERIC_READ := 0x80000000
	i8 FILE_SHARE_READ := 1
	i8 FILE_SHARE_WRITE := 2
	i8 OPEN_EXISTING := 3
	i16 FILE_ATTRIBUTE_NORMAL := 128
	
	i64 InputFileHandle := CreateFile(InputFilePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)
	
	if (InputFileHandle = -1) {
		Console:AWrite("Could not open input file: error code ")
		Console:IWriteLine(GetLastError())
		Console:AWriteLine("Aborting")
		Exit(1)
	}
	
	Console:AWrite("Input File: ")
	Console:WriteLine(InputFilePath)
	
	i32 InputFileSize := GetFileSize(InputFileHandle, 0)
	void* FileBuffer := Alloc(InputFileSize)
	
	i32 ReadFileBytesRead := 0
	i8 ReadFileSuccess := ReadFile(InputFileHandle, FileBuffer, InputFileSize, &ReadFileBytesRead, 0)
	
	if (!(ReadFileSuccess) || ReadFileBytesRead != InputFileSize) {
		Console:AWrite("Could not open read file: error code ")
		Console:IWriteLine(GetLastError())
		Console:AWriteLine("Aborting")
		Exit(1)
	}
	
	i16* Source := AToW(FileBuffer As i8*, InputFileSize)
	
	Free(FileBuffer)
	CloseHandle(InputFileHandle)
	
	TokenizerState T
	T.CurrentToken := Alloc(Token.Size) As Token*
	T.Source := Source
	T.SourceLength := WideStringLength(Source) - 1
	T.Index := 0
	
	ParserStart(&T)
	
	
}

define i16* AToW(i8* AString, i32 Length) {
	i16* NewBuffer := (Alloc((Length * 2) + 2) As i16*)
	
	for (i32 Index := 0, Index < Length, Index += 1) {
		NewBuffer[Index] := AString[Index]
	}
	
	return NewBuffer
}

define i32 WideStringLength(i16* WideString) {
	i16 NextCharacter := WideString[0]
	i32 Index := 0
	
	while (NextCharacter != 0) {
		NextCharacter := WideString[Index]
		Index += 1
	}
	
	return Index
}

i8 TOKEN_TYPE_EOF := 0
i8 TOKEN_TYPE_NONE := 100
i8 TOKEN_TYPE_OPERATOR := 1
i8 TOKEN_TYPE_IDENTIFER := 2
i8 TOKEN_TYPE_INTEGER := 3
i8 TOKEN_TYPE_STRING := 4
i8 TOKEN_TYPE_PUNCTUATION := 5
i8 TOKEN_TYPE_KEYWORD := 6


i8 OPERATOR_COLON_EQUAL := 0
i8 OPERATOR_PLUS_EQUAL := 1
i8 OPERATOR_MINUS_EQUAL := 2
i8 OPERATOR_STAR_EQUAL := 3

i8 OPERATOR_PLUS := 4
i8 OPERATOR_MINUS := 5
i8 OPERATOR_STAR := 6
i8 OPERATOR_SLASH := 7
i8 OPERATOR_EQUAL := 8
i8 OPERATOR_DOT := 9

i8 OPERATOR_MINUS_GREATER := 10
i8 OPERATOR_BANG := 11

i8 OPERATOR_LOGICAL_AND := 12
i8 OPERATOR_LOGICAL_OR := 13

i8 OPERATOR_LESS := 14
i8 OPERATOR_LESS_EQAUL := 15
i8 OPERATOR_GREATER := 16
i8 OPERATOR_GREATER_EQAUL := 17

i8 OPERATOR_AND := 18
i8 OPERATOR_OR := 19

i8 OPERATOR_COLON := 20
i8 OPERATOR_AS := 21

i8 OPERATOR_BANG_EQUAL := 22
i8 OPERATOR_OPEN_BRACKET := 23


i8 PUNCTUATION_OPEN_PAREN := 0
i8 PUNCTUATION_CLOSE_PAREN := 1

i8 PUNCTUATION_OPEN_BRACE := 2
i8 PUNCTUATION_CLOSE_BRACE := 3

i8 PUNCTUATION_CLOSE_BRACKET := 4

i8 PUNCTUATION_COMMA := 5


i8 KEYWORD_DEFINE := 0
i8 KEYWORD_DLLIMPORT := 1

i8 KEYWORD_IF := 2
i8 KEYWORD_ELSE := 3

i8 KEYWORD_FOR := 4
i8 KEYWORD_WHILE := 5
i8 KEYWORD_LOOP := 6

i8 KEYWORD_CONTINUE := 7
i8 KEYWORD_BREAK := 8

i8 KEYWORD_STRUCT := 9
i8 KEYWORD_RETURN := 10

define void Backtrack(TokenizerState* pState) {
	pState->Index -= 1
}

define i16 PeekNextCharacter(TokenizerState* pState) {
	return Lower((pState->Source)[pState->Index])
}
define i16 GetNextCharacter(TokenizerState* pState) {
	i16 NextCharacter := PeekNextCharacter(pState)

	pState->Index += 1
	return NextCharacter
}
define i8 NextCharacterMatches(TokenizerState* pState, i8 CharacterToCheck) {
	if (PeekNextCharacter(pState) = CharacterToCheck) {
		GetNextCharacter(pState)
		return 1
	}
	
	return 0
}

define i8 TokenizerAtEnd(TokenizerState* pState) {
	return (pState->Index) > (pState->SourceLength)
}

define void TokenizerError(TokenizerState* pState, i8* Message) {
	Console:AWriteLine(Message)
	Console:AWrite("At: ")
	
	Backtrack(pState)
	
	SafeWideString SourcePrintoutHelper
	
	SourcePrintoutHelper.Buffer := (pState->Source) + ((pState->Index) * 2)
	
	SourcePrintoutHelper.Length := WideStringLength(SourcePrintoutHelper.Buffer)
	
	PrintSafeString(&SourcePrintoutHelper)
	
	Exit(1)
}


define Token* GetNextToken(TokenizerState* pState) {
	while (!TokenizerAtEnd(pState)) {
		i32 StartingIndex := pState->Index
		i16 NextCharacter := GetNextCharacter(pState)

		if (PeekNextCharacter(pState) = '=') {
			GetNextCharacter(pState)
			
			i8 NewType := TOKEN_TYPE_NONE
			
			if (NextCharacter = ':') {
				NewType := OPERATOR_COLON_EQUAL
			}
			else if (NextCharacter = '+') {
				NewType := OPERATOR_PLUS_EQUAL
			}
			else if (NextCharacter = '-') {
				NewType := OPERATOR_MINUS_EQUAL
			}
			else if (NextCharacter = '*') {
				NewType := OPERATOR_STAR_EQUAL
			}
			else if (NextCharacter = '<') {
				NewType := OPERATOR_LESS_EQAUL
			}
			else if (NextCharacter = '>') {
				NewType := OPERATOR_GREATER_EQAUL
			}
			else if (NextCharacter = '!') {
				NewType := OPERATOR_BANG_EQUAL
			}
			else {
				Backtrack(pState)
			}
			
			if (NewType != TOKEN_TYPE_NONE) {
				return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, NewType)
			}
		}
		
		if (NextCharacter = ''') {
			NextCharacter := GetNextCharacter(pState)
			
			if (GetNextCharacter(pState) != ''') {
				TokenizerError(pState, "Expected close single quote for character constant")
			}
			
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_INTEGER, NextCharacter)
		}
		else if (NextCharacter = '=') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_EQUAL)
		}
		else if (NextCharacter = '+') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_PLUS)
		}
		else if (NextCharacter = '-') {
			if (NextCharacterMatches(pState, '>')) {
				return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_MINUS_GREATER)
			}
			
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_MINUS)
		}
		else if (NextCharacter = '*') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_STAR)
		}
		else if (NextCharacter = '/') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_SLASH)
		}
		else if (NextCharacter = '.') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_DOT)
		}
		else if (NextCharacter = '<') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_LESS)
		}
		else if (NextCharacter = '>') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_GREATER)
		}
		else if (NextCharacter = '&') {
			if (NextCharacterMatches(pState, '&')) {
				return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_LOGICAL_AND)
			}
			
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_AND)
		}
		else if (NextCharacter = '|') {
			if (NextCharacterMatches(pState, '|')) {
				return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_LOGICAL_OR)
			}
			
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_OR)
		}
		else if (NextCharacter = '!') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_BANG)
		}
		else if (NextCharacter = ':') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_COLON)
		}
		else if (NextCharacter = 'a' && PeekNextCharacter(pState) = 's') {
			GetNextCharacter(pState)
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_AS)
		}
		else if (NextCharacter = '(') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)
		}
		else if (NextCharacter = ')') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)
		}
		else if (NextCharacter = '{') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)
		}
		else if (NextCharacter = '}') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)
		}
		else if (NextCharacter = '[') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET)
		}
		else if (NextCharacter = ']') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET)
		}
		else if (NextCharacter = ',') {
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
		}
		else if (NextCharacter = '"') {
			NextCharacter := 0
			
			while ((NextCharacter != '"') && (!TokenizerAtEnd(pState))) {
				NextCharacter := GetNextCharacter(pState)
			}
			
			if (TokenizerAtEnd(pState)) {
				TokenizerError(pState, "Expected close quote before EOF")
			}
			
			SafeWideString* FoundString := MakeSafeStringToken(pState, StartingIndex + 1) As SafeWideString*
			FoundString->Length -= 1
			
			return MakeToken(pState, StartingIndex, TOKEN_TYPE_STRING, FoundString As void*)
		}
		else if (IsNumeric(NextCharacter)) {
			i8 NumberIsHex := false
			
			if (NextCharacterMatches(pState, 'x')) {
				NumberIsHex := true
				
				NextCharacter := PeekNextCharacter(pState)
				
				while (IsHex(NextCharacter) && (!TokenizerAtEnd(pState))) {
					NextCharacter := GetNextCharacter(pState)
				}
			}
			else {
				while (IsNumeric(NextCharacter) && (!TokenizerAtEnd(pState))) {
					NextCharacter := GetNextCharacter(pState)
				}
			}
			
			if !(TokenizerAtEnd(pState)) {
				Backtrack(pState)
			}
			
			SafeWideString* AsString := (MakeSafeStringToken(pState, StartingIndex + (NumberIsHex * 2)) As SafeWideString*)
			i8 NumberWasConverted := 0
			Token* ResultToken := MakeToken(pState, StartingIndex, TOKEN_TYPE_INTEGER, 0)
			
			if (NumberIsHex) {
				ResultToken->Value := SafeStringHexToI64(AsString, &NumberWasConverted)
			}
			else {
				ResultToken->Value := SafeStringToI64(AsString, &NumberWasConverted)
			}
			
			FreeSafeString(AsString)
			
			return ResultToken
		}
		else if (IsAlpha(NextCharacter) || NextCharacter = '_') {
			while (IsAlphaNumeric(NextCharacter) && (!TokenizerAtEnd(pState))) {
				NextCharacter := GetNextCharacter(pState)
			}
			
			if !(TokenizerAtEnd(pState)) {
				Backtrack(pState)
			}
			
			SafeWideString* TokenText := MakeSafeStringToken(pState, StartingIndex) As SafeWideString*
			
			i8 TokenAsKeyword := LookupKeyword(TokenText)
			
			if (TokenAsKeyword != TOKEN_TYPE_NONE) {
				FreeSafeString(TokenText)
				return MakeToken(pState, StartingIndex, TOKEN_TYPE_KEYWORD, TokenAsKeyword)
			}
			else {		
				return MakeToken(pState, StartingIndex, TOKEN_TYPE_IDENTIFER, TokenText As void*)
			}
		}
		
		if (NextCharacter = ' ' || NextCharacter = '	') {
			continue
		}
		else if (NextCharacter = 10 || NextCharacter = 13) {
			continue
		}
		else if (NextCharacter = 0) {
			continue
		}
		
		Console:WriteCharacter(NextCharacter)
		TokenizerError(pState, " - Unexpected character")
	}
	
	return MakeToken(pState, pState->SourceLength, TOKEN_TYPE_EOF, 0)
}

define i8 LookupKeyword(SafeWideString* PotentialKeyword) {
	if (SafeStringEqualsAString(PotentialKeyword, "define")) {
		return KEYWORD_DEFINE
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "dllimport")) {
		return KEYWORD_DLLIMPORT
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "if")) {
		return KEYWORD_IF
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "else")) {
		return KEYWORD_ELSE
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "for")) {
		return KEYWORD_FOR
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "while")) {
		return KEYWORD_WHILE
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "loop")) {
		return KEYWORD_LOOP
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "continue")) {
		return KEYWORD_CONTINUE
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "break")) {
		return KEYWORD_BREAK
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "struct")) {
		return KEYWORD_STRUCT
	}
	else if (SafeStringEqualsAString(PotentialKeyword, "return")) {
		return KEYWORD_RETURN
	}
	
	return TOKEN_TYPE_NONE
}

define i16 Lower(i16 Character) {
	if ('A' <= Character && Character <= 'Z') {
		Character += 32
	}
	
	return Character
}

define i8 CharacterEqualsNoCase(i16 CharacterOne, i16 CharacterTwo) {
	return Lower(CharacterOne) = Lower(CharacterTwo)
}

define i8 SafeStringEqualsAString(SafeWideString* StringOne, i8* StringTwo) {
	i32 Index := 0
	
	loop {
		if (Index >= StringOne->Length) {
			if (StringTwo[Index] = 0) {
				return true
			}
			else {
				return false
			}
		}
		else if (StringTwo[Index] = 0) {
			return false
		}
		
		if !(CharacterEqualsNoCase((StringOne->Buffer)[Index], StringTwo[Index])) {
			return false
		}
		
		Index += 1
	}

	return true
}

define SafeWideString* AllocateNewSafeString() {
	return Alloc(SafeWideString.Size) As SafeWideString*
}
define void FreeSafeString(SafeWideString* StringToFree) {
	Free(StringToFree As void*)
}

define void* MakeSafeStringToken(TokenizerState* pState, i32 StartingIndex) {
	SafeWideString* NewSafeString := AllocateNewSafeString()

	NewSafeString->Length := pState->Index - StartingIndex
	NewSafeString->Buffer := pState->Source + (StartingIndex * 2)

	return NewSafeString As void*
}

define void PrintSafeString(SafeWideString* StringToPrint) {
	i32 CharactersWritten := 0
	
	Console:WriteConsole(Console:STDOUT, StringToPrint->Buffer, StringToPrint->Length, &CharactersWritten, 0)
	
	return CharactersWritten
}

define Token* AllocateNewToken() {
	return Alloc(Token.Size) As Token*
}
define void FreeToken(Token* TokenToFree) {
	return 0
	/*
	if (TokenToFree->Type = TOKEN_TYPE_IDENTIFER || TokenToFree->Type = TOKEN_TYPE_STRING) {
		FreeSafeString((TokenToFree->Value) As SafeWideString*)
	}
	
	Free(TokenToFree As void*)*/
}
define void FreeTokenOnly(Token* TokenToFree) {
	return 0
	/*Free(TokenToFree As void*)*/
}

define Token* CopyToken(Token* TokenToCopy) {
	Token* TokenCopy := AllocateNewToken()
	
	TokenCopy->PositionInSource := TokenToCopy->PositionInSource
	TokenCopy->LengthInSource := TokenToCopy->LengthInSource
	TokenCopy->Type := TokenToCopy->Type
	TokenCopy->Value := TokenToCopy->Value
	
	return TokenCopy
}

define Token* MakeToken(TokenizerState* tState, i16 PositionInSource, i8 Type, void* Value) {
	Token* OutputToken := tState->CurrentToken

	OutputToken->PositionInSource := PositionInSource
	OutputToken->LengthInSource := (tState->Index) - PositionInSource
	OutputToken->Type := Type
	OutputToken->Value := Value
	
	return OutputToken
}

define void PrintToken(Token* TokenToPrint) {
	Console:AWrite("Type: ")
	Console:IWriteLine(TokenToPrint->Type)
	
	Console:AWrite("Value")
	
	if (TokenToPrint->Type = TOKEN_TYPE_IDENTIFER) {
		Console:AWrite(" (S): ")
		
		PrintSafeString((TokenToPrint->Value) As SafeWideString*)
		
		Console:WriteNewLine()
	}
	else if (TokenToPrint->Type = TOKEN_TYPE_STRING) {
		Console:AWrite(" (S): ")
		
		Console:WriteCharacter('"')
		PrintSafeString((TokenToPrint->Value) As SafeWideString*)
		Console:WriteCharacter('"')
		
		Console:WriteNewLine()
	}
	else if (TokenToPrint->Type = TOKEN_TYPE_OPERATOR) {
		Console:AWrite(" (O): ")
		
		PrintOperator(TokenToPrint->Value)
		Console:WriteNewLine()
	}
	else if (TokenToPrint->Type = TOKEN_TYPE_PUNCTUATION) {
		Console:AWrite(" (P): ")
		
		PrintPunctuation(TokenToPrint->Value)
		Console:WriteNewLine()
	}
	else if (TokenToPrint->Type = TOKEN_TYPE_KEYWORD) {
		Console:AWrite(" (K): ")
		
		PrintKeyword(TokenToPrint->Value)
		Console:WriteNewLine()
	}
	else {
		Console:AWrite(": ")
		Console:IWriteLine(TokenToPrint->Value)
	}
	
	Console:AWrite("Position: ")
	Console:IWriteLine(TokenToPrint->PositionInSource)
	
	Console:AWrite("Length: ")
	Console:IWriteLine(TokenToPrint->LengthInSource)
}

define void PrintOperator(i8 Operator) {
	i8 FirstCharacter := 0
	i8 SecondCharacter := 0
	
	if (Operator = OPERATOR_COLON_EQUAL) {
		FirstCharacter := ':'
		SecondCharacter := '='
	}
	else if (Operator = OPERATOR_PLUS_EQUAL) {
		FirstCharacter := '+'
		SecondCharacter := '='
	}
	else if (Operator = OPERATOR_MINUS_EQUAL) {
		FirstCharacter := '-'
		SecondCharacter := '='
	}
	else if (Operator = OPERATOR_STAR_EQUAL) {
		FirstCharacter := '*'
		SecondCharacter := '='
	}
	else if (Operator = OPERATOR_LESS_EQAUL) {
		FirstCharacter := '<'
		SecondCharacter := '='
	}
	else if (Operator = OPERATOR_GREATER_EQAUL) {
		FirstCharacter := '>'
		SecondCharacter := '='
	}
	else if (Operator = OPERATOR_BANG_EQUAL) {
		FirstCharacter := '!'
		SecondCharacter := '='
	}
	else if (Operator = OPERATOR_MINUS_GREATER) {
		FirstCharacter := '-'
		SecondCharacter := '>'
	}
	else if (Operator = OPERATOR_LOGICAL_AND) {
		FirstCharacter := '&'
		SecondCharacter := '&'
	}
	else if (Operator = OPERATOR_LOGICAL_OR) {
		FirstCharacter := '|'
		SecondCharacter := '|'
	}
	else if (Operator = OPERATOR_AS) {
		FirstCharacter := 'a'
		SecondCharacter := 's'
	}
	else if (Operator = OPERATOR_OPEN_BRACKET) {
		FirstCharacter := '['
	}
	else if (Operator = OPERATOR_PLUS) {
		FirstCharacter := '+'
	}
	else if (Operator = OPERATOR_MINUS) {
		FirstCharacter := '-'
	}
	else if (Operator = OPERATOR_STAR) {
		FirstCharacter := '*'
	}
	else if (Operator = OPERATOR_SLASH) {
		FirstCharacter := '/'
	}
	else if (Operator = OPERATOR_EQUAL) {
		FirstCharacter := '='
	}
	else if (Operator = OPERATOR_DOT) {
		FirstCharacter := '.'
	}
	else if (Operator = OPERATOR_BANG) {
		FirstCharacter := '!'
	}
	else if (Operator = OPERATOR_LESS) {
		FirstCharacter := '<'
	}
	else if (Operator = OPERATOR_GREATER) {
		FirstCharacter := '>'
	}
	else if (Operator = OPERATOR_AND) {
		FirstCharacter := '&'
	}
	else if (Operator = OPERATOR_OR) {
		FirstCharacter := '|'
	}
	else if (Operator = OPERATOR_COLON) {
		FirstCharacter := ':'
	}
	
	if (FirstCharacter) {
		Console:WriteCharacter(FirstCharacter)
	}
	if (SecondCharacter) {
		Console:WriteCharacter(SecondCharacter)
	}
}

define void PrintPunctuation(i8 Punctuation) {
	i8 Character := 0
	
	if (Punctuation = PUNCTUATION_OPEN_PAREN) {
		Character := '('
	}
	else if (Punctuation = PUNCTUATION_CLOSE_PAREN) {
		Character := ')'
	}
	else if (Punctuation = PUNCTUATION_OPEN_BRACE) {
		Character := '{'
	}
	else if (Punctuation = PUNCTUATION_CLOSE_BRACE) {
		Character := '}'
	}
	else if (Punctuation = PUNCTUATION_CLOSE_BRACKET) {
		Character := ']'
	}
	else if (Punctuation = PUNCTUATION_COMMA) {
		Character := ','
	}
	
	Console:WriteCharacter(Character)
}

define void PrintKeyword(i8 Keyword) {
	if (Keyword = KEYWORD_DEFINE) {
		Console:AWrite("define")
	}
	else if (Keyword = KEYWORD_DLLIMPORT) {
		Console:AWrite("DllImport")
	}
	else if (Keyword = KEYWORD_IF) {
		Console:AWrite("if")
	}
	else if (Keyword = KEYWORD_ELSE) {
		Console:AWrite("else")
	}
	else if (Keyword = KEYWORD_FOR) {
		Console:AWrite("for")
	}
	else if (Keyword = KEYWORD_WHILE) {
		Console:AWrite("while")
	}
	else if (Keyword = KEYWORD_LOOP) {
		Console:AWrite("loop")
	}
	else if (Keyword = KEYWORD_CONTINUE) {
		Console:AWrite("continue")
	}
	else if (Keyword = KEYWORD_BREAK) {
		Console:AWrite("break")
	}
	else if (Keyword = KEYWORD_STRUCT) {
		Console:AWrite("struct")
	}
	else if (Keyword = KEYWORD_RETURN) {
		Console:AWrite("return")
	}
}


define i8 IsAlphaNumeric(i16 Character) {
	return IsAlpha(Character) || IsNumeric(Character) || Character = '_'
}

define i8 IsAlpha(i16 Character) {
	if ('a' <= Character && Character <= 'z') {
		return 1
	}
	else if ('A' <= Character && Character <= 'Z') {
		return 1
	}

	return 0
}

define i8 IsHex(i16 Character) {
	return IsNumeric(Character) || _IsHex(Character)
}
define i8 _IsHex(i16 Character) {
	if ((Character >= 'a') && (Character <= 'f')) {
		return true
	}
	else if ((Character >= 'A') && (Character <= 'F')) {
		return true
	}
	
	return false
}

define i8 IsNumeric(i16 Character) {
	return (Character >= '0') && (Character <= '9')
}

define i64 SafeStringHexToI64(SafeWideString* StringToReadFrom, i8* Success) {
	i64 Result := 0
	
	i16* WString := StringToReadFrom->Buffer
	
	i16 FirstCharacter := WString[0]
	
	if !(IsHex(FirstCharacter)) {
		Success *= 0
		return 0
	}
	
	i32 Length := StringToReadFrom->Length
	
	for (i32 Index := 0, Index <= Length, Index += 1) {
		i16 NextCharacter := WString[Index]
		
		if !(IsHex(NextCharacter)) {
			Break
		}
		
		if (IsNumeric(NextCharacter)) {
			NextCharacter -= '0'
		}
		else {
			if (NextCharacter = 'a' || NextCharacter = 'A') {
				NextCharacter := 10
			}
			else if (NextCharacter = 'b' || NextCharacter = 'B') {
				NextCharacter := 11
			}
			else if (NextCharacter = 'c' || NextCharacter = 'C') {
				NextCharacter := 12
			}
			else if (NextCharacter = 'd' || NextCharacter = 'D') {
				NextCharacter := 13
			}
			else if (NextCharacter = 'e' || NextCharacter = 'E') {
				NextCharacter := 14
			}
			else if (NextCharacter = 'f' || NextCharacter = 'F') {
				NextCharacter := 15
			}
		}
		
		Result := (Result * 16) + (NextCharacter)
	}
	
	Success *= 1
	
	return Result
}


define i64 SafeStringToI64(SafeWideString* StringToReadFrom, i8* Success) {
	i64 Result := 0
	i64 Negative := 0
	
	i16* WString := StringToReadFrom->Buffer
	
	i16 FirstCharacter := WString[0]
	
	if (FirstCharacter = '-') {
		Negative := 1
		WString += 2
		FirstCharacter := WString[0]
	}
	
	if !(IsNumeric(FirstCharacter)) {
		Success *= 0
		return 0
	}
	
	i32 Length := StringToReadFrom->Length
	
	for (i32 Index := 0, Index < Length, Index += 1) {
		i16 NextCharacter := WString[Index]
		
		if !(IsNumeric(NextCharacter)) {
			Break
		}
		
		Result := (Result * 10) + (NextCharacter - '0')
	}
	
	Success *= 1
	
	if (Negative) {
		Result := -Result
	}
	
	return Result
}

/*
==========================================
	Expression parser constant lookup functions
==========================================
*/

i8 NONE_ASSOCIATIVE := 0
i8 LEFT_ASSOCIATIVE := 1
i8 RIGHT_ASSOCIATIVE := 2

define i8 GetPrecedence(Token* ForOperator) {
	i8 Operator := (ForOperator->Value) As i8
	
	if (Operator = OPERATOR_COLON_EQUAL || Operator = OPERATOR_STAR_EQUAL) {
		return 1
	}
	else if (Operator = OPERATOR_PLUS_EQUAL || Operator = OPERATOR_MINUS_EQUAL) {
		return 1
	}
	else if (Operator = OPERATOR_LOGICAL_AND || Operator = OPERATOR_LOGICAL_OR) {
		return 2
	}
	else if (Operator = OPERATOR_BANG_EQUAL || Operator = OPERATOR_EQUAL) {
		return 3
	}
	else if (Operator = OPERATOR_GREATER_EQAUL || Operator = OPERATOR_LESS_EQAUL) {
		return 3
	}
	else if (Operator = OPERATOR_GREATER || Operator = OPERATOR_LESS) {
		return 3
	}
	else if (Operator = OPERATOR_AS) {
		return 5
	}
	else if (Operator = OPERATOR_PLUS || Operator = OPERATOR_MINUS) {
		return 7
	}
	else if (Operator = OPERATOR_OPEN_BRACKET) {
		return 8
	}
	else if (Operator = OPERATOR_DOT || Operator = OPERATOR_MINUS_GREATER) {
		return 9
	}
	else if (Operator = OPERATOR_STAR || Operator = OPERATOR_SLASH) {
		return 10
	}
	else if (Operator = OPERATOR_AND || Operator = OPERATOR_OR) {
		return 12
	}
}

define i8 GetAssociation(Token* ForOperator) {
	i8 Precedence := GetPrecedence(ForOperator)
	
	if (Precedence = 1 || Precedence = 3) {
		return RIGHT_ASSOCIATIVE
	}
	else {
		return LEFT_ASSOCIATIVE
	}
}

define i8 GetPrefixPrecedence(Token* ForOperator) {
	i8 Operator := (ForOperator->Value) As i8
	
	if (Operator = OPERATOR_STAR) {
		return 4
	}
	else if (Operator = OPERATOR_AND) {
		return 4
	}
	else if (Operator = OPERATOR_BANG) {
		return 11
	}
	else if (Operator = OPERATOR_MINUS) {
		return 11
	}
	
	return 0
}

define i8 IsPrefixOperator(Token* ForOperator) {
	return GetPrefixPrecedence(ForOperator) != 0
}

/*
==========================================
	Typing helper structs
==========================================
*/

struct TypeInfo {
	SafeWideString* Name,
	HashMap* StructTypeFields,
	i16 Size,
	i8 IsStructType,
	i8 IsIncomplete
}

struct Type {
	TypeInfo* TrueType,
	i16 Size,
	i8 PointerDepth
}

struct StructField {
	SafeWideString* Name,
	i16 Offset,
	Type* ValueType
}

/*
==========================================
	Typing functions
==========================================
*/

Type* TYPE_NONE := 0

define TypeInfo* AddType(ParserState* pState, SafeWideString* Name, HashMap* Fields, i16 Size, i8 IsStructType, i8 IsIncomplete) {
	TypeInfo* NewType := Alloc(TypeInfo.Size) As TypeInfo*
	
	NewType->Name := Name
	NewType->StructTypeFields := Fields
	NewType->Size := Size
	NewType->IsStructType := IsStructType
	NewType->IsIncomplete := IsIncomplete
	
	Console:AWrite("Adding ")
	PrintSafeString(Name)
	Console:AWrite(" at ")
	Console:IWriteLine(NewType As i64)
	
	HashMapAddValue(pState->Types, Name, NewType As void)
	
	return NewType
}

define Type* MakeType(TypeInfo* BackingType, i8 PointerDepth) {
	Type* NewType := Alloc(Type.Size) As Type*
	
	NewType->TrueType := BackingType
	NewType->PointerDepth := PointerDepth
	
	if (PointerDepth) {
		NewType->Size := 8
	}
	else {
		NewType->Size := BackingType->Size
	}

	return NewType
}

define void CreateDefaultTypes(ParserState* pState) {
	/* Creates all the standard types, only called once */
	pState->i8 := AddType(pState, AToS("i8"), 0, 1, false, false)
	pState->i16 := AddType(pState, AToS("i16"), 0, 2, false, false)
	pState->i32 := AddType(pState, AToS("i32"), 0, 4, false, false)
	pState->i64 := AddType(pState, AToS("i64"), 0, 8, false, false)
	pState->void := AddType(pState, AToS("void"), 0, 8, false, false)
}

define Type* GetType(ParserState* pState, SafeWideString* TypeName, i8 PointerDepth) {
	HashMapElement* FoundElement := HashMapGetValue(pState->Types, TypeName)
	TypeInfo* FoundTypeInfo := 0
	
	Console:AWrite("Found ")
	PrintSafeString(TypeName)
	Console:AWrite(" at ")
	
	if (FoundElement) {
		Console:IWriteLine((FoundElement->Value) As i64)
		FoundTypeInfo := (FoundElement->Value) As TypeInfo*
	}
	else {
		Console:IWriteLine(0)
		/*
			If we did not find a typeinfo, then this type has to be an undefined user type, which is defined somewhere else
			So, we will call AddType and add it as incomplete
		*/
		
		if (PointerDepth = 0) {
			TokenizerError(pState->pState, "Incomplete types can only be used with pointers")
		}
		
		FoundTypeInfo := AddType(pState, TypeName, 0, 0, true, true)
	}
	
	Type* Result := Alloc(Type.Size) As Type*
	
	Result->PointerDepth := PointerDepth
	Result->TrueType := FoundTypeInfo
	
	if (PointerDepth) {
		Result->Size := 8
	}
	else {
		Result->Size := FoundTypeInfo->Size
	}
	
	return Result
}

define Type* DecrementPointerType(ParserState* pState, Type* TypeToDecrement) {
	Type* NewType := Alloc(Type.Size) As Type*
	
	if (TypeToDecrement->PointerDepth = 0) {
		TokenizerError(pState->pState, "Pointer type expected")
	}
	
	NewType->TrueType := TypeToDecrement->TrueType
	NewType->PointerDepth := (TypeToDecrement->PointerDepth) - 1
	
	return NewType
}
define Type* IncrementPointerType(ParserState* pState, Type* TypeToIncrement) {
	Type* NewType := Alloc(Type.Size) As Type*
	
	NewType->TrueType := TypeToIncrement->TrueType
	NewType->PointerDepth := (TypeToIncrement->PointerDepth) + 1

	return NewType
}

define void PrintType(Type* TypeToPrint) {
	PrintSafeString(TypeToPrint->TrueType->Name)
	
	loop (TypeToPrint->PointerDepth) {
		Console:WriteCharacter('*')
	}
}


/*
==========================================
	Variable struct + alloc helper + hashmap helpers
==========================================
*/

struct VariableInfo {
	SafeWideString* Name,
	Type* Type,
	i16 ScopedID,
	i8 IsGlobal,
	i8 IsParameter
}

define VariableInfo* AllocateNewVariableInfo() {
	return Alloc(VariableInfo.Size) As VariableInfo*
}
define void HashMapAddVariable(HashMap* TargetMap, VariableInfo* TargetVariable) {
	HashMapAddValue(TargetMap, TargetVariable->Name, TargetVariable As void)
}
define VariableInfo* HashMapGetVariable(HashMap* TargetMap, SafeWideString* VariableName) {
	HashMapElement* Result := HashMapGetValue(TargetMap, VariableName)
	
	if (Result) {
		return (Result->Value) As VariableInfo*
	}
	
	return 0 As VariableInfo*
}

/*
==========================================
	AST Node type constants
==========================================
*/

i8 NODE_TYPE_NONE := 0
i8 NODE_TYPE_TOKEN := 1

i8 NODE_TYPE_UNARY := 2
i8 NODE_TYPE_BINARY := 3
i8 NODE_TYPE_CALL := 4
i8 NODE_TYPE_ARRAYACCESS := 5

i8 NODE_TYPE_DEFINE := 6
i8 NODE_TYPE_DLLIMPORT := 7

i8 NODE_TYPE_IF := 8

i8 NODE_TYPE_FOR := 9
i8 NODE_TYPE_WHILE := 10
i8 NODE_TYPE_LOOP := 11
i8 NODE_TYPE_CONTINUEBREAK := 12

i8 NODE_TYPE_RETURN := 13
i8 NODE_TYPE_EXPRESSION := 14

i8 NODE_TYPE_VARIABLE := 15
i8 NODE_TYPE_INTEGER := 16
i8 NODE_TYPE_STRING := 17

i8 NODE_TYPE_TYPE := 18 /* For when an expression has an operand which is a literal type (like with 'as') */
i8 NODE_TYPE_STRUCT_ACCESS := 19

/*
==========================================
	AST Node definition + alloc/free helpers
==========================================
*/

struct ASTNode {
	void* TrueNode,
	Type* ValueType,
	i8 NodeType
}

define ASTNode* AllocateNewASTNode(i8 NewNodeType, void* NewNodeTrueNode, Type* NewNodeValueType) {
	ASTNode* NewNode := Alloc(ASTNode.Size) As ASTNode*
	
	NewNode->NodeType := NewNodeType
	NewNode->TrueNode := NewNodeTrueNode
	NewNode->ValueType := NewNodeValueType
	
	return NewNode
}
define void FreeASTNode(ASTNode* NodeToFree) {
	Free(NodeToFree As void*)
}

/*
==========================================
	True AST node types
==========================================
*/

struct UnaryExpression {
	Token* Operator,
	ASTNode* Operand
}

struct BinaryExpression {
	ASTNode* Left,
	Token* Operator,
	ASTNode* Right
}

struct StructAccessExpression {
	ASTNode* Left,
	Token* Operator,
	StructField* TargetField
}

struct Block {
	ASTNode** Statements,
	i16 StatementCount
}

struct FunctionDefine {
	SafeWideString* Name,
	Block* Body,
	VariableInfo** Parameters,
	HashMap* Locals,
	Type* ReturnType,
	i16 ParameterCount,
	i16 LocalCount
}

struct CallExpression {
	FunctionDefine* TargetFunction,
	ASTNode** Parameters,
	i32 ParameterCount
}

/*
==========================================
	AST Node construction helpers
==========================================
*/

define Type* GetBinaryResultType(ParserState* pState, Type* LeftType, Type* RightType) {
	TypeInfo* LeftBaseType := LeftType->TrueType
	TypeInfo* RightBaseType := RightType->TrueType
	
	if (LeftType->PointerDepth && RightType->PointerDepth) {
		TokenizerError(pState->pState, "Operations involving two pointers are disallowed.")
	}
	else if (LeftType->PointerDepth) {
		if (RightBaseType->IsStructType) {
			TokenizerError(pState->pState, "Invalid operation types1.")
		}
		
		return LeftType
	}
	else if (RightType->PointerDepth) {
		if (LeftBaseType->IsStructType) {
			TokenizerError(pState->pState, "Invalid operation types2.")
		}
		
		return RightType
	}
	else {
		if (LeftBaseType->IsStructType || RightBaseType->IsStructType) {
			TokenizerError(pState->pState, "Invalid operation types3.")
		}
		
		if (LeftBaseType->Size >= RightBaseType->Size) {
			return LeftType
		}
		else {
			return RightType
		}
	}
}

define ASTNode* MakeBinary(ParserState* pState, ASTNode* Left, Token* OperatorToken, ASTNode* Right) {
	i8 Operator := (OperatorToken->Value) As i8
	Type* ResultType := 0
	
	Type* LeftType := Left->ValueType
	Type* RightType := Right->ValueType
	TypeInfo* LeftBaseType := LeftType->TrueType
	TypeInfo* RightBaseType := RightType->TrueType
	
	if (Operator = OPERATOR_AS) {
		if (Right->NodeType != NODE_TYPE_TYPE) {
			TokenizerError(pState->pState, "Right side operand of 'as' must be a type name")
		}
		
		ResultType := RightType
	}
	else if (Operator = OPERATOR_DOT || Operator = OPERATOR_MINUS_GREATER) {
		if !(LeftType->TrueType->IsStructType) {
			TokenizerError(pState->pState, "Left side operand of '.' and '->' must be of a struct type")
		}
		
		if (LeftType->TrueType->IsIncomplete) {
			TokenizerError(pState->pState, "Fields of incomplete structs cannot be accessed.")
		}
		
		if (Right->NodeType != NODE_TYPE_VARIABLE) {
			TokenizerError(pState->pState, "Right side operand of of '.' and '->' must be a string")
		}
		
		SafeWideString* RightText := ((Right->TrueNode) As VariableInfo*)->Name
		
		HashMapElement* FoundStructField := HashMapGetValue(LeftType->TrueType->StructTypeFields, RightText)
		
		if !(FoundStructField) {
			PrintSafeString(RightText)
			Console:WriteNewLine()
			TokenizerError(pState->pState, "Unknown struct field")
		}
		
		StructField* TargetField := (FoundStructField->Value) As StructField*
		
		StructAccessExpression* NewAccess := Alloc(StructAccessExpression.Size) As StructAccessExpression*
		
		NewAccess->Left := Left
		NewAccess->Operator := OperatorToken
		NewAccess->TargetField := TargetField
		
		return AllocateNewASTNode(NODE_TYPE_STRUCT_ACCESS, NewAccess As void*, TargetField->ValueType)
	}
	else if (Operator = OPERATOR_COLON_EQUAL) {
		if (LeftType->PointerDepth && LeftBaseType->IsStructType && RightType->PointerDepth && RightBaseType->Size = 8) {
			ResultType := LeftType
		}
		else if (LeftType->PointerDepth != 0 && LeftBaseType->IsStructType) {
			TokenizerError(pState->pState, "Local structs cannot be assigned")
		}
		else if (LeftType->Size < RightType->Size) {
			TokenizerError(pState->pState, "Right side operand of ':=' cannot be a bigger type than left side operand")
		}
		else {
			ResultType := RightType
		}
	}
	else if (Operator = OPERATOR_OPEN_BRACKET) {
		if (RightType->PointerDepth || RightType->TrueType->IsStructType) {
			TokenizerError(pState->pState, "Right side operand of '[' must not be a pointer or struct.")
		}
		
		ResultType := DecrementPointerType(pState, LeftType)
	}
	else {
		ResultType := GetBinaryResultType(pState, LeftType, RightType)
	}
	
	if (Left->NodeType = NODE_TYPE_INTEGER) {
		Left->ValueType := ResultType
	}
	
	if (Right->NodeType = NODE_TYPE_INTEGER) {
		Right->ValueType := ResultType
	}
	
	BinaryExpression* Result := Alloc(BinaryExpression.Size) As BinaryExpression*
	
	Result->Left := Left
	Result->Operator := OperatorToken
	Result->Right := Right
	
	return AllocateNewASTNode(NODE_TYPE_BINARY, Result As void*, ResultType)
}
define ASTNode* MakeUnary(ParserState* pState, Token* OperatorToken, ASTNode* Operand) {
	UnaryExpression* Result := Alloc(UnaryExpression.Size) As UnaryExpression*
	
	Type* ResultType := Operand->ValueType
	i8 Operator := (OperatorToken->Value) As i8
	
	Result->Operator := OperatorToken
	Result->Operand := Operand
	
	if (Operator = OPERATOR_BANG) {
		ResultType := MakeType(pState->i8, 0)
	}
	else if (Operator = OPERATOR_AND) {
		if (Operand->NodeType != NODE_TYPE_VARIABLE) {
			TokenizerError(pState->pState, "Operand of the '&' operator must be a variable.")
		}
		
		ResultType := IncrementPointerType(pState, ResultType)
	}
	else if (Operator = OPERATOR_STAR) {
		ResultType := DecrementPointerType(pState, ResultType)
	}
	
	return AllocateNewASTNode(NODE_TYPE_UNARY, Result As void*, ResultType)
}
define ASTNode* MakeCall(ParserState* pState, SafeWideString* Name, ASTNode** Parameters, i32 ParameterCount) {
	CallExpression* Result := Alloc(CallExpression.Size) As CallExpression*
	
	HashMapElement* FoundFunction := HashMapGetValue(pState->Functions, Name)
	
	if !(FoundFunction) {
		PrintSafeString(Name)
		Console:WriteNewLine()
		TokenizerError(pState->pState, "Function definition not found.")
	}
	
	FunctionDefine* FoundDefine := (FoundFunction->Value) As FunctionDefine*
	
	if (FoundDefine->ParameterCount != ParameterCount) {
		TokenizerError(pState->pState, "Invalid number of parameters passed to function.")
	}
	
	Result->TargetFunction := FoundDefine
	Result->Parameters := Parameters
	Result->ParameterCount := ParameterCount
	
	return AllocateNewASTNode(NODE_TYPE_CALL, Result As void*, FoundDefine->ReturnType)
}

/*
==========================================
	Backing parser type + helpers
==========================================
*/

struct ParserState {
	TokenizerState* pState,
	
	HashMap* Functions,
	HashMap* Globals,
	HashMap* Types,
	
	TypeInfo* i8,
	TypeInfo* i16,
	TypeInfo* i32,
	TypeInfo* i64,
	TypeInfo* void,
	
	FunctionDefine* CurrentFunction,
	
	i16 FunctionCount,
	i16 GlobalCount,
	i16 TypeCount
}

define void ParserError(ParserState* pState, i8* ErrorMessage) {
	TokenizerError(pState->pState, ErrorMessage)
}

define i32 FreezeParser(ParserState* pState) {
	return pState->pState->Index
}
define void UnfreezeParser(ParserState* pState, i32 Index) {
	pState->pState->Index := Index
}

define Token* ParserNextToken(ParserState* pState) {
	Token* NextToken := GetNextToken(pState->pState)
	
	return NextToken
}
define i8 TokenMatches(Token* TokenToTest, i8 TokenType, i8 TokenValue) {
	if (TokenType = TOKEN_TYPE_IDENTIFER || TokenType = TOKEN_TYPE_STRING) {
		if (TokenToTest->Type = TokenType) {
			return true
		}
	}
	
	if (TokenToTest->Type = TokenType && TokenToTest->Value = TokenValue) {
		return true
	}
	
	return false
}
define i8 ParserNextMatches(ParserState* pState, i8 TokenType, i8 TokenValue) {
	i32 FrozenState := FreezeParser(pState)
	
	Token* NextToken := ParserNextToken(pState)
	i8 Matches := TokenMatches(NextToken, TokenType, TokenValue)
	
	if !(Matches) {
		UnfreezeParser(pState, FrozenState)
	}
	
	return Matches
}
define Token* Consume(ParserState* pState, i8 TokenType, i8 TokenValue, i8* Reason) {
	Token* NextToken := ParserNextToken(pState)
	
	if (NextToken->Type = TOKEN_TYPE_EOF) {
		TokenizerError(pState->pState, "Unexpected EOF")
	}
	
	if !(TokenMatches(NextToken, TokenType, TokenValue)) {
		TokenizerError(pState->pState, Reason)
	}
	
	return NextToken
}

define void ParserStart(TokenizerState* pState) {
	ParserState P
	P.pState := pState
	
	P.Globals := NewHashMap()
	P.GlobalCount := 0
	
	P.Functions := NewHashMap()
	P.FunctionCount := 0
	
	P.Types	:= NewHashMap()
	P.TypeCount := 0
	
	CreateDefaultTypes(&P)
	
	ParseProgram(&P)
	
	return 0
}

/*
==========================================
	Actual parsing functions
==========================================
*/

define void ParseProgram(ParserState* pState) {
	loop {
		Token* NextToken := ParserNextToken(pState)
		
		if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_DEFINE)) {
			Console:AWriteLine("Found define")
			
			ParseAndAddDefine(pState)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_DLLIMPORT)) {
		
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_STRUCT)) {
			Console:AWriteLine("Found struct")
			
			ParseAndAddStruct(pState)
		}
		
		if (TokenMatches(NextToken, TOKEN_TYPE_EOF, TOKEN_TYPE_EOF)) {
			break
		}
	}
}

define Type* ParseTypeName(ParserState* pState) {
	Token* NameToken := Consume(pState, TOKEN_TYPE_IDENTIFER, TOKEN_TYPE_NONE, "Type names must be identifiers")
	SafeWideString* Name := (NameToken->Value) As SafeWideString*
	
	i8 PointerDepth := 0
	
	while (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_STAR)) {
		PointerDepth += 1
	}
	
	Type* ResultType := GetType(pState, Name, PointerDepth)
	
	return ResultType
}

define void ParseAndAddStruct(ParserState* pState) {
	Token* NameToken := Consume(pState, TOKEN_TYPE_IDENTIFER, TOKEN_TYPE_NONE, "Expected identifier for struct name")
	SafeWideString* Name := (NameToken->Value) As SafeWideString*
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for struct body")
	
	HashMap* Fields := NewHashMap()
	i16 FieldCount := 0
	i16 NextFieldOffset := 0
	i16 TotalSize := 0
	
	loop {
		StructField* NextField := Alloc(StructField.Size) As StructField*
		
		NextField->ValueType := ParseTypeName(pState)

		Token* NameToken := Consume(pState, TOKEN_TYPE_IDENTIFER, 0, "Expected identifier for struct field name")
		
		SafeWideString* FieldName := (NameToken->Value) As SafeWideString*
		
		NextField->Name := FieldName
		HashMapAddValue(Fields, FieldName, NextField As void)
		
		NextField->Offset := NextFieldOffset
		NextFieldOffset += NextField->ValueType->Size
		
		FieldCount += 1
		TotalSize := NextFieldOffset
		
		if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
			break
		}
	
	}
	
	HashMapElement* FoundElement := HashMapGetValue(pState->Types, Name)
	TypeInfo* FoundType := 0
	
	if (FoundElement) {
		/*
			If an element for this type already exists in the type list then:
				A) It has been used as an incomplete type or,
				B) It has a duplicate definition
			We can check ->IsIncomplete to find out which is true
		*/
		
		FoundType := (FoundElement->Value) As TypeInfo*
		
		if !(FoundType->IsIncomplete) {
			TokenizerError(pState->pState, "Duplicate type definition")
		}
		
		FoundType->StructTypeFields := Fields
		FoundType->Size := TotalSize
		FoundType->IsStructType := true
		FoundType->IsIncomplete := false
	}
	else {
		AddType(pState, Name, Fields, TotalSize, true, false)
	}
}

define VariableInfo* FindVariable(ParserState* pState, SafeWideString* VariableName) {
	FunctionDefine* CurrentFunction := pState->CurrentFunction
	VariableInfo* FoundVariable := 0
	
	if (CurrentFunction) {
		FoundVariable := HashMapGetVariable(CurrentFunction->Locals, VariableName)
	}
	
	if !(FoundVariable) {
		FoundVariable := HashMapGetVariable(pState->Globals, VariableName)
	}
	
	if !(FoundVariable) {
		TokenizerError(pState->pState, "Undefined variable")
	}
	
	return FoundVariable
}

define void ParserAddLocal(ParserState* pState, VariableInfo* NewLocal) {
	FunctionDefine* CurrentFunction := pState->CurrentFunction
	
	Console:AWrite("Adding local ")
	PrintSafeString(NewLocal->Name)
	Console:WriteNewLine()
	
	if !(CurrentFunction) {
		TokenizerError(pState->pState, "Unexpected local variable")
	}
	
	if (HashMapGetVariable(CurrentFunction->Locals, NewLocal->Name)) {
		TokenizerError(pState->pState, "Duplicate definition")
	}
	
	NewLocal->ScopedID := CurrentFunction->LocalCount
	CurrentFunction->LocalCount += 1
	
	HashMapAddVariable(CurrentFunction->Locals, NewLocal)
}

define ASTNode* ParseAndAddDefine(ParserState* pState) {
	FunctionDefine* NewDefine := Alloc(FunctionDefine.Size) As FunctionDefine*
	
	NewDefine->Locals := NewHashMap()
	NewDefine->LocalCount := 0
	
	pState->CurrentFunction := NewDefine
	
	NewDefine->ReturnType := ParseTypeName(pState)

	Token* NameToken := Consume(pState, TOKEN_TYPE_IDENTIFER, TOKEN_TYPE_NONE, "Function names must be identifiers")
	NewDefine->Name := (NameToken->Value) As SafeWideString*
	
	ASTNode* NewDefineNode := AllocateNewASTNode(NODE_TYPE_DEFINE, NewDefine As void*, TYPE_NONE)
	
	HashMapAddValue(pState->Functions, NewDefine->Name, NewDefine As void)
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Function parameter lists must start with (")
	
	i8 ParameterCount := 0
	VariableInfo** ParameterList := Alloc(VariableInfo.Size * 16) As VariableInfo**
	
	if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
		loop {
			VariableInfo* NextParameter := AllocateNewVariableInfo()
			
			if (ParameterCount >= 16) {
				TokenizerError(pState->pState, "Max parameter limit reached")
			}
			
			ParameterList[ParameterCount] := NextParameter
			
			NextParameter->Type := ParseTypeName(pState)
			
			Token* NextParameterNameToken := Consume(pState, TOKEN_TYPE_IDENTIFER, TOKEN_TYPE_NONE, "Parameter names must be identifiers")
			
			NextParameter->Name := (NextParameterNameToken->Value) As SafeWideString*
			NextParameter->IsGlobal := false
			NextParameter->IsParameter := true
			NextParameter->ScopedID := ParameterCount
			
			ParserAddLocal(pState, NextParameter)
			
			ParameterCount += 1
			
			if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
				break
			}
		}
		
		if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
			TokenizerError(pState->pState, "Expected closing paren for parameter list")
		}
	}
	
	Console:AWrite("Parameter Count: ")
	Console:IWriteLine(ParameterCount)
	
	NewDefine->Parameters := ParameterList
	NewDefine->ParameterCount := ParameterCount
	
	NewDefine->Body := ParseBlock(pState)
	
	PrintAST(NewDefineNode)
	CompilerStart(NewDefine)
}

define Block* ParseBlock(ParserState* pState) {
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace in block")
	
	i16 StatementBufferSize := 8
	ASTNode** Statements := Alloc(StatementBufferSize * 8) As ASTNode**
	i16 StatementCount := 0
	
	loop {
		if (StatementCount * 8 <= StatementBufferSize) {
			Statements := ReAlloc(Statements As void*, (StatementCount + 10) * 8) As ASTNode**
			StatementBufferSize += (10 * 8)
		}
		
		Statements[StatementCount] := ParseStatement(pState)
		StatementCount += 1
		
		if (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
			break
		}
		else if (ParserNextMatches(pState, TOKEN_TYPE_EOF, 0)) {
			TokenizerError(pState->pState, "Expected close brace in block")
		}
	}
	
	Block* NewBlock := Alloc(Block.Size) As Block*
	NewBlock->Statements := Statements
	NewBlock->StatementCount := StatementCount
	
	Console:AWrite("Made new block with ")
	Console:IWrite(StatementCount)
	Console:AWriteLine(" statements")
	
	return NewBlock
}

define ASTNode* ParseStatement(ParserState* pState) {
	i32 FrozenState := FreezeParser(pState)
	
	Token* NextToken := ParserNextToken(pState)
	ASTNode* Result := 0
	
	if (NextToken->Type = TOKEN_TYPE_KEYWORD) {
		if (NextToken->Value = KEYWORD_CONTINUE) {
			Result := AllocateNewASTNode(NODE_TYPE_CONTINUEBREAK, true, TYPE_NONE)
		}
		else if (NextToken->Value = KEYWORD_BREAK) {
			Result := AllocateNewASTNode(NODE_TYPE_CONTINUEBREAK, false, TYPE_NONE)
		}
		else if (NextToken->Value = KEYWORD_RETURN) {
			ASTNode* ExpressionToReturn := ParseExpression(pState, 0)
			
			Type* ActualReturnType := ExpressionToReturn->ValueType
			Type* ExpectedReturnType := pState->CurrentFunction->ReturnType
			
			if (ActualReturnType->Size > ExpectedReturnType->Size) {
				TokenizerError(pState->pState, "Return type too large")
			}
			else if (ActualReturnType->PointerDepth != ExpectedReturnType->PointerDepth) {
				TokenizerError(pState->pState, "Return type has wrong pointer depth")
			}
			else if (ExpectedReturnType->TrueType->IsStructType != ActualReturnType->TrueType->IsStructType) {
				TokenizerError(pState->pState, "Return type should be a struct type")
			}
			
			Result := AllocateNewASTNode(NODE_TYPE_RETURN, ExpressionToReturn As void*, TYPE_NONE)
		}
	}
	
	if (Result = 0) {
		UnfreezeParser(pState, FrozenState)
		Result := AllocateNewASTNode(NODE_TYPE_EXPRESSION, ParseExpression(pState, 0) As void*, TYPE_NONE)
	}
	
	return Result
}

define Type* GetNumberType(ParserState* pState, i64 NumberToCheck) {
	if (NumberToCheck & 0x7FFFFFFF80000000) {
		return MakeType(pState->i64, 0)
	}
	else if (NumberToCheck & 0x7FFF8000) {
		return MakeType(pState->i32, 0)
	}
	else if (NumberToCheck & 0x7F80) {
		return MakeType(pState->i16, 0)
	}
	else if (NumberToCheck & 0x7F || NumberToCheck = 0) {
		return MakeType(pState->i8, 0)
	}
}


define ASTNode* TranslateTokenToNode(ParserState* pState, Token* TokenToTranslate) {
	Type* ResultType := 0
	
	if (TokenToTranslate->Type = TOKEN_TYPE_INTEGER) {
		ResultType := GetNumberType(pState, TokenToTranslate->Value)
		
		return AllocateNewASTNode(NODE_TYPE_INTEGER, TokenToTranslate->Value, ResultType)
	}
	else if (TokenToTranslate->Type = TOKEN_TYPE_IDENTIFER) {
		VariableInfo* FoundVariable := FindVariable(pState, (TokenToTranslate->Value) As SafeWideString*)
		
		return AllocateNewASTNode(NODE_TYPE_VARIABLE, FoundVariable As void*, FoundVariable->Type)
	}
	
	Console:AWrite("Unknown fuck ")
	PrintToken(TokenToTranslate)
	Exit(1)
}

define ASTNode* ParseExpressionOperand(ParserState* pState) {
	Token* NextToken := CopyToken(ParserNextToken(pState))
	ASTNode* Result := 0
	
	if (NextToken->Type = TOKEN_TYPE_PUNCTUATION && NextToken->Value = PUNCTUATION_OPEN_PAREN) {
		Result := ParseExpression(pState, 0)
		
		if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
			TokenizerError(pState->pState, "Expected closing paren")
		}
	}
	else if (NextToken->Type = TOKEN_TYPE_IDENTIFER) {
		if (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)) {
			i8 ParameterIndex := 0
			ASTNode** Parameters := Alloc(8 * 10) As ASTNode**
			
			if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
				while (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA) || ParameterIndex = 0) {
					Parameters[ParameterIndex] := ParseExpression(pState, 0)
					ParameterIndex += 1
				}
				
				if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
					TokenizerError(pState->pState, "Expected closing paren for function call")
				}
			}
			
			Result := MakeCall(pState, (NextToken->Value) As SafeWideString*, Parameters, ParameterIndex)
		}
		else {
			Result := TranslateTokenToNode(pState, NextToken)
		}
	}
	else if (NextToken->Type = TOKEN_TYPE_INTEGER) {	
		Result := TranslateTokenToNode(pState, NextToken)
	}
	else if (NextToken->Type = TOKEN_TYPE_OPERATOR && IsPrefixOperator(NextToken)) {
		Result := ParseExpression(pState, GetPrefixPrecedence(NextToken))
		
		Result := MakeUnary(pState, NextToken, Result)
	}
	else {
		PrintToken(NextToken)
		TokenizerError(pState->pState, "Unexpected token in expression")
	}
	
	FreeToken(NextToken)
	
	return Result
}

define ASTNode* ParseExpression(ParserState* pState, i8 Precedence) {
	ASTNode* Result := ParseExpressionOperand(pState)
	
	i32 FrozenState := FreezeParser(pState)
	Token* OperatorToken := CopyToken(ParserNextToken(pState))
	
	while (OperatorToken->Type = TOKEN_TYPE_OPERATOR && GetPrecedence(OperatorToken) >= Precedence) {
		i8 NewPrecedence := GetPrecedence(OperatorToken)
		
		if (GetAssociation(OperatorToken) = LEFT_ASSOCIATIVE) {
			NewPrecedence += 1
		}
		
		ASTNode* Operand := 0
		
		if (OperatorToken->Value = OPERATOR_OPEN_BRACKET) {
			Operand := ParseExpression(pState, 0)
			
			Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected closing bracket for array access")
		}
		else if (OperatorToken->Value = OPERATOR_AS) {
			Operand := AllocateNewASTNode(NODE_TYPE_TYPE, ParseTypeName(pState) As void*, TYPE_NONE)
		}
		else {
			Operand := ParseExpression(pState, NewPrecedence)
		}
		
		Result := MakeBinary(pState, Result, OperatorToken, Operand)
		
		FrozenState := FreezeParser(pState)
		OperatorToken := CopyToken(ParserNextToken(pState))
	}
	
	PrintType(Result->ValueType)
	Console:WriteCharacter(' ')
	PrintAST(Result)
	Console:WriteNewLine()
	
	UnfreezeParser(pState, FrozenState)
	
	return Result
}

define void PrintAST(ASTNode* NodeToPrint) {
	i8 NodeType := NodeToPrint->NodeType
	
	if (NodeType = NODE_TYPE_UNARY) {
		UnaryExpression* UnaryNode := (NodeToPrint->TrueNode) As UnaryExpression*
		
		Console:WriteCharacter('(')
		
		PrintOperator(UnaryNode->Operator->Value)
		PrintAST(UnaryNode->Operand)
		
		Console:WriteCharacter(')')
	}
	else if (NodeType = NODE_TYPE_BINARY) {
		BinaryExpression* BinaryNode := (NodeToPrint->TrueNode) As BinaryExpression*
		
		Console:WriteCharacter('(')
		
		PrintAST(BinaryNode->Left)
		
		Console:WriteCharacter(' ')
		
		PrintOperator(BinaryNode->Operator->Value)
		
		Console:WriteCharacter(' ')
		
		PrintAST(BinaryNode->Right)
		
		Console:WriteCharacter(')')
	}
	else if (NodeType = NODE_TYPE_CALL) {
		CallExpression* CallNode := (NodeToPrint->TrueNode) As CallExpression*
		
		PrintSafeString(CallNode->TargetFunction->Name)
		
		Console:WriteCharacter('(')
		
		i32 ParameterIndex := 0
		
		loop (CallNode->ParameterCount) {
			ASTNode* NextCallParameter := (CallNode->Parameters)[ParameterIndex]
			
			PrintAST(NextCallParameter)
			
			ParameterIndex += 1
			
			if (ParameterIndex != CallNode->ParameterCount) {
				Console:WriteCharacter(',')
				Console:WriteCharacter(' ')
			}
		}
		
		Console:WriteCharacter(')')
	}
	else if (NodeType = NODE_TYPE_TOKEN) {
		Token* TokenNode := (NodeToPrint->TrueNode) As Token*
		
		if (TokenNode->Type = TOKEN_TYPE_IDENTIFER) {
			PrintSafeString((TokenNode->Value) As SafeWideString*)
		}
		else if (TokenNode->Type = TOKEN_TYPE_INTEGER) {
			Console:IWrite(TokenNode->Value)
		}
	}
	else if (NodeType = NODE_TYPE_DEFINE) {
		FunctionDefine* DefineNode := (NodeToPrint->TrueNode) As FunctionDefine*
		
		Console:AWrite("define ")
		PrintType(DefineNode->ReturnType)
		Console:WriteCharacter(' ')
		PrintSafeString(DefineNode->Name)
		Console:WriteCharacter('(')
		
		i32 ParameterIndex := 0
		
		loop (DefineNode->ParameterCount) {
			VariableInfo* NextDefineParameter := (DefineNode->Parameters)[ParameterIndex]
			
			PrintType(NextDefineParameter->Type)
			Console:WriteCharacter(' ')
			PrintSafeString(NextDefineParameter->Name)
			
			ParameterIndex += 1
			
			if (ParameterIndex != DefineNode->ParameterCount) {
				Console:WriteCharacter(',')
				Console:WriteCharacter(' ')
			}
		}
		
		Console:AWriteLine(") {")
		
		i32 StatementIndex := 0
		
		loop (DefineNode->Body->StatementCount) {
			ASTNode* BodyStatement := (DefineNode->Body->Statements)[StatementIndex]
			
			PrintAST(BodyStatement)
			
			StatementIndex += 1
		}
		
		Console:WriteCharacter('}')
		Console:WriteNewLine()
	}
	else if (NodeType = NODE_TYPE_RETURN) {
		ASTNode* ReturnExpression := (NodeToPrint->TrueNode) As ASTNode*
		
		Console:AWrite("return ")
		PrintAST(ReturnExpression)
		Console:WriteNewLine()
	}
	else if (NodeType = NODE_TYPE_EXPRESSION) {
		ASTNode* ExpressionStatement := (NodeToPrint->TrueNode) As ASTNode*
		
		PrintAST(ExpressionStatement)
		Console:WriteNewLine()
	}
	else if (NodeType = NODE_TYPE_VARIABLE) {
		VariableInfo* TargetVariable := (NodeToPrint->TrueNode) As VariableInfo*
		
		PrintSafeString(TargetVariable->Name)
	}
	else if (NodeType = NODE_TYPE_INTEGER) {
		Console:IWrite(NodeToPrint->TrueNode)
	}
	else if (NodeType = NODE_TYPE_TYPE) {
		PrintType((NodeToPrint->TrueNode) As Type*)
	}
}

/*
==========================================
	aaaaaaaaaaaaa
==========================================
*/


struct Label {
	i32 LabelNumber,
	i32 OffsetToReplace,
	i8 IsPlaceholder
}

struct CompilerState {
	i8* CodeBuffer,
	i32 CodeBufferSize,
	i32 Index,
	
	LabelPlaceholder** Labels,
	i32 LabelCount,
	i32 LabelBufferCapacity,
	
	i32 LabelIndex,
	i32 CurrentFunctionReturnLabel,
	i32 LastReturnOffset,
	
	i8 RegisterStackIndex
}

/*
==========================================
	aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
==========================================
*/

define void CompilerStart(FunctionDefine* StartFunction) {
	CompilerState C
	C.CodeBuffer := Alloc(100) As i8*
	C.CodeBufferSize := 100
	C.Index := 0
	
	C.Labels := Alloc(80) As Label**
	C.LabelCount := 0
	C.LabelBufferCapacity := 10
	
	C.LabelIndex := 0
	C.RegisterStackIndex := 0
	
	CompileFunction(&C, StartFunction)
}

define i8 PushRegisterStack(CompilerState* cState) {
	i8 Result := (cState->RegisterStackIndex) + 8
	
	cState->RegisterStackIndex += 1
	
	return Result
}
define i8 TopOfRegisterStack(CompilerState* cState) {
	return (cState->RegisterStackIndex) + 8
}

define i8 PopRegisterStack(CompilerState* cState) {
	cState->RegisterStackIndex -= 1
	
	return (cState->RegisterStackIndex) + 8
}

define void CompileFunction(CompilerState* cState, FunctionDefine* FunctionToCompile) {
	i32 ReturnLabel := NextLabel(cState)
	cState->CurrentFunctionReturnLabel := ReturnLabel
	
	i8 RegisterParameterCount := 4
	i16 StackParameterCount := 0
	
	if (FunctionToCompile->ParameterCount < 4) {
		RegisterParameterCount := (FunctionToCompile->ParameterCount) As i8
	}
	else if (FunctionToCompile->ParameterCount >= 5) {
		StackParameterCount := (FunctionToCompile->ParameterCount) - 4
		EmitMove_R64_R64(cState, RBX, RSP)
	}
	
	EmitEnter_I16(cState, (FunctionToCompile->LocalCount) * 8)
	
	for (i8 RegisterParameterIndex := 0, RegisterParameterIndex < RegisterParameterCount, RegisterParameterIndex += 1) {
		VariableInfo* NextParameter := (FunctionToCompile->Parameters)[RegisterParameterIndex]
		i8 NextParameterRegister := RegisterParameterIndex + 1
		
		if (NextParameterRegister > 2) {
			NextParameterRegister += 5
		}
		
		EmitMove_RX_DISP8_RX(cState, RBP, NextParameterRegister, -((NextParameter->ScopedID) * 8), NextParameter->Type->Size)
	}
	
	for (i16 StackParameterIndex := 0, StackParameterIndex < StackParameterCount, StackParameterIndex += 1) {
		VariableInfo* NextStackParameter := (FunctionToCompile->Parameters)[StackParameterIndex + 4]
		
		EmitMove_RX_RX_DISP8(cState, RAX, RBX, 0x28 + (StackParameterIndex * 8), NextStackParameter->Type->Size)
		EmitMove_RX_DISP8_RX(cState, RBP, RAX, -((NextStackParameter->ScopedID) * 8), NextStackParameter->Type->Size)
	}
	
	
	CompileBlock(cState, FunctionToCompile->Body)
	
	SetLabel(cState, ReturnLabel)
	ResolveAllLabels(cState)
	
	if (cState->LastReturnOffset = cState->Index) {
		cState->Index -= 5
	}
	
	EmitLeave(cState)
	EmitReturn(cState)
	
	PEBuilder* B := BuildBuilder()
	
	AddData(B, 0x149)
	
	AddImport(B, AToS("Kernel32"), AToS("ExitProcess"))
	AddImport(B, AToS("Kernel32"), AToS("LocalFree"))
	
	AddRelocation(B, 0x1000, 40, 1)
	
	AddCode(B, cState->CodeBuffer, 40)
	
	FinalizeBuilder(B)
	
	PrintBuilder(B)
	
	/*PrintCodeBytes(cState)*/
}
define void CompileBlock(CompilerState* cState, Block* BlockToCompile) {
	for (i32 Index := 0, Index < BlockToCompile->StatementCount, Index += 1) {
		ASTNode* NextStatement := (BlockToCompile->Statements)[Index]
		
		Compile(cState, NextStatement)
	}
}
define void CompileReturn(CompilerState* cState, ASTNode* ReturnExpression) {
	CompileExpression(cState, RAX, ReturnExpression)
	
	EmitJump_Label(cState, cState->CurrentFunctionReturnLabel)
	cState->LastReturnOffset := cState->Index
}
define void Compile(CompilerState* cState, ASTNode* NodeToCompile) {
	i8 NodeType := NodeToCompile->NodeType
	
	if (NodeType = NODE_TYPE_RETURN) {
		CompileReturn(cState, (NodeToCompile->TrueNode) As ASTNode*)
	}
	else if (NodeType = NODE_TYPE_EXPRESSION) {
		CompileExpression(cState, RAX, (NodeToCompile->TrueNode) As ASTNode*)
	}
}
define void CompileExpression(CompilerState* cState, i8 ResultRegister, ASTNode* ExpressionToCompile) {
	i8 ExpressionType := ExpressionToCompile->NodeType
	
	if (ExpressionType = NODE_TYPE_INTEGER) {
		EmitMove_RX_IX(cState, ResultRegister, (ExpressionToCompile->TrueNode) As i64, ExpressionToCompile->ValueType->Size)
	}
	else if (ExpressionType = NODE_TYPE_VARIABLE) {
		VariableInfo* TargetVariable := (ExpressionToCompile->TrueNode) As VariableInfo*
		
		EmitMove_RX_RX_DISP8(cState, ResultRegister, RBP, -((TargetVariable->ScopedID) * 8), TargetVariable->Type->Size)
	}
	else if (ExpressionType = NODE_TYPE_UNARY) {
	
	}
	else if (ExpressionType = NODE_TYPE_BINARY) {
		BinaryExpression* BinaryNode := (ExpressionToCompile->TrueNode) As BinaryExpression*
		Type* ResultType := ExpressionToCompile->ValueType
		
		CompileBinary(cState, ResultRegister, ResultType, BinaryNode)
	}

}
define void CompileBinary(CompilerState* cState, i8 ResultRegister, Type* ResultType, BinaryExpression* ExpressionToCompile) {
	ASTNode* Left := ExpressionToCompile->Left
	ASTNode* Right := ExpressionToCompile->Right
	
	i16 LeftSize := Left->ValueType->Size
	i16 RightSize := Right->ValueType->Size
	
	i8 LeftRegister := ResultRegister
	i8 RightRegister := 0
	
	if (ExpressionToCompile->Operator->Value != OPERATOR_COLON_EQUAL) {
		CompileExpression(cState, LeftRegister, Left)
		
		RightRegister := PushRegisterStack(cState)
	}
	else {
		RightRegister := ResultRegister
	}
	
	CompileExpression(cState, RightRegister, Right)
	
	if (LeftSize > RightSize) {
		EmitMove_R64_RX(cState, RightRegister, RightRegister, RightSize)
	}
	else if (RightSize > LeftSize) {
		EmitMove_R64_RX(cState, LeftRegister, LeftRegister, LeftSize)
	}
	
	CompileBinaryOperation(cState, ResultRegister, ResultType, ExpressionToCompile->Operator, Left)
}
define void CompileBinaryOperation(CompilerState* cState, i8 LeftRegister, Type* ResultType, Token* OperatorToCompile, ASTNode* Left) {
	i8 Operator := (OperatorToCompile->Value) As i8

	if (Operator = OPERATOR_PLUS) {
		EmitAdd_RX_RX(cState, LeftRegister, PopRegisterStack(cState), ResultType->Size)
	}
	else if (Operator = OPERATOR_MINUS) {
		EmitSub_RX_RX(cState, LeftRegister, PopRegisterStack(cState), ResultType->Size)
	}
	else if (Operator = OPERATOR_COLON_EQUAL) {
		VariableInfo* TargetVariable := (Left->TrueNode) As VariableInfo*
		
		EmitMove_RX_DISP8_RX(cState, RBP, LeftRegister, -((TargetVariable->ScopedID) * 8), TargetVariable->Type->Size)
		
		if (TargetVariable->Type->Size < ResultType->Size) {
			EmitMove_R64_RX(cState, LeftRegister, LeftRegister, ResultType->Size)
		}
	}



}

/*
==========================================
	Code printing helpers
==========================================
*/

define i8 NumberToHex(i8 Number) {
	if (Number <= 9) {
		Number := Number + '0'
	}
	else {
		Number := (Number - 10) + 'A'
	}
	
	return Number
}

define void PrintByteHex(i8 NumberToPrint) {
	i8 SecondCharacter := NumberToHex(NumberToPrint & 0x0F)
	
	i8 FirstCharacter := NumberToHex((NumberToPrint / 0x10) & 0x0F)
	
	Console:WriteCharacter(FirstCharacter)
	Console:WriteCharacter(SecondCharacter)
}

define void PrintCodeBytes(CompilerState* cState) {
	for (i32 Index := 0, Index < (cState->Index), Index += 1) {
		PrintByteHex((cState->CodeBuffer)[Index])
		Console:WriteCharacter(' ')
	}
}

/*
==========================================
	Label helpers
==========================================
*/

define i32 NextLabel(CompilerState* cState) {
	i32 Result := cState->LabelIndex
	cState->LabelIndex += 1
	return Result
}

define void EnsureLabelBufferCapacity(CompilerState* cState) {
	if (cState->LabelBufferCapacity <= (cState->LabelCount + 1)) {
		cState->Labels := ReAlloc((cState->Labels) As void*, (cState->LabelBufferCapacity + 10) * 8) As Label**
		cState->LabelBufferCapacity += 10
	}
}

define void UseLabel(CompilerState* cState, i32 LabelNumber) {
	EnsureLabelBufferCapacity(cState)
	
	Label* NewLabel := Alloc(Label.Size) As Label*
	
	NewLabel->LabelNumber := LabelNumber
	NewLabel->OffsetToReplace := cState->Index
	NewLabel->IsPlaceholder := true
	
	cState->Index += 4
	
	(cState->Labels)[cState->LabelCount] := NewLabel
	cState->LabelCount += 1
}

define Label* SetLabel(CompilerState* cState, i32 LabelNumber) {
	EnsureLabelBufferCapacity(cState)
	
	Label* NewLabel := Alloc(Label.Size) As Label*
	
	NewLabel->LabelNumber := LabelNumber
	NewLabel->OffsetToReplace := cState->Index
	NewLabel->IsPlaceholder := false
	
	(cState->Labels)[cState->LabelCount] := NewLabel
	cState->LabelCount += 1
	
	return NewLabel
}

define void ResolveAllLabels(CompilerState* cState) {
	for (i32 Index := 0, Index < cState->LabelCount, Index += 1) {
		Label* NextLabel := (cState->Labels)[Index]
		
		if !(NextLabel->IsPlaceholder) {
			ResolveLabel(cState, NextLabel->LabelNumber, NextLabel->OffsetToReplace)
		}
	}
}

define void ResolveLabel(CompilerState* cState, i32 LabelNumber, i32 Value) {
	for (i32 Index := 0, Index < cState->LabelCount, Index += 1) {
		Label* NextLabel := (cState->Labels)[Index]
		
		if (NextLabel->LabelNumber = LabelNumber && NextLabel->IsPlaceholder) {
			i32* ActualPlaceholder := ((cState->CodeBuffer) + (NextLabel->OffsetToReplace)) As i32*
			ActualPlaceholder[0] := Value - ((NextLabel->OffsetToReplace) + 4)
		}
	}
}

/*
==========================================
	Number writing helpers
==========================================
*/

define void* GetIndexAsPointer(CompilerState* cState) {
	return ((cState->CodeBuffer) + (cState->Index)) As void*
}

define void PushI8(CompilerState* cState, i8 NumberToPush) {
	(cState->CodeBuffer)[cState->Index] := NumberToPush
	cState->Index += 1
}
define void PushByte(CompilerState* cState, i8 NumberToPush) {
	PushI8(cState, NumberToPush)
}

define void PushI16(CompilerState* cState, i16 NumberToPush) {
	i16* PushLocation := GetIndexAsPointer(cState) As i16*
	PushLocation[0] := NumberToPush
	
	cState->Index += 2
}
define void PushI32(CompilerState* cState, i32 NumberToPush) {
	i32* PushLocation := GetIndexAsPointer(cState) As i32*
	PushLocation[0] := NumberToPush
	
	cState->Index += 4
}
define void PushI64(CompilerState* cState, i64 NumberToPush) {
	i64* PushLocation := GetIndexAsPointer(cState) As i64*
	PushLocation[0] := NumberToPush
	
	cState->Index += 8
}

/*
==========================================
	Register numbers/register helpers
==========================================
*/

define i8 RegisterRequiresREX(i8 RegisterNumber) {
	return RegisterNumber >= 8
}
define i8 ClampRegisterNumber(i8 RegisterNumber) {
	if (RegisterRequiresREX(RegisterNumber)) {
		return RegisterNumber - 8
	}
	
	return RegisterNumber
}

i8 REX_BASE := 0x40

i8 REX_W := 8
i8 REX_R := 4
i8 REX_X := 2
i8 REX_B := 1

i8 NO_REGISTER := 0
i8 RAX := 0
i8 RBX := 3
i8 RCX := 1
i8 RDX := 2
i8 RSP := 4
i8 RBP := 5
i8 RSI := 6
i8 RDI := 7
i8 R8 := 8
i8 R9 := 9
i8 R10 := 10
i8 R11 := 11
i8 R12 := 12
i8 R13 := 13
i8 R14 := 14
i8 R15 := 15

i8 MODE_PTOR := 0
i8 MODE_PTOR_DISP8 := 1

i8 MODE_RTOR := 3

/*
==========================================
	REX/ModRM/SIB helpers
==========================================
*/

define void EmitREX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 ExtraREX) {
	i8 Prefix := REX_BASE | ExtraREX
	
	if (RegisterRequiresREX(SourceRegister)) {
		Prefix := Prefix | REX_B
	}
	
	if (RegisterRequiresREX(DestinationRegister)) {
		Prefix := Prefix | REX_R
	}
	
	if !(Prefix = REX_BASE && ExtraREX = 0) {
		PushByte(cState, Prefix)
	}
}

define void EmitModRM(CompilerState* cState, i8 Mode, i8 DestinationRegister, i8 SourceRegister) {
	PushByte(cState, (Mode * 64) | (ClampRegisterNumber(DestinationRegister) * 8) | (ClampRegisterNumber(SourceRegister)))
}

define void EmitLegacySizePrefix(CompilerState* cState) {
	PushByte(cState, 0x66)
}

define void EmitREXOpcodeModRM(CompilerState* cState, i8 Opcode, i8 Mode, i8 DestinationRegister, i8 SourceRegister, i8 ExtraREX) {
	EmitREX(cState, DestinationRegister, SourceRegister, ExtraREX)
	PushByte(cState, Opcode)
	EmitModRM(cState, Mode, DestinationRegister, SourceRegister)
}
define void EmitREXBigOpcodeModRM(CompilerState* cState, i8 FirstOpcodeByte, i8 SecondOpcodeByte, i8 Mode, i8 DestinationRegister, i8 SourceRegister, i8 ExtraREX) {
	EmitREX(cState, DestinationRegister, SourceRegister, ExtraREX)
	PushByte(cState, FirstOpcodeByte)
	PushByte(cState, SecondOpcodeByte)
	EmitModRM(cState, Mode, DestinationRegister, SourceRegister)
}

/*
==========================================
	Jumps
==========================================
*/

define void EmitJump_Label(CompilerState* cState, i32 LabelNumber) {
	PushByte(cState, 0xE9)
	UseLabel(cState, LabelNumber)
}

/*
==========================================
	Moves
==========================================
*/


define void EmitZeroRegister(CompilerState* cState, i8 RegisterNumber) {
	if (RegisterRequiresREX(RegisterNumber)) {
		EmitREX(cState, NO_REGISTER, RegisterNumber, 0)
	}
	
	PushByte(cState, 0x33)
	EmitModRM(cState, MODE_RTOR, RegisterNumber, RegisterNumber)
}

define void EmitMove_RX_IX(CompilerState* cState, i8 RegisterNumber, i64 NumberToMove, i8 Size) {
	if (Size = 1) {
		EmitMove_R8_I8(cState, RegisterNumber, NumberToMove As i8)
	}
	else if (Size = 2) {
		EmitMove_R16_I16(cState, RegisterNumber, NumberToMove As i16)
	}
	else if (Size = 4) {
		EmitMove_R32_I32(cState, RegisterNumber, NumberToMove As i32)
	}
	else {
		EmitMove_R64_I64(cState, RegisterNumber, NumberToMove)
	}
}

define void EmitMove_R64_I64(CompilerState* cState, i8 RegisterNumber, i64 NumberToMove) {
	EmitREX(cState, NO_REGISTER, RegisterNumber, REX_W)
	PushByte(cState, 0xB8 + ClampRegisterNumber(RegisterNumber))
	PushI64(cState, NumberToMove)
}
define void EmitMove_R32_I32(CompilerState* cState, i8 RegisterNumber, i32 NumberToMove) {
	EmitREX(cState, NO_REGISTER, RegisterNumber, 0)
	PushByte(cState, 0xB8 + ClampRegisterNumber(RegisterNumber))
	PushI32(cState, NumberToMove)
}
define void EmitMove_R16_I16(CompilerState* cState, i8 RegisterNumber, i16 NumberToMove) {
	EmitLegacySizePrefix(cState)
	
	if (RegisterRequiresREX(RegisterNumber)) {
		EmitREX(cState, NO_REGISTER, RegisterNumber, 0)
	}
	
	PushByte(cState, 0xB8 + ClampRegisterNumber(RegisterNumber))
	PushI16(cState, NumberToMove)
}
define void EmitMove_R8_I8(CompilerState* cState, i8 RegisterNumber, i8 NumberToMove) {
	EmitREX(cState, NO_REGISTER, RegisterNumber, REX_BASE)
	PushByte(cState, 0xB0 + ClampRegisterNumber(RegisterNumber))
	PushI8(cState, NumberToMove)
}


define void EmitMove_RX_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitMove_R8_R8(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 2) {
		EmitMove_R16_R16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitMove_R32_R32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitMove_R64_R64(cState, DestinationRegister, SourceRegister)
	}
}
define void EmitMove_R8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x8A, MODE_RTOR, DestinationRegister, SourceRegister, REX_BASE)
}
define void EmitMove_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x8B, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitMove_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitMove_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}

define void EmitMove_R64_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitMove_R64_R8(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 2) {
		EmitMove_R64_R16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitMove_R64_R32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitMove_R64_R64(cState, DestinationRegister, SourceRegister)
	}
}

define void EmitMove_R64_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0xBE, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitMove_R64_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0xBF, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitMove_R64_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x63, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}

define void EmitMove_RX_RX_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement, i8 Size) {
	if (Size = 1) {
		EmitMove_R8_R8_DISP8(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 2) {
		EmitMove_R16_R16_DISP8(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 4) {
		EmitMove_R32_R32_DISP8(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else {
		EmitMove_R64_R64_DISP8(cState, DestinationRegister, SourceRegister, Displacement)
	}
}

define void EmitMove_R8_R8_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8A, MODE_PTOR_DISP8, DestinationRegister, SourceRegister, REX_BASE)
	PushByte(cState, Displacement)
}
define void EmitMove_R16_R16_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR_DISP8, DestinationRegister, SourceRegister, 0)
	PushByte(cState, Displacement)
}
define void EmitMove_R32_R32_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR_DISP8, DestinationRegister, SourceRegister, 0)
	PushByte(cState, Displacement)
}
define void EmitMove_R64_R64_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR_DISP8, DestinationRegister, SourceRegister, REX_W)
	PushByte(cState, Displacement)
}

define void EmitMove_RX_DISP8_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement, i8 Size) {
	if (Size = 1) {
		EmitMove_R8_DISP8_R8(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 2) {
		EmitMove_R16_DISP8_R16(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 4) {
		EmitMove_R32_DISP8_R32(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else {
		EmitMove_R64_DISP8_R64(cState, DestinationRegister, SourceRegister, Displacement)
	}
}

/* Flipped operands due to MR encoding */

define void EmitMove_R8_DISP8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x88, MODE_PTOR_DISP8, SourceRegister, DestinationRegister, REX_BASE)
	PushByte(cState, Displacement)
}
define void EmitMove_R16_DISP8_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x89, MODE_PTOR_DISP8, SourceRegister, DestinationRegister, 0)
	PushByte(cState, Displacement)
}
define void EmitMove_R32_DISP8_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x89, MODE_PTOR_DISP8, SourceRegister, DestinationRegister, 0)
	PushByte(cState, Displacement)
}
define void EmitMove_R64_DISP8_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x89, MODE_PTOR_DISP8, SourceRegister, DestinationRegister, REX_W)
	PushByte(cState, Displacement)
}

/*
==========================================
	Adds
==========================================
*/

define void EmitAdd_RX_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitAdd_R8_R8(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 2) {
		EmitAdd_R16_R16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitAdd_R32_R32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitAdd_R64_R64(cState, DestinationRegister, SourceRegister)
	}
}


define void EmitAdd_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x03, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitAdd_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x03, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitAdd_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x03, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitAdd_R8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x02, MODE_RTOR, DestinationRegister, SourceRegister, REX_BASE)
}

/*
==========================================
	Subs
==========================================
*/

define void EmitSub_RX_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitSub_R8_R8(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 2) {
		EmitSub_R16_R16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitSub_R32_R32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitSub_R64_R64(cState, DestinationRegister, SourceRegister)
	}
}

define void EmitSub_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x2B, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitSub_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x2B, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitSub_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x2B, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitSub_R8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x2A, MODE_RTOR, DestinationRegister, SourceRegister, REX_BASE)
}

/*
==========================================
	Push/Pop
==========================================
*/

define void EmitPush_R64(CompilerState* cState, i8 RegisterNumber) {
	EmitREX(cState, NO_REGISTER, RegisterNumber, 0)
	PushByte(cState, 0x50 + ClampRegisterNumber(RegisterNumber))
}
define void EmitPop_R64(CompilerState* cState, i8 RegisterNumber) {
	EmitREX(cState, NO_REGISTER, RegisterNumber, 0)
	PushByte(cState, 0x58 + ClampRegisterNumber(RegisterNumber))
}

/*
==========================================
	Functions
==========================================
*/

define void EmitEnter_I16(CompilerState* cState, i16 ReserveBytes) {
	PushByte(cState, 0xC8)
	PushI16(cState, ReserveBytes)
	PushByte(cState, 0)
}

define void EmitLeave(CompilerState* cState) {
	PushByte(cState, 0xC9)
}

define void EmitReturn(CompilerState* cState) {
	PushByte(cState, 0xC3)
}



/*
==========================================
	PE building structs
==========================================
*/

struct MZHeader {
	i8 MagicM,
	i8 MagicZ,
	i16 BytesInLastPage,
	i16 PageCount,
	i16 RelocationCount,
	
	i16 HeaderParagraphCount,
	i16 MinimumExtraParagraphCount,
	i16 MaximumExtraParagraphCount,
	i16 StartingSS,
	
	i16 StartingSP,
	i16 Checksum,
	i16 StartingIP,
	i16 StartingCS,
	
	i16 RelocationTableOffset,
	i16 OverlayNumber,
	i16 Padding1,
	i16 Padding2,
	
	i16 OEMID,
	i16 OEMInfo,
	i16 Padding3,
	i16 Padding4,
	
	i64 Padding5,
	
	i64 Padding6,
	
	i32 Padding7,
	i32 PEHeaderOffset
}

i16 MZ_HEADER_OFFSET := 0x00
i16 MZ_HEADER_SIZE := 0x40
i16 MZ_PADDING_SIZE := 0xB0

i16 PE_MAGIC_OFFSET := 0xF0
i16 PE_MAGIC_SIZE := 0x04

i16 COFF_HEADER_OFFSET := 0xF4
i16 COFF_HEADER_SIZE := 0x14

i16 PE_HEADER_OFFSET := 0x108
i16 PE_HEADER_SIZE := 0xF0

i16 SECTION_HEADER_SIZE := 0x28

define void WriteDOSHeader(void* IntoBuffer) {
	MZHeader* NewHeader := IntoBuffer As MZHeader*
	
	NewHeader->MagicM := 'M'
	NewHeader->MagicZ := 'Z'
	NewHeader->BytesInLastPage := 0x90
	NewHeader->PageCount := 3
	NewHeader->RelocationCount := 0
	NewHeader->HeaderParagraphCount := 4
	NewHeader->MinimumExtraParagraphCount := 0
	NewHeader->MaximumExtraParagraphCount := 0xFFFF As i16
	NewHeader->StartingSS := 0
	NewHeader->StartingSP := 0xB8
	NewHeader->Checksum := 0
	NewHeader->StartingIP := 0
	NewHeader->StartingCS := 0
	NewHeader->RelocationTableOffset := 0x40
	NewHeader->OverlayNumber := 0
	NewHeader->PEHeaderOffset := PE_MAGIC_OFFSET
	
	WriteDOSStub(IntoBuffer + MZ_HEADER_SIZE)
	
}

define void WriteDOSStub(void* IntoBuffer) {
	IntoBuffer[0] := 0xCD09B4000EBA1F0E
	
	/* Rewrite the first byte since the sign bit gets dropped at some point */
	(IntoBuffer As i8*)[0] := 0xCD
	
	IntoBuffer[1] := 0x685421CD4C01B821
	IntoBuffer[2] := 0x72676F7270207369
	IntoBuffer[3] := 0x6F6E6E6163206D61
	IntoBuffer[4] := 0x6E75722065622074
	IntoBuffer[5] := 0x20534F44206E6920
	IntoBuffer[6] := 0x0000242E65646F6D
}

struct COFFHeader {
	i16 MachineType,
	i16 NumberOfSections,
	i32 TimeDateStamp,
	
	i32 PointerToSymbolTable,
	i32 NumberOfSymbols,
	
	i16 SizeOfOptionalHeader,
	i16 Characteristics
}

struct PEHeader {
	i16 Magic,
	i8 MajorLinkerVersion,
	i8 MinorLinkerVersion,
	i32 SizeOfCode,
	
	i32 SizeOfInitializedData,
	i32 SizeOfUninitializedData,
	
	i32 AddressOfEntryPoint,
	i32 BaseOfCode,
	
	i64 ImageBase,
	
	i32 SectionAlignment,
	i32 FileAlignment,
	
	i16 MajorOSVersion,
	i16 MinorOSVersion,
	i16 MajorImageVersion,
	i16 MinorImageVersion,
	
	i16 MajorSubsystemVersion,
	i16 MinorSubsystemVersion,
	i32 Win32Version,
	
	i32 SizeOfImage,
	i32 SizeOfHeaders,
	
	i32 Checksum,
	i16 Subsystem,
	i16 DllCharacteristics,
	
	i64 SizeOfStackReserve,
	
	i64 SizeOfStackCommit,

	i64 SizeOfHeapReserve,

	i64 SizeOfHeapCommit,
	
	i32 LoaderFlags,
	i32 NumberOfDataDirectories,
	
	i32 ExportTableRVA,
	i32 ExportTableSize,
	
	i32 ImportTableRVA,
	i32 ImportTableSize,
	
	i32 ResourceTableRVA,
	i32 ResourceTableSize,
	
	i32 ExceptionTableRVA,
	i32 ExceptionTableSize,
	
	i32 CertificateTableRVA,
	i32 CertificateTableSize,
	
	i32 BaseRelocationTableRVA,
	i32 BaseRelocationTableSize,
	
	i32 DebugTableRVA,
	i32 DebugTableSize,
	
	i64 Architecture,
	
	i32 GlobalPointerRVA,
	i32 GlobalPointerSize,
	
	i32 TLSTableRVA,
	i32 TLSTableSize,
	
	i32 LoadConfigTableRVA,
	i32 LoadConfigTableSize,
	
	i32 BoundImportTableRVA,
	i32 BoundImportTableSize,
	
	i32 ImportAddressTableRVA,
	i32 ImportAddressTableSize,
	
	i32 DelayImportTableRVA,
	i32 DelayImportTableSize,
	
	i32 CLRRuntimeHeaderRVA,
	i32 CLRRuntimeHeaderSize,
	
	i64 Reserved
}

i32 MACHINE_AMD64 := 0x8664

i16 COFF_EXECUTABLE_IMAGE := 0x0002
i16 COFF_LARGE_ADDRESS_AWARE := 0x0020
i16 COFF_IMAGE_FILE_DLL := 0x2000

i16 PE32_PLUS_MAGIC := 0x020B

i64 DEFAULT_IMAGE_BASE := 0x40000000
i32 DEFAULT_SECTION_ALIGNMENT := 0x1000
i32 DEFAULT_FILE_ALIGNMENT := 0x0200

i16 DEFAULT_MAJOR_OS_VERSION := 6
i16 DEFAULT_MINOR_OS_VERSION := 0

i16 IMAGE_SUBSYSTEM_WINDOWS_CUI := 3

i16 DLL_DYNAMIC_BASE := 0x0040
i16 DLL_HIGH_ENTROPY_VA := 0x0020

i32 DEFAULT_RESERVE := 0x00100000
i32 DEFAULT_COMMIT := 0x8000

define void WritePEHeader(void* IntoBuffer) {
	i8* MagicString := (IntoBuffer + PE_MAGIC_OFFSET) As i8*
	
	MagicString[0] := 'P'
	MagicString[1] := 'E'
	
	COFFHeader* NewCOFF := (IntoBuffer + COFF_HEADER_OFFSET) As COFFHeader*
	
	NewCOFF->MachineType := MACHINE_AMD64 As i16
	NewCOFF->NumberOfSections := 4
	
	NewCOFF->SizeOfOptionalHeader := PE_HEADER_SIZE
	NewCOFF->Characteristics := (COFF_EXECUTABLE_IMAGE | COFF_LARGE_ADDRESS_AWARE)
	
	PEHeader* NewPE := (IntoBuffer + PE_HEADER_OFFSET) As PEHeader*
	
	NewPE->Magic := PE32_PLUS_MAGIC
	NewPE->ImageBase := DEFAULT_IMAGE_BASE
	NewPE->SectionAlignment := DEFAULT_SECTION_ALIGNMENT
	NewPE->FileAlignment := DEFAULT_FILE_ALIGNMENT
	
	NewPE->MajorOSVersion := DEFAULT_MAJOR_OS_VERSION
	NewPE->MinorOSVersion := DEFAULT_MINOR_OS_VERSION
	NewPE->MajorSubsystemVersion := DEFAULT_MAJOR_OS_VERSION
	NewPE->MinorSubsystemVersion := DEFAULT_MINOR_OS_VERSION
	
	NewPE->Subsystem := IMAGE_SUBSYSTEM_WINDOWS_CUI
	NewPE->DllCharacteristics := (DLL_DYNAMIC_BASE | DLL_HIGH_ENTROPY_VA)
	
	NewPE->SizeOfStackReserve := DEFAULT_RESERVE
	NewPE->SizeOfStackCommit := DEFAULT_COMMIT
	NewPE->SizeOfHeapReserve := DEFAULT_RESERVE
	NewPE->SizeOfHeapCommit := DEFAULT_COMMIT
	
	NewPE->NumberOfDataDirectories := 16
}

/*
==========================================
	Section building
==========================================
*/

i16 DATA_OFFSET := 0x1F8
i16 IDATA_OFFSET := 0x220
i16 RELOC_OFFSET := 0x248
i16 TEXT_OFFSET := 0x270

struct SectionHeader {
	i64 PackedName,
	
	i32 Size,
	i32 RVA,
	
	i32 RoundedSize,
	i32 DataOffset,
	
	i32 RelocationRVA,
	i32 LineNumbersRVA,
	
	i16 NumberOfRelocations,
	i16 NumberOfLineNumbers,
	i32 Characteristics
}

i64 SECTION_CODE := 0x00000020
i64 SECTION_INITIALIZED_DATA := 0x00000040
i64 SECTION_UNINITIALIZED_DATA := 0x00000080
i64 SECTION_DISCARDABLE := 0x02000000
i64 SECTION_EXECUTE := 0x20000000
i64 SECTION_READ := 0x40000000
i64 SECTION_WRITE := 0x80000000

define SectionHeader* WriteSectionHeader(void* IntoBuffer, i64 Name, i32 Characteristics) {
	SectionHeader* NewSection := IntoBuffer As SectionHeader*
	
	NewSection->PackedName := Name
	NewSection->Characteristics := Characteristics
	
	return NewSection
}

/*
==========================================
	Data directory building
==========================================
*/

struct ImportHelper {
	i16 ImportCount,
	i32* RVABuffer
}

struct ImportTableEntry {
	i32 LookupTableRVA,
	i32 TimeDateStamp,
	i32 ForwarderChain,
	i32 DllNameRVA,
	i32 ThunkTableRVA
}

struct RelocationHelper {
	i32 PageRVA,
	i32 EntryCount,
	i16* Entries
}

struct RelocationBlockHeader {
	i32 PageRVA,
	i32 BlockSize
}


/*
==========================================
	Actual building helpers/functions
==========================================
*/

struct PEBuilder {
	void* Buffer,
	MZHeader* MZ,
	COFFHeader* COFF,
	PEHeader* PE,
	
	SectionHeader* RelocHeader,
	SectionHeader* IDataHeader,
	SectionHeader* DataHeader,
	SectionHeader* TextHeader,
	
	i32 ImportFunctionCount,
	
	i32* ImportSourceNameRVAs,
	i32 ImportSourceCount,
	
	ImportHelper** ImportHelpers,
	
	i8* HintNameTable,
	i32 HintNameTableSize,
	
	RelocationHelper** RelocationPages,
	i32 RelocationPageCount,
	i32 RelocationCount,
	
	i32 NextRVA,
	i32 BufferSize
}

define i32 RoundTo(i32 Value, i32 BaseValue) {
	i32 Remainder := Value % BaseValue
	
	if (Remainder = 0) {
		return Value
	}
	
	return (Value - Remainder) + BaseValue
}

define void ExtendBuilder(PEBuilder* BuilderToReAlloc, i32 NewSize) {
	BuilderToReAlloc->Buffer := ReAlloc(BuilderToReAlloc->Buffer, NewSize)
	
	void* Buffer := (BuilderToReAlloc->Buffer)
	
	BuilderToReAlloc->MZ := (Buffer) As MZHeader*
	BuilderToReAlloc->COFF := (Buffer + COFF_HEADER_OFFSET) As COFFHeader*
	BuilderToReAlloc->PE := (Buffer + PE_HEADER_OFFSET) As PEHeader*
	
	BuilderToReAlloc->RelocHeader := (Buffer + RELOC_OFFSET) As SectionHeader*
	BuilderToReAlloc->IDataHeader := (Buffer + IDATA_OFFSET) As SectionHeader*
	BuilderToReAlloc->DataHeader := (Buffer + DATA_OFFSET) As SectionHeader*
	BuilderToReAlloc->TextHeader := (Buffer + TEXT_OFFSET) As SectionHeader*
	
	BuilderToReAlloc->BufferSize := NewSize
}

define void* AllocatePEBuffer() {
	return Alloc(MZ_HEADER_SIZE + MZ_PADDING_SIZE + PE_MAGIC_SIZE + COFF_HEADER_SIZE + PE_HEADER_SIZE + (SECTION_HEADER_SIZE * 4))
}

define PEBuilder* BuildBuilder() {
	PEBuilder* NewBuilder := Alloc(PEBuilder.Size) As PEBuilder*
	
	NewBuilder->Buffer := AllocatePEBuffer()
	
	WriteDOSHeader(NewBuilder->Buffer)
	WritePEHeader(NewBuilder->Buffer)
	
	NewBuilder->MZ := (NewBuilder->Buffer) As MZHeader*
	NewBuilder->COFF := ((NewBuilder->Buffer) + COFF_HEADER_OFFSET) As COFFHeader*
	NewBuilder->PE := ((NewBuilder->Buffer) + PE_HEADER_OFFSET) As PEHeader*
	
	void* Sections := NewBuilder->Buffer
	
	NewBuilder->RelocHeader := WriteSectionHeader(Sections + RELOC_OFFSET, 0x0000636F6C65722E, SECTION_READ | SECTION_INITIALIZED_DATA | SECTION_DISCARDABLE)
	NewBuilder->IDataHeader := WriteSectionHeader(Sections + IDATA_OFFSET, 0x000061746164692E, SECTION_READ | SECTION_INITIALIZED_DATA)
	NewBuilder->DataHeader := WriteSectionHeader(Sections + DATA_OFFSET, 0x000000617461642E, SECTION_READ | SECTION_WRITE | SECTION_UNINITIALIZED_DATA)
	NewBuilder->TextHeader := WriteSectionHeader(Sections + TEXT_OFFSET, 0x000000747865742E, SECTION_READ | SECTION_EXECUTE | SECTION_CODE)
	
	NewBuilder->BufferSize := MZ_HEADER_SIZE + MZ_PADDING_SIZE + PE_MAGIC_SIZE + COFF_HEADER_SIZE + PE_HEADER_SIZE + (SECTION_HEADER_SIZE * 4)
	NewBuilder->PE->SizeOfHeaders := RoundTo(NewBuilder->BufferSize, DEFAULT_FILE_ALIGNMENT)
	
	NewBuilder->NextRVA := DEFAULT_SECTION_ALIGNMENT
	
	NewBuilder->ImportSourceNameRVAs := Alloc(4) As i32*
	NewBuilder->ImportHelpers := Alloc(8) As ImportHelper**
	NewBuilder->HintNameTable := Alloc(8) As i8*
	NewBuilder->HintNameTableSize := 2
	
	NewBuilder->RelocationPages := Alloc(8) As RelocationHelper**
	NewBuilder->RelocationCount := 0
	
	return NewBuilder
}

define void PopulateSection(PEBuilder* ToBuilder, SectionHeader* TargetSection, i8* Data, i32 DataLength) {
	i32 FileOffset := RoundTo(ToBuilder->BufferSize, DEFAULT_FILE_ALIGNMENT)
	i32 NewSize := FileOffset + DataLength
	i32 RVA := ToBuilder->NextRVA
	
	TargetSection->Size := DataLength
	TargetSection->RVA := RVA
	TargetSection->RoundedSize := RoundTo(DataLength, DEFAULT_FILE_ALIGNMENT)
	TargetSection->DataOffset := FileOffset
	
	ExtendBuilder(ToBuilder, NewSize)
	
	i8* SectionBuffer := ((ToBuilder->Buffer) + FileOffset) As i8*
	
	for (i32 Index := 0, Index < DataLength, Index += 1) {
		SectionBuffer[Index] := Data[Index]
	}
	
	ToBuilder->NextRVA += (DataLength / DEFAULT_SECTION_ALIGNMENT) * DEFAULT_SECTION_ALIGNMENT
	
	if (DataLength % DEFAULT_SECTION_ALIGNMENT) {
		ToBuilder->NextRVA += DEFAULT_SECTION_ALIGNMENT
	}
}

/*
==========================================
	Section Building
==========================================
*/

define void AddData(PEBuilder* ToBuilder, i32 DataSize) {
	i32 DataRVA := (ToBuilder->NextRVA)
	
	ToBuilder->DataHeader->Size := DataSize
	ToBuilder->DataHeader->RVA := DataRVA
	ToBuilder->DataHeader->RoundedSize := 0
	ToBuilder->DataHeader->DataOffset := 0
	
	ToBuilder->NextRVA += (DataSize / DEFAULT_SECTION_ALIGNMENT) * DEFAULT_SECTION_ALIGNMENT
	
	if (DataSize % DEFAULT_SECTION_ALIGNMENT) {
		ToBuilder->NextRVA += DEFAULT_SECTION_ALIGNMENT
	}
}

define void AddCode(PEBuilder* ToBuilder, i8* CodeBytes, i32 CodeLength) {
	FinalizeImports(ToBuilder)
	FinalizeRelocations(ToBuilder)
	
	i32 RVA := ToBuilder->NextRVA
	
	PopulateSection(ToBuilder, ToBuilder->TextHeader, CodeBytes, CodeLength)
	
	ToBuilder->PE->SizeOfCode := CodeLength
	ToBuilder->PE->AddressOfEntryPoint := RVA
	ToBuilder->PE->BaseOfCode := RVA
}

define void AddRelocation(PEBuilder* ToBuilder, i32 PageRVA, i16 OffsetInPage, i8 Is64Bit) {
	ToBuilder->RelocationCount += 1
	
	for (i32 Index := 0, Index < (ToBuilder->RelocationPageCount), Index += 1) {
		RelocationHelper* NextPage := (ToBuilder->RelocationPages)[Index]
		
		if (NextPage->PageRVA = PageRVA) {
			return AddRelocationToHelper(NextPage, OffsetInPage, Is64Bit)
		}
	}
	
	RelocationHelper* NewHelper := Alloc(RelocationHelper.Size) As RelocationHelper*
	NewHelper->PageRVA := PageRVA
	NewHelper->Entries := Alloc(2) As i16*
	NewHelper->EntryCount
	
	ToBuilder->RelocationPages := ReAlloc((ToBuilder->RelocationPages) As void*, ((ToBuilder->RelocationPageCount) + 1) * 8) As RelocationHelper**
	(ToBuilder->RelocationPages)[ToBuilder->RelocationPageCount] := NewHelper
	ToBuilder->RelocationPageCount += 1
	
	AddRelocationToHelper(NewHelper, OffsetInPage, Is64Bit)
}

/*
==========================================
	Relocation helpers
==========================================
*/

i16 RELOCATION_HIGHLOW := 3 * 0x1000
i16 RELOCATION_DIR64 := 10 * 0x1000

define void AddRelocationToHelper(RelocationHelper* Helper, i16 OffsetInPage, i8 Is64Bit) {
	i32 Type := RELOCATION_HIGHLOW
	
	if (Is64Bit) {
		Type := RELOCATION_DIR64
	}
	
	Helper->Entries := ReAlloc((Helper->Entries) as void*, ((Helper->EntryCount) + 1) * 2) As i16*
	(Helper->Entries)[Helper->EntryCount] := Type + OffsetInPage
	Helper->EntryCount += 1
}

define void FinalizeRelocations(PEBuilder* TargetBuilder) {
	i32 PageHeadersSize := (TargetBuilder->RelocationPageCount) * RelocationBlockHeader.Size
	i32 PageEntriesSize := (TargetBuilder->RelocationCount) * 2
	
	i32 RelocationSectionSize := PageHeadersSize + PageEntriesSize
	
	void* Buffer := Alloc(RelocationSectionSize)
	i32 BufferIndex := 0
	
	for (i32 PageIndex := 0, PageIndex < (TargetBuilder->RelocationPageCount), PageIndex += 1) {
		RelocationBlockHeader* NextBlock := (Buffer + BufferIndex) As RelocationBlockHeader*
		BufferIndex += 8
		
		RelocationHelper* NextHelper := (TargetBuilder->RelocationPages)[PageIndex]
		
		NextBlock->PageRVA := NextHelper->PageRVA
		NextBlock->BlockSize := 8 + ((NextHelper->EntryCount) * 2)
		
		for (i32 EntryIndex := 0, EntryIndex < (NextHelper->EntryCount), EntryIndex += 1) {
			i16 NextEntry := (NextHelper->Entries)[EntryIndex]
			
			((Buffer + BufferIndex) As i16*)[0] := NextEntry
			BufferIndex += 2
		}
	}
	
	TargetBuilder->PE->BaseRelocationTableRVA := TargetBuilder->NextRVA
	TargetBuilder->PE->BaseRelocationTableSize := RelocationSectionSize
	
	PopulateSection(TargetBuilder, TargetBuilder->RelocHeader, Buffer As i8*, RelocationSectionSize)
}

/*
==========================================
	Import hint/name table helpers
==========================================
*/

define i32 AddHintNameTableEntry(PEBuilder* ToBuilder, SafeWideString* EntryText) {
	i32 Offset := ToBuilder->HintNameTableSize
	i32 NewSize := (ToBuilder->HintNameTableSize) + (EntryText->Length) + 2
	
	if (NewSize % 2) {
		NewSize += 1
	}
	
	ToBuilder->HintNameTable := ReAlloc((ToBuilder->HintNameTable) As void*, NewSize) As i8*
	ToBuilder->HintNameTableSize := NewSize
	
	for (i32 Index := 0, Index < (EntryText->Length), Index += 1) {
		(ToBuilder->HintNameTable)[Offset + Index] := (EntryText->Buffer)[Index] As i8
	}
	
	return Offset
}

i32 HINT_NAME_ENTRY_NOT_FOUND := 0x0FFFFFFF

define i32 FindHintNameTableEntry(PEBuilder* InBuilder, SafeWideString* EntryToFind) {
	i32 Run := 0
	
	for (i32 Index := 0, Index < (InBuilder->HintNameTableSize), Index += 1) {
		if ((InBuilder->HintNameTable)[Index] = (EntryToFind->Buffer)[Run]) {
			Run += 1
		}
		else {
			Run := 0
		}
		
		if (Run = (EntryToFind->Length)) {
			return (Index - Run) + 1
		}
	}
	
	return HINT_NAME_ENTRY_NOT_FOUND
}

/*
==========================================
	Higher-level import helpers 
==========================================
*/

define i32 FindOrAddImportDll(PEBuilder* ToBuilder, SafeWideString* DllName) {
	i32 FoundIndex := 0
	
	i32 TargetRVA := FindHintNameTableEntry(ToBuilder, DllName)
	
	if (TargetRVA = HINT_NAME_ENTRY_NOT_FOUND) {
		FoundIndex := ToBuilder->ImportSourceCount
		
		(ToBuilder->ImportSourceNameRVAs)[FoundIndex] := AddHintNameTableEntry(ToBuilder, DllName)
		
		ImportHelper* ThisDllHelper := Alloc(ImportHelper.Size) As ImportHelper*
		
		ToBuilder->ImportHelpers := ReAlloc((ToBuilder->ImportHelpers) As void*, (FoundIndex + 1) * 8) As ImportHelper**
		(ToBuilder->ImportHelpers)[FoundIndex] := ThisDllHelper
		
		ThisDllHelper->ImportCount := 0
		ThisDllHelper->RVABuffer := Alloc(4) As i32*
		
		ToBuilder->ImportFunctionCount += 1
		ToBuilder->ImportSourceCount += 1
		
		return FoundIndex
	}
	else {
		for (i32 Index := 0, Index < (ToBuilder->ImportSourceCount), Index += 1) {
			i32 FoundNameRVA := (ToBuilder->ImportSourceNameRVAs)[Index]
			
			if (FoundNameRVA = TargetRVA) {
				return Index
			}
		}
	}
}

define void AddImport(PEBuilder* ToBuilder, SafeWideString* ToDll, SafeWideString* FunctionName) {
	i32 EntryIndex := FindOrAddImportDll(ToBuilder, ToDll)
	
	ImportHelper* EntryHelper := (ToBuilder->ImportHelpers)[EntryIndex]
	
	EntryHelper->RVABuffer := ReAlloc((EntryHelper->RVABuffer) As void*, ((EntryHelper->ImportCount) + 1) * 4)
	
	(EntryHelper->RVABuffer)[EntryHelper->ImportCount] := AddHintNameTableEntry(ToBuilder, FunctionName)
	EntryHelper->ImportCount += 1
	
	ToBuilder->ImportFunctionCount += 1
}

/*
==========================================
	Actual idata section builder
==========================================
*/

define void FinalizeImports(PEBuilder* TargetBuilder) {
	i32 ImportSectionRVA := TargetBuilder->NextRVA
	
	i32 ImportLookupBase := ImportSectionRVA
	i32 ImportLookupSize := RoundTo(TargetBuilder->ImportFunctionCount, 2) * 16
	
	i32 ImportTableBase := ImportLookupBase + ImportLookupSize
	i32 ImportTableSize := RoundTo(((TargetBuilder->ImportSourceCount) + 1) * ImportTableEntry.Size, 16)
	
	i32 HintNameBase := ImportTableBase + ImportTableSize
	i32 HintNameSize := TargetBuilder->HintNameTableSize
	
	Console:IWrite(ImportTableSize)
	Console:WriteCharacter(':')
	Console:IWrite(ImportLookupSize)
	Console:WriteCharacter(':')
	Console:IWriteLine(HintNameSize)
	
	
	i32 ImportSectionSize := ImportTableSize + ImportLookupSize + HintNameSize
	
	TargetBuilder->PE->ImportTableRVA := ImportTableBase
	TargetBuilder->PE->ImportTableSize := ImportSectionSize
	
	TargetBuilder->PE->ImportAddressTableRVA := ImportLookupBase
	TargetBuilder->PE->ImportAddressTableSize := ((TargetBuilder->ImportFunctionCount) - (TargetBuilder->ImportSourceCount)) * 8
	
	
	void* ImportSectionBuffer := Alloc(ImportSectionSize)
	
	i64* ImportLookups := ImportSectionBuffer As i64*
	ImportTableEntry* ImportEntries := (ImportSectionBuffer + ImportLookupSize) As ImportTableEntry*
	i8* HintName := (ImportSectionBuffer + ImportLookupSize + ImportTableSize) As i8*
	
	i32 LookupIndex := 0
	i32 LookupMaxIndex := RoundTo(TargetBuilder->ImportFunctionCount, 2)
	
	for (i32 Index := 0, Index < (TargetBuilder->ImportSourceCount), Index += 1) {
		i32 NextEntryNameRVA := (TargetBuilder->ImportSourceNameRVAs)[Index]
		ImportHelper* NextHelper := (TargetBuilder->ImportHelpers)[Index]
		
		ImportTableEntry* NextEntry := (ImportEntries + (Index * ImportTableEntry.Size)) As ImportTableEntry*
		
		NextEntry->DllNameRVA := HintNameBase + NextEntryNameRVA
		NextEntry->LookupTableRVA := ImportLookupBase + (LookupIndex * 8)
		NextEntry->ThunkTableRVA := ImportLookupBase + (LookupIndex * 8) + (LookupMaxIndex * 8)
		
		for (i32 ImportIndex := 0, ImportIndex < (NextHelper->ImportCount), ImportIndex += 1) {
			i32 NextImportNameRVA := (NextHelper->RVABuffer)[ImportIndex]
			
			ImportLookups[LookupIndex] := (HintNameBase + NextImportNameRVA) - 2
			ImportLookups[LookupIndex + LookupMaxIndex] := (HintNameBase + NextImportNameRVA) - 2
			LookupIndex += 1
		}
		
		LookupIndex += 1
	}
	
	for (i32 CopyIndex := 0, CopyIndex < (TargetBuilder->HintNameTableSize), CopyIndex += 1) {
		Console:WriteCharacter((TargetBuilder->HintNameTable)[CopyIndex])
		HintName[CopyIndex] := (TargetBuilder->HintNameTable)[CopyIndex]
	}
	
	Console:WriteNewLine()
	
	PopulateSection(TargetBuilder, TargetBuilder->IDataHeader, ImportSectionBuffer As i8*, ImportSectionSize)
}

/*
==========================================
	Misc utility functions
==========================================
*/

define void FinalizeBuilder(PEBuilder* Builder) {
	i32 FileSize := RoundTo(Builder->BufferSize, DEFAULT_FILE_ALIGNMENT)
	
	ExtendBuilder(Builder, FileSize)
	
	Builder->PE->SizeOfImage := RoundTo(Builder->NextRVA, DEFAULT_SECTION_ALIGNMENT)
	Builder->PE->SizeOfInitializedData := (Builder->IDataHeader->Size) + (Builder->RelocHeader->Size) + (Builder->TextHeader->Size)
	Builder->PE->SizeOfUnInitializedData := (Builder->DataHeader->Size)
}

define void PrintBuilder(PEBuilder* Builder) {
	i8* BufferAsBytes := (Builder->Buffer) As i8*
	
	for (i32 Index := 0, Index < Builder->BufferSize, Index += 1) {
		PrintByteHex(BufferAsBytes[Index])
		Console:WriteCharacter(' ')
	}
}