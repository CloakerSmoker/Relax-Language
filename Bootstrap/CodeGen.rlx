/*
==========================================
	Code printing helpers
==========================================
*/

define void PrintByteHex(i8 NumberToPrint) {
	i8 SecondCharacter := NumberToHex(NumberToPrint & 0x0F)
	i8 FirstCharacter := NumberToHex((NumberToPrint / 0x10) & 0x0F)
	
	WriteCharacter(FirstCharacter)
	WriteCharacter(SecondCharacter)
}

define void PrintCodeBytes(CompilerState* cState) {
	for (i32 Index := 0, Index < (cState->Index), Index += 1) {
		PrintByteHex((cState->CodeBuffer)[Index])
		WriteCharacter(' ')
	}
}

/*
==========================================
	Label helpers
==========================================
*/

define i32 NextLabel(CompilerState* cState) {
	i32 Result := cState->LabelIndex
	cState->LabelIndex += 1
	return Result
}

define void EnsureLabelBufferCapacity(CompilerState* cState) {
	/* Ensures that cState can hold at least one more label in its label buffer */
	
	if (cState->LabelBufferCapacity <= (cState->LabelCount + 1)) {
		cState->Labels := ReAlloc((cState->Labels) As void*, (cState->LabelBufferCapacity + 10) * 8) As Label**
		cState->LabelBufferCapacity += 10
	}
}

define void UseLabel(CompilerState* cState, i32 LabelNumber) {
	/* Registers a label as being used, and writes a placeholder value into CodeBuffer for the label */
	
	EnsureLabelBufferCapacity(cState)
	
	Label* NewLabel := Alloc(Label.Size) As Label*
	
	NewLabel->LabelNumber := LabelNumber
	NewLabel->OffsetToReplace := cState->Index
	NewLabel->IsPlaceholder := true
	
	cState->Index += 4
	
	(cState->Labels)[cState->LabelCount] := NewLabel
	cState->LabelCount += 1
}

define Label* SetLabel(CompilerState* cState, i32 LabelNumber) {
	/* Creates a new label which points to the current cState->Index */
	
	EnsureLabelBufferCapacity(cState)
	
	Label* NewLabel := Alloc(Label.Size) As Label*
	
	NewLabel->LabelNumber := LabelNumber
	NewLabel->OffsetToReplace := cState->Index
	NewLabel->IsPlaceholder := false
	
	i32 Index := cState->LabelCount
	
	cState->LabelCount += 1
	(cState->Labels)[Index] := NewLabel
	
	return NewLabel
}

define void ResolveLabel(CompilerState* cState, i32 LabelNumber, i32 Value) {
	for (i32 Index := 0, Index < cState->LabelCount, Index += 1) {
		Label* NextLabel := (cState->Labels)[Index]
		
		if (NextLabel->LabelNumber = LabelNumber && NextLabel->IsPlaceholder) {
			i32* ActualPlaceholder := ((cState->CodeBuffer) + (NextLabel->OffsetToReplace)) As i32*
			ActualPlaceholder[0] := Value - ((NextLabel->OffsetToReplace) + 4)
		}
	}
}
define void ResolveAllLabels(CompilerState* cState) {
	/* Goes through each label which is not a placeholder, but actually points to an index */
	
	for (i32 Index := 0, Index < cState->LabelCount, Index += 1) {
		Label* NextLabel := (cState->Labels)[Index]
		
		if !(NextLabel->IsPlaceholder) {
			/* And resolves each use of the label to the offset */
			ResolveLabel(cState, NextLabel->LabelNumber, NextLabel->OffsetToReplace)
		}
	}
}

/*
==========================================
	Number writing helpers
==========================================
*/

define void* GetIndexAsPointer(CompilerState* cState) {
	/* Helper to get a pointer into cState->CodeBuffer */
	
	return ((cState->CodeBuffer) + (cState->Index)) As void*
}

/* Helpers which write a number into cState->CodeBuffer and increment cState->Index */

declare void EnsureCodeBufferSize(CompilerState*)

define void PushI8(CompilerState* cState, i8 NumberToPush) {
	EnsureCodeBufferSize(cState)
	
	(cState->CodeBuffer)[cState->Index] := NumberToPush
	cState->Index += 1
}
define void PushByte(CompilerState* cState, i8 NumberToPush) {
	/* Alternate name for PushI8 since I was too used to typing PushByte */
	
	PushI8(cState, NumberToPush)
}

define void PushI16(CompilerState* cState, i16 NumberToPush) {
	EnsureCodeBufferSize(cState)
	
	i16* PushLocation := GetIndexAsPointer(cState) As i16*
	PushLocation[0] := NumberToPush
	
	cState->Index += 2
}
define void PushI32(CompilerState* cState, i32 NumberToPush) {
	EnsureCodeBufferSize(cState)
	
	i32* PushLocation := GetIndexAsPointer(cState) As i32*
	PushLocation[0] := NumberToPush
	
	cState->Index += 4
}
define void PushI64(CompilerState* cState, i64 NumberToPush) {
	EnsureCodeBufferSize(cState)
	
	i64* PushLocation := GetIndexAsPointer(cState) As i64*
	PushLocation[0] := NumberToPush
	
	cState->Index += 8
}

/*
==========================================
	Register numbers/register helpers
==========================================
*/

/* Helpers to translate our R8-R15 into x64 R8-R15 */

define i8 RegisterRequiresREX(i8 RegisterNumber) {
	return RegisterNumber >= 8
}
define i8 ClampRegisterNumber(i8 RegisterNumber) {
	/* Takes a 0-15 register number and returns it as a 0-7 number (which might need a REX prefix) */
	
	if (RegisterRequiresREX(RegisterNumber)) {
		return RegisterNumber - 8 As i8
	}
	
	return RegisterNumber
}

/* Constants used while generating code */

i8 REX_BASE := 0x40

i8 REX_W := 8
i8 REX_R := 4
i8 REX_X := 2
i8 REX_B := 1

i8 NO_REGISTER := 0
i8 RAX := 0
i8 RBX := 3
i8 RCX := 1
i8 RDX := 2
i8 RSP := 4
i8 RBP := 5
i8 RSI := 6
i8 RDI := 7

/* Although R8-R15 actually have the same numbers of RAX-RDI, REX.B is encoded as bit 3 (which is removed and replaced with a REX prefix while actually encoding) */

i8 R8 := 8
i8 R9 := 9
i8 R10 := 10
i8 R11 := 11
i8 R12 := 12
i8 R13 := 13
i8 R14 := 14
i8 R15 := 15

i8 MODE_PTOR := 0
i8 MODE_PTOR_DISP8 := 1
i8 MODE_PTOR_DISP32 := 2

i8 MODE_RTOR := 3

/*
==========================================
	REX/ModRM/SIB helpers
==========================================
*/

define void EmitREX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 ExtraREX) {
	i8 Prefix := REX_BASE | ExtraREX
	
	if (RegisterRequiresREX(SourceRegister)) {
		Prefix := Prefix | REX_B
	}
	
	if (RegisterRequiresREX(DestinationRegister)) {
		Prefix := Prefix | REX_R
	}
	
	if !(Prefix = REX_BASE && ExtraREX = 0) {
		PushByte(cState, Prefix)
	}
}

define void EmitModRM(CompilerState* cState, i8 Mode, i8 DestinationRegister, i8 SourceRegister) {
	PushByte(cState, (Mode * 64) | (ClampRegisterNumber(DestinationRegister) * 8) | (ClampRegisterNumber(SourceRegister)))
}

define void EmitLegacySizePrefix(CompilerState* cState) {
	PushByte(cState, 0x66)
}

define void EmitREXOpcodeModRM(CompilerState* cState, i8 Opcode, i8 Mode, i8 DestinationRegister, i8 SourceRegister, i8 ExtraREX) {
	EmitREX(cState, DestinationRegister, SourceRegister, ExtraREX)
	PushByte(cState, Opcode)
	EmitModRM(cState, Mode, DestinationRegister, SourceRegister)
}
define void EmitREXBigOpcodeModRM(CompilerState* cState, i8 FirstOpcodeByte, i8 SecondOpcodeByte, i8 Mode, i8 DestinationRegister, i8 SourceRegister, i8 ExtraREX) {
	EmitREX(cState, DestinationRegister, SourceRegister, ExtraREX)
	PushByte(cState, FirstOpcodeByte)
	PushByte(cState, SecondOpcodeByte)
	EmitModRM(cState, Mode, DestinationRegister, SourceRegister)
}

define void EmitSIB(CompilerState* cState, i8 Scale, i8 IndexRegister, i8 BaseRegister) {
	i8 TrueScale := 0
	
	if (Scale = 2) {TrueScale := 1}
	else if (Scale = 4) {TrueScale := 2}
	else if (Scale = 8) {TrueScale := 3}
	
	PushByte(cState, (TrueScale * 64) | (IndexRegister * 8) | BaseRegister)
}

define void EmitREXOpcodeModRMSIB(CompilerState* cState, i8 Opcode, i8 Mode, i8 DestinationRegister, i8 Scale, i8 IndexRegister, i8 BaseRegister, i8 ExtraREX) {
	if (RegisterRequiresREX(IndexRegister)) {
		ExtraREX := ExtraREX | REX_X
	}
	
	EmitREX(cState, DestinationRegister, BaseRegister, ExtraREX)
	PushByte(cState, Opcode)
	EmitModRM(cState, Mode, DestinationRegister, 4)
	EmitSIB(cState, Scale, ClampRegisterNumber(IndexRegister), ClampRegisterNumber(BaseRegister))
}

/*
==========================================
	Jumps
==========================================
*/


define void EmitJump_RI64(CompilerState* cState, i8 Register) {
	EmitREXOpcodeModRM(cState, 0xFF, MODE_PTOR, 4, Register, 0)
}

define void EmitJump_Label(CompilerState* cState, i32 LabelNumber) {
	PushByte(cState, 0xE9)
	UseLabel(cState, LabelNumber)
}
define void EmitJEZ_Label(CompilerState* cState, i32 LabelNumber) {
	PushByte(cState, 0x0F)
	PushByte(cState, 0x84)
	UseLabel(cState, LabelNumber)
}
define void EmitJNZ_Label(CompilerState* cState, i32 LabelNumber) {
	PushByte(cState, 0x0F)
	PushByte(cState, 0x85)
	UseLabel(cState, LabelNumber)
}

/*
==========================================
	Moves
==========================================
*/


define void EmitZeroRegister(CompilerState* cState, i8 RegisterNumber) {
	if (RegisterRequiresREX(RegisterNumber)) {
		EmitREX(cState, NO_REGISTER, RegisterNumber, 0)
	}
	
	PushByte(cState, 0x33)
	EmitModRM(cState, MODE_RTOR, RegisterNumber, RegisterNumber)
}

define void EmitMove_R64_I64(CompilerState* cState, i8 RegisterNumber, i64 NumberToMove) {
	EmitREX(cState, NO_REGISTER, RegisterNumber, REX_W)
	PushByte(cState, 0xB8 + ClampRegisterNumber(RegisterNumber))
	PushI64(cState, NumberToMove)
}
define void EmitMove_R32_I32(CompilerState* cState, i8 RegisterNumber, i32 NumberToMove) {
	EmitREX(cState, NO_REGISTER, RegisterNumber, 0)
	PushByte(cState, 0xB8 + ClampRegisterNumber(RegisterNumber))
	PushI32(cState, NumberToMove)
}
define void EmitMove_R16_I16(CompilerState* cState, i8 RegisterNumber, i16 NumberToMove) {
	EmitLegacySizePrefix(cState)
	
	if (RegisterRequiresREX(RegisterNumber)) {
		EmitREX(cState, NO_REGISTER, RegisterNumber, 0)
	}
	
	PushByte(cState, 0xB8 + ClampRegisterNumber(RegisterNumber))
	PushI16(cState, NumberToMove)
}
define void EmitMove_R8_I8(CompilerState* cState, i8 RegisterNumber, i8 NumberToMove) {
	EmitREX(cState, NO_REGISTER, RegisterNumber, REX_BASE)
	PushByte(cState, 0xB0 + ClampRegisterNumber(RegisterNumber))
	PushI8(cState, NumberToMove)
}
define void EmitMove_RX_IX(CompilerState* cState, i8 RegisterNumber, i64 NumberToMove, i8 Size) {
	if (Size = 1) {EmitMove_R8_I8(cState, RegisterNumber, NumberToMove As i8)}
	else if (Size = 2) {EmitMove_R16_I16(cState, RegisterNumber, NumberToMove As i16)}
	else if (Size = 4) {EmitMove_R32_I32(cState, RegisterNumber, NumberToMove As i32)}
	else if (Size = 8) {EmitMove_R64_I64(cState, RegisterNumber, NumberToMove)}
}


define void EmitMove_R8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x8A, MODE_RTOR, DestinationRegister, SourceRegister, REX_BASE)
}
define void EmitMove_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x8B, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitMove_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitMove_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitMove_RX_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitMove_R8_R8(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 2) {
		EmitMove_R16_R16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitMove_R32_R32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitMove_R64_R64(cState, DestinationRegister, SourceRegister)
	}
}


define void EmitMove_R64_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0xBE, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitMove_R64_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0xBF, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitMove_R64_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x63, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitMove_R64_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitMove_R64_R8(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 2) {
		EmitMove_R64_R16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitMove_R64_R32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitMove_R64_R64(cState, DestinationRegister, SourceRegister)
	}
}


define void EmitMove_R8_RI8_DISP32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8A, MODE_PTOR_DISP32, DestinationRegister, SourceRegister, REX_BASE)
	PushI32(cState, Displacement)
}
define void EmitMove_R16_RI16_DISP32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR_DISP32, DestinationRegister, SourceRegister, 0)
	PushI32(cState, Displacement)
}
define void EmitMove_R32_RI32_DISP32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR_DISP32, DestinationRegister, SourceRegister, 0)
	PushI32(cState, Displacement)
}
define void EmitMove_R64_RI64_DISP32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR_DISP32, DestinationRegister, SourceRegister, REX_W)
	PushI32(cState, Displacement)
}
define void EmitMove_RX_RIX_DISP32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement, i8 Size) {
	if (Size = 1) {
		EmitMove_R8_RI8_DISP32(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 2) {
		EmitMove_R16_RI16_DISP32(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 4) {
		EmitMove_R32_RI32_DISP32(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else {
		EmitMove_R64_RI64_DISP32(cState, DestinationRegister, SourceRegister, Displacement)
	}
}


define void EmitMove_R8_RI8_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8A, MODE_PTOR_DISP8, DestinationRegister, SourceRegister, REX_BASE)
	PushByte(cState, Displacement)
}
define void EmitMove_R16_RI16_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR_DISP8, DestinationRegister, SourceRegister, 0)
	PushByte(cState, Displacement)
}
define void EmitMove_R32_RI32_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR_DISP8, DestinationRegister, SourceRegister, 0)
	PushByte(cState, Displacement)
}
define void EmitMove_R64_RI64_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR_DISP8, DestinationRegister, SourceRegister, REX_W)
	PushByte(cState, Displacement)
}
define void EmitMove_RX_RIX_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement, i8 Size) {
	if (Size = 1) {
		EmitMove_R8_RI8_DISP8(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 2) {
		EmitMove_R16_RI16_DISP8(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 4) {
		EmitMove_R32_RI32_DISP8(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else {
		EmitMove_R64_RI64_DISP8(cState, DestinationRegister, SourceRegister, Displacement)
	}
}

/* Move [register + displacement], register */

/* Flipped operands due to MR encoding */

define void EmitMove_RI8_DISP32_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x88, MODE_PTOR_DISP32, SourceRegister, DestinationRegister, REX_BASE)
	PushI32(cState, Displacement)
}
define void EmitMove_RI16_DISP32_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x89, MODE_PTOR_DISP32, SourceRegister, DestinationRegister, 0)
	PushI32(cState, Displacement)
}
define void EmitMove_RI32_DISP32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x89, MODE_PTOR_DISP32, SourceRegister, DestinationRegister, 0)
	PushI32(cState, Displacement)
}
define void EmitMove_RI64_DISP32_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x89, MODE_PTOR_DISP32, SourceRegister, DestinationRegister, REX_W)
	PushI32(cState, Displacement)
}
define void EmitMove_RIX_DISP32_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement, i8 Size) {
	if (Size = 1) {
		EmitMove_RI8_DISP32_R8(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 2) {
		EmitMove_RI16_DISP32_R16(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 4) {
		EmitMove_RI32_DISP32_R32(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else {
		EmitMove_RI64_DISP32_R64(cState, DestinationRegister, SourceRegister, Displacement)
	}
}

/* Flipped operands due to MR encoding */

define void EmitMove_RI8_DISP8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x88, MODE_PTOR_DISP8, SourceRegister, DestinationRegister, REX_BASE)
	PushByte(cState, Displacement)
}
define void EmitMove_RI16_DISP8_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x89, MODE_PTOR_DISP8, SourceRegister, DestinationRegister, 0)
	PushByte(cState, Displacement)
}
define void EmitMove_RI32_DISP8_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x89, MODE_PTOR_DISP8, SourceRegister, DestinationRegister, 0)
	PushByte(cState, Displacement)
}
define void EmitMove_RI64_DISP8_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement) {
	EmitREXOpcodeModRM(cState, 0x89, MODE_PTOR_DISP8, SourceRegister, DestinationRegister, REX_W)
	PushByte(cState, Displacement)
}
define void EmitMove_RIX_DISP8_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Displacement, i8 Size) {
	if (Size = 1) {
		EmitMove_RI8_DISP8_R8(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 2) {
		EmitMove_RI16_DISP8_R16(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else if (Size = 4) {
		EmitMove_RI32_DISP8_R32(cState, DestinationRegister, SourceRegister, Displacement)
	}
	else {
		EmitMove_RI64_DISP8_R64(cState, DestinationRegister, SourceRegister, Displacement)
	}
}


define void EmitMove_RIX_DISPX_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement, i8 Size) {
	i8 DisplacementSize := GetNumberSize(Displacement As i64)
	
	if (DisplacementSize > 1) {
		EmitMove_RIX_DISP32_RX(cState, DestinationRegister, SourceRegister, Displacement As i32, Size)
	}
	else {
		EmitMove_RIX_DISP8_RX(cState, DestinationRegister, SourceRegister, Displacement As i8, Size)
	}
}


define void EmitMove_R8_SIB(CompilerState* cState, i8 DestinationRegister, i8 IndexRegister, i8 BaseRegister) {
	EmitREXOpcodeModRMSIB(cState, 0x8A, MODE_PTOR, DestinationRegister, 1, IndexRegister, BaseRegister, REX_BASE)
}
define void EmitMove_R16_SIB(CompilerState* cState, i8 DestinationRegister, i8 IndexRegister, i8 BaseRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRMSIB(cState, 0x8B, MODE_PTOR, DestinationRegister, 2, IndexRegister, BaseRegister, 0)
}
define void EmitMove_R32_SIB(CompilerState* cState, i8 DestinationRegister, i8 IndexRegister, i8 BaseRegister) {
	EmitREXOpcodeModRMSIB(cState, 0x8B, MODE_PTOR, DestinationRegister, 4, IndexRegister, BaseRegister, 0)
}
define void EmitMove_R64_SIB(CompilerState* cState, i8 DestinationRegister, i8 IndexRegister, i8 BaseRegister) {
	EmitREXOpcodeModRMSIB(cState, 0x8B, MODE_PTOR, DestinationRegister, 8, IndexRegister, BaseRegister, REX_W)
}

define void EmitMove_RX_SIB(CompilerState* cState, i8 DestinationRegister, i8 Scale, i8 IndexRegister, i8 BaseRegister) {
	if (Scale = 1) {EmitMove_R8_SIB(cState, DestinationRegister, IndexRegister, BaseRegister)}
	else if (Scale = 2) {EmitMove_R16_SIB(cState, DestinationRegister, IndexRegister, BaseRegister)}
	else if (Scale = 4) {EmitMove_R32_SIB(cState, DestinationRegister, IndexRegister, BaseRegister)}
	else if (Scale = 8) {EmitMove_R64_SIB(cState, DestinationRegister, IndexRegister, BaseRegister)}
}

/*
==========================================
	Deref moves
==========================================
*/

define void EmitMove_R8_RI8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x8A, MODE_PTOR, DestinationRegister, SourceRegister, REX_BASE)
}
define void EmitMove_R16_RI16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitMove_R32_RI32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitMove_R64_RI64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x8B, MODE_PTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitMove_RX_RIX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitMove_R8_RI8(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 2) {
		EmitMove_R16_RI16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitMove_R32_RI32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitMove_R64_RI64(cState, DestinationRegister, SourceRegister)
	}
}

/*
==========================================
	Lea
==========================================
*/

define void EmitLea_R64_R64_DISP8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8D, MODE_PTOR_DISP8, DestinationRegister, SourceRegister, REX_W)
	PushByte(cState, Displacement)
}
define void EmitLea_R64_R64_DISP32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	EmitREXOpcodeModRM(cState, 0x8D, MODE_PTOR_DISP32, DestinationRegister, SourceRegister, REX_W)
	PushI32(cState, Displacement)
}
define void EmitLea_R64_R64_DISPX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i32 Displacement) {
	i8 Size := GetNumberSize(Displacement)
	
	if (Size = 1) {
		EmitLea_R64_R64_DISP8(cState, DestinationRegister, SourceRegister, Displacement As i8)
	}
	else {
		EmitLea_R64_R64_DISP32(cState, DestinationRegister, SourceRegister, Displacement)
	}
}

define void EmitLea_R64_SIB(CompilerState* cState, i8 DestinationRegister, i8 Scale, i8 IndexRegister, i8 BaseRegister) {
	EmitREXOpcodeModRMSIB(cState, 0x8D, MODE_PTOR, DestinationRegister, Scale, IndexRegister, BaseRegister, REX_W)
}

/*
==========================================
	Adds
==========================================
*/

define void EmitAdd_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x03, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitAdd_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x03, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitAdd_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x03, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitAdd_R8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x02, MODE_RTOR, DestinationRegister, SourceRegister, REX_BASE)
}
define void EmitAdd_RX_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitAdd_R8_R8(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 2) {
		EmitAdd_R16_R16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitAdd_R32_R32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitAdd_R64_R64(cState, DestinationRegister, SourceRegister)
	}
}

define void EmitAdd_R64_I8(CompilerState* cState, i8 TargetRegister, i8 Number) {
	EmitREXOpcodeModRM(cState, 0x83, MODE_RTOR, 0, TargetRegister, REX_W)
	PushByte(cState, Number)
}
define void EmitAdd_R64_I32(CompilerState* cState, i8 TargetRegister, i32 Number) {
	EmitREXOpcodeModRM(cState, 0x81, MODE_RTOR, 0, TargetRegister, REX_W)
	PushI32(cState, Number)
}
define void EmitAdd_R64_IX(CompilerState* cState, i8 TargetRegister, i32 Number) {
	i8 Size := GetNumberSize(Number)
	
	if (Size = 1) {EmitAdd_R64_I8(cState, TargetRegister, Number As i8)}
	else if (Size <= 4) {EmitAdd_R64_I32(cState, TargetRegister, Number)}
}

/*
==========================================
	Subs
==========================================
*/

define void EmitSub_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x2B, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitSub_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x2B, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitSub_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x2B, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitSub_R8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x2A, MODE_RTOR, DestinationRegister, SourceRegister, REX_BASE)
}
define void EmitSub_RX_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitSub_R8_R8(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 2) {
		EmitSub_R16_R16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitSub_R32_R32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitSub_R64_R64(cState, DestinationRegister, SourceRegister)
	}
}


define void EmitSub_R64_I8(CompilerState* cState, i8 TargetRegister, i8 Number) {
	EmitREXOpcodeModRM(cState, 0x83, MODE_RTOR, 5, TargetRegister, REX_W)
	PushByte(cState, Number)
}
define void EmitSub_R64_I32(CompilerState* cState, i8 TargetRegister, i32 Number) {
	EmitREXOpcodeModRM(cState, 0x81, MODE_RTOR, 5, TargetRegister, REX_W)
	PushI32(cState, Number)
}
define void EmitSub_R64_IX(CompilerState* cState, i8 TargetRegister, i32 Number) {
	i8 Size := GetNumberSize(Number)
	
	if (Size = 1) {EmitSub_R64_I8(cState, TargetRegister, Number As i8)}
	else if (Size <= 4) {EmitSub_R64_I32(cState, TargetRegister, Number)}
}


define void EmitNeg_R8(CompilerState* cState, i8 TargetRegister) {
	EmitREXOpcodeModRM(cState, 0xF6, MODE_RTOR, 3, TargetRegister, REX_BASE)
}
define void EmitNeg_R16(CompilerState* cState, i8 TargetRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0xF7, MODE_RTOR, 3, TargetRegister, 0)
}
define void EmitNeg_R32(CompilerState* cState, i8 TargetRegister) {
	EmitREXOpcodeModRM(cState, 0xF7, MODE_RTOR, 3, TargetRegister, 0)
}
define void EmitNeg_R64(CompilerState* cState, i8 TargetRegister) {
	EmitREXOpcodeModRM(cState, 0xF7, MODE_RTOR, 3, TargetRegister, REX_W)
}
define void EmitNeg_RX(CompilerState* cState, i8 TargetRegister, i8 Size) {
	if (Size = 1) {EmitNeg_R8(cState, TargetRegister)}
	else if (Size = 2) {EmitNeg_R16(cState, TargetRegister)}
	else if (Size = 4) {EmitNeg_R32(cState, TargetRegister)}
	else if (Size = 8) {EmitNeg_R64(cState, TargetRegister)}
}
/*
==========================================
	Mul/div
==========================================
*/

define void EmitIMul_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0xAF, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitIMul_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0xAF, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitIMul_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXBigOpcodeModRM(cState, 0x0F, 0xAF, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitIMul_RX_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		AWriteLine("Bad size passed to EmitIMul_RX_RX")
	}
	else if (Size = 2) {
		EmitIMul_R16_R16(cState, DestinationRegister, SourceRegister)
	}
	else if (Size = 4) {
		EmitIMul_R32_R32(cState, DestinationRegister, SourceRegister)
	}
	else {
		EmitIMul_R64_R64(cState, DestinationRegister, SourceRegister)
	}
}


define void EmitIMul_AL_R8(CompilerState* cState, i8 SourceRegister) {
	/* Opcode entension 5 */
	
	EmitREXOpcodeModRM(cState, 0x2A, MODE_RTOR, 5, SourceRegister, 0)
}


define void EmitCWD(CompilerState* cState) {
	EmitLegacySizePrefix(cState)
	PushByte(cState, 0x99)
}
define void EmitCDQ(CompilerState* cState) {
	PushByte(cState, 0x99)
}
define void EmitCQO(CompilerState* cState) {
	PushByte(cState, REX_BASE | REX_W)
	PushByte(cState, 0x99)
}
define void EmitCXX(CompilerState* cState, i8 Size) {
	if (Size = 1) {AWriteLine("Bad size passed to EmitCXX")}
	else if (Size = 2) {EmitCWD(cState)}
	else if (Size = 4) {EmitCDQ(cState)}
	else if (Size = 8) {EmitCQO(cState)}
}


define void EmitIDiv_RAX_R16(CompilerState* cState, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0xF7, MODE_RTOR, 7, SourceRegister, 0)
}
define void EmitIDiv_RAX_R32(CompilerState* cState, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0xF7, MODE_RTOR, 7, SourceRegister, 0)
}
define void EmitIDiv_RAX_R64(CompilerState* cState, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0xF7, MODE_RTOR, 7, SourceRegister, REX_W)
}
define void EmitIDiv_RAX_RX(CompilerState* cState, i8 SourceRegister, i8 Size) {
	if (Size = 1) {AWriteLine("Bad size passed to EmitIDiv_RAX_RX")}
	else if (Size = 2) {EmitIDiv_RAX_R16(cState, SourceRegister)}
	else if (Size = 4) {EmitIDiv_RAX_R32(cState, SourceRegister)}
	else if (Size = 8) {EmitIDiv_RAX_R64(cState, SourceRegister)}
}

/*
==========================================
	Push/Pop
==========================================
*/

define void EmitPush_R64(CompilerState* cState, i8 RegisterNumber) {
	EmitREX(cState, NO_REGISTER, RegisterNumber, 0)
	PushByte(cState, 0x50 + ClampRegisterNumber(RegisterNumber))
}
define void EmitPop_R64(CompilerState* cState, i8 RegisterNumber) {
	EmitREX(cState, NO_REGISTER, RegisterNumber, 0)
	PushByte(cState, 0x58 + ClampRegisterNumber(RegisterNumber))
}

/*
==========================================
	Functions
==========================================
*/

define void EmitEnter_I16(CompilerState* cState, i16 ReserveBytes) {
	PushByte(cState, 0xC8)
	PushI16(cState, ReserveBytes)
	PushByte(cState, 0)
}

define void EmitLeave(CompilerState* cState) {
	PushByte(cState, 0xC9)
}

define void EmitReturn(CompilerState* cState) {
	PushByte(cState, 0xC3)
}

define void EmitCall_Label(CompilerState* cState, i32 LabelNumber) {
	PushByte(cState, 0xE8)
	UseLabel(cState, LabelNumber)
}

/*
==========================================
	Logic
==========================================
*/

define void EmitTest_R8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x84, MODE_RTOR, DestinationRegister, SourceRegister, REX_BASE)
}
define void EmitTest_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x85, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitTest_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x85, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitTest_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x85, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitTest_RX_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitTest_R8_R8(cState, SourceRegister, DestinationRegister)
	}
	else if (Size = 2) {
		EmitTest_R16_R16(cState, SourceRegister, DestinationRegister)
	}
	else if (Size = 4) {
		EmitTest_R32_R32(cState, SourceRegister, DestinationRegister)
	}
	else {
		EmitTest_R64_R64(cState, SourceRegister, DestinationRegister)
	}
}


define void EmitCmp_R8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x38, MODE_RTOR, DestinationRegister, SourceRegister, REX_BASE)
}
define void EmitCmp_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x39, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitCmp_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x39, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitCmp_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x39, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitCmp_RX_RX(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister, i8 Size) {
	if (Size = 1) {
		EmitCmp_R8_R8(cState, SourceRegister, DestinationRegister)
	}
	else if (Size = 2) {
		EmitCmp_R16_R16(cState, SourceRegister, DestinationRegister)
	}
	else if (Size = 4) {
		EmitCmp_R32_R32(cState, SourceRegister, DestinationRegister)
	}
	else {
		EmitCmp_R64_R64(cState, SourceRegister, DestinationRegister)
	}
}

/*
==========================================
	Specific Logic
==========================================
*/

/* Flipped operands due to MR encoding */
define void EmitAnd_R8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x20, MODE_RTOR, DestinationRegister, SourceRegister, REX_BASE)
}
define void EmitAnd_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x21, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitAnd_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x21, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitAnd_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x21, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitAnd_RX_RX(CompilerState* cState, i8 SourceRegister, i8 DestinationRegister, i8 Size) {
	if (Size = 1) {EmitAnd_R8_R8(cState, DestinationRegister, SourceRegister)}
	else if (Size = 2) {EmitAnd_R16_R16(cState, DestinationRegister, SourceRegister)}
	else if (Size = 4) {EmitAnd_R32_R32(cState, DestinationRegister, SourceRegister)}
	else if (Size = 8) {EmitAnd_R64_R64(cState, DestinationRegister, SourceRegister)}
}


define void EmitOr_R8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x08, MODE_RTOR, DestinationRegister, SourceRegister, REX_BASE)
}
define void EmitOr_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x09, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitOr_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x09, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitOr_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x09, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitOr_RX_RX(CompilerState* cState, i8 SourceRegister, i8 DestinationRegister, i8 Size) {
	if (Size = 1) {EmitOr_R8_R8(cState, DestinationRegister, SourceRegister)}
	else if (Size = 2) {EmitOr_R16_R16(cState, DestinationRegister, SourceRegister)}
	else if (Size = 4) {EmitOr_R32_R32(cState, DestinationRegister, SourceRegister)}
	else if (Size = 8) {EmitOr_R64_R64(cState, DestinationRegister, SourceRegister)}
}


define void EmitXor_R8_R8(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x30, MODE_RTOR, DestinationRegister, SourceRegister, REX_BASE)
}
define void EmitXor_R16_R16(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitLegacySizePrefix(cState)
	EmitREXOpcodeModRM(cState, 0x31, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitXor_R32_R32(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x31, MODE_RTOR, DestinationRegister, SourceRegister, 0)
}
define void EmitXor_R64_R64(CompilerState* cState, i8 DestinationRegister, i8 SourceRegister) {
	EmitREXOpcodeModRM(cState, 0x31, MODE_RTOR, DestinationRegister, SourceRegister, REX_W)
}
define void EmitXor_RX_RX(CompilerState* cState, i8 SourceRegister, i8 DestinationRegister, i8 Size) {
	if (Size = 1) {EmitXor_R8_R8(cState, DestinationRegister, SourceRegister)}
	else if (Size = 2) {EmitXor_R16_R16(cState, DestinationRegister, SourceRegister)}
	else if (Size = 4) {EmitXor_R32_R32(cState, DestinationRegister, SourceRegister)}
	else if (Size = 8) {EmitXor_R64_R64(cState, DestinationRegister, SourceRegister)}
}

define void R8NeedsREX(i8 RegisterNumber) {
	if (4 <= RegisterNumber && RegisterNumber <= 7) {
		return REX_BASE
	}
	
	return 0
}

define void EmitSetE_R8(CompilerState* cState, i8 DestinationRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0x94, MODE_RTOR, NO_REGISTER, DestinationRegister, R8NeedsREX(DestinationRegister))
}
define void EmitSetNE_R8(CompilerState* cState, i8 DestinationRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0x95, MODE_RTOR, NO_REGISTER, DestinationRegister, R8NeedsREX(DestinationRegister))
}
define void EmitSetL_R8(CompilerState* cState, i8 DestinationRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0x9C, MODE_RTOR, NO_REGISTER, DestinationRegister, R8NeedsREX(DestinationRegister))
}
define void EmitSetLE_R8(CompilerState* cState, i8 DestinationRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0x9E, MODE_RTOR, NO_REGISTER, DestinationRegister, R8NeedsREX(DestinationRegister))
}
define void EmitSetG_R8(CompilerState* cState, i8 DestinationRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0x9F, MODE_RTOR, NO_REGISTER, DestinationRegister, R8NeedsREX(DestinationRegister))
}
define void EmitSetGE_R8(CompilerState* cState, i8 DestinationRegister) {
	EmitREXBigOpcodeModRM(cState, 0x0F, 0x9D, MODE_RTOR, NO_REGISTER, DestinationRegister, R8NeedsREX(DestinationRegister))
}