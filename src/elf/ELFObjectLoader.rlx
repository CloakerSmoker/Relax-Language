
#Require "$/Console.rlx"
#Require "$/File.rlx"

#Require "$/AVLTree.rlx"

#Require "./src/elf/ELFBuilder.rlx"


i32 ELF_SECTION_TYPE_DISCARD := 0x8000_0000 As i32

struct ELFObjectSection {
    ELFSectionHeader* Header

    i8* Name
    void* Data

    ; For any section which has symbols defined inside of it
    PointerArray* Symbols ; <ELFObjectSymbol*>
    PointerArray* Relocations ; <ELFObjectRelocation*>

    static self* New(ELFSectionHeader* Header, i8* Name, void* Data) {
        self* this := Alloc(#self)

        this->Header := Header
        this->Name := Name
        this->Data := Data

        this->Symbols := PointerArray:New()
        this->Relocations := PointerArray:New()

        return this
    }

    define i8 Is(i32 Type) {
        return this->Header->Type = Type
    }

    define i8 IsReloctions() {
        return this->Is(ELF_SECTION_TYPE_RELOCATIONS) || this->Is(ELF_SECTION_TYPE_RELOCATIONS_ADDEND)
    }

    define void Discard() {
        this->Symbols->Clear()
        this->Relocations->Clear()
        this->Header->FileSize := 0
        this->Header->Type := ELF_SECTION_TYPE_DISCARD
    }
}

struct ELFObjectSymbol {
    ELFSymbol* Header

    ELFObjectSection* Section
    i8* Name

    PointerArray* Relocations ; <ELFObjectRelocation*>

    static self* New(ELFSymbol* Header, ELFObjectSection* Section, i8* Name) {
        self* this := Alloc(#self)

        this->Header := Header
        this->Section := Section
        this->Name := Name

        this->Relocations := PointerArray:New()
        
        return this
    }
}

struct ELFObjectRelocation {
    ELFObjectSection* Owner

    i64 Offset
    i64 Type
	i64 Addend

    ELFObjectSymbol* Target

    static self* New(ELFObjectSection* Owner, i64 Offset, i64 Type, i64 Addend, ELFObjectSymbol* Target) {
        self* this := Alloc(#self)

        this->Owner := Owner

        this->Offset := Offset
        this->Type := Type
        this->Addend := Addend

        this->Target := Target

        return this
    }
}

struct ELFObjectFile {
    union {
        void* Buffer
        ELFHeader* Header
    }

    i32 Size

    ELFProgramHeader* ProgramHeaders
    ELFSectionHeader* SectionHeaders

    PointerArray* Sections ; <ObjectSection>
    AVLTree SectionsByName ; <i64, ObjectSection*>

    ELFSectionHeader* StringTableSectionHeader
    i8* StringTable

    static self* New(void* Buffer, i32 Size) {
        self* this := Alloc(#self)

        this->Buffer := Buffer
        this->Size := Size

        this->Sections := PointerArray:New()
        this~>SectionsByName->ValueSize := #ELFObjectSection*

        this->ProgramHeaders := Buffer + this->Header->ProgramHeadersOffset
        this->SectionHeaders := Buffer + this->Header->SectionHeadersOffset

        this->StringTableSectionHeader := this->SectionHeaders[this->Header->SectionNameSectionIndex]
        this->StringTable := Buffer + this->StringTableSectionHeader->FileOffset

        return this
    }

    define ObjectSection* TranslateSection(ELFSectionHeader* Header) {
        i8* Name := &this->StringTable[Header->NameOffset]
        void* Data := this->Buffer + Header->FileOffset

        auto Type := TranslateELFSectionType(Header->Type)

        if (Type = SECTION_TYPE_DISCARD) {
            return null
        }

        auto Section := ObjectSection:New(Type, Name, Data, Header->FileSize)

        return Section
    }

    define ObjectSection* TranslateTemporarySection(ELFSectionHeader* Header) {
        void* Data := this->Buffer + Header->FileOffset
        
        return ObjectSection:New(SECTION_TYPE_DISCARD, &this->StringTable[Header->NameOffset], Data, Header->FileSize)
    }

    define void LoadSections() {
        for (i32 Index := 0, Index < this->Header->SectionHeaderEntryCount, Index++) {
            ELFSectionHeader* Header := this->SectionHeaders[Index]

            i8 IsSymbolTable := Header->Type = ELF_SECTION_TYPE_SYMBOL_TABLE
            i8 IsRelocations := Header->Type = ELF_SECTION_TYPE_RELOCATIONS || Header->Type = ELF_SECTION_TYPE_RELOCATIONS_ADDEND

            if (IsSymbolTable || IsRelocations) {
                ; Pad section list for non-data sections to preserve section
                ; index based references

                this->Sections->Push(this->TranslateTemporarySection(Header))
            }
            else {
                this->Sections->Push(this->TranslateSection(Header))
            }
        }
    }

    define void LoadSymbolTables() {
        i32 SectionCount := this->Header->SectionHeaderEntryCount

        for (i32 SectionIndex := 1, SectionIndex < SectionCount, SectionIndex++) {
            ELFSectionHeader* Header := this->SectionHeaders[SectionIndex]
            ObjectSection* Section := this->Sections->At(SectionIndex)

            if (Header->Type != ELF_SECTION_TYPE_SYMBOL_TABLE) {
                continue
            }

            i64 Count := Header->FileSize / #ELFSymbol

            ELFSymbol* Symbols := Section->Data

            i32 StringTableIndex := Header->AssociatedSectionIndex
            ObjectSection* StringTableSection := this->Sections->At(StringTableIndex)
            i8* StringTable := StringTableSection->Data

            for (i32 Index := 0, Index < Count, Index++) {
                ELFSymbol* SymbolHeader := Symbols[Index]
                i8* Name := &StringTable[SymbolHeader->NameOffset]

                ObjectSection* SymbolSection := null

                if (SymbolHeader->SectionIndex > 0) {
                    SymbolSection := this->Sections->At(SymbolHeader->SectionIndex)
                }

                if (SymbolHeader->Type() = ELF_STT_SECTION && SymbolSection) {
                    Name := SymbolSection->Name
                }

                SYMBOL_BINDING Binding := TranslateELFSymbolBinding(SymbolHeader->Binding())
                SYMBOL_TYPE Type := TranslateELFSymbolType(SymbolHeader->Type())
                SYMBOL_VISIBILITY Visibility := TranslateELFSymbolVisibility(SymbolHeader->Visibility())

                ObjectSymbol* Symbol := ObjectSymbol:New(Binding, Type, Visibility, SymbolSection, Name, SymbolHeader->Size, SymbolHeader->Value)

                Section->Symbols->Push(Symbol)

                if (SymbolSection) {
                    SymbolSection->Symbols->Push(Symbol)
                }
            }
        }
    }

    define void LoadRelocations() {
        i32 SectionCount := this->Header->SectionHeaderEntryCount

        for (i32 SectionIndex := 1, SectionIndex < SectionCount, SectionIndex++) {
            ELFSectionHeader* Header := this->SectionHeaders[SectionIndex]
            ObjectSection* Section := this->Sections->At(SectionIndex)

            if (Header->Type != ELF_SECTION_TYPE_RELOCATIONS && Header->Type != ELF_SECTION_TYPE_RELOCATIONS_ADDEND) {
                continue
            }

            i32 SymbolTableIndex := Header->AssociatedSectionIndex
            i32 ApplicantIndex := Header->ExtraInfo

            ObjectSection* SymbolTable := this->Sections->At(SymbolTableIndex)
            ObjectSection* Applicant := this->Sections->At(ApplicantIndex)

            if (Header->Type = ELF_SECTION_TYPE_RELOCATIONS) {
                i64 Count := Header->FileSize / #ELFDirectRelocation
                ELFDirectRelocation* DirectRelocations := Section->Data

                for (i32 Index := 0, Index < Count, Index++) {
                    ELFDirectRelocation* DirectHeader := DirectRelocations[Index]

                    i32 SymbolIndex := ELFRelocationSymbol(DirectHeader->Info)
                    RELOCATION_TYPE Type := TranslateELFRelocationType(ELFRelocationType(DirectHeader->Info))

                    ObjectSymbol* Symbol := SymbolTable->Symbols->At(SymbolIndex)

                    ObjectRelocation* Relocation := ObjectRelocation:New(Section, Type, DirectHeader->Offset, Symbol, 0)

                    Section->Relocations->Push(Relocation)

                    Applicant->Relocations->Push(Relocation)
                    Symbol->Relocations->Push(Relocation)
                }
            }
            else if (Header->Type = ELF_SECTION_TYPE_RELOCATIONS_ADDEND) {
                i64 Count := Header->FileSize / #ELFRelocation
                ELFRelocation* Relocations := Section->Data

                for (i32 Index := 0, Index < Count, Index++) {
                    ELFRelocation* RelocationHeader := Relocations[Index]

                    i32 SymbolIndex := ELFRelocationSymbol(RelocationHeader->Info)
                    RELOCATION_TYPE Type := TranslateELFRelocationType(ELFRelocationType(RelocationHeader->Info))

                    ObjectSymbol* Symbol := SymbolTable->Symbols->At(SymbolIndex)

                    ObjectRelocation* Relocation := ObjectRelocation:New(Section, Type, RelocationHeader->Offset, Symbol, RelocationHeader->Addend)

                    Section->Relocations->Push(Relocation)

                    Applicant->Relocations->Push(Relocation)
                    Symbol->Relocations->Push(Relocation)
                }
            }
        }
    }

    define void Load() {
        this->LoadSections()
        this->LoadSymbolTables()
        this->LoadRelocations()
    }

    ;define ObjectFile* AsObject() {
     ;   ObjectFile* 
    ;}
}

/*

define void JoinSections(ELFObjectSection* Target, ELFObjectSection* Source, i8* SourceFileName) {
    i64 OffsetInTarget := Target->Header->FileSize
    i64 NewSize := Target->Header->FileSize + Source->Header->FileSize

    Target->Header->FileSize := NewSize
    Target->Data := ReAlloc(Target->Data, NewSize)
    MoveMemory(Target->Data + OffsetInTarget, Source->Data, Source->Header->FileSize As i32)

    i32 Count := Source->Symbols->Count()

    for (i32 Index := 0, Index < Count, Index++) {
        ELFObjectSymbol* Symbol := Source->Symbols->At(Index)

        Symbol->Section := Target
        Symbol->Header->Value += OffsetInTarget

        if (StringEquals(Symbol->Name, Source->Name)) {
            Symbol->Name := FormatString("%s%s", SourceFileName, Symbol->Name)
        }

        Target->Symbols->Push(Symbol)
    }

    i32 Count := Source->Relocations->Count()

    for (i32 Index := 0, Index < Count, Index++) {
        ELFObjectRelocation* Relocation := Source->Relocations->At(Index)

        Relocation->Owner := Target
        Relocation->Offset += OffsetInTarget

        Target->Relocations->Push(Relocation)
    }

    Source->Discard()
}

define ELFObjectFile* LinkObjects(ELFObjectFile* Left, ELFObjectFile* Right) {


    return null
}

*/