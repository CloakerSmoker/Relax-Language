
#Require "$/Console.rlx"
#Require "$/File.rlx"

#Require "$/AVLTree.rlx"

#Require "./src/elf/ELFBuilder.rlx"


i32 ELF_SECTION_TYPE_DISCARD := 0x8000_0000 As i32

struct ELFObjectSection {
    ELFSectionHeader* Header

    i8* Name
    void* Data

    ; For any section which has symbols defined inside of it
    PointerArray* Symbols ; <ELFObjectSymbol*>
    PointerArray* Relocations ; <ELFObjectRelocation*>

    static self* New(ELFSectionHeader* Header, i8* Name, void* Data) {
        self* this := Alloc(#self)

        this->Header := Header
        this->Name := Name
        this->Data := Data

        this->Symbols := PointerArray:New()
        this->Relocations := PointerArray:New()

        return this
    }

    define i8 Is(i32 Type) {
        return this->Header->Type = Type
    }

    define i8 IsReloctions() {
        return this->Is(ELF_SECTION_TYPE_RELOCATIONS) || this->Is(ELF_SECTION_TYPE_RELOCATIONS_ADDEND)
    }

    define void Discard() {
        this->Symbols->Clear()
        this->Relocations->Clear()
        this->Header->FileSize := 0
        this->Header->Type := ELF_SECTION_TYPE_DISCARD
    }
}

struct ELFObjectSymbol {
    ELFSymbol* Header

    ELFObjectSection* Section
    i8* Name

    PointerArray* Relocations ; <ELFObjectRelocation*>

    static self* New(ELFSymbol* Header, ELFObjectSection* Section, i8* Name) {
        self* this := Alloc(#self)

        this->Header := Header
        this->Section := Section
        this->Name := Name

        this->Relocations := PointerArray:New()
        
        return this
    }
}

struct ELFObjectRelocation {
    ELFObjectSection* Owner

    i64 Offset
    i64 Type
	i64 Addend

    ELFObjectSymbol* Target

    static self* New(ELFObjectSection* Owner, i64 Offset, i64 Type, i64 Addend, ELFObjectSymbol* Target) {
        self* this := Alloc(#self)

        this->Owner := Owner

        this->Offset := Offset
        this->Type := Type
        this->Addend := Addend

        this->Target := Target

        return this
    }
}

struct ELFObjectFile {
    union {
        void* Buffer
        ELFHeader* Header
    }

    i32 Size

    ELFProgramHeader* ProgramHeaders
    ELFSectionHeader* SectionHeaders

    PointerArray* SectionsByIndex ; <ObjectSection>
    AVLTree SectionsByName ; <i64, ObjectSection*>

    ELFSectionHeader* StringTableSectionHeader
    i8* StringTable

    static self* New(void* Buffer, i32 Size) {
        self* this := Alloc(#self)

        this->Buffer := Buffer
        this->Size := Size

        this->SectionsByIndex := PointerArray:New()
        this~>SectionsByName->ValueSize := #ELFObjectSection*

        this->ProgramHeaders := Buffer + this->Header->ProgramHeadersOffset
        this->SectionHeaders := Buffer + this->Header->SectionHeadersOffset

        this->StringTableSectionHeader := this->SectionHeaders[this->Header->SectionNameSectionIndex]
        this->StringTable := Buffer + this->StringTableSectionHeader->FileOffset

        return this
    }

    define ObjectSection* LoadSection(i32 Index) {
        ELFSectionHeader* Header := this->SectionHeaders[Index]
        i8* Name := &this->StringTable[Header->NameOffset]
        void* Data := this->Buffer + Header->FileOffset

        

        ELFObjectSection* Section := ObjectSection:New(, Name, Data)

        this->SectionsByIndex->Insert(Index - 1, Section)
        this~>SectionsByName->Insert(FNV1A(Name), &Section)

        return Section
    }

    define void LoadSections() {
        for (i32 Index := 1, Index < this->Header->SectionHeaderEntryCount, Index++) {
            this->LoadSection(Index)
        }
    }

    define void LoadSymbolTables() {
        i32 SectionCount := this->SectionsByIndex->Count()

        for (i32 SectionIndex := 0, SectionIndex < SectionCount, SectionIndex++) {
            ELFObjectSection* Section := this->SectionsByIndex->At(SectionIndex)

            if (Section->Header->Type = ELF_SECTION_TYPE_SYMBOL_TABLE) {
                i64 Count := Section->Header->FileSize / #ELFSymbol

                ELFSymbol* Symbols := Section->Data

                i32 StringTableIndex := Section->Header->AssociatedSectionIndex
                ELFObjectSection* StringTableSection := this->SectionsByIndex->At(StringTableIndex - 1)
                i8* StringTable := StringTableSection->Data

                for (i32 Index := 1, Index < Count, Index++) {
                    ELFSymbol* Header := Symbols[Index]
                    i8* Name := &StringTable[Header->NameOffset]

                    ELFObjectSection* SymbolSection := null

                    if (Header->SectionIndex > 0) {
                        SymbolSection := this->SectionsByIndex->At(Header->SectionIndex - 1)
                    }

                    if (Header->Type() = ELF_STT_SECTION && SymbolSection) {
                        Name := SymbolSection->Name
                    }

                    ELFObjectSymbol* Symbol := ELFObjectSymbol:New(Header, SymbolSection, Name)

                    Section->Symbols->Push(Symbol)

                    if (SymbolSection) {
                        SymbolSection->Symbols->Push(Symbol)
                    }
                }

                Section->Discard()
            }
        }
    }

    define void LoadRelocations() {
        i32 SectionCount := this->SectionsByIndex->Count()

        for (i32 SectionIndex := 0, SectionIndex < SectionCount, SectionIndex++) {
            ELFObjectSection* Section := this->SectionsByIndex->At(SectionIndex)

            if !(Section->IsReloctions()) {
                continue
            }

            i32 SymbolTableIndex := Section->Header->AssociatedSectionIndex
            i32 ApplicantIndex := Section->Header->ExtraInfo

            ELFObjectSection* SymbolTable := this->SectionsByIndex->At(SymbolTableIndex - 1)
            ELFObjectSection* Applicant := this->SectionsByIndex->At(ApplicantIndex - 1)

            if (Section->Is(ELF_SECTION_TYPE_RELOCATIONS)) {
                i64 Count := Section->Header->FileSize / #ELFDirectRelocation
                ELFDirectRelocation* DirectRelocations := Section->Data

                for (i32 Index := 0, Index < Count, Index++) {
                    ELFDirectRelocation* DirectHeader := DirectRelocations[Index]

                    i32 SymbolIndex := ELFRelocationSymbol(DirectHeader->Info)
                    i32 Type := ELFRelocationType(DirectHeader->Info)

                    ELFObjectSymbol* Symbol := SymbolTable->Symbols->At(SymbolIndex - 1)

                    ELFObjectRelocation* Relocation := ELFObjectRelocation:New(Section, DirectHeader->Offset, Type, 0, Symbol)

                    Section->Relocations->Push(Relocation)
                    Applicant->Relocations->Push(Relocation)
                    Symbol->Relocations->Push(Relocation)
                }
            }
            else if (Section->Is(ELF_SECTION_TYPE_RELOCATIONS_ADDEND)) {
                i64 Count := Section->Header->FileSize / #ELFRelocation
                ELFRelocation* Relocations := Section->Data

                for (i32 Index := 0, Index < Count, Index++) {
                    ELFRelocation* Header := Relocations[Index]

                    i32 SymbolIndex := ELFRelocationSymbol(Header->Info)
                    i32 Type := ELFRelocationType(Header->Info)

                    ELFObjectSymbol* Symbol := SymbolTable->Symbols->At(SymbolIndex - 1)

                    ELFObjectRelocation* Relocation := ELFObjectRelocation:New(Section, Header->Offset, Type, 0, Symbol)

                    Section->Relocations->Push(Relocation)
                    Applicant->Relocations->Push(Relocation)
                    Symbol->Relocations->Push(Relocation)
                }
            }

            Section->Discard()
        }
    }

    define void Load() {
        this->LoadSections()
        this->LoadSymbolTables()
        this->LoadRelocations()
    }

    define ELFObjectSection* GetSectionByName(i8* Name) {
        return this~>SectionsByName->GetPointer(FNV1A(Name))
    }
}

define void JoinSections(ELFObjectSection* Target, ELFObjectSection* Source, i8* SourceFileName) {
    i64 OffsetInTarget := Target->Header->FileSize
    i64 NewSize := Target->Header->FileSize + Source->Header->FileSize

    Target->Header->FileSize := NewSize
    Target->Data := ReAlloc(Target->Data, NewSize)
    MoveMemory(Target->Data + OffsetInTarget, Source->Data, Source->Header->FileSize As i32)

    i32 Count := Source->Symbols->Count()

    for (i32 Index := 0, Index < Count, Index++) {
        ELFObjectSymbol* Symbol := Source->Symbols->At(Index)

        Symbol->Section := Target
        Symbol->Header->Value += OffsetInTarget

        if (StringEquals(Symbol->Name, Source->Name)) {
            Symbol->Name := FormatString("%s%s", SourceFileName, Symbol->Name)
        }

        Target->Symbols->Push(Symbol)
    }

    i32 Count := Source->Relocations->Count()

    for (i32 Index := 0, Index < Count, Index++) {
        ELFObjectRelocation* Relocation := Source->Relocations->At(Index)

        Relocation->Owner := Target
        Relocation->Offset += OffsetInTarget

        Target->Relocations->Push(Relocation)
    }

    Source->Discard()
}

define ELFObjectFile* LinkObjects(ELFObjectFile* Left, ELFObjectFile* Right) {


    return null
}

define void DumpSection(ELFObjectSection* Section) {
    Print("%s\n", Section->Name)

    i32 SymbolCount := Section->Symbols->Count()

    if (SymbolCount && !Section->Is(ELF_SECTION_TYPE_SYMBOL_TABLE)) {
        Print("\tSymbols:\n")

        for (i32 SymbolIndex := 0, SymbolIndex < SymbolCount, SymbolIndex++) {
            ELFObjectSymbol* Symbol := Section->Symbols->At(SymbolIndex)

            Print("\t\tSymbol %i: %s (%x) @ %x\n", SymbolIndex, Symbol->Name, Symbol->Header->Size, Symbol->Header->Value)
        }
    }

    i32 RelocationCount := Section->Relocations->Count()

    if (RelocationCount && !Section->IsReloctions()) {
        Print("\tReloctions:\n", Section->Name)    

        for (i32 RelocationIndex := 0, RelocationIndex < RelocationCount, RelocationIndex++) {
            ELFObjectRelocation* Relocation := Section->Relocations->At(RelocationIndex)

            Print("\t\t%x: -> %s + %i\n", Relocation->Offset, Relocation->Target->Name, Relocation->Addend)
        }
    }

    if (Section->Header->Type = ELF_SECTION_TYPE_DATA) {
        Print("\tData:\n%hexdump\n", Section->Data, Section->Header->FileSize)
    }
}

define ELFObjectFile* LoadAndDumpObject(i8* FileName) {
    i64 F := FileOpen(FileName, FILE_READ)

    i32 Size := FileGetSize(F)
    void* Data := FileReadAll(F)

    FileClose(F)

    ELFObjectFile* Object := ELFObjectFile:New(Data, Size)

    Object->Load()

    Print("\nObject File: %s\n", FileName)

    i32 Count := Object->SectionsByIndex->Count()

    for (i32 Index := 0, Index < Count, Index++) {
        ELFObjectSection* Section := Object->SectionsByIndex->At(Index)

        Print("Section %i: ", Index)
        DumpSection(Section)
    }

    return Object
}

define void Main(i64 ArgC, i8** ArgV) {
    PointerArray* Objects := PointerArray:New() ; <ELFObjectFile*>

    for (i32 Index := 1, Index < ArgC, Index++) {
        i8* FileName := ArgV[Index]
        ELFObjectFile* Object := LoadAndDumpObject(FileName)

        ELFObjectSection* Text := Object->GetSectionByName(".text")
        ELFObjectSection* Frame := Object->GetSectionByName(".eh_frame")

        JoinSections(Text, Frame, FileName)

        DumpSection(Text)
        DumpSection(Frame)

        Objects->Push(Object)
    }
}