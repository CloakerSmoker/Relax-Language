
#Require "$/Console.rlx"
#Require "$/File.rlx"

#Require "$/AVLTree.rlx"

#Require "./src/elf/ELFBuilder.rlx"

struct ELFObjectSection {
    ELFSectionHeader* Header

    i8* Name
    void* Data

    ; For any section which has symbols defined inside of it
    PointerArray* Symbols ; <ELFObjectSymbol*>
    PointerArray* Relocations ; <ELFObjectRelocation*>

    static self* New(ELFSectionHeader* Header, i8* Name, void* Data) {
        self* this := Alloc(#self)

        this->Header := Header
        this->Name := Name
        this->Data := Data

        this->Symbols := PointerArray:New()
        this->Relocations := PointerArray:New()

        return this
    }

    define i8 Is(i32 Type) {
        return this->Header->Type = Type
    }

    define i8 IsReloctions() {
        return this->Is(ELF_SECTION_TYPE_RELOCATIONS) || this->Is(ELF_SECTION_TYPE_RELOCATIONS_ADDEND)
    }
}

struct ELFObjectSymbol {
    ELFSymbol* Header

    ELFObjectSection* Section
    i8* Name

    PointerArray* Relocations ; <ELFObjectRelocation*>

    static self* New(ELFSymbol* Header, ELFObjectSection* Section, i8* Name) {
        self* this := Alloc(#self)

        this->Header := Header
        this->Section := Section
        this->Name := Name

        this->Relocations := PointerArray:New()
        
        return this
    }
}

struct ELFObjectRelocation {
    ELFObjectSection* Owner

    i64 Offset
    i64 Type
	i64 Addend

    ELFObjectSymbol* Target

    static self* New(ELFObjectSection* Owner, i64 Offset, i64 Type, i64 Addend, ELFObjectSymbol* Target) {
        self* this := Alloc(#self)

        this->Owner := Owner

        this->Offset := Offset
        this->Type := Type
        this->Addend := Addend

        this->Target := Target

        return this
    }
}

struct ELFObjectFile {
    union {
        void* Buffer
        ELFHeader* Header
    }

    i32 Size

    ELFProgramHeader* ProgramHeaders
    ELFSectionHeader* SectionHeaders

    PointerArray* SectionsByIndex ; <ELFObjectSection>
    AVLTree SectionsByName ; <i64, ELFObjectSection*>

    AVLTree SymbolsByName

    ELFSectionHeader* StringTableSectionHeader
    i8* StringTable

    static self* New(void* Buffer, i32 Size) {
        self* this := Alloc(#self)

        this->Buffer := Buffer
        this->Size := Size

        this->SectionsByIndex := PointerArray:New()
        this~>SectionsByName->ValueSize := #ELFObjectSection*

        this->ProgramHeaders := Buffer + this->Header->ProgramHeadersOffset
        this->SectionHeaders := Buffer + this->Header->SectionHeadersOffset

        this->StringTableSectionHeader := this->SectionHeaders[this->Header->SectionNameSectionIndex]
        this->StringTable := Buffer + this->StringTableSectionHeader->FileOffset

        return this
    }

    define ELFObjectSection* LoadSection(i32 Index) {
        ELFSectionHeader* Header := this->SectionHeaders[Index]
        i8* Name := &this->StringTable[Header->NameOffset]
        void* Data := this->Buffer + Header->FileOffset

        ELFObjectSection* Section := ELFObjectSection:New(Header, Name, Data)

        this->SectionsByIndex->Insert(Index - 1, Section)
        this~>SectionsByName->Insert(FNV1A(Name), &Section)

        return Section
    }

    define void LoadSections() {
        for (i32 Index := 1, Index < this->Header->SectionHeaderEntryCount, Index++) {
            this->LoadSection(Index)
        }
    }

    define void LoadSymbolTables() {
        i32 SectionCount := this->SectionsByIndex->Count()

        for (i32 SectionIndex := 0, SectionIndex < SectionCount, SectionIndex++) {
            ELFObjectSection* Section := this->SectionsByIndex->At(SectionIndex)

            if (Section->Header->Type = ELF_SECTION_TYPE_SYMBOL_TABLE) {
                i64 Count := Section->Header->FileSize / #ELFSymbol

                ELFSymbol* Symbols := Section->Data

                i32 StringTableIndex := Section->Header->AssociatedSectionIndex
                ELFObjectSection* StringTableSection := this->SectionsByIndex->At(StringTableIndex - 1)
                i8* StringTable := StringTableSection->Data

                for (i32 Index := 1, Index < Count, Index++) {
                    ELFSymbol* Header := Symbols[Index]
                    i8* Name := &StringTable[Header->NameOffset]

                    ELFObjectSection* SymbolSection := null

                    if (Header->SectionIndex > 0) {
                        SymbolSection := this->SectionsByIndex->At(Header->SectionIndex - 1)
                    }

                    if (Header->Type() = ELF_STT_SECTION && SymbolSection) {
                        Name := SymbolSection->Name
                    }

                    ELFObjectSymbol* Symbol := ELFObjectSymbol:New(Header, SymbolSection, Name)

                    Section->Symbols->Push(Symbol)

                    if (SymbolSection) {
                        SymbolSection->Symbols->Push(Symbol)
                    }
                }
            }
        }
    }

    define void LoadRelocations() {
        i32 SectionCount := this->SectionsByIndex->Count()

        for (i32 SectionIndex := 0, SectionIndex < SectionCount, SectionIndex++) {
            ELFObjectSection* Section := this->SectionsByIndex->At(SectionIndex)

            if !(Section->IsReloctions()) {
                continue
            }

            i32 SymbolTableIndex := Section->Header->AssociatedSectionIndex
            i32 ApplicantIndex := Section->Header->ExtraInfo

            ELFObjectSection* SymbolTable := this->SectionsByIndex->At(SymbolTableIndex - 1)
            ELFObjectSection* Applicant := this->SectionsByIndex->At(ApplicantIndex - 1)

            if (Section->Is(ELF_SECTION_TYPE_RELOCATIONS)) {
                i64 Count := Section->Header->FileSize / #ELFDirectRelocation
                ELFDirectRelocation* DirectRelocations := Section->Data

                for (i32 Index := 0, Index < Count, Index++) {
                    ELFDirectRelocation* DirectHeader := DirectRelocations[Index]

                    i32 SymbolIndex := ELFRelocationSymbol(DirectHeader->Info)
                    i32 Type := ELFRelocationType(DirectHeader->Info)

                    ELFObjectSymbol* Symbol := SymbolTable->Symbols->At(SymbolIndex - 1)

                    ELFObjectRelocation* Relocation := ELFObjectRelocation:New(Section, DirectHeader->Offset, Type, 0, Symbol)

                    Section->Relocations->Push(Relocation)
                    Applicant->Relocations->Push(Relocation)
                    Symbol->Relocations->Push(Relocation)
                }
            }
            else if (Section->Is(ELF_SECTION_TYPE_RELOCATIONS_ADDEND)) {
                i64 Count := Section->Header->FileSize / #ELFRelocation
                ELFRelocation* Relocations := Section->Data

                for (i32 Index := 0, Index < Count, Index++) {
                    ELFRelocation* Header := Relocations[Index]

                    i32 SymbolIndex := ELFRelocationSymbol(Header->Info)
                    i32 Type := ELFRelocationType(Header->Info)

                    ELFObjectSymbol* Symbol := SymbolTable->Symbols->At(SymbolIndex - 1)

                    ELFObjectRelocation* Relocation := ELFObjectRelocation:New(Section, Header->Offset, Type, 0, Symbol)

                    Section->Relocations->Push(Relocation)
                    Applicant->Relocations->Push(Relocation)
                    Symbol->Relocations->Push(Relocation)
                }
            }
        }
    }

    define void Load() {
        this->LoadSections()
        this->LoadSymbolTables()
        this->LoadRelocations()
    }
}

define ELFObjectSection* MoveSymbols(ELFObjectSection* Target, ELFObjectSection* Source) {
    


}

define ELFObjectSection* MergeSections(ELFObjectSection* Left, ELFObjectSection* Right) {
    i64 TotalSize := Left->Header->FileSize + Right->Header->FileSize
    void* Data := Alloc(TotalSize)

    MoveMemory(Data, Left->Data, Left->Header->FileSize As i32)
    MoveMemory(Data + Left->Header->FileSize, Right->Data, Right->Header->FileSize As i32)

    ELFObjectSection* Relocations := ELFObjectSection:New(RelocationsHeader, )    

    ELFSectionHeader* Header := Alloc(#ELFSectionHeader)

    Header->Type := Left->Header->Type
    Header->Flags := Left->Header->Flags
    Header->FileSize := TotalSize

    ELFObjectSection* Section := ELFObjectSection:New(Header, Left->Name, Data)

    i32 Count := Left->Symbols
    

    return null
}

define ELFObjectFile* LinkObjects(ELFObjectFile* Left, ELFObjectFile* Right) {


    return null
}

define ELFObjectFile* LoadAndDumpObject(i8* FileName) {
    i64 F := FileOpen(FileName, FILE_READ)

    i32 Size := FileGetSize(F)
    void* Data := FileReadAll(F)

    FileClose(F)

    ELFObjectFile* Object := ELFObjectFile:New(Data, Size)

    Object->Load()

    Print("\nObject File: %s\n", FileName)

    i32 Count := Object->SectionsByIndex->Count()

    for (i32 Index := 0, Index < Count, Index++) {
        ELFObjectSection* Section := Object->SectionsByIndex->At(Index)

        Print("Section %i: %s\n", Index, Section->Name)

        i32 SymbolCount := Section->Symbols->Count()

        if (SymbolCount && !Section->Is(ELF_SECTION_TYPE_SYMBOL_TABLE)) {
            Print("\tSymbols:\n")

            for (i32 SymbolIndex := 0, SymbolIndex < SymbolCount, SymbolIndex++) {
                ELFObjectSymbol* Symbol := Section->Symbols->At(SymbolIndex)

                Print("\t\tSymbol %i: %s (%x) @ %x\n", SymbolIndex, Symbol->Name, Symbol->Header->Size, Symbol->Header->Value)
            }
        }

        i32 RelocationCount := Section->Relocations->Count()

        if (RelocationCount && !Section->IsReloctions()) {
            Print("\tReloctions:\n", Section->Name)    

            for (i32 RelocationIndex := 0, RelocationIndex < RelocationCount, RelocationIndex++) {
                ELFObjectRelocation* Relocation := Section->Relocations->At(RelocationIndex)

                Print("\t\t%x: -> %s + %i\n", Relocation->Offset, Relocation->Target->Name, Relocation->Addend)
            }
        }

        if (Section->Header->Type = ELF_SECTION_TYPE_DATA) {
            Print("\tData:\n%hexdump\n", Section->Data, Section->Header->FileSize)
        }
    }

    return Object
}

define void Main(i64 ArgC, i8** ArgV) {
    PointerArray* Objects := PointerArray:New() ; <ELFObjectFile*>

    for (i32 Index := 1, Index < ArgC, Index++) {
        i8* FileName := ArgV[Index]
        ELFObjectFile* Object := LoadAndDumpObject(FileName)

        Objects->Push(Object)
    }
}