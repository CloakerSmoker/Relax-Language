
#Require "$/Console.rlx"
#Require "$/File.rlx"

#Require "$/AVLTree.rlx"

#Require "./src/elf/ELFBuilder.rlx"

struct ELFObjectSection {
    ELFSectionHeader* Header

    i8* Name
    void* Data

    ; For a data section with relocations
    ELFObjectSection* RelocationSection

    ; For a relocation section
    ELFObjectSection* TargetSection
    ELFObjectSection* SymbolSection
    PointerArray* Relocations ; <ELFObjectRelocation*>

    ; For a symbol table section
    ELFObjectSection* StringSection
    PointerArray* Symbols ; <ELFObjectSymbol*>

    static self* New(ELFSectionHeader* Header, i8* Name, void* Data) {
        self* this := Alloc(#self)

        this->Header := Header
        this->Name := Name
        this->Data := Data

        if (Header->Type = ELF_SECTION_TYPE_RELOCATIONS || Header->Type = ELF_SECTION_TYPE_RELOCATIONS_ADDEND) {
            this->Relocations := PointerArray:New()
        }
        else if (Header->Type = ELF_SECTION_TYPE_SYMBOL_TABLE) {
            this->Symbols := PointerArray:New()
        }

        return this
    }
}

struct ELFObjectSymbol {
    ELFSymbol* Header

    ELFObjectSection* Section
    i8* Name

    static self* New(ELFSymbol* Header, ELFObjectSection* Section, i8* Name) {
        self* this := Alloc(#self)

        this->Header := Header
        this->Section := Section
        this->Name := Name
        
        return this
    }
}

struct ELFObjectRelocation {
    i64 Offset
    i64 Type
	i64 Addend

    ELFObjectSymbol* Target

    static self* New(i64 Offset, i64 Type, i64 Addend, ELFObjectSymbol* Target) {
        self* this := Alloc(#self)

        this->Offset := Offset
        this->Type := Type
        this->Addend := Addend

        this->Target := Target

        return this
    }
}

struct ELFObjectFile {
    union {
        void* Buffer
        ELFHeader* Header
    }

    i32 Size

    ELFProgramHeader* ProgramHeaders
    ELFSectionHeader* SectionHeaders

    PointerArray* SectionsByIndex ; <ELFObjectSection>
    AVLTree SectionsByName ; <i64, ELFObjectSection*>

    ELFSectionHeader* StringTableSectionHeader
    i8* StringTable

    static self* New(void* Buffer, i32 Size) {
        self* this := Alloc(#self)

        this->Buffer := Buffer
        this->Size := Size

        this->SectionsByIndex := PointerArray:New()
        this~>SectionsByName->ValueSize := #ELFObjectSection*

        this->ProgramHeaders := Buffer + this->Header->ProgramHeadersOffset
        this->SectionHeaders := Buffer + this->Header->SectionHeadersOffset

        this->StringTableSectionHeader := this->SectionHeaders[this->Header->SectionNameSectionIndex]
        this->StringTable := Buffer + this->StringTableSectionHeader->FileOffset

        return this
    }

    define ELFObjectSection* LoadSection(i32 Index) {
        ELFSectionHeader* Header := this->SectionHeaders[Index]
        i8* Name := &this->StringTable[Header->NameOffset]
        void* Data := this->Buffer + Header->FileOffset

        ELFObjectSection* Section := ELFObjectSection:New(Header, Name, Data)

        this->SectionsByIndex->Insert(Index - 1, Section)
        this~>SectionsByName->Insert(FNV1A(Name), &Section)

        return Section
    }

    define void LoadSections() {
        for (i32 Index := 1, Index < this->Header->SectionHeaderEntryCount, Index++) {
            this->LoadSection(Index)
        }

        i32 SectionCount := this->SectionsByIndex->Count()

        for (i32 SectionIndex := 0, SectionIndex < SectionCount, SectionIndex++) {
            ELFObjectSection* Section := this->SectionsByIndex->At(SectionIndex)

            if (Section->Header->Type = ELF_SECTION_TYPE_RELOCATIONS || Section->Header->Type = ELF_SECTION_TYPE_RELOCATIONS_ADDEND) {
                i32 SymbolTableIndex := Section->Header->AssociatedSectionIndex
                i32 ApplicantIndex := Section->Header->ExtraInfo

                ELFObjectSection* SymbolTable := this->SectionsByIndex->At(SymbolTableIndex - 1)
                ELFObjectSection* Applicant := this->SectionsByIndex->At(ApplicantIndex - 1)

                Applicant->RelocationSection := Section

                Section->TargetSection := Applicant
                Section->SymbolSection := SymbolTable
            }
            else if (Section->Header->Type = ELF_SECTION_TYPE_SYMBOL_TABLE) {
                i32 StringTableIndex := Section->Header->AssociatedSectionIndex

                ELFObjectSection* StringTable := this->SectionsByIndex->At(StringTableIndex - 1)

                Section->StringSection := StringTable
            }
        }
    }

    define void LoadSymbolTables() {
        i32 SectionCount := this->SectionsByIndex->Count()

        for (i32 SectionIndex := 0, SectionIndex < SectionCount, SectionIndex++) {
            ELFObjectSection* Section := this->SectionsByIndex->At(SectionIndex)

            if (Section->Header->Type = ELF_SECTION_TYPE_SYMBOL_TABLE) {
                i64 Count := Section->Header->FileSize / #ELFSymbol

                ELFSymbol* Symbols := Section->Data
                i8* StringTable := Section->StringSection->Data

                for (i32 Index := 1, Index < Count, Index++) {
                    ELFSymbol* Symbol := Symbols[Index]
                    i8* Name := &StringTable[Symbol->NameOffset]

                    ELFObjectSection* SymbolSection := null

                    if (Symbol->SectionIndex > 0) {
                        SymbolSection := this->SectionsByIndex->At(Symbol->SectionIndex - 1)
                    }

                    if (Symbol->Type() = ELF_STT_SECTION && SymbolSection) {
                        Name := SymbolSection->Name
                    }

                    Section->Symbols->Push(ELFObjectSymbol:New(Symbol, SymbolSection, Name))
                }
            }
        }
    }

    define void LoadRelocations() {
        i32 SectionCount := this->SectionsByIndex->Count()

        for (i32 SectionIndex := 0, SectionIndex < SectionCount, SectionIndex++) {
            ELFObjectSection* Section := this->SectionsByIndex->At(SectionIndex)

            if (Section->Header->Type = ELF_SECTION_TYPE_RELOCATIONS) {
                i64 Count := Section->Header->FileSize / #ELFDirectRelocation
                ELFDirectRelocation* DirectRelocations := Section->Data

                for (i32 Index := 0, Index < Count, Index++) {
                    ELFDirectRelocation* DirectRelocation := DirectRelocations[Index]

                    i32 SymbolIndex := ELFRelocationSymbol(DirectRelocation->Info)
                    i32 Type := ELFRelocationType(DirectRelocation->Info)

                    ELFObjectSymbol* Symbol := Section->SymbolSection->Symbols->At(SymbolIndex - 1)

                    Section->Relocations->Push(ELFObjectRelocation:New(DirectRelocation->Offset, Type, 0, Symbol))
                }
            }
            else if (Section->Header->Type = ELF_SECTION_TYPE_RELOCATIONS_ADDEND) {
                i64 Count := Section->Header->FileSize / #ELFRelocation
                ELFRelocation* Relocations := Section->Data

                for (i32 Index := 0, Index < Count, Index++) {
                    ELFRelocation* Relocation := Relocations[Index]

                    i32 SymbolIndex := ELFRelocationSymbol(Relocation->Info)
                    i32 Type := ELFRelocationType(Relocation->Info)

                    ELFObjectSymbol* Symbol := Section->SymbolSection->Symbols->At(SymbolIndex - 1)

                    Section->Relocations->Push(ELFObjectRelocation:New(Relocation->Offset, Type, Relocation->Addend, Symbol))
                }
            }
        }
    }
}

define void Main(i64 ArgC, i8** ArgV) {
    i64 F := FileOpen(ArgV[1], FILE_READ)

    i32 Size := FileGetSize(F)
    void* Data := FileReadAll(F)

    FileClose(F)

    ELFObjectFile* Object := ELFObjectFile:New(Data, Size)

    Object->LoadSections()
    Object->LoadSymbolTables()
    Object->LoadRelocations()

    i32 Count := Object->SectionsByIndex->Count()

    for (i32 Index := 0, Index < Count, Index++) {
        ELFObjectSection* Section := Object->SectionsByIndex->At(Index)

        Print("%i: %s\n", Index, Section->Name)

        if (Section->RelocationSection) {
            Print("\tRelocations: %s\n", Section->RelocationSection->Name)
            Print("\t\tSymbols: %s\n", Section->RelocationSection->SymbolSection->Name)
            Print("\t\t\tStrings: %s\n", Section->RelocationSection->SymbolSection->StringSection->Name)
        }
        else if (Section->Symbols) {
            i32 SymbolCount := Section->Symbols->Count()

            for (i32 SymbolIndex := 0, SymbolIndex < SymbolCount, SymbolIndex++) {
                ELFObjectSymbol* Symbol := Section->Symbols->At(SymbolIndex)

                Print("Symbol[%i]: ", SymbolIndex)

                if (Symbol->Section) {
                    Print("%s::", Symbol->Section->Name)
                }

                Print("%s\n", Symbol->Name)
            }
        }
        else if (Section->Relocations) {
            Print("Relocations for %s:\n", Section->TargetSection->Name)
            
            i32 RelocationCount := Section->Relocations->Count()

            for (i32 RelocationIndex := 0, RelocationIndex < RelocationCount, RelocationIndex++) {
                ELFObjectRelocation* Relocation := Section->Relocations->At(RelocationIndex)

                Print("\t%x: -> %s + %i\n", Relocation->Offset, Relocation->Target->Name, Relocation->Addend)
            }
        }
    }


}