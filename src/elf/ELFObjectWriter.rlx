
; ELF loader: ELF object -> ELF shaped generic object -> generic object
; object linker: generic objects -> generic object
; ELF writer: generic object -> ELF shaped generic object -> 

; ELF object flavors: object (passthrough), static, dynamic

/*

Stages of lowering a generic object to a passthrough object:
1. Take ownership of sections (and assign section indexes)
2. Translate symbols (and assign symbol indexes)
3. Translate relocations (using section+symbol indexes)
4. Translate section headers

1. Translate sections
    - Assign section indexes
    - Create section header
    - Populate section header and preserve section data
    - Link related section headers (symtab -> strtab)
2. Translate symbols
    - Assimilate symbol tables
        - Convert as we go, adding to string table
    - Populate symbol table section header (symtab.first_non_local)
3. Translate relocations
    - Create relocation sections
    - Populate relocation section header (symbol table, applicant section)
    - 

0. Initialize
    1. Create internal sections
        - null
        - strtab
        - shstrtab
        - symtab
1. Juggle
    1. Expand sections
        - Each section with relocations is expanded into a .rela<name> section
        - Indexes assigned
    2. Transfer symbols
        - Symbol table is ordered
        - Indexes assigned
        - Symbols go from sections to the relocation section
    3. Transfer relocations
        - Relocations go from sections to specific relocation sections
2. Lower
    1. Translate sections
        - Mirror sections as ELFSectionHeader-s
        - Link related sections
        - Update flags/name (populate string table)
    2. Translate symbols
        - Mirror symbol table as ELFSymbol-s
        - Link symbols to sections
        - Update flags/name (populate symbol string table)
    3. Translate Relocations
        - Mirror relocations as ELFRelocation-s
        - Link relocations to sections/symbols
3. Emit
    1. Write headers
        - Copy section headers into ELF buffer
    2. Populate data
        - Copy section data into ELF buffer
 */


struct ELFObjectWriter {
    PointerArray* Sections ; <ObjectSection*>
    PointerArray* ELFSections ; <ELFSectionHeader*>

    ; Each symbol table also has a list of associated relocation sections
    ;  which target the given symbol table. These tables can either be
    ;  emitted into an object file, or merged into a single table and
    ;  emitted into an executable image.

    ; List of all smybol tables present
    PointerArray* SymbolTables ; <ObjectSection*>

    ; Maps a section with relocations to its individual relocation sections
    ;  for each symbol table present (sparsely)
    ; aka Map<DataSection, Map<SymbolTable, RelocationSection>
    AVLTree* SectionRelocationSections ; <ObjectSection*, AVLTree*<ObjectSection*, ObjectSection*>>
    AVLTree* RelocationSectionSections ; <ObjectSection*, ObjectSection*>

    ObjectSection* NullSection
    ObjectSection* SharedStringTable

    define ObjectSection* CreateSection(SECTION_TYPE Type, i8* Name, i32 InitialSize) {
        ObjectSection* Result := ObjectSection:New(Type, Name, Alloc(InitialSize + 1), InitialSize)

        this->Sections->Push(Result)

        return Result
    }

    define i32 GetSectionIndex(ObjectSection* Section) {
        return this->Sections->Find(Section)
    }

    define ObjectSection* CreateSymbolTable(i8* Name, i8* StringsName) {
        ObjectSection* StringTable := this->CreateSection(SECTION_TYPE_DATA, StringsName, 1)
        ObjectSection* SymbolTable := this->CreateSection(SECTION_TYPE_DATA, Name, 0)

        this->SymbolTables->Push(SymbolTable)

        return SymbolTable
    }

    define i32 GetSymbolTableIndex(ObjectSection* SymbolTable) {
        return this->SymbolTables->Find(SymbolTable)
    }

    void* State
    ObjectSection*(void*, ObjectSymbol*) _AssignSymbolTable

    static self* New(void* State, ObjectSection*(void*, ObjectSymbol*) AssignSymbolTable) {
        self* this := Alloc(#self)

        this->State := State
        this->_AssignSymbolTable := AssignSymbolTable

        this->Sections := PointerArray:New()
        this->ELFSections := PointerArray:New()

        this->SymbolTables := PointerArray:New()
        this->SectionRelocationSections := AVLTree:New(#AVLTree*)
        this->RelocationSectionSections := AVLTree:New(#ObjectSection*)

        ; Null section (to pad section indexes)
        this->NullSection := this->CreateSection(SECTION_TYPE_DISCARD, "", 0)

        ; String tables, 1 byte allocated size, 0 bytes actual size (to not skew string table offsets)
        this->SharedStringTable := this->CreateSection(SECTION_TYPE_DATA, ".shstrtab", 1)

        return this
    }

    ; Juggling

    define ObjectSection* AssignSymbolTable(ObjectSymbol* Symbol) {
        return this->_AssignSymbolTable(this->State, Symbol)
    }

    define void AddSection(ObjectSection* Section) {
        ; Adopt a section, and create a dedicated relocation section for it
        ;  if it needs one.

        Section := Section->Clone()
        this->Sections->Push(Section)

        i32 RelocationCount := Section->Relocations->Count()

        if (RelocationCount) {
            AVLTree* RelocationSections := AVLTree:New(#ObjectSection*)
            this->SectionRelocationSections->InsertPointer(Section As i64, RelocationSections)

            for (i32 Index := 0, Index < RelocationCount, Index++) {
                ObjectRelocation* Relocation := Section->Relocations->At(Index)

                ObjectSection* SymbolTableSection := this->AssignSymbolTable(Relocation->Target)
                ObjectSection* RelocationSection := null

                if (RelocationSections->Has(SymbolTableSection As i64)) {
                    RelocationSection := RelocationSections->GetPointer(SymbolTableSection As i64)
                }
                else {
                    i8* RelocationSectionName := FormatString("%s.rela%s", SymbolTableSection->Name, Section->Name)

                    RelocationSection := this->CreateSection(SECTION_TYPE_DATA, RelocationSectionName, 0)

                    RelocationSections->InsertPointer(SymbolTableSection As i64, RelocationSection)

                    this->RelocationSectionSections->InsertPointer(RelocationSection As i64, Section)
                }

                RelocationSection->Relocations->Push(Relocation)
            }

            Section->Relocations->Clear()
        }
    }

    define void AddSections(ObjectFile* File) {
        i32 SectionCount := File->Sections->Count()

        for (i32 Index := 0, Index < SectionCount, Index++) {
            ObjectSection* Section := File->Sections->At(Index)

            this->AddSection(Section)
        }
    }

    define void PopulateFromSymbolTable(ObjectSymbolTable* Source) {
        ; Symbols are moved from the specific symbol table into a less specific
        ;  (and generic) ELF symbol table

        i32 Count := Source->Count()

        for (i32 Index := 0, Index < Count, Index++) {
            ObjectSymbol* Symbol := Source->At(Index)

            ObjectSection* SymbolTableSection := this->AssignSymbolTable(Symbol)

            SymbolTableSection->Symbols->Push(Symbol)
        }
    }

    ; Lowering

    define i32 FindOrAddString(ObjectSection* StringTable, i8* String) {
        i32 Length := StringLength(String)
        i32 Offset := StringTable->Size As i32
        StringTable->Size += Length + 1

        StringTable->Data := ReAlloc(StringTable->Data, StringTable->Size)

        MoveMemory(StringTable->Data + Offset, String, Length)

        return Offset
    }

    define ELFSectionHeader* LowerSection(ObjectSection* Section) {
        ELFSectionHeader* Header := ELFSectionHeader:New()

        Header->NameOffset := this->FindOrAddString(this->SharedStringTable, Section->Name)

        return Header
    }

    define ELFSymbol* TranslateSymbol(ObjectSymbol* Symbol) {
        ELFSymbol* Result := ELFSymbol:New()

        ObjectSection* SymbolTable := this->AssignSymbolTable(Symbol)
        ObjectSection* StringTable := this->Sections->At(this->GetSectionIndex(SymbolTable) - 1)
        Result->NameOffset := this->FindOrAddString(StringTable, Symbol->Name)

        if (Symbol->Section) {
            Result->SectionIndex := this->GetSectionIndex(Symbol->Section) As i16
        }
        else {
            Result->SectionIndex := ELF_SHN_UNDEF
        }

        Result->Value := Symbol->Value
        Result->Size := Symbol->Size

        return Result
    }

    define i32 GetSymbolIndex(ObjectSymbol* Symbol) {
        ObjectSection* SymbolTable := this->AssignSymbolTable(Symbol)
        return SymbolTable->Symbols->Find(Symbol)
    }

    define ELFRelocation* TranslateRelocation(ObjectRelocation* Relocation) {
        ELFRelocation* Result := ELFRelocation:New()

        Result->Offset := Relocation->Offset
        Result->Addend := Relocation->Addend
        Result->Symbol(this->GetSymbolIndex(Relocation->Target))

        return Result
    }

    define void Lower() {
        i32 SectionCount := this->Sections->Count()

        for (i32 Index := 0, Index < SectionCount, Index++) {
            ObjectSection* Section := this->Sections->At(Index)
            ELFSectionHeader* Header := this->LowerSection(Section)

            this->ELFSections->Push(Header)

            if (Section->Relocations->Count()) {
                ObjectRelocation* FirstRelocation := Section->Relocations->First()
                ObjectSection* SymbolTable := this->AssignSymbolTable(FirstRelocation->Target)
                i32 SymbolTableIndex := this->GetSectionIndex(SymbolTable)

                Header->AssociatedSectionIndex := SymbolTableIndex

                ObjectSection* ContainerSection := this->RelocationSectionSections->Get(Section As i64)
                i32 ContainerSectionIndex := this->GetSectionIndex(ContainerSection)

                Header->ExtraInfo := ContainerSectionIndex
            }
            else if (Section->Symbols->Count()) {
                ; Slight hack: symbol tables are directly proceded by their string tables

                Header->AssociatedSectionIndex := Index - 1
            }
        }

        for (i32 Index := 0, Index < SectionCount, Index++) {
            ObjectSection* Section := this->Sections->At(Index)
            ELFSectionHeader* Header := this->ELFSections->At(Index)

            i32 SymbolCount := Section->Symbols->Count()

            if (SymbolCount) {
                Section->Size := 0
                Section->Data := Alloc((SymbolCount + 1) * #ELFSymbol)

                ELFSymbol* Symbols := Section->Data

                for (i32 SymbolIndex := 0, SymbolIndex < SymbolCount, SymbolIndex++) {
                    ObjectSymbol* OriginalSymbol := Section->Symbols->At(SymbolIndex)
                    ELFSymbol* Symbol := this->TranslateSymbol(OriginalSymbol)

                    MoveMemory(Symbols[SymbolIndex], Symbol, #ELFSymbol)

                    ; TODO: Figure out if this is the first non-local
                }
            }
        }

        for (i32 Index := 0, Index < SectionCount, Index++) {
            ObjectSection* Section := this->Sections->At(Index)
            ELFSectionHeader* Header := this->ELFSections->At(Index)

            i32 RelocationCount := Section->Relocations->Count()

            if (RelocationCount) {
                Section->Size := 0
                Section->Data := Alloc((SymbolCount + 1) * #ELFRelocation)

                ELFRelocation* Relocations := Section->Data

                for (i32 RelocationIndex := 0, RelocationIndex < RelocationCount, RelocationIndex++) {
                    ObjectRelocation* OriginalRelocation := Section->Relocations->At(RelocationIndex)
                    ELFRelocation* Relocation := this->TranslateRelocation(OriginalRelocation)

                    MoveMemory(Relocations[RelocationIndex], Relocation, #ELFRelocation)
                }
            }
        }
    }
}

struct ELFPassthroughObjectWriter {
    ELFObjectWriter* Writer

    ObjectSection* SymbolTable

    define ObjectSection* AssignSymbolTable(ObjectSymbol* Symbol) {
        return this->SymbolTable
    }

    static self* New(ObjectFile* File) {
        self* this := Alloc(#self)

        this->Writer := ELFObjectWriter:New(this, &self.AssignSymbolTable)

        this->SymbolTable := this->Writer->CreateSymbolTable(".symtab", ".strtab")

        this->Writer->AddSections(File)

        this->Writer->PopulateFromSymbolTable(File->LocalSymbols)
        this->Writer->PopulateFromSymbolTable(File->GlobalSymbols)
        this->Writer->PopulateFromSymbolTable(File->WeakSymbols)
        this->Writer->PopulateFromSymbolTable(File->UndefinedSymbols)

        return this
    }

    define void Lower() {
        this->Writer->Lower()
    }
}