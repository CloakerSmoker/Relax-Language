
define i8* _R(i32 Index) {
	if (Index >= 16) {
		return Concatenate("stack", IToA(Index - 15))
	}
	
	i8*[16] Names {"rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"}
	
	return Names[Index]
}

/*

I can barely remember how this works

Virtual Register = IR register, a variable or temporary. Unlimited number can exist at once
Real Register = An actual storage location, but not guaranteed to be an actual register.

Now this might sound funky, since virtual/real registers are both abstract ideas of a storage location, *but* real
 registers are Actually partitioned as:
	0-15: Actual x64 registers
	16+ : Offsets into the stack

So, by just having a generic "allocate real register" function and grabbing the next free real register, we can seamlessly
 implement spilling onto the stack, since once the first 16 real registers are allocated, a new one must be created, and
  that new one will live on the stack.
  
This does complicate code a bit though, mainly because before emitting actual instructions, there has to be a check
 for if a register is on the stack or not.
 
 
Better:

Introduce a "storage" concept instead, don't even call it a register.

Each storage location holds a single value from an IR register



StoreVirtualRegister
PutRegisterInFreeStorage
AssignRegisterStorage
DiscardRegisterStorage


*/

struct X64LabelReference {
	i32 LabelNumber
	i32 CodeOffset
}

struct IRToX64 {
	IRCompilerState* IR
	X64Generator* Generator
	
	i8 StorageLocationCount
	i64* StorageLocations
	
	i32 LabelCapacity
	i32 LabelCount
	i32* LabelPositions
	
	i32 LabelReferenceCapacity
	i32 LabelReferenceCount
	X64LabelReference* LabelReferences
	
	static IRToX64* New() {
		IRToX64* this := Alloc(#IRToX64)
		
		this->StorageLocationCount := 16
		this->StorageLocations := Alloc(this->StorageLocationCount * #i64)
		
		this->StorageLocations[RSP] := -1
		this->StorageLocations[RBP] := -1
		this->StorageLocations[R15] := -1
		
		this->Generator := X64Generator:New()
		
		this->LabelCapacity := 100
		this->LabelPositions := Alloc(this->LabelCapacity * #i32)
		
		this->LabelReferenceCapacity := 100
		this->LabelReferences := Alloc(this->LabelReferenceCapacity * #X64LabelReference)
		
		return this
	}
	
	define void SetLabel(i32 LabelNumber) {
	 
	}
	define void UseLabel(i32 LabelNumber) {
		if (this->LabelReferenceCount + 10 >= this->LabelReferenceCapacity) {
			this->LabelReferenceCapacity += 100
			this->LabelReferences := ReAlloc(this->LabelReferences, this->LabelReferenceCapacity * #X64LabelReference)
		}
		
		X64LabelReference* Reference := this->LabelReferences[this->LabelReferenceCount++]
		
		Reference->LabelNumber := LabelNumber
		Reference->CodeOffset := this->Generator->CodeBufferIndex
	}
	
	define i8 GetSystemVParameterStorage(i8 ParameterIndex) {
		if (ParameterIndex < 6) {
			; RDI, RSI, RDX, RCX, R8, R9
			return i8[7, 6, 2, 1, 8, 9][ParameterIndex]
		}
		else {
			; Todo: Stack parameters
			
			return 0
		}
	}
	
	define i8 FindRegisterStorage(i64 Register) {
		for (i8 Index := 0, Index < this->StorageLocationCount, Index++) {
			if (this->StorageLocations[Index] = Register) {
				return Index
			}
		}
		
		IRPrint("Warning, lookup for %t failed\n", Register)
		
		return -1 As i8
	}
	
	define i8 IsStorageOnStack(i64 StorageIndex) {
		return StorageIndex >= 16
	}
	define i32 GetStorageStackOffset(i64 StorageIndex) {
		return ((StorageIndex - 16) * 8) As i32
	}
	
	define i8 AllocateNewStackStorage() {
		i8 Result := this->StorageLocationCount++
		
		this->StorageLocations := ReAlloc(this->StorageLocations, this->StorageLocationCount * #i64)
		
		return Result
	}
	
	define i8 AssignRegisterStorage(i64 Register) {
		for (i8 StorageIndex := 0, StorageIndex < this->StorageLocationCount, StorageIndex++) {
			if (this->StorageLocations[StorageIndex] = 0) {
				this->StorageLocations[StorageIndex] := Register
				
				IRPrint("\t%s now holds virtual value %t\n", _R(StorageIndex), Register)
				;IRPrint("  = %t\n", this->Registers[Index])
				return StorageIndex
			}
		}
		
		StorageIndex := this->AllocateNewStackStorage()
		IRPrint("\t%s now holds virtual value %t\n", _R(StorageIndex), Register)
		this->StorageLocations[StorageIndex] := Register
		
		return StorageIndex
	}
	define i8 ReassignRegisterStorage(i64 Register, i8 StorageIndex) {
		IRPrint("\t%s now holds virtual value %t\n", _R(StorageIndex), Register)
		this->StorageLocations[StorageIndex] := Register
		
		return StorageIndex
	}
	
	define void DiscardStorageValue(i8 StorageIndex) {
		this->StorageLocations[StorageIndex] := 0
	}
	
	define void DiscardRegisterStorage(i64 Register) {
		i8 StorageIndex := this->FindRegisterStorage(Register)
		
		if (StorageIndex < 0) {
			;Print("N/A\n")
			return
		}
		
		IRPrint("\tDiscarding %s, used to hold value %t\n", _R(StorageIndex), Register)

		this->DiscardStorageValue(StorageIndex)
	}
	
	define void EmitMove(i8 DestinationStorageIndex, i8 SourceStorageIndex, i8 Size) {
		i8 DestinationOnStack := this->IsStorageOnStack(DestinationStorageIndex)
		i8 SourceOnStack := this->IsStorageOnStack(SourceStorageIndex)
		
		if (DestinationOnStack && SourceOnStack) {
			i32 SourceStackOffset := this->GetStorageStackOffset(SourceStorageIndex)
			
			SourceStorageIndex := R15
			;EmitMove_RX_RIX_DISPX(this~>Compiler, SourceStorageIndex, RBP, SourceStackOffset, Size)
			
			this->Generator->Move_RX_RIX_DISPX(Size, SourceStorageIndex, RBP, SourceStackOffset)
		}
		
		if (DestinationOnStack) {
			i32 DestinationStackOffset := this->GetStorageStackOffset(DestinationStorageIndex)
			
			;EmitMove_RIX_DISPX_RX(this~>Compiler, RBP, SourceStorageIndex, DestinationStackOffset, Size)
			
			this->Generator->Move_RIX_DISPX_RX(Size, RBP, DestinationStackOffset, SourceStorageIndex)
		}
		else if (SourceOnStack) {
			SourceStackOffset := this->GetStorageStackOffset(SourceStorageIndex)
			
			;EmitMove_RX_RIX_DISPX(this~>Compiler, DestinationStorageIndex, RBP, SourceStackOffset, Size)
			
			this->Generator->Move_RX_RIX_DISPX(Size, DestinationStorageIndex, RBP, SourceStackOffset)
		}
		else {
			;EmitMove_RX_RX(this~>Compiler, DestinationStorageIndex, SourceStorageIndex, Size)
			
			this->Generator->Move_RX_RX(Size, DestinationStorageIndex, SourceStorageIndex)
		}
	}
	
	i32 CurrentFunctionPrologueStart
	i32 CurrentFunctionPrologueEnd
	
	define void EndFunction() {
		i32 StackVariables := this->StorageLocationCount - 16
		
		i32 StackSize := StackVariables * 8
		
		i32 OldIndex := this->Generator->CodeBufferIndex
		i32 PrologueStart := this->CurrentFunctionPrologueStart
		i32 PrologueEnd := this->CurrentFunctionPrologueEnd
		
		if (StackSize < 127) {
			; This is... a bit of a mess. But it is a correct mess
			; The idea is that we've just finished compiling a function which needs X bytes on the stack
			;  and since we can only figure out X by compiling the function, we need to backtrack and
			;   rewrite the `sub rsp, 0` at the start of the function to be `sub rsp, X`.
			; But, in some cases X might be 0, or only a single byte, so we need to handle totally removing
			;  the `sub`, and transforming the `sub rsp, i32` into `sub rsp, i8`
			
			this->Generator->CodeBufferIndex := PrologueStart
			void* Prologue := this->Generator->GetPointerToTail()
			
			if (StackSize != 0) {
				this->Generator->Sub_RX_I8(8, RBP, StackSize As i8)
			}
			
			i32 OldPrologueSize := PrologueEnd - PrologueStart
			i32 NewPrologueSize := this->Generator->CodeBufferIndex - PrologueStart
			
			i32 PrologueSizeDifference := OldPrologueSize - NewPrologueSize
			
			void* OldPrologueTail := Prologue + OldPrologueSize
			void* NewPrologueTail := Prologue + NewPrologueSize
			
			i32 FunctionBodySize := OldIndex - PrologueEnd
			
			MoveMemory(NewPrologueTail, OldPrologueTail, FunctionBodySize)
			
			this->Generator->CodeBufferIndex := PrologueStart + NewPrologueSize + FunctionBodySize
		}
		else {
			this->Generator->CodeBufferIndex := PrologueEnd - 4
			i32* ExistingStackSize := this->Generator->GetPointerToTail() 
			
			*ExistingStackSize := StackSize
			
			this->Generator->CodeBufferIndex := OldIndex
		}
	}
	
	define void EmitNode(IRNode* Node) {
		Print("\tEmitting node: ") Node->Print() Print("\n")
		
		if (Node->Kind = IR_FUNCTION) {
			for (i8 ParameterIndex := 0, ParameterIndex < Node~>FunctionNode->ParameterCount, ParameterIndex++) {
				i64 ParameterRegister := Node~>FunctionNode->Parameters[ParameterIndex]
				i8 ParameterStorage := this->GetSystemVParameterStorage(ParameterIndex)
				
				this->ReassignRegisterStorage(ParameterRegister, ParameterStorage)
			}
			
			this->Generator->Push_R64(RBP)
			this->Generator->Move_RX_RX(8, RBP, RSP)
			
			this->CurrentFunctionPrologueStart := this->Generator->CodeBufferIndex
			
			this->Generator->Sub_RX_I32(8, RBP, 0)
			
			this->CurrentFunctionPrologueEnd := this->Generator->CodeBufferIndex
		}
		else if (Node->Kind = IR_LOAD_INTEGER) {
			i8 IntegerDestination := this->FindRegisterStorage(Node->Destination)
			
			if (this->IsStorageOnStack(IntegerDestination)) {
				i32 IntegerDestinationOffset := this->GetStorageStackOffset(IntegerDestination)
				
				;EmitMove_RIX_DISPX_IX(this~>Compiler, RBP, IntegerDestinationOffset, Node->SourceValue, 4)
				
				; TODO: Handle Node->SourceValue being 64 bits, since Move_RIX_DISPX_IX can only do 8-32 bits
				;  so we'll need to do
				;   mov r15, %value%
				;   mov [RBP + IntegerDestinationOffset], r15
				
				this->Generator->Move_RIX_DISPX_IX(4, RBP, IntegerDestinationOffset, Node->SourceValue As i32)
			}
			else {
				;EmitMove_RX_IX(this~>Compiler, IntegerDestination, Node->SourceValue, 4)
				
				this->Generator->Move_RX_IX(4, IntegerDestination, Node->SourceValue)
			}
		}
		else if (Node->Kind = IR_RETURN) {
			i8 ReturnValue := this->FindRegisterStorage(Node->Operand)
			
			if (ReturnValue != RAX) {
				this->EmitMove(RAX, ReturnValue, Node->Size)
			}
			
			;EmitReturn(this~>Compiler)
			
			this->Generator->Leave()
			this->Generator->Ret()
		}
		else if (Node->Kind = IR_MOVE) {
			i8 MoveDestination := this->FindRegisterStorage(Node->Destination)
			i8 MoveSource := this->FindRegisterStorage(Node->Operand)
			
			this->DiscardStorageValue(MoveDestination)
			this->ReassignRegisterStorage(Node->Destination, MoveSource)
			
			;this->EmitMove(MoveDestination, MoveSource, Node->Size)
		}
		else if (Node->Kind = IR_UNARY) {
			i64 UnaryOperand := Node->Operand
			
			i8 OperandStorage := this->FindRegisterStorage(UnaryOperand)
			
			if (this->IR->GetRegisterReferenceCount(UnaryOperand) != 0) {
				i8 OperandClone := this->AssignRegisterStorage(UnaryOperand)
				
				this->EmitMove(OperandClone, OperandStorage, Node->Size)
				
				OperandStorage := OperandClone
			}
			
			this->DiscardRegisterStorage(Node->Destination)
			this->ReassignRegisterStorage(Node->Destination, OperandStorage)
			
			if (this->IsStorageOnStack(OperandStorage)) {
				i32 OperandStackOffset := this->GetStorageStackOffset(OperandStorage)
				
				if (Node->Operator = OPERATOR_MINUS) {
					;EmitNeg_RIX_DISPX(this~>Compiler, RBP, OperandStackOffset, Node->Size)
					
					this->Generator->Neg_RIX_DISPX(Node->Size, RBP, OperandStackOffset)
				}
				else if (Node->Operator = OPERATOR_BANG) {
					
				}
			}
			else {
				if (Node->Operator = OPERATOR_MINUS) {
					;EmitNeg_RX(this~>Compiler, OperandStorage, Node->Size)
					
					this->Generator->Neg_RX(Node->Size, OperandStorage)
				}
				else if (Node->Operator = OPERATOR_BANG) {
					
				}
			}
		}
		else if (Node->Kind = IR_BINARY) {
			; First, we need to bind the result (virtual) register to the actual register the left operand lives in
			;  since any binary instruction operates in place
			
			i64 LeftOperand := Node~>Operands[0]
			i64 RightOperand := Node~>Operands[1]
			
			IRPrint("Emitting binary expression (%t %o %t)\n", LeftOperand, Node->Operator, RightOperand)
			
			i8 LeftStorage := this->FindRegisterStorage(LeftOperand)
			i8 RightStorage := this->FindRegisterStorage(RightOperand)
			
			if (this->IR->GetRegisterReferenceCount(LeftOperand) != 0) {
				i8 LeftClone := this->AssignRegisterStorage(LeftOperand)
				
				IRPrint("Copied %t to %s from %s for binary, as a future expression must reuse this virtual value\n", LeftOperand, _R(LeftClone), _R(LeftStorage))
				
				this->EmitMove(LeftClone, LeftStorage, Node->Size)
				
				LeftStorage := LeftClone
			}
			
			; Discard the storage automatically assigned to hold the result, and reassign the storage containing
			;  the left side operand to contain the result
			
			this->DiscardRegisterStorage(Node->Destination)
			this->ReassignRegisterStorage(Node->Destination, LeftStorage)
			
			IRPrint("Done with binary fidding, final expression: (%s %o %s)\n", _R(LeftStorage), Node->Operator, _R(RightStorage))
			
			i8 LeftOnStack := this->IsStorageOnStack(LeftStorage)
			i8 RightOnStack := this->IsStorageOnStack(RightStorage)
			
			if (LeftOnStack && RightOnStack) {
				i32 RightStorageStackOffset := this->GetStorageStackOffset(RightStorage)
				
				RightStorage := R15
				
				;EmitMove_RX_RIX_DISPX(this~>Compiler, RightStorage, RBP, RightStorageStackOffset, Node->Size)
				
				this->Generator->Move_RX_RIX_DISPX(Node->Size, RightStorage, RBP, RightStorageStackOffset)
			}
			
			if (LeftOnStack) {
				; Left register lives on the stack
				
				i32 LeftStorageStackOffset := this->GetStorageStackOffset(LeftStorage)
				
				if (Node->Operator = OPERATOR_PLUS) {
					;EmitAdd_RIX_DISPX_RX(this~>Compiler, RBP, RightStorage, LeftStorageStackOffset, Node->Size)
					
					this->Generator->Add_RIX_DISPX_RX(Node->Size, RBP, LeftStorageStackOffset, RightStorage)
				}
			}
			else if (RightOnStack) {
				RightStorageStackOffset := this->GetStorageStackOffset(RightStorage)
				
				if (Node->Operator = OPERATOR_PLUS) {
					;EmitAdd_RX_RIX_DISPX(this~>Compiler, LeftStorage, RBP, RightStorageStackOffset, Node->Size)
					
					this->Generator->Add_RX_RIX_DISPX(Node->Size, LeftStorage, RBP, RightStorageStackOffset)
				}
			}
			else {
				if (Node->Operator = OPERATOR_PLUS) {
					;EmitAdd_RX_RX(this~>Compiler, LeftStorage, RightStorage, Node->Size)
					
					this->Generator->Add_RX_RX(Node->Size, LeftStorage, RightStorage)
				}
			}
		}
		
		Print("\n")
		
	}
	
	define IRBackendTraits* GetTraits() {
		return IRBackendTraits:New(this, &IRToX64.AssignRegisterStorage, &IRToX64.DiscardRegisterStorage, &IRToX64.EmitNode, &IRToX64.EndFunction)
	}
	
	define void PrintCode() {
		for (i32 Index := 0, Index < this->Generator->CodeBufferIndex, Index++) {
			i32 NextByte := this->Generator->CodeBufferBytes[Index]
			
			i8 First := NumberToCharacter(((NextByte >> 4) & 0xF) As i8)
			i8 Second := NumberToCharacter(((NextByte) & 0xF) As i8)
			
			Print("%c%c ", First, Second)
		}
		
		Print("\n")
	}
}