
define i8* _R(i32 Index) {
	if (Index >= 16) {
		return Concatenate("stack", IToA(Index - 15))
	}
	
	i8*[16] Names {"rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"}
	
	return Names[Index]
}

/*

I can barely remember how this works

Virtual Register = IR register, a variable or temporary. Unlimited number can exist at once
Real Register = An actual storage location, but not guaranteed to be an actual register.

Now this might sound funky, since virtual/real registers are both abstract ideas of a storage location, *but* real
 registers are Actually partitioned as:
	0-15: Actual x64 registers
	16+ : Offsets into the stack

So, by just having a generic "allocate real register" function and grabbing the next free real register, we can seamlessly
 implement spilling onto the stack, since once the first 16 real registers are allocated, a new one must be created, and
  that new one will live on the stack.
  
This does complicate code a bit though, mainly because before emitting actual instructions, there has to be a check
 for if a register is on the stack or not.
 
 
Better:

Introduce a "storage" concept instead, don't even call it a register.

Each storage location holds a single value from an IR register



StoreVirtualRegister
PutRegisterInFreeStorage
AssignRegisterStorage
DiscardRegisterStorage


*/

struct X64LabelReference {
	i32 LabelNumber
	i32 CodeOffset
}

i8 X64_TEMP_REGISTER := RDX ; register used for when data we need in a register is stored elsewhere

struct IRToX64 {
	IRCompilerState* IR
	X64Generator* Generator
	
	i8 StorageLocationCount
	i64* StorageLocations
	
	i32 LabelCapacity
	i32 LabelCount
	i32* LabelPositions
	
	i32 LabelReferenceCapacity
	i32 LabelReferenceCount
	X64LabelReference* LabelReferences
	
	static IRToX64* New() {
		IRToX64* this := Alloc(#IRToX64)
		
		this->StorageLocationCount := 16
		this->StorageLocations := Alloc(this->StorageLocationCount * #i64)
		
		this->StorageLocations[X64_TEMP_REGISTER] := -1
		this->StorageLocations[RSP] := -1
		this->StorageLocations[RBP] := -1
		
		this->Generator := X64Generator:New()
		
		this->LabelCapacity := 100
		this->LabelPositions := Alloc(this->LabelCapacity * #i32)
		
		this->LabelReferenceCapacity := 100
		this->LabelReferences := Alloc(this->LabelReferenceCapacity * #X64LabelReference)
		
		return this
	}
	
	define void SetLabel(i32 LabelNumber) {
		if (LabelNumber + 20 >= this->LabelCapacity) {
			this->LabelCapacity := LabelNumber + 50
			this->LabelPositions := ReAlloc(this->LabelPositions, this->LabelCapacity * #i32)
		}
		
		Print("Lable[%i] := %x\n", LabelNumber, this->Generator->CodeBufferIndex)
		
		this->LabelPositions[LabelNumber] := this->Generator->CodeBufferIndex
	}
	define void UseLabel(i32 LabelNumber) {
		if (this->LabelReferenceCount + 10 >= this->LabelReferenceCapacity) {
			this->LabelReferenceCapacity += 100
			this->LabelReferences := ReAlloc(this->LabelReferences, this->LabelReferenceCapacity * #X64LabelReference)
		}
		
		Print("UseLabel %i at %i\n", LabelNumber, this->Generator->CodeBufferIndex - 4)
		
		X64LabelReference* Reference := this->LabelReferences[this->LabelReferenceCount++]
		
		Reference->LabelNumber := LabelNumber
		Reference->CodeOffset := this->Generator->CodeBufferIndex - 4
	}
	define void LinkLabels() {
		Print("LRC %i\n", this->LabelReferenceCount)
		
		for (i32 Index := 0, Index < this->LabelReferenceCount, Index++) {
			X64LabelReference* Reference := this->LabelReferences[Index]
			
			
			i32 Destination := this->LabelPositions[Reference->LabelNumber]
			i32* Placeholder := this->Generator->CodeBuffer + Reference->CodeOffset
			i32 Displacement := Destination - (Reference->CodeOffset + 4)
			
			Print("%i => %i (%i)\n", Reference->CodeOffset, Destination, Displacement)
			
			Placeholder[0] += Displacement
			
			Print("%i\n", Placeholder[0])
		}
	}
	
	define i8 GetSystemVParameterStorage(i8 ParameterIndex) {
		if (ParameterIndex < 6) {
			; RDI, RSI, RDX, RCX, R8, R9
			return i8[7, 6, 2, 1, 8, 9][ParameterIndex]
		}
		else {
			; Todo: Stack parameters
			
			return 0
		}
	}
	
	define i8 FindRegisterStorage(i64 Register) {
		for (i8 Index := 0, Index < this->StorageLocationCount, Index++) {
			if (this->StorageLocations[Index] = Register) {
				return Index
			}
		}
		
		IRPrint("Warning, lookup for %t failed\n", Register)
		
		return -1 As i8
	}
	
	define i8 IsStorageOnStack(i64 StorageIndex) {
		return StorageIndex >= 16
	}
	define i32 GetStorageStackOffset(i64 StorageIndex) {
		return ((StorageIndex - 16) * 8) As i32
	}
	
	define i8 AllocateNewStackStorage() {
		i8 Result := this->StorageLocationCount++
		
		this->StorageLocations := ReAlloc(this->StorageLocations, this->StorageLocationCount * #i64)
		
		return Result
	}
	
	define i8 AssignRegisterStorage(i64 Register) {
		for (i8 StorageIndex := 0, StorageIndex < this->StorageLocationCount, StorageIndex++) {
			if (this->StorageLocations[StorageIndex] = 0) {
				this->StorageLocations[StorageIndex] := Register
				
				IRPrint("\t%s now holds virtual value %t\n", _R(StorageIndex), Register)
				;IRPrint("  = %t\n", this->Registers[Index])
				return StorageIndex
			}
		}
		
		StorageIndex := this->AllocateNewStackStorage()
		IRPrint("\t%s now holds virtual value %t\n", _R(StorageIndex), Register)
		this->StorageLocations[StorageIndex] := Register
		
		return StorageIndex
	}
	define i8 ReassignRegisterStorage(i64 Register, i8 StorageIndex) {
		IRPrint("\t%s now holds virtual value %t\n", _R(StorageIndex), Register)
		this->StorageLocations[StorageIndex] := Register
		
		return StorageIndex
	}
	
	define void DiscardStorageValue(i8 StorageIndex) {
		this->StorageLocations[StorageIndex] := 0
	}
	
	define void DiscardRegisterStorage(i64 Register) {
		i8 StorageIndex := this->FindRegisterStorage(Register)
		
		if (StorageIndex < 0) {
			;Print("N/A\n")
			return
		}
		
		IRPrint("\tDiscarding %s, used to hold value %t\n", _R(StorageIndex), Register)

		this->DiscardStorageValue(StorageIndex)
	}
	
	define void EmitMove(i8 DestinationStorageIndex, i8 SourceStorageIndex, i8 Size) {
		i8 DestinationOnStack := this->IsStorageOnStack(DestinationStorageIndex)
		i8 SourceOnStack := this->IsStorageOnStack(SourceStorageIndex)
		
		if (DestinationOnStack && SourceOnStack) {
			i32 SourceStackOffset := this->GetStorageStackOffset(SourceStorageIndex)
			
			SourceStorageIndex := X64_TEMP_REGISTER
			;EmitMove_RX_RIX_DISPX(this~>Compiler, SourceStorageIndex, RBP, SourceStackOffset, Size)
			
			this->Generator->Move_RX_RIX_DISPX(Size, SourceStorageIndex, RBP, SourceStackOffset)
		}
		
		if (DestinationOnStack) {
			i32 DestinationStackOffset := this->GetStorageStackOffset(DestinationStorageIndex)
			
			;EmitMove_RIX_DISPX_RX(this~>Compiler, RBP, SourceStorageIndex, DestinationStackOffset, Size)
			
			this->Generator->Move_RIX_DISPX_RX(Size, RBP, DestinationStackOffset, SourceStorageIndex)
		}
		else if (SourceOnStack) {
			SourceStackOffset := this->GetStorageStackOffset(SourceStorageIndex)
			
			;EmitMove_RX_RIX_DISPX(this~>Compiler, DestinationStorageIndex, RBP, SourceStackOffset, Size)
			
			this->Generator->Move_RX_RIX_DISPX(Size, DestinationStorageIndex, RBP, SourceStackOffset)
		}
		else {
			;EmitMove_RX_RX(this~>Compiler, DestinationStorageIndex, SourceStorageIndex, Size)
			
			this->Generator->Move_RX_RX(Size, DestinationStorageIndex, SourceStorageIndex)
		}
	}
	
	i32 CurrentFunctionLabelBase
	i32 CurrentFunctionLabelReferenceBase
	i32 CurrentFunctionPrologueStart
	i32 CurrentFunctionPrologueEnd
	
	define void EndFunction() {
		i32 StackVariables := this->StorageLocationCount - 16
		
		i32 StackSize := StackVariables * 8
		
		i32 OldIndex := this->Generator->CodeBufferIndex
		i32 PrologueStart := this->CurrentFunctionPrologueStart
		i32 PrologueEnd := this->CurrentFunctionPrologueEnd
		
		if (StackSize < 127) {
			; This is... a bit of a mess. But it is a correct mess
			; The idea is that we've just finished compiling a function which needs X bytes on the stack
			;  and since we can only figure out X by compiling the function, we need to backtrack and
			;   rewrite the `sub rsp, 0` at the start of the function to be `sub rsp, X`.
			; But, in some cases X might be 0, or only a single byte, so we need to handle totally removing
			;  the `sub`, and transforming the `sub rsp, i32` into `sub rsp, i8`
			
			this->Generator->CodeBufferIndex := PrologueStart
			void* Prologue := this->Generator->GetPointerToTail()
			
			if (StackSize != 0) {
				this->Generator->Sub_RX_I8(8, RBP, StackSize As i8)
			}
			
			i32 OldPrologueSize := PrologueEnd - PrologueStart
			i32 NewPrologueSize := this->Generator->CodeBufferIndex - PrologueStart
			
			i32 PrologueSizeDifference := OldPrologueSize - NewPrologueSize
			
			void* OldPrologueTail := Prologue + OldPrologueSize
			void* NewPrologueTail := Prologue + NewPrologueSize
			
			i32 FunctionBodySize := OldIndex - PrologueEnd
			
			MoveMemory(NewPrologueTail, OldPrologueTail, FunctionBodySize)
			
			i32 LabelBase := this->CurrentFunctionLabelBase
			i32 LabelCount := this->LabelCount - LabelBase
			
			for (i32 LabelIndex := 0, LabelIndex < LabelCount, LabelIndex++) {
				this->LabelPositions[LabelBase + LabelIndex] -= PrologueSizeDifference
			}
			
			i32 LabelReferenceBase := this->CurrentFunctionLabelReferenceBase
			i32 LabelReferenceCount := this->LabelReferenceCount - LabelReferenceBase
			
			for (LabelIndex := 0, LabelIndex < LabelReferenceCount, LabelIndex++) {
				this->LabelReferences[LabelReferenceBase + LabelIndex]->CodeOffset -= PrologueSizeDifference
			}
			
			this->Generator->CodeBufferIndex := PrologueStart + NewPrologueSize + FunctionBodySize
		}
		else {
			this->Generator->CodeBufferIndex := PrologueEnd - 4
			i32* ExistingStackSize := this->Generator->GetPointerToTail() 
			
			*ExistingStackSize := StackSize
			
			this->Generator->CodeBufferIndex := OldIndex
		}
	}
	
	define i8 IsComparison(i32 Operator) {
		return (OPERATOR_FIRST_SHORT_CIRCUIT <= Operator && Operator <= OPERATOR_LAST_COMPARISON)
	}
	
	define void EmitNode(IRNode* Node) {
		Print("\tEmitting node: ") Node->Print() Print("\n")
		
		if (Node->Kind = IR_FUNCTION) {
			for (i8 ParameterIndex := 0, ParameterIndex < Node~>FunctionNode->ParameterCount, ParameterIndex++) {
				i64 ParameterRegister := Node~>FunctionNode->Parameters[ParameterIndex]
				i8 ParameterStorage := this->GetSystemVParameterStorage(ParameterIndex)
				
				this->ReassignRegisterStorage(ParameterRegister, ParameterStorage)
			}
			
			this->Generator->Push_R64(RBP)
			this->Generator->Move_RX_RX(8, RBP, RSP)
			
			this->CurrentFunctionPrologueStart := this->Generator->CodeBufferIndex
			
			this->Generator->Sub_RX_I32(8, RBP, 0)
			
			this->CurrentFunctionPrologueEnd := this->Generator->CodeBufferIndex
			
			this->CurrentFunctionLabelBase := this->LabelCount
			this->CurrentFunctionLabelReferenceBase := this->LabelReferenceCount
		}
		else if (Node->Kind = IR_LOAD_INTEGER) {
			i8 IntegerDestination := this->FindRegisterStorage(Node->Destination)
			
			if (this->IsStorageOnStack(IntegerDestination)) {
				i32 IntegerDestinationOffset := this->GetStorageStackOffset(IntegerDestination)
				
				;EmitMove_RIX_DISPX_IX(this~>Compiler, RBP, IntegerDestinationOffset, Node->SourceValue, 4)
				
				; TODO: Handle Node->SourceValue being 64 bits, since Move_RIX_DISPX_IX can only do 8-32 bits
				;  so we'll need to do
				;   mov X64_TEMP_REGISTER, %value%
				;   mov [RBP + IntegerDestinationOffset], X64_TEMP_REGISTER
				
				this->Generator->Move_RIX_DISPX_IX(4, RBP, IntegerDestinationOffset, Node->SourceValue As i32)
			}
			else {
				;EmitMove_RX_IX(this~>Compiler, IntegerDestination, Node->SourceValue, 4)
				
				this->Generator->Move_RX_IX(4, IntegerDestination, Node->SourceValue)
			}
		}
		else if (Node->Kind = IR_RETURN) {
			i8 ReturnValue := this->FindRegisterStorage(Node->Operand)
			
			if (ReturnValue != RAX) {
				this->EmitMove(RAX, ReturnValue, Node->Size)
			}
			
			;EmitReturn(this~>Compiler)
			
			this->Generator->Leave()
			this->Generator->Ret()
		}
		else if (Node->Kind = IR_MOVE) {
			i8 MoveDestination := this->FindRegisterStorage(Node->Destination)
			i8 MoveSource := this->FindRegisterStorage(Node->Operand)
			
			this->DiscardStorageValue(MoveDestination)
			this->ReassignRegisterStorage(Node->Destination, MoveSource)
			
			;this->EmitMove(MoveDestination, MoveSource, Node->Size)
		}
		else if (Node->Kind = IR_UNARY) {
			i64 UnaryOperand := Node->Operand
			
			i8 OperandStorage := this->FindRegisterStorage(UnaryOperand)
			
			if (Node->Destination != UnaryOperand && this->IR->GetRegisterReferenceCount(UnaryOperand) != 0) {
				i8 OperandClone := this->AssignRegisterStorage(UnaryOperand)
				
				this->EmitMove(OperandClone, OperandStorage, Node->Size)
				
				OperandStorage := OperandClone
			}
			
			this->DiscardRegisterStorage(Node->Destination)
			this->ReassignRegisterStorage(Node->Destination, OperandStorage)
			
			if (this->IsStorageOnStack(OperandStorage)) {
				i32 OperandStackOffset := this->GetStorageStackOffset(OperandStorage)
				
				if (Node->Operator = OPERATOR_MINUS) {
					this->Generator->Neg_RIX_DISPX(Node->Size, RBP, OperandStackOffset)
				}
				else if (Node->Operator = OPERATOR_TILDE) {
					this->Generator->Not_RIX_DISPX(Node->Size, RBP, OperandStackOffset)
				}
				else if (Node->Operator = OPERATOR_BANG) {
					this->Generator->Cmp_RIX_DISPX_I8(Node->Size, RBP, OperandStackOffset, 0)
					this->Generator->SetE_RI8_DISPX(RBP, OperandStackOffset)
				}
			}
			else {
				if (Node->Operator = OPERATOR_MINUS) {
					this->Generator->Neg_RX(Node->Size, OperandStorage)
				}
				else if (Node->Operator = OPERATOR_TILDE) {
					this->Generator->Not_RX(Node->Size, OperandStorage)
				}
				else if (Node->Operator = OPERATOR_BANG) {
					this->Generator->Test_RX_RX(Node->Size, OperandStorage, OperandStorage)
					this->Generator->SetE_R8(OperandStorage)
				}
			}
		}
		else if (Node->Kind = IR_BINARY) {
			; First, we need to bind the result (virtual) register to the actual register the left operand lives in
			;  since any binary instruction operates in place
			
			i64 LeftOperand := Node~>Operands[0]
			i64 RightOperand := Node~>Operands[1]
			
			IRPrint("Emitting binary expression (%t %o %t)\n", LeftOperand, Node->Operator, RightOperand)
			
			i8 LeftStorage := this->FindRegisterStorage(LeftOperand)
			i8 RightStorage := this->FindRegisterStorage(RightOperand)
			
			if (Node->Destination != LeftOperand && this->IR->GetRegisterReferenceCount(LeftOperand) != 0) {
				i8 LeftClone := this->AssignRegisterStorage(LeftOperand)
				
				IRPrint("Copied %t to %s from %s for binary, as a future expression must reuse this virtual value\n", LeftOperand, _R(LeftClone), _R(LeftStorage))
				
				this->EmitMove(LeftClone, LeftStorage, Node->Size)
				
				LeftStorage := LeftClone
			}
			
			; Discard the storage automatically assigned to hold the result, and reassign the storage containing
			;  the left side operand to contain the result
			
			this->DiscardRegisterStorage(Node->Destination)
			this->ReassignRegisterStorage(Node->Destination, LeftStorage)
			
			IRPrint("Done with binary fidding, final expression: (%s %o %s)\n", _R(LeftStorage), Node->Operator, _R(RightStorage))
			
			i8 LeftOnStack := this->IsStorageOnStack(LeftStorage)
			i8 RightOnStack := this->IsStorageOnStack(RightStorage)
			
			if (LeftOnStack && RightOnStack) {
				i32 RightStorageStackOffset := this->GetStorageStackOffset(RightStorage)
				
				RightStorage := X64_TEMP_REGISTER
				
				;EmitMove_RX_RIX_DISPX(this~>Compiler, RightStorage, RBP, RightStorageStackOffset, Node->Size)
				
				this->Generator->Move_RX_RIX_DISPX(Node->Size, RightStorage, RBP, RightStorageStackOffset)
			}
			
			if (LeftOnStack) {
				i32 LeftStorageStackOffset := this->GetStorageStackOffset(LeftStorage)
				
				if (this->IsComparison(Node->Operator)) {
					this->Generator->Cmp_RIX_DISPX_RX(Node->Size, RBP, LeftStorageStackOffset, RightStorage)
				}
				
				if (Node->Operator = OPERATOR_PLUS) {
					;EmitAdd_RIX_DISPX_RX(this~>Compiler, RBP, RightStorage, LeftStorageStackOffset, Node->Size)
					
					this->Generator->Add_RIX_DISPX_RX(Node->Size, RBP, LeftStorageStackOffset, RightStorage)
				}
				else if (Node->Operator = OPERATOR_MINUS) {
					this->Generator->Sub_RIX_DISPX_RX(Node->Size, RBP, LeftStorageStackOffset, RightStorage)
				}
				else if (Node->Operator = OPERATOR_STAR) {
					; IMul only has RM encodings, so we need to swap things around so we do a RM operation
					;  but store the result in M without touching R
					
					this->Generator->XChg_RX_RIX_DISPX(Node->Size, RightStorage, RBP, LeftStorageStackOffset)
					this->Generator->IMul_RX_RIX_DISPX(Node->Size, RightStorage, RBP, LeftStorageStackOffset)
					this->Generator->XChg_RX_RIX_DISPX(Node->Size, RightStorage, RBP, LeftStorageStackOffset)
				}
				else if (Node->Operator = OPERATOR_SLASH || Node->Operator = OPERATOR_PERCENT) {
					; `stack / register` or `stack % register`
					;  First, we need to get `stack` into RAX without clobbering RAX
					
					if (this->StorageLocations[RAX]) {
						; RAX has a value, swap it and `stack` (saving the old value)
						
						this->Generator->XChg_RX_RIX_DISPX(Node->Size, RAX, RBP, LeftStorageStackOffset)
					}
					else {
						; RAX doesn't have a value, just move `stack` into RAX
						
						this->Generator->Move_RX_RIX_DISPX(Node->Size, RAX, RBP, LeftStorageStackOffset)
					}
					
					this->Generator->CXX(Node->Size)
					this->Generator->IDiv_RAX_RX(Node->Size, RightStorage)
					
					; Alright, we've done the operation, now we need to:
					;  Move our result (which is in RAX for `/`, and RDX for `%`) back to `stack`
					;  Restore the old value of RAX (if it had an old value)
					
					if (this->StorageLocations[RAX]) {
						; No matter the operator, swap RAX and `stack` back if RAX needs to be restored
						; This always puts the result of `stack / register` into `stack`, which might be the correct
						;  result, but for `stack % register` we need to still move RDX into `stack`
						
						this->Generator->XChg_RX_RIX_DISPX(Node->Size, RAX, RBP, LeftStorageStackOffset)
					}
					else if (Node->Operator = OPERATOR_SLASH) {
						; RAX didn't have a value, we don't need to restore it, and can directly our result from RAX
						;  to stack
						
						this->Generator->Move_RIX_DISPX_RX(Node->Size, RBP, LeftStorageStackOffset, RAX)
					}
					
					; Ok, so by now we're 100% certain that RAX holds the correct value, and that `stack / register` is all
					;  done, which means we only need to store the result of `stack % register` into the right place, and
					;   we're done.
					
					if (Node->Operator = OPERATOR_PERCENT) {
						this->Generator->Move_RIX_DISPX_RX(Node->Size, RBP, LeftStorageStackOffset, RDX)
					}
				}
				else if (Node->Operator = OPERATOR_EQUAL) {
					this->Generator->SetE_RI8_DISPX(RBP, LeftStorageStackOffset)
				}
				else if (Node->Operator = OPERATOR_BANG_EQUAL) {
					this->Generator->SetNE_RI8_DISPX(RBP, LeftStorageStackOffset)
				}
				else if (Node->Operator = OPERATOR_LESS) {
					this->Generator->SetL_RI8_DISPX(RBP, LeftStorageStackOffset)
				}
				else if (Node->Operator = OPERATOR_LESS_EQAUL) {
					this->Generator->SetLE_RI8_DISPX(RBP, LeftStorageStackOffset)
				}
				else if (Node->Operator = OPERATOR_GREATER) {
					this->Generator->SetG_RI8_DISPX(RBP, LeftStorageStackOffset)
				}
				else if (Node->Operator = OPERATOR_GREATER_EQAUL) {
					this->Generator->SetGE_RI8_DISPX(RBP, LeftStorageStackOffset)
				}
				else if (Node->Operator = OPERATOR_AND) {
					this->Generator->And_RIX_DISPX_RX(Node->Size, RBP, LeftStorageStackOffset, RightStorage)
				}
				else if (Node->Operator = OPERATOR_OR) {
					this->Generator->Or_RIX_DISPX_RX(Node->Size, RBP, LeftStorageStackOffset, RightStorage)
				}
				else if (Node->Operator = OPERATOR_XOR) {
					this->Generator->Xor_RIX_DISPX_RX(Node->Size, RBP, LeftStorageStackOffset, RightStorage)
				}
				else if (Node->Operator = OPERATOR_LESS_LESS || Node->Operator = OPERATOR_GREATER_GREATER) {
					if (RightStorage != RCX) {
						if (this->StorageLocations[RCX] = 0) {
							this->Generator->Move_RX_RX(Node->Size, RCX, RightStorage)
						}
						else {
							this->Generator->XChg_RX_RX(Node->Size, RCX, RightStorage)
						}
					}
					
					if (Node->Operator = OPERATOR_LESS_LESS) {
						this->Generator->SAL_RIX_DISPX_CL(Node->Size, RBP, LeftStorageStackOffset)
					}
					else if (Node->Operator = OPERATOR_GREATER_GREATER) {
						this->Generator->SHR_RIX_DISPX_CL(Node->Size, RBP, LeftStorageStackOffset)
					}
					
					if (RightStorage != RCX && this->StorageLocations[RCX] != 0) {
						this->Generator->XChg_RX_RX(Node->Size, RCX, RightStorage)
					}
				}
			}
			else if (RightOnStack) {
				RightStorageStackOffset := this->GetStorageStackOffset(RightStorage)
				
				if (this->IsComparison(Node->Operator)) {
					this->Generator->Cmp_RX_RIX_DISPX(Node->Size, LeftStorage, RBP, RightStorageStackOffset)
				}
				
				if (Node->Operator = OPERATOR_PLUS) {
					;EmitAdd_RX_RIX_DISPX(this~>Compiler, LeftStorage, RBP, RightStorageStackOffset, Node->Size)
					
					this->Generator->Add_RX_RIX_DISPX(Node->Size, LeftStorage, RBP, RightStorageStackOffset)
				}
				else if (Node->Operator = OPERATOR_MINUS) {
					this->Generator->Sub_RX_RIX_DISPX(Node->Size, LeftStorage, RBP, RightStorageStackOffset)
				}
				else if (Node->Operator = OPERATOR_STAR) {
					this->Generator->IMul_RX_RIX_DISPX(Node->Size, LeftStorage, RBP, RightStorageStackOffset)
				}
				else if (Node->Operator = OPERATOR_SLASH || Node->Operator = OPERATOR_PERCENT) {
					if (LeftStorage != RAX) {
						if (this->StorageLocations[RAX]) {						
							this->Generator->XChg_RAX_R64(LeftStorage)
						}
						else {
							this->Generator->Move_RX_RX(Node->Size, RAX, LeftStorage)
						}
					}
					
					this->Generator->CXX(Node->Size)
					this->Generator->IDiv_RAX_RIX_DISPX(Node->Size, RBP, RightStorageStackOffset)
					
					if (LeftStorage != RAX) {
						if (this->StorageLocations[RAX]) {						
							this->Generator->XChg_RAX_R64(LeftStorage)
						}
						else if (Node->Operator = OPERATOR_SLASH) {
							this->Generator->Move_RX_RX(Node->Size, LeftStorage, RAX)
						}
						
						if (Node->Operator = OPERATOR_PERCENT) {
							this->Generator->Move_RX_RX(Node->Size, LeftStorage, RDX)
						}
					}
				}
				else if (Node->Operator = OPERATOR_EQUAL) {
					this->Generator->SetE_R8(LeftStorage)
				}
				else if (Node->Operator = OPERATOR_BANG_EQUAL) {
					this->Generator->SetNE_R8(LeftStorage)
				}
				else if (Node->Operator = OPERATOR_LESS) {
					this->Generator->SetL_R8(LeftStorage)
				}
				else if (Node->Operator = OPERATOR_LESS_EQAUL) {
					this->Generator->SetLE_R8(LeftStorage)
				}
				else if (Node->Operator = OPERATOR_GREATER) {
					this->Generator->SetG_R8(LeftStorage)
				}
				else if (Node->Operator = OPERATOR_GREATER_EQAUL) {
					this->Generator->SetGE_R8(LeftStorage)
				}
				else if (Node->Operator = OPERATOR_AND) {
					this->Generator->And_RX_RIX_DISPX(Node->Size, LeftStorage, RBP, RightStorageStackOffset)
				}
				else if (Node->Operator = OPERATOR_OR) {
					this->Generator->Or_RX_RIX_DISPX(Node->Size, LeftStorage, RBP, RightStorageStackOffset)
				}
				else if (Node->Operator = OPERATOR_XOR) {
					this->Generator->Xor_RX_RIX_DISPX(Node->Size, LeftStorage, RBP, RightStorageStackOffset)
				}
				else if (Node->Operator = OPERATOR_LESS_LESS || Node->Operator = OPERATOR_GREATER_GREATER) {
					; We need to get the right operand off of the stack, and into RCX
					
					if (this->StorageLocations[RCX] = 0) {
						; RCX doesn't hold anything, just overwrite it
						
						this->Generator->Move_RX_RIX_DISPX(Node->Size, RCX, RBP, RightStorageStackOffset)
					}
					else {
						; RCX holds a value
						
						if (LeftStorage = RCX) {
							; RCX is the left operand, move it to the temp register, and then overwrite it
							
							LeftStorage := X64_TEMP_REGISTER
							
							this->Generator->Move_RX_RX(Node->Size, LeftStorage, RCX)
							this->Generator->Move_RX_RIX_DISPX(Node->Size, RCX, RBP, RightStorageStackOffset)
						}
						else {
							; Swap the old value onto the stack, and the right operand into RCX
							
							this->Generator->XChg_RX_RIX_DISPX(Node->Size, RCX, RBP, RightStorageStackOffset)
						}
					}
					
					; Do the operation
					
					if (Node->Operator = OPERATOR_LESS_LESS) {
						this->Generator->SAL_RX_CL(Node->Size, LeftStorage)
					}
					else if (Node->Operator = OPERATOR_GREATER_GREATER) {
						this->Generator->SHR_RX_CL(Node->Size, LeftStorage)
					}
					
					if (this->StorageLocations[RCX] != 0) {
						; We have an old value we need to restore RCX to
						
						if (LeftStorage = X64_TEMP_REGISTER) {
							; Old value was the left operand, move it directly back into RCX
							
							this->Generator->Move_RX_RX(Node->Size, RCX, X64_TEMP_REGISTER)
						}
						else {
							; Old value was swapped onto stack, swap it back into RCX
							
							this->Generator->XChg_RX_RIX_DISPX(Node->Size, RCX, RBP, RightStorageStackOffset)
						}
					}
				}
			}
			else {
				if (this->IsComparison(Node->Operator)) {
					this->Generator->Cmp_RX_RX(Node->Size, LeftStorage, RightStorage)
				}
				
				if (Node->Operator = OPERATOR_PLUS) {
					;EmitAdd_RX_RX(this~>Compiler, LeftStorage, RightStorage, Node->Size)
					
					this->Generator->Add_RX_RX(Node->Size, LeftStorage, RightStorage)
				}
				else if (Node->Operator = OPERATOR_MINUS) {
					this->Generator->Sub_RX_RX(Node->Size, LeftStorage, RightStorage)
				}
				else if (Node->Operator = OPERATOR_STAR) {
					this->Generator->IMul_RX_RX(Node->Size, LeftStorage, RightStorage)
				}
				else if (Node->Operator = OPERATOR_SLASH || Node->Operator = OPERATOR_PERCENT) {
					if (LeftStorage != RAX) {
						if (this->StorageLocations[RAX]) {
							this->Generator->XChg_RAX_R64(LeftStorage)
						}
						else {
							this->Generator->Move_RX_RX(Node->Size, RAX, LeftStorage)
						}
						
						if (RightStorage = RAX) {
							; If we've just swapped the left operand into RAX, and the right operand into LeftStorage
							;  from RAX then we need to update RightStorage to be the register that was swapped into 
							;   instead of RAX
							
							RightStorage := LeftStorage
						}
					}
					
					this->Generator->CXX(Node->Size)
					this->Generator->IDiv_RAX_RX(Node->Size, RightStorage)
					
					if (LeftStorage != RAX) {
						if (this->StorageLocations[RAX]) {
							this->Generator->XChg_RAX_R64(LeftStorage)
						}
						else if (Node->Operator = OPERATOR_SLASH) {
							this->Generator->Move_RX_RX(Node->Size, LeftStorage, RAX)
						}
						
						if (Node->Operator = OPERATOR_PERCENT) {
							this->Generator->Move_RX_RX(Node->Size, LeftStorage, RDX)
						}
					}
				}
				else if (Node->Operator = OPERATOR_EQUAL) {
					this->Generator->SetE_R8(LeftStorage)
				}
				else if (Node->Operator = OPERATOR_BANG_EQUAL) {
					this->Generator->SetNE_R8(LeftStorage)
				}
				else if (Node->Operator = OPERATOR_LESS) {
					this->Generator->SetL_R8(LeftStorage)
				}
				else if (Node->Operator = OPERATOR_LESS_EQAUL) {
					this->Generator->SetLE_R8(LeftStorage)
				}
				else if (Node->Operator = OPERATOR_GREATER) {
					this->Generator->SetG_R8(LeftStorage)
				}
				else if (Node->Operator = OPERATOR_GREATER_EQAUL) {
					this->Generator->SetGE_R8(LeftStorage)
				}
				else if (Node->Operator = OPERATOR_AND) {
					this->Generator->And_RX_RX(Node->Size, LeftStorage, RightStorage)
				}
				else if (Node->Operator = OPERATOR_OR) {
					this->Generator->Or_RX_RX(Node->Size, LeftStorage, RightStorage)
				}
				else if (Node->Operator = OPERATOR_XOR) {
					this->Generator->Xor_RX_RX(Node->Size, LeftStorage, RightStorage)
				}
				else if (Node->Operator = OPERATOR_LESS_LESS || Node->Operator = OPERATOR_GREATER_GREATER) {
					if (RightStorage != RCX) {
						if (this->StorageLocations[RCX] = 0) {
							this->Generator->Move_RX_RX(Node->Size, RCX, RightStorage)
						}
						else {							
							this->Generator->XChg_RX_RX(Node->Size, RCX, RightStorage)
						}
					}
					
					if (Node->Operator = OPERATOR_LESS_LESS) {
						this->Generator->SAL_RX_CL(Node->Size, LeftStorage)
					}
					else if (Node->Operator = OPERATOR_GREATER_GREATER) {
						this->Generator->SHR_RX_CL(Node->Size, LeftStorage)
					}
					
					if (RightStorage != RCX && this->StorageLocations[RCX] != 0) {
						this->Generator->XChg_RX_RX(Node->Size, RCX, RightStorage)
					}
				}
			}
		}
		else if (Node->Kind = IR_JUMP) {
			this->Generator->JMP_REL32(0)
			this->UseLabel(Node->JumpToBlock)
		}
		
		Print("\n")
		
	}
	
	define IRBackendTraits* GetTraits() {
		return IRBackendTraits:New(this, &IRToX64.AssignRegisterStorage, &IRToX64.DiscardRegisterStorage, &IRToX64.EmitNode, &IRToX64.SetLabel, &IRToX64.EndFunction)
	}
	
	define void PrintCode() {
		for (i32 Index := 0, Index < this->Generator->CodeBufferIndex, Index++) {
			i32 NextByte := this->Generator->CodeBufferBytes[Index]
			
			i8 First := NumberToCharacter(((NextByte >> 4) & 0xF) As i8)
			i8 Second := NumberToCharacter(((NextByte) & 0xF) As i8)
			
			Print("%c%c ", First, Second)
		}
		
		Print("\n")
	}
}