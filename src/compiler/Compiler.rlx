/*
==========================================
	Backing compiler state
==========================================
*/

#Require "./src/elf/Library.rlx"
#Require "$/ByteArray.rlx"

#Require "./src/compiler/DWARF/DWARFBuilder.rlx"

struct LabelInfo {
	i32 LabelNumber,
	i32 OffsetToReplace,
	i8 IsPlaceholder
}

declare i8 GetSystemVRegister(i32)
declare i32 GetVariableOffset(CompilerState*, VariableInfo*, i8*)

struct CompilerState {
	BuildConfig* Config,
	ParserState* Parser,
	FunctionDefine* CurrentFunction,
	
	union {
		/* Output file builders */
		
		PEBuilder* PE,
		ELFBuilder* ELF
	},
	
	/* Address (in loaded output file) where globals will live */
	i64 GlobalBase,
	i64 CodeBase,
	
	/* Buffer containing assembled (but not linked) code */
	i8* CodeBuffer,
	i32 CodeBufferSize,
	i32 Index,
	
	/* Array of relocations */
	i32* CodeRelocations,
	i32 CodeRelocationCount,
	
	/* Record of label definitions/usages inside of CodeBuffer, for actually linking labels */
	LabelInfo** Labels,
	i32 LabelCount,
	i32 LabelBufferCapacity,
	
	i32 LabelIndex,
	
	/* Labels for `continue` and `break` statements to jump to */
	i32 CurrentLoopContinueLabel,
	i32 CurrentLoopBreakLabel,
	
	/* Label for the current function's buffer of strings used */
	i32 CurrentFunctionStringsLabel,
	
	/* Next free register number for expression evaluation/whatever */
	i8 RegisterStackIndex,
	
	/* Flags to ensure that certain registers are not clobbered */
	i8 NoClobberCD89,
	i32 ParameterRegistersMaxSave,
	i32 ParameterRegistersMinSave,
	i8 NoClobberA,
	
	/* Flags the correct return sequence for `Main()` is used when Config->OutputFormat = OUTPUT_ELF */
	i8 CompilingMain,

	i32 MainOffset
	i32 MainEnd
	
	/* Count of `Try` statements logically 'wrapping' the current area in code 
		With loops resetting ScopedTryDepth for Continue/Break
	*/
	i32 ScopedTryDepth,
	i32 TotalTryDepth
	
	i32 GlobalStringsLabel
	
	; Number of functions present in output file
	i16 FunctionCount
	
	i32 DistanceBetweenGlobalsAndCode
	
	DWARFBuilder* DWARF
	
	i32 DWARFCompilationUnitOffset

	; Init labels (called from Main() before user code)

	PointerArray* InitializerLabels ; <i64>

	; New Linker Fields

	ObjectFile* Object
	ObjectSection* CodeSection
	ObjectSection* ReadOnlyDataSection
	ObjectSection* DataSection
	ObjectSection* ZeroSection
	ObjectSection* VirtualFunctionTablesSection

	ByteArray* ReadOnlyData

	ObjectSymbol* CurrentFunctionSymbol
	ObjectSymbol* GlobalStringsSymbol
	ObjectSymbol* CurrentFunctionStringsSymbol

	PointerArray* VirtualFunctionTables ; <ObjectSymbol*>
	
	define void Initialize(BuildConfig* Config, ParserState* Parser) {
		this->Config := Config
		this->Parser := Parser

		if (Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
			this->Object := ObjectFile:New()

			ObjectSection* NoteGNUStack := ObjectSection:New(SECTION_TYPE_DATA, ".note.GNU-stack")
			this->Object->AddNewSection(NoteGNUStack)

			this->CodeSection := ObjectSection:New(SECTION_TYPE_DATA, ".text")
			this->Object->AddNewSection(this->CodeSection)

			this->ReadOnlyDataSection := ObjectSection:New(SECTION_TYPE_DATA, ".rodata")
			this->Object->AddNewSection(this->ReadOnlyDataSection)

			this->DataSection := ObjectSection:New(SECTION_TYPE_DATA, ".data")
			this->Object->AddNewSection(this->DataSection)

			this->ZeroSection := ObjectSection:New(SECTION_TYPE_DATA, ".bss")
			this->Object->AddNewSection(this->ZeroSection)

			this->VirtualFunctionTablesSection := new ObjectSection(SECTION_TYPE_DATA, ".data.vftbl")
			this->VirtualFunctionTables := new PointerArray()

			this->ReadOnlyData := ByteArray:New()
			
			this->ReadOnlyData->Push(Parser->GlobalConstantsBuffer, Parser->GlobalConstantBufferSize)

			this->GlobalStringsSymbol := ObjectSymbol:New(
				SYMBOL_BINDING_LOCAL, SYMBOL_TYPE_DATA, SYMBOL_VISIBILITY_DEFAULT,
				this->ReadOnlyDataSection, "strings(global)",
				Parser->GlobalConstantBufferSize, 0
			)

			this->Object->AddSymbol(this->GlobalStringsSymbol)
		}
		
		this->CodeBufferSize := 0x10000
		this->CodeBuffer := Alloc(0x10000)
		this->Index := 0
		
		this->CodeRelocations := Alloc(8)
		this->CodeRelocationCount := 0
		
		this->Labels := Alloc(80) As LabelInfo**
		this->LabelCount := 0
		this->LabelBufferCapacity := 10
		
		this->LabelIndex := (Parser->LabelCount) + 1
		this->RegisterStackIndex := 0
		
		this->ParameterRegistersMaxSave := 0
		this->ParameterRegistersMinSave := 0
		
		this->CurrentFunction := null
		
		this->ScopedTryDepth := 0
		this->TotalTryDepth := 0
		
		this->FunctionCount := 0

		this->InitializerLabels := PointerArray:New()
	}
	
	define ObjectSymbol* FindOrAddGlobalObjectSymbol(VariableInfo* Variable) {
		if !(Variable->ObjectSymbol) {
			if (Variable->IsExternal) {
				SYMBOL_TYPE TargetType := SYMBOL_TYPE_DATA

				if (TypeIsCallable(Variable->Type)) {
					TargetType := SYMBOL_TYPE_FUNCTION
				}

				Variable->ObjectSymbol := ObjectSymbol:New(
					SYMBOL_BINDING_GLOBAL, TargetType, SYMBOL_VISIBILITY_DEFAULT,
					null, Variable->ExternalSymbolName->Buffer,
					0, 0
				)
			}
			else {
				Variable->ObjectSymbol := ObjectSymbol:New(
					SYMBOL_BINDING_LOCAL, SYMBOL_TYPE_DATA, SYMBOL_VISIBILITY_DEFAULT,
					this->ZeroSection, Variable->Name->Buffer,
					0, 0
				)
			}

			this->Object->AddSymbol(Variable->ObjectSymbol)
		}

		return Variable->ObjectSymbol
	}

	define i8* SourcePathToAbsolutePath(i8* Path) {
		return this->Config->LookupIncludedPath(Path)
	}
	
	define void TranslateTypeNamespace(TypeNamespace* Container) {
		i32 Count := Container->Entries->Count()

		for (i32 Index := 0, Index < Count, Index++) {
			TypeInfo* Info := Container->Entries->PointerAt(Index)

			this->DWARF->FindOrTranslateType(Info->AsNonPointer(), false)
		}

		i32 Count := Container->Children->Count()

		for (i32 Index := 0, Index < Count, Index++) {
			TypeNamespace* Child := Container->Children->PointerAt(Index)

			this->TranslateTypeNamespace(Child)
		}
	}

	define void InitializeDebugInfo() {
		BuildConfig* Config := this->Config
		
		if (Config->DebugMode & DEBUG_EMIT_DWARF) {
			this->DWARF := DWARFBuilder:New()
			this->DWARF->CreateAbbreviations()
			
			i8* AbsoluteSourceFile := this->SourcePathToAbsolutePath(Config->SourceFile)
			
			this->DWARFCompilationUnitOffset := this->DWARF->StartCompilationUnit(AbsoluteSourceFile, "", Config->ImageBase, 0)
			
			this->DWARF->AddBaseType("i8", 1)
			this->DWARF->AddBaseType("i16", 2)
			this->DWARF->AddBaseType("i32", 4)
			this->DWARF->AddBaseType("i64", 8)
			this->DWARF->AddBaseType("void", 8)

			this->TranslateTypeNamespace(this->Parser->RootNamespace)
			
			;this->DWARF->LineInfo->AddDirectory("/")
			this->DWARF->LineInfo->AddFile(AbsoluteSourceFile)
			
			this->DWARF->LineInfo->SetImageBase(Config->ImageBase)

			if (Config->ImageBase != 0) {
				this->DWARF->LineInfo->EmitSetAddress(Config->ImageBase)
			}
		}
		
		VariableHashMap* Globals := this->Parser~>Globals
		HashMap* RawGlobals := Globals->Map
		
		void* Elements := RawGlobals->Elements
		
		i32 MaxOffset := Globals->NextOffset
		
		i32 MaxIndex := RawGlobals->BufferMaxCount As i32
		
		for (i32 ElementIndex := 0, ElementIndex < MaxIndex, ElementIndex += 1) {
			if (Elements[ElementIndex]) {
				HashMapElement* FoundElement := Elements[ElementIndex] As HashMapElement*
				
				while (FoundElement) {
					VariableInfo* NextGlobal := FoundElement->Value
					
					if (NextGlobal->IsGlobal = GLOBAL_IS_OPTIMIZED_AWAY || NextGlobal->IsExternal) {
						FoundElement := FoundElement->NextElement
						
						continue
					}

					if (Config->DebugMode & DEBUG_EMIT_DWARF) {
						i32 TypeOffset := this->DWARF->FindOrTranslateType(NextGlobal->Type)	
						i32 Size := GetTypeStorageSize(NextGlobal->Type)

						this->DWARF->AddGlobalVariable(NextGlobal->Name->Buffer, Size, TypeOffset, this->GlobalBase + NextGlobal->StackOffset)
					}

					if (Config->DebugMode & DEBUG_EMIT_GLOBAL_SYMBOLS) {
						i32 Size := GetTypeStorageSize(NextGlobal->Type)

						if (Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
							NextGlobal->ObjectSymbol := this->FindOrAddGlobalObjectSymbol(NextGlobal)

							NextGlobal->ObjectSymbol->Value := NextGlobal->StackOffset
							NextGlobal->ObjectSymbol->Size := Size
						}
						else {
							NextGlobal->Symbol := this->ELF->AddGlobalSymbol(ELF_STB_LOCAL, NextGlobal->Name->Buffer, NextGlobal->StackOffset, NextGlobal->StackOffset + GetTypeStorageSize(NextGlobal->Type))
						}
					}
					
					FoundElement := FoundElement->NextElement
				}
			}
		}
	}
	
	define void Free() {
		Free(this->CodeBuffer)
		Free(this->CodeRelocations)
		Free(this->Labels)
	}
	
	SafeString* CurrentSourceFile
	i32 LineNumberHighWaterMark
	
	define void MarkLineNumber(SourceContext* Context) {
		if (Context->Lexer = null) {
			return
		}
		
		if (this->Config->DebugMode & DEBUG_EMIT_DWARF) {
			i64 Offset := this->CodeBase + this->Index
			
			i8* AbsoluteSourceFile := this->SourcePathToAbsolutePath(Context->Lexer->SourceFilePath->Buffer)
			
			this->DWARF->LineInfo->AddLine(Offset As i32, Context->LineNumber, AbsoluteSourceFile)
		}
		
		if (this->Config->DumpInfo & DUMP_LINES) {
			if (Context->Lexer->SourceFilePath = this->CurrentSourceFile) {
				if (Context->LineNumber > this->LineNumberHighWaterMark) {
					Print("\t%i:	%x\n", Context->LineNumber, this->CodeBase + this->Index)
					this->LineNumberHighWaterMark := Context->LineNumber
				}
			}
		}
	}

	define void RecordGeneratedFunction(i8* Name, i64 StartAddress, i32 Size) {
		if (this->Config->DebugMode & DEBUG_EMIT_DWARF) {
			i32 DWARFVoid := this->DWARF->FindOrTranslateType(this->Parser->void->AsNonPointer())
			i32 Function := this->DWARF->StartFunction(Name, DWARFVoid, StartAddress, false)
			this->DWARF->EndFunction(Function, Size)
		}
	}

	define i64 AddressOfCodeOffset(i32 Offset) {
		return this->Config->ImageBase + this->CodeBase + Offset
	}
	
	define i32 BeforeCompileFunction(FunctionDefine* Function) {
		i32 Result := 0
		
		if (this->Config->DebugMode & DEBUG_EMIT_DWARF) {
			this->MarkLineNumber(Function~>Context)
			
			i32 ReturnTypeOffset := this->DWARF->FindOrTranslateType(Function->ReturnType)
			i64 FunctionAddress := this->Config->ImageBase + this->CodeBase + this->Index
			i8 IsMain := Function->Name->Equals("Main")
			
			for (i32 Index := 0, Index < Function->ParameterCount, Index++) {
				VariableInfo* NextParameter := Function->Parameters[Index]
				
				this->DWARF->FindOrTranslateType(NextParameter->Type)
			}
			
			i32 NameLength := Function->GetStringLength()
			i8* NameBuffer := Alloc(NameLength + 1)
			
			Function->StringifyInto(NameBuffer, '.')
			
			Result := this->DWARF->StartFunction(NameBuffer, ReturnTypeOffset, FunctionAddress, IsMain)
			
			Free(NameBuffer)
			
			for (i32 Index := 0, Index < Function->ParameterCount, Index++) {
				VariableInfo* NextParameter := Function->Parameters[Index]
				
				i32 TypeOffset := this->DWARF->FindOrTranslateType(NextParameter->Type)
				i32 Size := GetTypeStorageSize(NextParameter->Type)
				i32 StackOffset := GetVariableOffset(this, NextParameter, null)
				
				this->DWARF->AddLocalVariable(NextParameter->Name->Buffer, Size, TypeOffset, StackOffset)
			}
			
			HashMap* Locals := Function~>Locals~>BackingMap
			
			i32 ElementCount := Locals->BufferMaxCount As i32
			void* Elements := Locals->Elements
			
			for (i32 ElementIndex := 0, ElementIndex < ElementCount, ElementIndex += 1) {
				if (Elements[ElementIndex]) {
					HashMapElement* FoundElement := Elements[ElementIndex] As HashMapElement*
					
					while (FoundElement) {
						VariableInfo* NextLocal := FoundElement->Value As VariableInfo*
						
						if (NextLocal->IsParameter) {
							FoundElement := FoundElement->NextElement
							
							continue
						}
						
						TypeOffset := this->DWARF->FindOrTranslateType(NextLocal->Type)
						i32 Size := GetTypeStorageSize(NextLocal->Type)
						StackOffset := GetVariableOffset(this, NextLocal, null)
						
						this->DWARF->AddLocalVariable(NextLocal->Name->Buffer, Size, TypeOffset, StackOffset)
						
						FoundElement := FoundElement->NextElement
					}
				}
			}
		}
		
		
		if (this->Config->DumpInfo & DUMP_LINES) {
			Print("[ ^80")
			Function~>Context->Lexer->SourceFilePath->Print()
			Print("^F0: ")
			
			i8* Buffer := Alloc(Function->GetStringLength())
			Function->StringifyInto(Buffer)
			
			Print("%s ]\n", Buffer)
			
			Free(Buffer)
			
			this->CurrentSourceFile := Function~>Context->Lexer->SourceFilePath
			this->LineNumberHighWaterMark := Function~>Context->LineNumber
		}
		
		return Result
	}
	define void AfterPrologueEnd() {
		if (this->Config->DebugMode & DEBUG_EMIT_DWARF) {
			this->DWARF->LineInfo->EmitOpcode(DWARF_LINE_PROGRAM_OPCODE_SET_PROLOGUE_END)
		}
	}
	define void BeforeEpilogueBegin() {
		if (this->Config->DebugMode & DEBUG_EMIT_DWARF) {
			this->DWARF->LineInfo->EmitOpcode(DWARF_LINE_PROGRAM_OPCODE_SET_EPILOGUE_BEGIN)
		}
	}

	define ObjectSymbol* FindOrAddFunctionObjectSymbol(FunctionDefine* Function) {
		if !(Function->ObjectSymbol) {
			if (Function->IsMethod = FUNCTION_IS_DERIVED_METHOD) {
				InterfaceImplementationInfo* Implementation := Function->DerivedImplementationInfo
				
				TypeInfo* InterfaceType := Implementation->ForInterface
				i32 MethodIndex := Function->DerivedMethodIndex

				TypeInfo* ClassType := Implementation->ForType
				ClassInfo* Info := ClassType->ClassInfo

				i8* NameBuffer := FormatString("%S.derived.%S.%S", ClassType->Name, Implementation->ForInterface->Name, Function->Name)
			}
			else {
				i32 NameLength := Function->GetStringLength()
				i8* NameBuffer := Alloc(NameLength + 1)
				
				Function->StringifyInto(NameBuffer, '.')
			}

			ObjectSymbol* FunctionSymbol := ObjectSymbol:New(
				SYMBOL_BINDING_LOCAL, SYMBOL_TYPE_FUNCTION, SYMBOL_VISIBILITY_DEFAULT,
				this->CodeSection, NameBuffer,
				0, 0
			)

			Function->ObjectSymbol := FunctionSymbol
			this->Object->AddSymbol(FunctionSymbol)
		}

		return Function->ObjectSymbol
	}

	define void ReferenceSymbolFromCode(i32 Offset, ObjectSymbol* Target, i32 Addend) {
		ObjectRelocation* Relocation := ObjectRelocation:New(
			this->CodeSection, RELOCATION_TYPE_OFFSET_32,
			Offset, Target, Addend
		)

		Target->ReferenceBy(Relocation)
		this->CodeSection->AddRelocation(Relocation)
	}

	define ELFSymbol* FindOrAddFunctionSymbol(FunctionDefine* Function) {
		if !(Function->Symbol) {
			i32 NameLength := Function->GetStringLength()
			i8* NameBuffer := Alloc(NameLength + 1)
			
			Function->StringifyInto(NameBuffer, '.')

			Function->Symbol := this->ELF->AddFunctionSymbol(ELF_STB_LOCAL, NameBuffer, 0, 0)

			;Print("Partial symbol for %s at index %i\n", NameBuffer, Function->SymbolNumber)

			Free(NameBuffer)
		}

		return Function->Symbol
	}
	
	define void AfterCompileFunction(FunctionDefine* Function, i32 Data, i32 FunctionOffset) {
		i64 FunctionAddress := FunctionOffset

		if (this->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {

		}
		else if (this->Config->DebugMode & DEBUG_EMIT_FUNCTION_SYMBOLS) {

		}
		else if (this->Config->DebugMode & DEBUG_EMIT_OBJECT) {
			FunctionAddress += this->Config->ImageBase
		}
		else {
			FunctionAddress += this->CodeBase
		}

		i32 FunctionSize := this->Index - FunctionOffset

		if (this->Config->DebugMode & DEBUG_EMIT_DWARF) {
			i64 Offset := this->CodeBase + this->Index
			
			this->DWARF->LineInfo->EmitEndSequence(Offset As i32)
			
			this->DWARF->EndFunction(Data, FunctionSize)
		}

		if (this->Config->DebugMode & DEBUG_EMIT_FUNCTION_SYMBOLS) {
			i32 NameLength := Function->GetStringLength()
			i8* NameBuffer := Alloc(NameLength + 1)
			
			Function->StringifyInto(NameBuffer, '.')

			if (this->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
				ObjectSymbol* FunctionSymbol := this->FindOrAddFunctionObjectSymbol(Function)

				FunctionSymbol->Value := FunctionAddress
				FunctionSymbol->Size := FunctionSize

				if (Function->Name->Equals("Main")) {
					ObjectSymbol* FunctionSymbol := ObjectSymbol:New(
						SYMBOL_BINDING_GLOBAL, SYMBOL_TYPE_FUNCTION, SYMBOL_VISIBILITY_DEFAULT,
						this->CodeSection, "main",
						FunctionSize, FunctionAddress
					)

					this->Object->AddSymbol(FunctionSymbol)
				}
			}
			else {
				if (Function->Symbol) {
					ELFSymbol* Symbol := Function->Symbol

					Symbol->Value := FunctionAddress
					Symbol->Size := FunctionSize
				}
				else {
					Function->Symbol := this->ELF->AddFunctionSymbol(ELF_STB_LOCAL, NameBuffer, FunctionAddress, FunctionAddress + FunctionSize - 1)
				}
			}

			if (Function->Attributes & FUNCTION_ATTRIBUTE_EXPORT) {
				i8* ExportName := NameBuffer

				if (Function->ExportName) {
					ExportName := Function->ExportName->Buffer
				}
				
				if (this->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
					ObjectSymbol* FunctionSymbol := ObjectSymbol:New(
						SYMBOL_BINDING_GLOBAL, SYMBOL_TYPE_FUNCTION, SYMBOL_VISIBILITY_DEFAULT,
						this->CodeSection, ExportName,
						FunctionSize, FunctionAddress
					)

					this->Object->AddSymbol(FunctionSymbol)
				}
				else {
					this->ELF->AddFunctionSymbol(ELF_STB_GLOBAL, ExportName, FunctionAddress, FunctionAddress + FunctionSize - 1)
				}
			}

			;Free(NameBuffer)
		}
	}

	define i8 GetParameterRegister(i8 Index, i8 ForceX64) {
		i8 Result := 0
		
		if (ForceX64) {
			Result := (Index + 1) As i8
			
			if (Result > 2) {
				Result += 5
			}
		}
		else {
			Result := GetSystemVRegister(Index)
		}

		return Result
	}

	define i8 GetParameterRegister(i8 Index) {
		return this->GetParameterRegister(Index, false)
	}
}

/*
==========================================
	High-ish level compiling functions, along with global/function dumping
==========================================
*/

#Require "./src/compiler/Parser/OptimizeAST.rlx"
#Require "./src/compiler/CodeGen.rlx"

declare void CompileImportStub(CompilerState*, FunctionDefine*)
declare i32 CompileFunction(CompilerState*, FunctionDefine*, i8)

define void DumpGlobals(CompilerState* Compiler) {
	/* Walk the globals hashmap and print the offset/size of each */
	ParserState* Parser := Compiler->Parser
	
	i8 DumpOptimized := (Compiler->Config->DumpInfo & DUMP_OPTIMIZED_GLOBALS) != 0
	i8 DumpPresent := (Compiler->Config->DumpInfo & DUMP_PRESENT_GLOBALS) != 0

	VariableHashMap* Globals := Parser~>Globals
	HashMap* RawGlobals := Globals->Map
	
	void* Elements := RawGlobals->Elements
	
	i32 MaxOffset := Globals->NextOffset
	i64 Base := Compiler->GlobalBase
	
	i32 MaxIndex := RawGlobals->BufferMaxCount As i32

	for (i32 ElementIndex := 0, ElementIndex < MaxIndex, ElementIndex += 1) {
		if (Elements[ElementIndex]) {
			HashMapElement* FoundElement := Elements[ElementIndex] As HashMapElement*
			
			while (FoundElement) {
				VariableInfo* NextGlobal := FoundElement->Value
				
				if (NextGlobal->IsGlobal = GLOBAL_IS_OPTIMIZED_AWAY) {
					if (DumpOptimized) {
						Print("^60     Opimized Away    = ")
						NextGlobal->Name->PrintLine()
						ResetColors()
					}
				}
				else {
					if (DumpPresent) {
						i32 ThisOffset := NextGlobal->StackOffset
						i32 ThisSize := GetTypeStorageSize(NextGlobal->Type)
						
						i64 Start := Base + ThisOffset
						i64 End := Start + ThisSize
						
						Print("%x:%x = ", Start, End)
						NextGlobal->Name->PrintLine()
						ResetColors()
					}
				}
				
				FoundElement := FoundElement->NextElement
			}
		}
	}
}

define void PrintFunction(CompilerState* Compiler, FunctionDefine* TargetFunction, i8 IsOverload) {
	/* Print a function in the format:
			Address Of Function - Size of function (Call count of function) Name
		With the type signature of the function optionally printed afterwards, if the function is overloaded.
	*/
	
	if (TargetFunction->CallCount = 0) {
		Print("^60		 - 	(0)	")
	}
	else {
		Print("%x	 - %i	(%i)	", Compiler->AddressOfCodeOffset(TargetFunction->CodeOffset), Compiler->Index - TargetFunction->CodeOffset, TargetFunction->CallCount)
	}
	
	i32 NameBufferSize := TargetFunction->GetStringLength()
	i8* NameBuffer := Alloc(NameBufferSize)
	
	TargetFunction->StringifyInto(NameBuffer)
	
	Print("%s^F0\n", NameBuffer)
	
	Free(NameBuffer)
}

define void CompileDerivedMethod(CompilerState* Compiler, FunctionDefine* DerivedMethod) {
	; Derives the method :)

	if (DerivedMethod->CodeOffset != 0) {
		return
	}

	InterfaceImplementationInfo* Implementation := DerivedMethod->DerivedImplementationInfo
	
	TypeInfo* InterfaceType := Implementation->ForInterface
	i32 MethodIndex := DerivedMethod->DerivedMethodIndex

	TypeInfo* ClassType := Implementation->ForType
	ClassInfo* Info := ClassType->ClassInfo

	if (Compiler->Config->DebugMode & DEBUG_EMIT_DWARF) {
		Compiler->MarkLineNumber(Implementation->Blame)
	}

	;Print("SetLabel %i Derived %func @ %x\n", DerivedMethod->LabelNumber, DerivedMethod, Compiler->AddressOfCodeOffset(Compiler->Index))

	if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
		ObjectSymbol* FunctionSymbol := Compiler->FindOrAddFunctionObjectSymbol(DerivedMethod)

		FunctionSymbol->Value := Compiler->Index
	}
	else {
		SetLabel(Compiler, DerivedMethod->LabelNumber)
	}
	
	DerivedMethod->CodeOffset := Compiler->Index

	if (InterfaceType = Compiler->Parser->IAnyType) {
		if (MethodIndex = 2) {
			i8 P1 := Compiler->GetParameterRegister(0)

			i32 InterfaceCount := Info->InterfacesInOrder->Count()

			for (i32 Index := 0, Index < InterfaceCount, Index++) {
				InterfaceImplementationInfo* ImplementationInfo := Info->InterfacesInOrder->At(Index)

				; lea rbx, vtfb[Index]
				; mov [p1 + Index * 8], rbx

				if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
					ObjectSymbol* VirtualFunctionTableSymbol := ImplementationInfo->VirtualFunctionTableSymbol

					EmitLea_R64_REL32(Compiler, RBX, 0)

					Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, VirtualFunctionTableSymbol, -4)
				}
				else {
					EmitLea_R64_Label(Compiler, RBX, ImplementationInfo->VirtualFunctionTableLabel)
				}

				EmitMove_RIX_DISP8_RX(Compiler, P1, RBX, (Index * 8) As i8, 8)
			}
		}
		else if (MethodIndex = 0) {
			EmitMove_R64_I64(Compiler, RAX, ClassType->GetTypeID())
		}
		else if (MethodIndex = 1) {
			; `IAny->As(InterfaceID)`

			i8 P1 := Compiler->GetParameterRegister(0)
			i8 P2 := Compiler->GetParameterRegister(1)

			i32 End := NextLabel(Compiler)
			i32 Next := NextLabel(Compiler)

			i32 InterfaceCount := Info->InterfacesInOrder->Count()

			for (i32 Index := 0, Index < InterfaceCount, Index++) {
				InterfaceImplementationInfo* ImplementationInfo := Info->InterfacesInOrder->At(Index)

				EmitMove_R64_I64(Compiler, RAX, ImplementationInfo->ForInterface->GetTypeID())
				EmitCmp_RX_RX(Compiler, P2, RAX, 8)
				EmitJNZ_Label(Compiler, Next)

				EmitMove_R64_R64(Compiler, RAX, P1)
				EmitAdd_R64_IX(Compiler, RAX, (Index * 8) As i8)
				EmitJump_Label(Compiler, End)

				SetLabel(Compiler, Next)

				Next := NextLabel(Compiler)
			}

			SetLabel(Compiler, Next)
			SetLabel(Compiler, End)
		}
	}
	else if (InterfaceType = Compiler->Parser->IAllocateType) {
		i8 P1 := Compiler->GetParameterRegister(0)
		i8 P2 := Compiler->GetParameterRegister(1)

		EmitMove_R64_I64(Compiler, P2, ClassType->GetTypeID())

		if (MethodIndex = 0) {
			; auto Result := Alloc(sizeof(Self))
			; Result->Initialize()

			EmitMove_R32_I32(Compiler, P1, ClassType->Size)

			if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
				ObjectSymbol* AllocatorSymbol := Compiler->FindOrAddFunctionObjectSymbol(Compiler->Parser->Allocator)
				EmitCall_REL32(Compiler, 0)
				Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, AllocatorSymbol, -4)
			}
			else {
				EmitCall_Label(Compiler, Compiler->Parser->Allocator->LabelNumber)
			}
			
			EmitPush_R64(Compiler, RAX)
			
			EmitMove_R64_R64(Compiler, P1, RAX)
			FunctionDefine* IAnyInitialize := Info->IAnyImplementation->Methods->At(2)

			if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
				ObjectSymbol* InitializeSymbol := Compiler->FindOrAddFunctionObjectSymbol(IAnyInitialize)
				EmitCall_REL32(Compiler, 0)
				Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, InitializeSymbol, -4)
			}
			else {
				EmitCall_Label(Compiler, IAnyInitialize->LabelNumber)
			}

			EmitPop_R64(Compiler, RAX)
		}
		else if (MethodIndex = 1) {
			if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
				ObjectSymbol* DeleterSymbol := Compiler->FindOrAddFunctionObjectSymbol(Compiler->Parser->Deleter)
				EmitCall_REL32(Compiler, 0)
				Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, DeleterSymbol, -4)
			}
			else {
				EmitCall_Label(Compiler, Compiler->Parser->Deleter->LabelNumber)
			}
		}
	}
	else if (InterfaceType = Compiler->Parser->INewType) {
		; The flow here is super annoying.
		; We need to call IAllocate->Allocate, but also preserve *all* of our parameters
		;  for the INew->New() implementation. As if that didn't suck enough, we also need
		;   to insert the `this` parameter which is the result of IAllocate->Allocate.

		; First we push everything onto the stack to survive IAllocate->Allocate
		; Then we pop our register parameters
		; Then we push the result value
		; Then we duplicate the stack parameter list
		; Then we call INew->New() and cleanup the parameters after
		; Finally, we pop the result in RAX and can return

		i8 P1 := Compiler->GetParameterRegister(0)
		i8 P2 := Compiler->GetParameterRegister(1)

		FunctionDefine* Target := DerivedMethod->WrappedNewMethod

		InterfaceImplementationInfo* IAllocateImplementation := Info->Interfaces->GetPointer(Compiler->Parser->IAllocateType)
		FunctionDefine* IAllocateAllocate := IAllocateImplementation->Methods->At(0)

		i32 StackParameterCount := 0
		i32 RegisterParameterCount := 6

		if (DerivedMethod->ParameterCount < 6) {
			RegisterParameterCount := DerivedMethod->ParameterCount
		}
		else {
			StackParameterCount := DerivedMethod->ParameterCount - RegisterParameterCount
		}

		; Save all of the parameter registers
		
		for (i32 Index := RegisterParameterCount - 1, Index >= 0, Index--) {
			EmitPush_R64(Compiler, Compiler->GetParameterRegister(Index As i8))
		}

		if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
			ObjectSymbol* AllocateSymbol := Compiler->FindOrAddFunctionObjectSymbol(IAllocateAllocate)
			EmitCall_REL32(Compiler, 0)
			Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, AllocateSymbol, -4)
		}
		else {
			EmitCall_Label(Compiler, IAllocateAllocate->LabelNumber)
		}

		EmitPush_R64(Compiler, RAX)

		i32 NewParameterCount := DerivedMethod->ParameterCount + 1
		
		i32 NewStackParameterCount := 0
		i32 NewRegisterParameterCount := 6

		if (NewParameterCount < 6) {
			NewRegisterParameterCount := NewParameterCount
		}
		else {
			NewStackParameterCount := NewParameterCount - NewRegisterParameterCount
		}

		; Pop all of our parameter registers (with `this` magically inserted)

		for (i32 Index := 0, Index < NewRegisterParameterCount, Index++) {
			EmitPop_R64(Compiler, Compiler->GetParameterRegister(Index As i8))
		}

		; Save our return value

		EmitPush_R64(Compiler, RDI)

		; Duplicate stack parameters

		EmitMove_R64_R64(Compiler, RAX, RSP)

		for (i32 Index := 0, Index < NewStackParameterCount, Index++) {
			EmitPush_R64_DISP8(Compiler, RAX, (Index * 8) As i8)
		}

		if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
			ObjectSymbol* TargetSymbol := Compiler->FindOrAddFunctionObjectSymbol(Target)
			EmitCall_REL32(Compiler, 0)
			Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, TargetSymbol, -4)
		}
		else {
			EmitCall_Label(Compiler, Target->LabelNumber)
		}

		; Cleanup stack

		if (NewStackParameterCount != 0) {
			EmitAdd_R64_I8(Compiler, RSP, (NewStackParameterCount * 8) As i8)
		}

		; Get return value

		EmitPop_R64(Compiler, RAX)

		; If we bumped a register parameter onto the stack, clean it up
		;  (the caller doesn't know to clean it up)

		if (StackParameterCount != NewStackParameterCount) {
			EmitPop_R64(Compiler, RBX)
		}
	}

	EmitReturn(Compiler)

	i8* Name := FormatString("%func", DerivedMethod)
	i64 Address := Compiler->AddressOfCodeOffset(DerivedMethod->CodeOffset)
	i32 Size := Compiler->Index - DerivedMethod->CodeOffset

	if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
		FunctionSymbol->Size := Size
	}

	if (Compiler->Config->DebugMode & DEBUG_EMIT_DWARF) {
		Compiler->DWARF->LineInfo->EmitEndSequence((Compiler->CodeBase + Compiler->Index) As i32)
	}

	Compiler->RecordGeneratedFunction(Name, Address, Size)
}

define void CompileOverload(CompilerState* Compiler, FunctionDefine* BaseFunction, i8 IsOverload) {
	/* Compiles either:
		A single function (BaseFunction)
		Or an entire linked list of function overloads, starting with BaseFunction
	*/
	
	;BaseFunction->CodeOffset := Compiler->Index

	if (BaseFunction->CodeOffset = 0) {
		if (BaseFunction->IsMethod = FUNCTION_IS_DERIVED_METHOD) {
			CompileDerivedMethod(Compiler, BaseFunction)
		}
		else if (BaseFunction->IsImported) {
			if (Compiler->Config->OutputFormat = OUTPUT_PE && BaseFunction->CallCount != 0) {
				CompileImportStub(Compiler, BaseFunction)
			}
		}
		else if !(BaseFunction->HasFullDefinition) {
			BaseFunction~>Context->Error("Function is declared, but never defined.")
		}
		else {
			i8 IsMain := BaseFunction->Name->Equals("Main")
			
			if (BaseFunction->CallCount != 0) {
				Compiler->FunctionCount += 1
				BaseFunction->CodeOffset := CompileFunction(Compiler, BaseFunction, IsMain)
			}
		}
		
		if (Compiler->Config->DumpInfo & DUMP_FUNCTIONS) {
			/* If we're dumping a function in an overload chain, then print it as an overload
				Or, if we're dumping a single function and it has `->Next` set, then we've just started an overload chain
				and still need to print it as an overload
			*/
			
			PrintFunction(Compiler, BaseFunction, BaseFunction->Next != null || IsOverload)
		}
	}
	
	if !(IsOverload) {
		; If this is the start of an overload chain, then we need to compile any/all functions in the chain
		
		while (BaseFunction->Next) {
			BaseFunction := BaseFunction->Next
			
			CompileOverload(Compiler, BaseFunction, true)
		}
	}
}

define void CompileFunctionHashMap(CompilerState* Compiler, HashMap* Map) {
	/* Compiles a hashmap containing FunctionDefine*'s as if it were a linear array 
		Returns true if the main function was found
	*/
	
	void* Elements := Map->Elements
	
	for (i32 ElementIndex := 0, ElementIndex < (Map->BufferMaxCount), ElementIndex += 1) {
		if (Elements[ElementIndex]) {
			HashMapElement* FoundElement := Elements[ElementIndex] As HashMapElement*
			
			while (FoundElement) {
				FunctionDefine* NextFunction := (FoundElement->Value) As FunctionDefine*
				
				CompileOverload(Compiler, NextFunction, false)
				
				/* Update the current element to be the next element in the linked list */
				FoundElement := FoundElement->NextElement
			}
		}
	}
}

declare void CompileClassInterfaces(CompilerState*, TypeInfo*)

define void CompileTypeNamespace(CompilerState* Compiler, TypeNamespace* Container) {
	i32 Count := Container->Entries->Count()

	for (i32 Index := 0, Index < Count, Index++) {
		TypeInfo* Info := Container->Entries->PointerAt(Index)

		if (Info->Is(TYPE_KIND_STRUCTURE) || Info->Is(TYPE_KIND_BIT_FIELDS) || Info->Is(TYPE_KIND_ENUMERATION)) {
			if (Info->IsClass) {
				CompileClassInterfaces(Compiler, Info)
			}

			CompileFunctionHashMap(Compiler, Info~>Methods)
			CompileFunctionHashMap(Compiler, Info~>StaticMethods)
		}
	}

	i32 Count := Container->Children->Count()

	for (i32 Index := 0, Index < Count, Index++) {
		TypeNamespace* Child := Container->Children->PointerAt(Index)

		CompileTypeNamespace(Compiler, Child)
	}
}

#Require "./src/compiler/Parser/CallGraph.rlx"

define void CompilerStart(BuildConfig* Config, ParserState* Parser, i8* OutputFilePath) {
	CheckTypes(Parser)

	CallGraph* Calls := CallGraph:New(Parser)

	Calls->VisitProgramRoot()

	if (Config->DumpInfo & DUMP_CALL_GRAPH) {
		Calls->DumpAll()
	}
	else if (Config->DumpInfo & DUMP_CALL_GRAPH_DOT) {
		Calls->DumpAllDot()
	}

	CountReferences(Parser)
	InsertClassInterfaceCasts(Parser)

	EliminateGlobals(Parser)
	FoldConstants(Parser)

	
	CompilerState* Compiler := Alloc(#CompilerState)
	
	; Todo: Fix all of the random constants for section offsets
	
	Compiler->Initialize(Config, Parser)
	
	if (Config->OutputFormat = OUTPUT_BIN) {
		Compiler->GlobalBase := Config->ImageBase + 0x10
		Compiler->CodeBase := (Parser~>Globals->NextOffset + 0x10) As i32
		
		Compiler->DistanceBetweenGlobalsAndCode := Parser~>Globals->NextOffset
	}
	else if (Config->OutputFormat = OUTPUT_ELF && Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
		; :shrug:

		Config->ImageBase := 0
	}
	else if (Config->OutputFormat = OUTPUT_ELF) {
		i16 ELFType := ELF_FILETYPE_EXECUTABLE

		if (Config->DebugMode & DEBUG_EMIT_DYNAMIC) {
			ELFType := ELF_FILETYPE_DYNAMIC
			Config->ImageBase := 0
		}
		else if (Config->DebugMode & DEBUG_EMIT_OBJECT) {
			ELFType := ELF_FILETYPE_RELOCATABLE
			Config->ImageBase := 0
		}

		Compiler->ELF := ELFBuilder:New(Config->ELFABI, 0, ELFType)

		if (Config->DebugMode & DEBUG_EMIT_DYNAMIC) {
			Compiler->ELF->SetupDynamicSection()

			for (i32 Index := 0, Index < Parser->ExternalSources->Count(), Index++) {
				Token* Source := Parser->ExternalSources->At(Index)

				Compiler->ELF->RequireDynamicLibrary(Source->StringValue->Buffer)
			}
		}
		
		i64 GlobalBytes := Parser~>Globals->NextOffset
		i64 GlobalPages := GlobalBytes / 0x1000
		
		if (GlobalBytes % 0x1000) {
			GlobalPages += 1
		}

		i32 ELFCodeOffset := 0x1000
		
		Compiler->GlobalBase := Config->ImageBase + 0x1000
		Compiler->CodeBase := (0x1000 + ELFCodeOffset + (GlobalPages * 0x1000)) As i32
		
		Compiler->DistanceBetweenGlobalsAndCode := ELFCodeOffset + (GlobalPages * 0x1000) As i32
	}
	else if (Config->OutputFormat = OUTPUT_PE) {
		Compiler->PE := BuildBuilder(Config->PESubsystem, Config->DebugMode & DEBUG_EMIT_RELOC)
		
		Compiler->PE->ImportFixupBase := Compiler->CodeBuffer
		Compiler->PE->PE->ImageBase := Config->ImageBase
		
		Compiler->GlobalBase := Config->ImageBase + 0x2000
		Compiler->CodeBase := 0x3000

		Compiler->DistanceBetweenGlobalsAndCode := 0x2000

		if (Config->PESubsystem = IMAGE_SUBSYSTEM_EFI_APPLICATION) {
			Compiler->GlobalBase := Config->ImageBase
			Compiler->CodeBase := Config->ImageBase + 0x2000
		}
	}
	
	Compiler->InitializeDebugInfo()
	
	Compiler->GlobalStringsLabel := NextLabel(Compiler)

	if (Config->DumpInfo & DUMP_GLOBALS) {
		DumpGlobals(Compiler)
	}

	; Loop through each custom type
	CompileTypeNamespace(Compiler, Parser->RootNamespace)
	
	; Compile all global functions
	CompileFunctionHashMap(Compiler, Parser~>Functions)
	
	if (Parser->MainFunction = null) {
		SwapOutputStream()
		Print("^C_Main function not found, aborting.^F_")
		Exit(1)
	}
	
	i32 MainOffset := Parser->MainFunction->CodeOffset
	
	ResolveAllLabels(Compiler)
	
	if (Config->DumpInfo & DUMP_FUNCTIONS) {
		Print("\t^1_Globals use %i bytes\n\t%i total bytes of code generated.\n\t%i total functions compiled.^F_\n", Parser~>Globals->NextOffset, Compiler->Index, Compiler->FunctionCount)
	}
	
	/* Actual compiling is done, time to build the output file */
	
	i64 OutputFileHandle := FileOpen(OutputFilePath, FILE_READ | FILE_WRITE | FILE_CREATE_NEW)
	
	if (OutputFileHandle < 0) {
		SwapOutputStream()
		Print("Could not open output file, error code: %i\nAborting\n", FileGetError(OutputFileHandle))
		Exit(1)
	}
	
	i32 Result := 0
	i32 BytesWritten := 0
	
	if (Config->OutputFormat = OUTPUT_BIN) {
		; The "bin" format is pretty much a 64 bit `.com` file. Except it contains an image base
		
		i32 CodeBase := Parser~>Globals->NextOffset + 0x10
		i32 FileSize := CodeBase + Compiler->Index
		
		void* Binary := Alloc(FileSize)
		i8* BinaryBytes := Binary As i8*
		
		BinaryBytes[0] := 0xE9 As i8
		((Binary + 1) As i32*)[0] := CodeBase + MainOffset - 5
		((Binary + 8) As i64*)[0] := Config->ImageBase
		
		for (i32 CodeIndex := 0, CodeIndex < Compiler->Index, CodeIndex += 1) {
			BinaryBytes[CodeBase + CodeIndex] := Compiler->CodeBuffer[CodeIndex]
		}
		
		Result := FileWrite(OutputFileHandle, Binary, FileSize)
		BytesWritten := FileSize
	}
	else if (Config->OutputFormat = OUTPUT_ELF && Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
		Compiler->CodeSection->Data := Compiler->CodeBuffer
		Compiler->CodeSection->Size := Compiler->Index

		Compiler->ReadOnlyDataSection->Data := Compiler->ReadOnlyData->Start()
		Compiler->ReadOnlyDataSection->Size := Compiler->ReadOnlyData->Size()

		Compiler->ZeroSection->Size := Parser~>Globals->NextOffset
		Compiler->ZeroSection->Data := Alloc(Compiler->ZeroSection->Size)

		if (Compiler->VirtualFunctionTables->Count()) {
			Compiler->VirtualFunctionTablesSection->Size := Compiler->VirtualFunctionTables->Count() * 8
			Compiler->VirtualFunctionTablesSection->Data := Alloc(Compiler->VirtualFunctionTablesSection->Size)

			Compiler->Object->AddNewSection(Compiler->VirtualFunctionTablesSection)
		}

		;Compiler->Object->Dump()

		ELFPassthroughObjectWriter* Passthrough := ELFPassthroughObjectWriter:New(Compiler->Object)
		Passthrough->Lower()
		ELFEmitter* Emit := Passthrough->Emit()

		BytesWritten := FileWrite(OutputFileHandle, Emit->Buffer, Emit->Size)
	}
	else if (Config->OutputFormat = OUTPUT_ELF) {
		Compiler->ELF->AddEmptyDataSection(Parser~>Globals->NextOffset)
		Compiler->ELF->AddCodeSection(Compiler->CodeBuffer, Compiler->Index)
		
		if (Config->DebugMode & DEBUG_EMIT_DWARF) {
			Compiler->DWARF->EndCompilationUnit(Compiler->DWARFCompilationUnitOffset, (Compiler->CodeBase + Compiler->Index) As i32)
			Compiler->DWARF->WriteSections(Compiler->ELF)
		}

		if (Config->PhysicalImageBase = 0) {
			Config->PhysicalImageBase := Config->ImageBase
		}

		if (Config->DebugMode & DEBUG_EMIT_OBJECT) {
			Compiler->ELF->AddSectionSymbols()
		}

		if (Config->DebugMode & DEBUG_EMIT_SYMBOLS) {
			; Global symbols need to come last

			if (Config->DebugMode & DEBUG_EMIT_NO_START_CODE) {
				; Only define our own `_start` if we want to emit startup code.
				; Otherwise, give it a better name

				Compiler->ELF->AddFunctionSymbol(ELF_STB_GLOBAL, "main", Compiler->MainOffset, Compiler->MainEnd)
			}
			else {
				Compiler->ELF->AddFunctionSymbol(ELF_STB_GLOBAL, "_start", Compiler->MainOffset, Compiler->MainEnd)
			}

			i16 SymbolTableIndex := Compiler->ELF->FinalizeSymbolTable()

			if (Config->DebugMode & DEBUG_EMIT_RELOC) {
				Compiler->ELF->FinalizeTextRelocations(SymbolTableIndex)
			}
		}

		if (Config->DebugMode & DEBUG_EMIT_DYNAMIC) {
			Compiler->ELF->SetProgramInterpreter("/lib64/ld-linux-x86-64.so.2")

			Compiler->ELF->FinalizeDynamicSection()
		}
		
		Compiler->ELF->Finalize(ELFCodeOffset, MainOffset, Config->ImageBase, Config->PhysicalImageBase)
		
		Result := FileWrite(OutputFileHandle, Compiler->ELF->Buffer, Compiler->ELF->BufferSize)
		BytesWritten := Compiler->ELF->BufferSize
	}
	else if (Config->OutputFormat = OUTPUT_PE) {
		AddData(Compiler->PE, Parser~>Globals->NextOffset)
		
		i64 TextRVA := AddCode(Compiler->PE, Compiler->CodeBuffer, Compiler->Index, MainOffset)
		
		if (Config->DebugMode & DEBUG_EMIT_RELOC) {
			for (i32 RelocationIndex := 0, RelocationIndex < (Compiler->CodeRelocationCount), RelocationIndex += 1) {
				i32 NextRelocationOffset := (Compiler->CodeRelocations)[RelocationIndex]
				
				i64 PageRVA := TextRVA + (NextRelocationOffset / 0x1000)
				i16 OffsetInPage := (NextRelocationOffset % 0x1000) As i16
				
				/* Todo: Decide if a 32 bit relocation is correct or not. As long as imagebase is 32 bits, this is fine for now */
				
				AddRelocation(Compiler->PE, PageRVA As i32, OffsetInPage, false)
			}
		}
		
		FinalizeBuilder(Compiler->PE, Config->DebugMode & DEBUG_EMIT_RELOC)
		
		Result := FileWrite(OutputFileHandle, Compiler->PE->Buffer, Compiler->PE->BufferSize)
		BytesWritten := Compiler->PE->BufferSize
	}
	
	if (Result < 0) {
		SwapOutputStream()
		Print("Error writing output file, error code: %i\nAborting\n", FileGetError(Result))
		Exit(1)
	}

	FileTruncate(OutputFileHandle, FileTell(OutputFileHandle))
	
	if !(Config->DumpInfo & DUMP_SILENT) {
		Print("^4_Done writing output file, %i bytes written, file format contains %i bytes of overhead^F_\n", BytesWritten, BytesWritten - Compiler->Index)
	}
	
	FileClose(OutputFileHandle)
}

define i8 StackIndexToRegister(i8 Index) {
	if (Index = 4) {
		return R13
	}
	else if (Index > 4) {
		return Index + 9 As i8
	}
	else {
		return Index + 8 As i8
	}
}



define i8 PushRegisterStack(CompilerState* Compiler) {
	i8 Index := Compiler->RegisterStackIndex
	
	i8 TrueIndex := (Index % 7) As i8
	i8 Result := StackIndexToRegister(TrueIndex)
	
	if (Index >= 8) {
		EmitPush_R64(Compiler, Result)
	}

	Compiler->RegisterStackIndex += 1
	
	return Result
}
define i8 TopOfRegisterStack(CompilerState* Compiler) {
	return StackIndexToRegister(Compiler->RegisterStackIndex)
}
define i8 PopRegisterStack(CompilerState* Compiler) {
	Compiler->RegisterStackIndex -= 1
	
	i8 Index := Compiler->RegisterStackIndex
	
	i8 TrueIndex := (Index % 7) As i8
	i8 Result := StackIndexToRegister(TrueIndex)
	
	if (Index >= 8) {
		EmitPop_R64(Compiler, Result)
	}
	
	return Result
}

define void EnsureCodeBufferSize(CompilerState* Compiler) {
	if ((Compiler->Index + 0x100) >= (Compiler->CodeBufferSize)) {
		Compiler->CodeBufferSize += 0x5000
		Compiler->CodeBuffer := ReAlloc(Compiler->CodeBuffer, Compiler->CodeBufferSize)
		
		if (Compiler->Config->OutputFormat = OUTPUT_PE) {
			Compiler->PE->ImportFixupBase := Compiler->CodeBuffer
		}
	}
}

define void AddCodeRelocation(CompilerState* Compiler, i32 Offset) {
	i32 Index := Compiler->CodeRelocationCount
	
	Compiler->CodeRelocations := ReAlloc(Compiler->CodeRelocations, (Index + 1) * 8)
	(Compiler->CodeRelocations)[Index] := Offset
	
	Compiler->CodeRelocationCount += 1
}


/*
==========================================
	Variable helpers
==========================================
*/

define i32 GetVariableOffset(CompilerState* Compiler, VariableInfo* TargetVariable, i8* FitsDisp8) {
	i32 Offset := TargetVariable->StackOffset
	
	if !(TargetVariable->IsGlobal) {
		if (Compiler->Config->DebugMode & DEBUG_EMIT_FUNCTION_NAMES) {
			Offset += 0x10
		}
	}
	
	if (FitsDisp8 != null) {
		FitsDisp8[0] := (Offset <= 112)
	}
	
	if (TargetVariable->IsGlobal) {
		return Offset
	}
	
	return -(Offset + 8)
}

define i32 GetGlobalMemoryOffset(CompilerState* Compiler, VariableInfo* TargetVariable) {
	; Get the distance from the first global to this code
	
	i64 GlobalsOffset := Compiler->DistanceBetweenGlobalsAndCode + Compiler->Index
	
	; Then negate it (making it the distance from this code to the first global) and add the variable's offset
	
	return (-GlobalsOffset + TargetVariable->StackOffset) As i32
}

/* Todo: Merge these three functions into one */

define void CompileGetVariableAddress(CompilerState* Compiler, i8 ResultRegister, VariableInfo* TargetVariable) {
	if (TargetVariable->IsGlobal) {
		if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
			ObjectSymbol* TargetSymbol := Compiler->FindOrAddGlobalObjectSymbol(TargetVariable)

			EmitLea_R64_REL32(Compiler, ResultRegister, 0)

			Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, TargetSymbol, -4)
		}
		else if (Compiler->Config->DebugMode & DEBUG_EMIT_OBJECT) {
			EmitLea_R64_REL32(Compiler, ResultRegister, 0)

			Compiler->ELF->ReferenceSymbol(Compiler->Index - 4, TargetVariable->Symbol, -4)
		}
		else {
			EmitLea_R64_Offset(Compiler, ResultRegister, GetGlobalMemoryOffset(Compiler, TargetVariable))
		}
	}
	else {
		i8 UseDisp8 := false
		i32 Offset := GetVariableOffset(Compiler, TargetVariable, &UseDisp8)
	
		if (UseDisp8) {
			EmitLea_R64_R64_DISP8(Compiler, ResultRegister, RBP, Offset As i8)
		}
		else {
			EmitLea_R64_R64_DISP32(Compiler, ResultRegister, RBP, Offset)
		}
	}
}

declare void CompileExpression(CompilerState*, i8, ASTNode*)
declare void Cast(CompilerState*, i8, i8)

define void CompileGetVariableValue(CompilerState* Compiler, i8 ResultRegister, VariableInfo* TargetVariable) {
	i8 TargetSize := GetTypeSize(TargetVariable->Type) As i8
	
	if (TargetVariable->Type.IsArray) {
		CompileGetVariableAddress(Compiler, ResultRegister, TargetVariable)
	}
	else if (TargetVariable->IsExternal) {
		if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
			ObjectSymbol* Target := Compiler->FindOrAddGlobalObjectSymbol(TargetVariable)

			EmitLea_R64_REL32(Compiler, ResultRegister, 0)

			Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, Target, -4)
		}
		else if (Compiler->Config->DebugMode & DEBUG_EMIT_OBJECT) {
			if !(TargetVariable->Symbol) {
				i8 SymbolType := ELF_STT_NONE

				if (TypeIsCallable(TargetVariable->Type)) {
					SymbolType := ELF_STT_FUNC
				}
				else {
					SymbolType := ELF_STT_OBJECT
				}

				TargetVariable->Symbol := Compiler->ELF->AddSymbol(TargetVariable->ExternalSymbolName->Buffer, ELF_SHN_UNDEF, ELF_STB_GLOBAL, SymbolType, 0, 0)
			}

			;Print("external reference to %s is symbol %i\n", TargetVariable->ExternalSymbolName->Buffer, TargetVariable->SymbolNumber)

			EmitLea_R64_REL32(Compiler, ResultRegister, 0)

			Compiler->ELF->ReferenceSymbol(Compiler->Index - 4, TargetVariable->Symbol, -4)
		}
		else {
			if !(TargetVariable->Symbol) {
				if (TypeIsCallable(TargetVariable->Type)) {
					TargetVariable->Symbol := Compiler->ELF->AddDynamicFunctionSymbol(TargetVariable->ExternalSymbolName->Buffer)
				}
				else {
					TargetVariable->Symbol := Compiler->ELF->AddDynamicGlobalSymbol(TargetVariable->ExternalSymbolName->Buffer)
				}
			}

			EmitMove_R64_I64(Compiler, ResultRegister, 0)

			Compiler->ELF->ReferenceDynamicSymbol(Compiler->Index - 8, TargetVariable->Symbol)
		}

		if !(TypeIsCallable(TargetVariable->Type)) {
			EmitMove_RX_RIX(Compiler, ResultRegister, ResultRegister, 8)
		}
	}
	else if (TargetVariable->IsGlobal = GLOBAL_IS_OPTIMIZED_AWAY) {
		; Node: I have no idea why this still needs to exist, FoldConstants should replace uses of these variables
		
		ASTNode* LastValue := TargetVariable->LastValue
		
		CompileExpression(Compiler, ResultRegister, LastValue)
		
		i16 LastValueSize := GetTypeSize(LastValue->ValueType)
		
		if (LastValueSize < 4) {
			Cast(Compiler, ResultRegister, LastValueSize As i8)
		}
	}
	else if (GetPointerDepth(TargetVariable->Type) = 0 && GetBaseType(TargetVariable->Type)->Is(TYPE_KIND_STRUCTURE)) {
		/* If GetVariableValue is called on a struct, then we should actually result in a pointer to that struct
			So Compile(Get|Set)StructField can depending on getting a pointer, and never the struct as a number
			Any time this could be abused *should* be caught by type checking 
		*/
		
		CompileGetVariableAddress(Compiler, ResultRegister, TargetVariable)
	}
	else {
		if (TargetVariable->IsGlobal) {
			if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
				ObjectSymbol* TargetSymbol := Compiler->FindOrAddGlobalObjectSymbol(TargetVariable)

				EmitMove_RX_REL32(Compiler, ResultRegister, 0, TargetSize)

				Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, TargetSymbol, -4)
			}
			else if (Compiler->Config->DebugMode & DEBUG_EMIT_OBJECT) {
				EmitMove_RX_REL32(Compiler, ResultRegister, 0, TargetSize)

				Compiler->ELF->ReferenceSymbol(Compiler->Index - 4, TargetVariable->Symbol, -4)
			}
			else {
				EmitMove_RX_Offset(Compiler, ResultRegister, GetGlobalMemoryOffset(Compiler, TargetVariable), TargetSize)
			}
		}
		else {
			i8 UseDisp8 := false
			i32 Offset := GetVariableOffset(Compiler, TargetVariable, &UseDisp8)
			
			EmitMove_RX_RIX_DISPX(Compiler, ResultRegister, RBP, Offset, UseDisp8, TargetSize)
		}
	}
}
define void CompileSetVariableValue(CompilerState* Compiler, VariableInfo* TargetVariable, i8 SourceRegister) {
	i8 TargetSize := GetTypeSize(TargetVariable->Type) As i8
	
	if (TargetVariable->IsGlobal) {
		if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
			ObjectSymbol* GlobalSymbol := Compiler->FindOrAddGlobalObjectSymbol(TargetVariable)

			EmitMove_REL32_RX(Compiler, 0, SourceRegister, TargetSize)

			Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, GlobalSymbol, -4)
		}
		else if (Compiler->Config->DebugMode & DEBUG_EMIT_OBJECT) {
			EmitMove_REL32_RX(Compiler, 0, SourceRegister, TargetSize)

			Compiler->ELF->ReferenceSymbol(Compiler->Index - 4, TargetVariable->Symbol, -4)
		}
		else {
			EmitMove_Offset_RX(Compiler, GetGlobalMemoryOffset(Compiler, TargetVariable), SourceRegister, TargetSize)
		}
	}
	else {
		i8 UseDisp8 := false
		i32 Offset := GetVariableOffset(Compiler, TargetVariable, &UseDisp8)
		
		if (UseDisp8) {
			EmitMove_RIX_DISP8_RX(Compiler, RBP, SourceRegister, Offset As i8, TargetSize)
		}
		else {
			EmitMove_RIX_DISP32_RX(Compiler, RBP, SourceRegister, Offset, TargetSize)
		}
	}
}


/*
==========================================
	Actual compile functions
==========================================
*/

define void Cast(CompilerState* Compiler, i8 Register, i8 Size) {
	if (Size <= 4) {
		EmitMove_R64_RX(Compiler, Register, Register, Size)
	}
}

define void CompileImportStub(CompilerState* Compiler, FunctionDefine* FunctionToCompile) {
	/* Compiles an imported function by emitting a jump to the actual function */
	
	FunctionToCompile->CodeOffset := Compiler->Index
	
	SetLabel(Compiler, FunctionToCompile->LabelNumber)
	
	EmitMove_R64_I64(Compiler, RBX, 0)
	
	AddImport(Compiler->PE, FunctionToCompile->ImportFileName, FunctionToCompile->ImportFunctionName, (Compiler->Index) - 8)
	AddCodeRelocation(Compiler, Compiler->Index - 8)
	
	EmitJump_RI64(Compiler, RBX)
}

declare void CompileBlock(CompilerState*, CodeBlock*)
declare void CompileAssembly(CompilerState*, AssemblyBlock*)

define i32 CompileFunction(CompilerState* Compiler, FunctionDefine* FunctionToCompile, i8 IsMain) {
	/* Compiles a single function */

	;Print("CompileFunction %s %x %x %x\n", FunctionToCompile->Name->Buffer, FunctionToCompile->AliasFor, Compiler->Index, FunctionToCompile->CodeOffset)

	if (FunctionToCompile->AliasFor) {
		;Print("ASDOIAUSDOIHASD\n")

		;FunctionToCompile~>Context->Warn("A")
		;FunctionToCompile->AliasFor~>Context->Warn("B")

		;Print("a: %i\n", FunctionToCompile->Body->StatementCount)
		;Print("b: %i\n", FunctionToCompile->AliasFor->Body->StatementCount)


		return CompileFunction(Compiler, FunctionToCompile->AliasFor, false)
	}

	if (FunctionToCompile->CodeOffset) {
		if (FunctionToCompile->IsMethod = FUNCTION_IS_INTERFACE_METHOD) {
			return FunctionToCompile->CodeOffset
		}
		else {
			FunctionToCompile~>Context->Error("INTERNAL: Compiled more than once")
		}
	}
	
	if (IsMain) {
		SetLabel(Compiler, Compiler->GlobalStringsLabel)
		
		if !(Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
			for (i32 ConstantByteIndex := 0, ConstantByteIndex < Compiler->Parser->GlobalConstantBufferSize, ConstantByteIndex += 1) {
				PushByte(Compiler, Compiler->Parser->GlobalConstantsBuffer[ConstantByteIndex])
			}
		}

			/*ObjectSymbol* MainSymbol := ObjectSymbol:New(
				SYMBOL_BINDING_GLOBAL, SYMBOL_TYPE_FUNCTION, SYMBOL_VISIBILITY_DEFAULT,
				Compiler->CodeSection, "main",
				Compiler->Index, 0
			)

			Compiler->Object->AddSymbol(MainSymbol)*/
	}
	
	; First though, we'll prefix the function's code with any strings which it uses
	i32 StringsLabel := NextLabel(Compiler)
	
	if (FunctionToCompile->StringBufferSize) {
		SetLabel(Compiler, StringsLabel)

		if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
			i8* SymbolName := FormatString("strings(%func)", FunctionToCompile)

			ObjectSymbol* StringsSymbol := ObjectSymbol:New(
				SYMBOL_BINDING_LOCAL, SYMBOL_TYPE_DATA, SYMBOL_VISIBILITY_DEFAULT,
				Compiler->ReadOnlyDataSection, SymbolName,
				FunctionToCompile->StringBufferSize, Compiler->ReadOnlyData->Size()
			)

			; TODO: This looks like a compiler bug. StringsSymbol->Value is set in :New
			;  but has a bad value. Seems to be related to `SymbolName` being inlined, with
			;   the variadic call to `FormatString`

			Compiler->ReadOnlyData->Push(FunctionToCompile->StringBuffer, FunctionToCompile->StringBufferSize)
			Compiler->Object->AddSymbol(StringsSymbol)

			Compiler->CurrentFunctionStringsSymbol := StringsSymbol
		}
		else {
			for (i32 CharacterIndex := 0, CharacterIndex < FunctionToCompile->StringBufferSize, CharacterIndex += 1) {
				PushByte(Compiler, FunctionToCompile->StringBuffer[CharacterIndex])
			}
		}
	}
	
	i32 FunctionOffset := Compiler->Index
	SetLabel(Compiler, FunctionToCompile->LabelNumber)

	FunctionToCompile->CodeOffset := Compiler->Index

	;Print("SetLabel %i %func @ %x\n", FunctionToCompile->LabelNumber, FunctionToCompile, Compiler->AddressOfCodeOffset(FunctionOffset))
	
	i32 DebugData := Compiler->BeforeCompileFunction(FunctionToCompile)
	
	if (FunctionToCompile->Attributes & FUNCTION_ATTRIBUTE_ASSEMBY) {
		/* Assembly functions should have no extra code generated, just whatever the asm block contains. */
		
		CompileAssembly(Compiler, FunctionToCompile->AssemblyBody)
		
		Compiler->AfterCompileFunction(FunctionToCompile, DebugData, FunctionOffset)
		
		return FunctionOffset
	}
	
	if (FunctionToCompile->Body->StatementCount = 0) {
		/* Empty functions don't deserve any prelude code. */
		
		EmitReturn(Compiler)
		
		Compiler->AfterCompileFunction(FunctionToCompile, DebugData, FunctionOffset)
		
		return FunctionOffset
	}
	
	Compiler->RegisterStackIndex := 0
	Compiler->CurrentFunction := FunctionToCompile
	Compiler->CurrentFunctionStringsLabel := StringsLabel
	
	i8 USE_SYSTEMV := true /* Compiler->OutputELF */
	
	if (FunctionToCompile->Attributes & FUNCTION_ATTRIBUTE_USE_X64) {
		; Force a function to be compiled using the x64 ABI
		USE_SYSTEMV := false
	}
	
	/* Assume 4 register parameters, and 0 stack parameters */
	i8 MAX_REGISTER_PARAMETERS := 4
	
	if (USE_SYSTEMV) {
		MAX_REGISTER_PARAMETERS := 6
	}
	
	i16 ParameterCount := FunctionToCompile->ParameterCount
	i16 RegisterParameterCount := MAX_REGISTER_PARAMETERS
	i16 StackParameterCount := 0
	
	if (ParameterCount < MAX_REGISTER_PARAMETERS) {
		/* If there are less than 4/6 parameters, then the number of register parameters is just the number of parameters */
		
		RegisterParameterCount := ParameterCount
	}
	else if (ParameterCount > MAX_REGISTER_PARAMETERS) {
		/* Else if there are 5/7+ parameters, the stack parameter count is (TotalParamCount - MAX_REGISTER_PARAMETERS) */
		
		StackParameterCount := ParameterCount - MAX_REGISTER_PARAMETERS
		
		/* Also, store RSP in RBX for extracting the stack parameters with smaller offsets */
		EmitMove_R64_R64(Compiler, RBX, RSP)
	}
	
	/* Set up the stack frame for this function */
	i32 LocalSpace := FunctionToCompile~>Locals->NextOffset
	i32 LocalSpaceRemainder := LocalSpace % 16
	
	if (LocalSpaceRemainder) {
		LocalSpace += 16 - LocalSpaceRemainder
	}
	
	EmitPush_R64(Compiler, RBP)
	EmitMove_R64_R64(Compiler, RBP, RSP)
	
	if (IsMain && Compiler->Config->OutputFormat = OUTPUT_ELF && ParameterCount <= 2) {
		/* When compiling main for SystemV, load the first two parameter registers (if they exist) 
			With ArgC and ArgV loaded from the stack since:
				RBP + 0 = ArgC
				RBP + 1..ArgC = ArgV
			so mov rdi, [rsp+8] will get argc, and
			lea rsi, [rsp+16] will get argv
			which are then moved into the local ArgC/ArgV variables by the default parameter saving behavior

			NOTE: FreeBSD aligns the stack before calling the entrypoint, which is super annoying to deal with here.
				However, the CRT startup code assumes that RDI points to argc, so that's what we do too.
		*/
		
		if !(Compiler->Config->DebugMode & DEBUG_EMIT_NO_START_CODE) {
			if (Compiler->Config->ELFABI = ELF_ABI_LINUX) {
				EmitMove_RX_RIX_DISPX(Compiler, RDI, RBP, 0x8, true, 8)
				EmitLea_R64_R64_DISP8(Compiler, RSI, RBP, 0x10)
			}
			else if (Compiler->Config->ELFABI = ELF_ABI_FREEBSD) {
				EmitLea_R64_R64_DISP8(Compiler, RSI, RDI, 0x8)
				EmitMove_RX_RIX(Compiler, RDI, RDI, 8)
			}
		}
	}
	
	if (Compiler->Config->DebugMode & DEBUG_EMIT_FUNCTION_NAMES) {
		EmitPush_I32(Compiler, 0x12345678)

		if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
			EmitLea_R64_REL32(Compiler, RAX, 0)

			Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, Compiler->CurrentFunctionStringsSymbol, -4)
		}
		else {
			EmitLea_R64_Label(Compiler, RAX, StringsLabel)
		}

		EmitPush_R64(Compiler, RAX)
		
		; Extend LocalSpace to account for extra offset from RBP to local variables
		LocalSpace += 0x10
	}
	
	if (LocalSpace) {
		/* Only emit an instruction to allocate space for locals when we have locals */
		
		i32 LocalSlots := LocalSpace / 8
		
		if (LocalSlots < 4) {
			for (i32 Index := 0, Index < LocalSlots, Index++) {
				EmitPush_R64(Compiler, RAX)
			}
		}
		else {
			EmitSub_R64_IX(Compiler, RSP, LocalSpace)
		}
	}
	
	for (i8 RegisterParameterIndex := 0, RegisterParameterIndex < RegisterParameterCount, RegisterParameterIndex += 1) {
		/* For each register parameter */
		
		/* Get the VariableInfo structure for the parameter */
		VariableInfo* NextParameter := (FunctionToCompile->Parameters)[RegisterParameterIndex]
		
		/* And which register it is in (according to the target ABI) */
		i8 NextParameterRegister := Compiler->GetParameterRegister(RegisterParameterIndex, !USE_SYSTEMV)
		
		/* And write the parameter register's value into the parameter's stack space */
		CompileSetVariableValue(Compiler, NextParameter, NextParameterRegister)
	}
	
	; On SystemV, there's only a return address between entry RSP and the stack parameters, but on windows, there's
	;  0x20 bytes of "shadow space" which we need to account for
	
	i32 StackParametersOffset := 0x20 * !USE_SYSTEMV 
	
	for (i8 StackParameterIndex := 0, StackParameterIndex < StackParameterCount, StackParameterIndex += 1) {
		/* For each stack parameter */
		
		/* Get the VariableInfo structure for the parameter */
		VariableInfo* NextStackParameter := FunctionToCompile->Parameters[StackParameterIndex + MAX_REGISTER_PARAMETERS]
		
		/* Load RAX with the parameter's value (using RBX/old RSP as a base) */
		
		i8 NextParameterOffset := ((StackParameterIndex + 1) * 8) As i8
		i8 NextParameterSize := GetTypeSize(NextStackParameter->Type) As i8
		
		;EmitMove_RX_RIX_DISP8(Compiler, RAX, RBX, NextParameterOffset, NextParameterSize)
		EmitMove_RX_RIX_DISPX(Compiler, RAX, RBX, StackParametersOffset + NextParameterOffset, true, NextParameterSize)
		
		/* Write RAX(/the parameter's value) into the parameter's stack space */
		CompileSetVariableValue(Compiler, NextStackParameter, RAX)
	}
	
	if (IsMain) {
		Compiler->CurrentFunctionStringsLabel := Compiler->GlobalStringsLabel
		Compiler->CurrentFunctionStringsSymbol := Compiler->GlobalStringsSymbol
		
		ASTNode** GlobalDefaults := Compiler->Parser->GlobalDefaults
		i32 Length := GetArrayLength(GlobalDefaults)
		
		for (i32 GlobalDefaultIndex := 0, GlobalDefaultIndex < Length, GlobalDefaultIndex += 1) {
			ASTNode* NextGlobalDefault := GlobalDefaults[GlobalDefaultIndex]
			
			if (NextGlobalDefault->NodeType = NODE_TYPE_BINARY && NextGlobalDefault->BinaryNode->Left->NodeType = NODE_TYPE_VARIABLE) {
				VariableInfo* TargetGlobal := NextGlobalDefault->BinaryNode->Left->VariableValue
				
				if (TargetGlobal->IsGlobal != GLOBAL_IS_OPTIMIZED_AWAY) {
					;Print("CMLN1 %s\n", TargetGlobal->Name->Buffer)
					
					Compiler->MarkLineNumber(NextGlobalDefault~>Context)
					
					;Print("CMLN2 %s\n", TargetGlobal->Name->Buffer)
					
					CompileExpression(Compiler, RAX, NextGlobalDefault)
				}
			}
			else {
				;Print("CMLN3\n")
				
				Compiler->MarkLineNumber(NextGlobalDefault~>Context)
				
				;Print("CMLN4\n")
				
				CompileExpression(Compiler, RAX, NextGlobalDefault)
			}
		}
		
		Compiler->CurrentFunctionStringsLabel := StringsLabel
		Compiler->CurrentFunctionStringsSymbol := StringsSymbol

		i32 InitializerCount := Compiler->InitializerLabels->Count()

		for (i32 Index := 0, Index < InitializerCount, Index++) {
			i32 InitializerLabel := Compiler->InitializerLabels->At(Index) As i32

			EmitCall_Label(Compiler, InitializerLabel)
		}
	}
	
	Compiler->MarkLineNumber(FunctionToCompile~>Context)
	Compiler->AfterPrologueEnd()
	
	/* Compile the body of the function */
	
	CodeBlock* Body := FunctionToCompile->Body
	i32 BodyCount := Body->StatementCount
	ASTNode* ReturnExpression := null
	
	if (BodyCount >= 1) {
		/* If the last statement of the function body is a return, then don't emit a Leave;Ret combo for it 
			since every function automatically gets Leave;Ret emitted for it.
		*/
		
		ASTNode* LastStatement := Body->Statements[BodyCount - 1]
		
		if (LastStatement->NodeType = NODE_TYPE_RETURN) {
			;LastStatement->Warn("LAST")

			ReturnExpression := LastStatement->ReturnNode->Value
			Body->StatementCount -= 1
		}
	}
	
	Compiler->CompilingMain := IsMain
	
	CompileBlock(Compiler, Body)
	
	if (ReturnExpression) {
		;Compiler->MarkLineNumber(LastStatement~>Context)
		
		CompileExpression(Compiler, RAX, ReturnExpression)
		
		i16 ReturnValueSize := GetTypeSize(ReturnExpression->ValueType)
		i16 ReturnTypeSize := GetTypeSize(Compiler->CurrentFunction->ReturnType)
		
		if (ReturnValueSize < ReturnTypeSize || ReturnValueSize < 4) {
			Cast(Compiler, RAX, ReturnValueSize As i8)
		}
	}
	
	;Compiler->BeforeEpilogueBegin()
	
	EmitLeave(Compiler)

	i8 IsELF := Compiler->Config->OutputFormat = OUTPUT_ELF
	i8 IsNotGeneric := Compiler->Config->ELFABI != ELF_ABI_SYSTEMV
	i8 EmitStartCode := !(Compiler->Config->DebugMode & DEBUG_EMIT_NO_START_CODE)
	
	if (IsMain && IsELF && IsNotGeneric && EmitStartCode) {
		EmitMove_R64_R64(Compiler, RDI, RAX)

		i32 LINUX_SYSCALL_EXIT := 60
		i32 FREEBSD_13_1_SYSCALL_EXIT := 1

		if (Compiler->Config->ELFABI = ELF_ABI_LINUX) {
			EmitMove_R32_I32(Compiler, RAX, LINUX_SYSCALL_EXIT)
		}
		else if (Compiler->Config->ELFABI = ELF_ABI_FREEBSD) {
			EmitMove_R32_I32(Compiler, RAX, FREEBSD_13_1_SYSCALL_EXIT)
		}

		EmitSysCall(Compiler)
	}
	else {
		EmitReturn(Compiler)
	}
	
	if (Compiler->RegisterStackIndex != 0) {
		FunctionToCompile~>Context->Error("Register stack not empty, good job")
	}
	
	Compiler->CurrentFunction := null

	if (IsMain) {
		Compiler->MainOffset := FunctionOffset
		Compiler->MainEnd := Compiler->Index
	}
	
	Compiler->AfterCompileFunction(FunctionToCompile, DebugData, FunctionOffset)
	
	return FunctionOffset
}

declare void Compile(CompilerState*, ASTNode*)

define void CompileBlock(CompilerState* Compiler, CodeBlock* BlockToCompile) {
	/* Compiles a block of statements */
	
	for (i32 Index := 0, Index < BlockToCompile->StatementCount, Index += 1) {
		ASTNode* NextStatement := (BlockToCompile->Statements)[Index]
		
		Compile(Compiler, NextStatement)
	}
}

declare void CompileReturn(CompilerState*, ASTNode*)
declare void CompileIf(CompilerState*, IfGroup*)
declare void CompileFor(CompilerState*, ForLoop*)
declare void CompileLoop(CompilerState*, CodeBlock*)
declare void CompileWhile(CompilerState*, WhileLoop*)
declare void CompileTry(CompilerState*, TryCatch*)

declare void CompileUnary(CompilerState*, i8, Type, UnaryExpression*, i8)
declare void CompileBinary(CompilerState*, i8, Type, BinaryExpression*, i8)
declare void CompileGetStructAccess(CompilerState*, i8, StructAccessExpression*)
declare void CompileCall(CompilerState*, i8, ASTNode*)

declare void CompileUnwindTry(CompilerState*, i8)

define void Compile(CompilerState* Compiler, ASTNode* NodeToCompile) {
	/* Compiles some kind of statement */

	Compiler->MarkLineNumber(NodeToCompile~>Context)
	
	i8 NodeType := NodeToCompile->NodeType
	
	if (NodeType = NODE_TYPE_RETURN) {
		CompileReturn(Compiler, NodeToCompile->ReturnNode->Value)
	}
	else if (NodeType = NODE_TYPE_IF) {
		CompileIf(Compiler, NodeToCompile->IfNode)
	}
	else if (NodeType = NODE_TYPE_FOR) {
		CompileFor(Compiler, NodeToCompile->ForNode)
	}
	else if (NodeType = NODE_TYPE_LOOP) {
		CompileLoop(Compiler, NodeToCompile->LoopBody)
	}
	else if (NodeType = NODE_TYPE_WHILE) {
		CompileWhile(Compiler, NodeToCompile->WhileNode)
	}
	else if (NodeType = NODE_TYPE_TRY) {
		CompileTry(Compiler, NodeToCompile->TryNode)
	}
	else if (NodeType = NODE_TYPE_CONTINUEBREAK) {
		CompileUnwindTry(Compiler, false)
		
		if (NodeToCompile->IsContinue) {
			EmitJump_Label(Compiler, Compiler->CurrentLoopContinueLabel)
		}
		else {
			EmitJump_Label(Compiler, Compiler->CurrentLoopBreakLabel)
		}
	}
	else if (NodeType = NODE_TYPE_EXPRESSION) {
		CompileExpression(Compiler, RAX, NodeToCompile->ExpressionStatement)
	}
	else if (NodeType = NODE_TYPE_ASSEMBLY) {
		CompileAssembly(Compiler, NodeToCompile->AssemblyValue)
	}
	else if (NodeType = NODE_TYPE_BLOCK) {
		CompileBlock(Compiler, NodeToCompile->BlockValue)
	}
}

define void CompileReturn(CompilerState* Compiler, ASTNode* ReturnExpression) {
	/* Compile the expression to return */
	
	CompileUnwindTry(Compiler, true)
	
	CompileExpression(Compiler, RAX, ReturnExpression)
	
	i16 ReturnValueSize := GetTypeSize(ReturnExpression->ValueType)
	i16 ReturnTypeSize := GetTypeSize(Compiler->CurrentFunction->ReturnType)
	
	/* And cast it up to (at least) 4 bytes, to ensure no garbage is left in RAX */
	
	if (ReturnValueSize < ReturnTypeSize || ReturnValueSize < 4) {
		Cast(Compiler, RAX, ReturnValueSize As i8)
	}
	
	;Compiler->BeforeEpilogueBegin()
	;Compiler->MarkLineNumber(ReturnExpression~>Context)
	
	EmitLeave(Compiler)

	i8 IsMain := Compiler->CompilingMain
	i8 IsELF := Compiler->Config->OutputFormat = OUTPUT_ELF
	i8 EmitStartCode := !(Compiler->Config->DebugMode & DEBUG_EMIT_NO_START_CODE)
	
	if (IsMain && IsELF && EmitStartCode) {
		/* If returning from Main() on Linux/BSD, actually call sys_exit() to ensure that the program exits correctly. */
		
		EmitMove_R64_R64(Compiler, RDI, RAX)

		i32 LINUX_SYSCALL_EXIT := 60
		i32 FREEBSD_13_1_SYSCALL_EXIT := 1

		if (Compiler->Config->ELFABI = ELF_ABI_LINUX) {
			EmitMove_R32_I32(Compiler, RAX, LINUX_SYSCALL_EXIT)
		}
		else if (Compiler->Config->ELFABI = ELF_ABI_FREEBSD) {
			EmitMove_R32_I32(Compiler, RAX, FREEBSD_13_1_SYSCALL_EXIT)
		}

		EmitSysCall(Compiler)
	}
	else {
		EmitReturn(Compiler)
	}
}

define i8 IsComparison(Token* OperatorToken) {
	i8 Operator := OperatorToken->Value As i8
	
	return (OPERATOR_FIRST_SHORT_CIRCUIT <= Operator && Operator <= OPERATOR_LAST_COMPARISON)
}

define void CompileCondition(CompilerState* Compiler, ASTNode* ConditionExpression, i32 JumpToLabel) {
	/* Checks ConditionExpression for being false, and jumps to JumpToLabel if it is 
		This might seem a bit backwards, but loops/if statements all check for false, and jump out (or to the next branch)
		 depending on their conditions being false, which eliminates lots of extra jumping
	*/
	
	i8 ConditionType := ConditionExpression->NodeType
	
	BinaryExpression* BinaryNode := ConditionExpression->BinaryNode
	UnaryExpression* UnaryNode := ConditionExpression->UnaryNode
	
	if (ConditionType = NODE_TYPE_BINARY && IsComparison(BinaryNode->Operator)) {
		/* Compile the expression without a result being stored into RAX, since we use the value in EFLAGS */
		
		i8 Operator := BinaryNode->Operator->Value As i8
		
		ASTNode* Right := BinaryNode->Right
		i8 IsEquals := (Operator = OPERATOR_EQUAL || Operator = OPERATOR_BANG_EQUAL)
		
		if (IsEquals && (Right->NodeType = NODE_TYPE_INTEGER && Right->IntegerValue = 0)) {
			CompileExpression(Compiler, RAX, BinaryNode->Left)
			
			EmitOr_RX_RX(Compiler, RAX, RAX, GetTypeSize(BinaryNode->Left->ValueType) As i8)
			
			if (Operator = OPERATOR_EQUAL) {
				EmitJNZ_Label(Compiler, JumpToLabel)
			}
			else {
				EmitJEZ_Label(Compiler, JumpToLabel)
			}
		}
		else {
			CompileBinary(Compiler, RAX, ConditionExpression->ValueType, BinaryNode, true)
			
			/* Use inverted conditions to decide if this branch had a false condition, and to jump past it or not */
			
			if (Operator = OPERATOR_EQUAL) {
				EmitJNZ_Label(Compiler, JumpToLabel)
			}
			else if (Operator = OPERATOR_BANG_EQUAL) {
				EmitJEZ_Label(Compiler, JumpToLabel)
			}
			else if (Operator = OPERATOR_LESS) {
				EmitJGE_Label(Compiler, JumpToLabel)
			}
			else if (Operator = OPERATOR_LESS_EQAUL) {
				EmitJGT_Label(Compiler, JumpToLabel)
			}
			else if (Operator = OPERATOR_GREATER) {
				EmitJLE_Label(Compiler, JumpToLabel)
			}
			else if (Operator = OPERATOR_GREATER_EQAUL) {
				EmitJLT_Label(Compiler, JumpToLabel)
			}
			else if (Operator = OPERATOR_LOGICAL_AND || Operator = OPERATOR_LOGICAL_OR) {
				EmitJEZ_Label(Compiler, JumpToLabel)
			}
		}
	}
	else if (ConditionType = NODE_TYPE_UNARY && (UnaryNode->Operator->Value As i8) = OPERATOR_BANG) {
		CompileUnary(Compiler, RAX, ConditionExpression->ValueType, UnaryNode, true)
		EmitJNZ_Label(Compiler, JumpToLabel)
	}
	else {
		/* In this case, the expression is not conditional, and we will need to check the result for being 0 or not */
		
		CompileExpression(Compiler, RAX, ConditionExpression)
		EmitTest_RX_RX(Compiler, RAX, RAX, GetTypeSize(ConditionExpression->ValueType) As i8)
		EmitJEZ_Label(Compiler, JumpToLabel)
	}
}

define void CompileIf(CompilerState* Compiler, IfGroup* IfToCompile) {
	i32 BranchCount := IfToCompile->BranchCount
	i32 HasElse := (IfToCompile->ElseBranch) != 0
	
	i32 EndLabel := NextLabel(Compiler)
	i32 NextBranch := NextLabel(Compiler)
	
	i8 ConditionResultRegister := PushRegisterStack(Compiler)
	
	for (i32 BranchIndex := 0, BranchIndex < BranchCount, BranchIndex += 1) {
		SetLabel(Compiler, NextBranch)
		NextBranch := NextLabel(Compiler)
		
		ASTNode* Condition := IfToCompile->Conditions[BranchIndex]
		
		if (Condition->NodeType = NODE_TYPE_NONE) {
			continue
		}
		
		CompileCondition(Compiler, Condition, NextBranch)
		CompileBlock(Compiler, IfToCompile->Bodies[BranchIndex])
		
		if (HasElse || (BranchIndex != (BranchCount - 1))) {
			/* Only emit a jump to the end label if: We have an 'else', or we are not the last branch 
				This will eliminate a single extra `jmp, endlabel` on the final 'else if' of the statement
				
			*/
			
			EmitJump_Label(Compiler, EndLabel)
		}
	}
	
	PopRegisterStack(Compiler)
	
	SetLabel(Compiler, NextBranch)
	
	if (IfToCompile->ElseBranch) {
		CompileBlock(Compiler, IfToCompile->ElseBranch)
	}
	
	SetLabel(Compiler, EndLabel)
}

/* Helpers to save/restore the current loop's continue/break labels (for nested loops) */

bits LoopLables As i64 {
	[0:31] ContinueLabel,
	[32:63] BreakLabel
}
define i64 EnterLoop(CompilerState* Compiler, i32 ContinueLabel, i32 BreakLabel) {
	LoopLables Result := Compiler->CurrentLoopContinueLabel As LoopLables
	Result.BreakLabel := Compiler->CurrentLoopBreakLabel
	
	Compiler->CurrentLoopContinueLabel := ContinueLabel
	Compiler->CurrentLoopBreakLabel := BreakLabel
	
	return Result As i64
}
define void ExitLoop(CompilerState* Compiler, i64 PackedLooParser) {
	LoopLables LoopState := PackedLooParser As LoopLables
	
	Compiler->CurrentLoopContinueLabel := LoopState.ContinueLabel
	Compiler->CurrentLoopBreakLabel := LoopState.BreakLabel
}


/* Actual loop compiling functions */

define void CompileFor(CompilerState* Compiler, ForLoop* ForToCompile) {
	CompileExpression(Compiler, RAX, ForToCompile->Initializer)
	
	i32 StartLabel := NextLabel(Compiler)
	i32 ContinueLabel := NextLabel(Compiler)
	i32 EndLabel := NextLabel(Compiler)
	
	SetLabel(Compiler, StartLabel)
	
	CompileCondition(Compiler, ForToCompile->Condition, EndLabel)
	
	i32 TryDepth := Compiler->ScopedTryDepth
	Compiler->ScopedTryDepth := 0
	i64 LoopState := EnterLoop(Compiler, ContinueLabel, EndLabel)

	/* Prelude stuff done, condition is checked, so now we can compile the body */	
	
	CompileBlock(Compiler, ForToCompile->Body)
	
	SetLabel(Compiler, ContinueLabel) /* On continue (or after the body ends naturally) execute the step, and jump to the condition check */
	CompileExpression(Compiler, RAX, ForToCompile->Step)
	
	EmitJump_Label(Compiler, StartLabel)
	
	SetLabel(Compiler, EndLabel) /* Jumped to on ForToCompile->Condition being false, or a break statement */
	
	ExitLoop(Compiler, LoopState)
	Compiler->ScopedTryDepth := TryDepth
}

define void CompileLoop(CompilerState* Compiler, CodeBlock* LoopBody) {
	i32 StartLabel := NextLabel(Compiler)
	i32 EndLabel := NextLabel(Compiler)
	
	i32 TryDepth := Compiler->ScopedTryDepth
	Compiler->ScopedTryDepth := 0
	i64 LoopState := EnterLoop(Compiler, StartLabel, EndLabel)
	
	SetLabel(Compiler, StartLabel)
	
	CompileBlock(Compiler, LoopBody)
	
	EmitJump_Label(Compiler, StartLabel)
	SetLabel(Compiler, EndLabel)
	
	ExitLoop(Compiler, LoopState)
	Compiler->ScopedTryDepth := TryDepth
}

define void CompileWhile(CompilerState* Compiler, WhileLoop* WhileToCompile) {
	i32 StartLabel := NextLabel(Compiler)
	i32 EndLabel := NextLabel(Compiler)
	
	i32 TryDepth := Compiler->ScopedTryDepth
	Compiler->ScopedTryDepth := 0
	i64 LoopState := EnterLoop(Compiler, StartLabel, EndLabel)
	
	SetLabel(Compiler, StartLabel)
	
	CompileCondition(Compiler, WhileToCompile->Condition, EndLabel)
	CompileBlock(Compiler, WhileToCompile->Body)
	
	EmitJump_Label(Compiler, StartLabel)
	SetLabel(Compiler, EndLabel)
	
	ExitLoop(Compiler, LoopState)
	Compiler->ScopedTryDepth := TryDepth
}

define void CompileGetStorageValue(CompilerState* Compiler, ASTNode* ValueToGet) { 
	
	
}
define void CompileSetStorageValue(CompilerState* Compiler, ASTNode* ValueToSet, i8 RegisterToSetTo) {
	
}

define void CompileGetStorageValuePointer(CompilerState* Compiler, ASTNode* ValueToGet) {
	
}


define void CompileExpression(CompilerState* Compiler, i8 ResultRegister, ASTNode* ExpressionToCompile) {
	/* Compiles some kind of expression */
	
	i8 ExpressionType := ExpressionToCompile->NodeType
	Type ResultType := ExpressionToCompile->ValueType
	
	if (ExpressionType = NODE_TYPE_INTEGER) {
		/* Simply move the integer being used into the result register */
		
		i8 ResultSize := GetTypeSize(ResultType) As i8
		i64 IntegerValue := ExpressionToCompile->IntegerValue
		
		if (IntegerValue = 0) {
			EmitXor_RX_RX(Compiler, ResultRegister, ResultRegister, 4)
		}
		else {
			i8 IntegerSize := GetNumberSize(IntegerValue)
			
			if (ResultSize >= 4 && IntegerSize <= 4) {
				ResultSize := 4
			}
			
			EmitMove_RX_IX(Compiler, ResultRegister, IntegerValue, ResultSize)
		}
	}
	else if (ExpressionType = NODE_TYPE_ZERO) {
		EmitXor_RX_RX(Compiler, ResultRegister, ResultRegister, 4)
	}
	else if (ExpressionType = NODE_TYPE_VARIABLE) {
		VariableInfo* TargetVariable := ExpressionToCompile->VariableValue
		
		CompileGetVariableValue(Compiler, ResultRegister, TargetVariable)
	}
	else if (ExpressionType = NODE_TYPE_UNARY) {
		UnaryExpression* UnaryNode := ExpressionToCompile->UnaryNode
	
		CompileUnary(Compiler, ResultRegister, ResultType, UnaryNode, false)
	}
	else if (ExpressionType = NODE_TYPE_BINARY) {
		/* Calls into CompileBinary with the correct parameters extracted from ExpressionToCompile */
		
		BinaryExpression* BinaryNode := ExpressionToCompile->BinaryNode
		
		CompileBinary(Compiler, ResultRegister, ResultType, BinaryNode, false)
	}
	else if (ExpressionType = NODE_TYPE_STRUCT_ACCESS) {
		StructAccessExpression* AccessNode := ExpressionToCompile->AccessNode
		
		CompileGetStructAccess(Compiler, ResultRegister, AccessNode)
	}
	else if (ExpressionType = NODE_TYPE_CALL) {
		CompileCall(Compiler, ResultRegister, ExpressionToCompile)
	}
	else if (ExpressionType = NODE_TYPE_STRING) {
		if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
			EmitLea_R64_REL32(Compiler, ResultRegister, 0)

			Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, Compiler->CurrentFunctionStringsSymbol, ExpressionToCompile->StringOffsetValue - 4)
		}
		else {
			EmitLea_R64_Label(Compiler, ResultRegister, Compiler->CurrentFunctionStringsLabel)
			OffsetLabel(Compiler, ExpressionToCompile->StringOffsetValue)
		}
	}
	else if (ExpressionType = NODE_TYPE_GET_TYPE_SIZE) {
		i32 OperandTypeSize := GetTypeStorageSize(ExpressionToCompile->TypeValue)
		
		EmitMove_RX_IX(Compiler, ResultRegister, OperandTypeSize, 4)
	}
	else if (ExpressionType = NODE_TYPE_EXPRESSION_BLOCK) {
		CodeBlock* ExpressionBlock := ExpressionToCompile->BlockValue
		
		for (i32 Index := 0, Index < ExpressionBlock->StatementCount, Index += 1) {
			CompileExpression(Compiler, RAX, ExpressionBlock->Statements[Index])
		}
	}
	else if (ExpressionType = NODE_TYPE_DYNAMIC_CAST) {
		if !(Compiler->Config->DumpInfo & DUMP_SILENT) {
			;ExpressionToCompile->Warn("Dynamic Cast")
		}

		ASTNode* Value := ExpressionToCompile->CastFromValue

		CompileExpression(Compiler, ResultRegister, Value)

		TypeInfo* From := GetBaseType(Value->ValueType)
		TypeInfo* To := GetBaseType(ExpressionToCompile->ValueType)

		i32 Sign := 0
		ClassInfo* Info := null
		TypeInfo* InterfaceType := null

		if (From->IsClass) {
			; Downcast, class -> interface

			Sign := 1
			Info := From->ClassInfo
			InterfaceType := To
		}
		else if (To->IsClass) {
			; Upcast, interface -> class

			Sign := -1
			Info := To->ClassInfo
			InterfaceType := From
		}

		InterfaceImplementationInfo* Implementation := Info->Interfaces->GetPointer(InterfaceType)
		i32 Index := Info->InterfacesInOrder->Find(Implementation)

		if (Index != 0) {
			if (Sign = 1) {
				EmitAdd_R64_IX(Compiler, ResultRegister, Index * 8)
			}
			else if (Sign = -1) {
				EmitSub_R64_IX(Compiler, ResultRegister, Index * 8)
			}
		}
	}
}
;/*
define void CompileInterfaceImplementation(CompilerState* Compiler, TypeInfo* ForType, InterfaceImplementationInfo* Info) {
	ClassInfo* ForClass := ForType->ClassInfo
	InterfaceInfo* ForInterface := Info->ForInterfaceInfo
	i32 Offset := ForClass->InterfacesInOrder->Find(Info)

	if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
		;*null := 0
	}

	Print("CompileInterfaceImpl %t %s\n", ForType->AsNonPointer(), ForInterface->Name->Buffer)

	i32 Count := ForInterface->Methods->Count()

	AVLTree* SeenMethods := AVLTree:New(8)

	for (i32 Index := 0, Index < Count, Index++) {
		FunctionDefine* Implementation := Info->Methods->At(Index)
		i32 StubLabel := Info->StubLabels[Index]

		i32 Before := Compiler->Index
		SetLabel(Compiler, StubLabel)

		i32 CastSize := 0

		FunctionDefine* InterfaceMethod := ForInterface->Methods->At(Index)

		Print("InterfaceMethod %s.%s\n", ForInterface->Name->Buffer, Implementation->Name->Buffer)

		if (Implementation->IsMethod = FUNCTION_IS_DERIVED_METHOD) {
			Compiler->MarkLineNumber(Info->Blame)
		}
		else {
			Compiler->MarkLineNumber(Implementation~>Context)
		}

		if (Implementation->AliasFor) {
			Implementation := Implementation->AliasFor
		}

		if (Implementation != InterfaceMethod) {
			; `this` is a `ForInterface*`, which we need to cast back to a `ForType*`
			;  except for when `Implementation` is a default method implementation
			;   which actually expects a `ForInterface*`. In this case, we can just
			;    skip the cast entirely.

			CastSize := Offset * 8
		}

		EmitSub_R64_IX(Compiler, RDI, CastSize)

		if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
			ObjectSymbol* ImplementationSymbol := Compiler->FindOrAddFunctionObjectSymbol(Implementation)
			EmitJump_REL32(Compiler, 0)
			Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, ImplementationSymbol, -4)
		}
		else {
			EmitJump_Label(Compiler, Implementation->LabelNumber)
		}

		i32 After := Compiler->Index

		i64 Hash := Implementation->Name->Hash()
		i32 ID := 0

		if (SeenMethods->Has(Hash)) {
			ID := SeenMethods->GetPointer(Hash) As i32
		}

		SeenMethods->InsertPointer(Hash, (ID + 1) As void*)

		i8* Name := FormatString("%S.%S.%S.%i", ForType->Name, ForInterface->Name, Implementation->Name, ID)
		i64 Address := Compiler->AddressOfCodeOffset(Before)
		i32 Size := After - Before

		if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
			ObjectSymbol* StubSymbol := new ObjectSymbol(
				SYMBOL_BINDING_LOCAL, SYMBOL_TYPE_FUNCTION, SYMBOL_VISIBILITY_DEFAULT,
				Compiler->CodeSection, Name,
				Size, Address
			)

			Compiler->Object->AddSymbol(StubSymbol)

			Info->StubSymbols[Index] := StubSymbol
		}

		;Print("%s: Generated stub call to label %i\n", Name, Implementation->LabelNumber)

		if (Compiler->Config->DebugMode & DEBUG_EMIT_DWARF) {
			Compiler->DWARF->LineInfo->EmitEndSequence((Compiler->CodeBase + After) As i32)
		}

		Compiler->RecordGeneratedFunction(Name, Address, Size)
	}

	if (Compiler->Index % 2) { PushI8(Compiler, 0x90 As i8) }
	if (Compiler->Index % 4) { PushI16(Compiler, 0x9090 As i16) }
	if (Compiler->Index % 8) { PushI32(Compiler, 0x90909090 As i32) }

	if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
		i32 FirstSlot := Compiler->VirtualFunctionTables->Count()

		Info->VirtualFunctionTableSymbol := new ObjectSymbol(
			SYMBOL_BINDING_LOCAL, SYMBOL_TYPE_DATA, SYMBOL_VISIBILITY_DEFAULT,
			Compiler->VirtualFunctionTablesSection, FormatString("%S.%S", ForType->Name, ForInterface->Name),
			Count * 8, FirstSlot * 8
		)

		Compiler->Object->AddSymbol(Info->VirtualFunctionTableSymbol)

		for (i32 Index := 0, Index < Count, Index++) {
			ObjectSymbol* StubSymbol := Info->StubSymbols[Index]

			ObjectRelocation* Relocation := new ObjectRelocation(
				Compiler->VirtualFunctionTablesSection, RELOCATION_TYPE_ABSOLUTE_64,
				(FirstSlot + Index) * 8, StubSymbol, 0
			)

			StubSymbol->ReferenceBy(Relocation)
			Compiler->VirtualFunctionTablesSection->AddRelocation(Relocation)

			Compiler->VirtualFunctionTables->Push(null)
		}
	}
	else {
		i32 Before := Compiler->Index
		SetLabel(Compiler, Info->VirtualFunctionTableLabel)

		for (i32 Index := 0, Index < Count, Index++) {
			PushI64(Compiler, 0)
		}

		i32 After := Compiler->Index
		Compiler->RecordGeneratedFunction(FormatString("%S.%S.VirtualFunctionTable", ForType->Name, ForInterface->Name), Compiler->AddressOfCodeOffset(Before), After - Before)

		i32 Before := Compiler->Index
		SetLabel(Compiler, Info->SetupVirtualFunctionTableLabel)
		EmitLea_R64_Label(Compiler, RAX, Info->VirtualFunctionTableLabel)

		for (i32 Index := 0, Index < Count, Index++) {
			i32 StubLabel := Info->StubLabels[Index]

			EmitLea_R64_Label(Compiler, RBX, StubLabel)

			if (Index >= 0x10) {
				EmitMove_RIX_DISP32_RX(Compiler, RAX, RBX, (Index * 8), 8)
			}
			else {
				EmitMove_RIX_DISP8_RX(Compiler, RAX, RBX, (Index * 8) As i8, 8)
			}
		}

		EmitReturn(Compiler)

		i32 After := Compiler->Index
		Compiler->RecordGeneratedFunction(FormatString("%S.%S.MakeVirtualFunctionTable", ForType->Name, ForInterface->Name), Compiler->AddressOfCodeOffset(Before), After - Before)
	}
}

define void CompileClassInterfaces(CompilerState* Compiler, TypeInfo* ForType) {
	ClassInfo* Info := ForType->ClassInfo
	i32 Count := Info->InterfacesInOrder->Count()

	for (i32 Index := 0, Index < Count, Index++) {
		InterfaceImplementationInfo* ImplementationInfo := Info->InterfacesInOrder->At(Index)

		CompileInterfaceImplementation(Compiler, ForType, ImplementationInfo)

		if !(Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
			Compiler->InitializerLabels->Push(ImplementationInfo->SetupVirtualFunctionTableLabel As void*)
		}
	}
}

;*/

define void CompileGetEnumeratorName(CompilerState* Compiler, i8 ResultRegister, ASTNode* Node) {
	TypeInfo* Enumeration := GetBaseType(Node->ValueType)
	i32 FieldCount := Enumeration->FieldsInOrder->Count()
	i8 TypeSize := GetTypeSize(Node->ValueType) As i8

	CompileExpression(Compiler, ResultRegister, Node)

	if (TypeSize < 4) {
		Cast(Compiler, ResultRegister, TypeSize)
	}

	i8 Temp := PushRegisterStack(Compiler)

	i8 EmitObject := (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) != 0

	if (Enumeration->IsLinearEnumeration) {
		i32 BadRangeLabel := NextLabel(Compiler)
		i32 DoneLabel := NextLabel(Compiler)

		if (Enumeration->EnumerationBase != 0) {
			EmitSub_R64_IX(Compiler, ResultRegister, Enumeration->EnumerationBase)
		}

		EmitCmp_R32_IX(Compiler, ResultRegister, 0)
		EmitJLT_Label(Compiler, BadRangeLabel)

		EmitCmp_R32_IX(Compiler, ResultRegister, FieldCount)
		EmitJGE_Label(Compiler, BadRangeLabel)
		
		if (EmitObject) {
			EmitLea_R64_REL32(Compiler, Temp, 0)
			Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, Compiler->GlobalStringsSymbol, Enumeration->EnumerationNamesOffset - 4)
		}
		else {
			EmitLea_R64_Label(Compiler, Temp, Compiler->GlobalStringsLabel)
			OffsetLabel(Compiler, Enumeration->EnumerationNamesOffset)
		}

		EmitMove_RX_SIB(Compiler, ResultRegister, 4, ResultRegister, Temp)

		if (EmitObject) {
			EmitLea_R64_REL32(Compiler, Temp, 0)
			Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, Compiler->GlobalStringsSymbol, -4)
		}
		else {
			EmitLea_R64_Label(Compiler, Temp, Compiler->GlobalStringsLabel)
		}

		EmitAdd_RX_RX(Compiler, ResultRegister, Temp, 8)

		EmitJump_Label(Compiler, DoneLabel)

		SetLabel(Compiler, BadRangeLabel)
		EmitZeroRegister(Compiler, ResultRegister)

		SetLabel(Compiler, DoneLabel)
	}
	else {
		i32 FoundLabel := NextLabel(Compiler)
		i32 DoneLabel := NextLabel(Compiler)

		if (EmitObject) {
			EmitLea_R64_REL32(Compiler, Temp, 0)
			Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, Compiler->GlobalStringsSymbol, Enumeration->EnumerationNamesOffset - 4)
		}
		else {
			EmitLea_R64_Label(Compiler, Temp, Compiler->GlobalStringsLabel)
			OffsetLabel(Compiler, Enumeration->EnumerationNamesOffset)
		}

		for (i32 Index := 0, Index < FieldCount, Index++) {
			StructField* Field := Enumeration->FieldsInOrder->At(Index)

			EmitCmp_R32_I32(Compiler, ResultRegister, Field->EnumValue)
			EmitJEZ_Label(Compiler, FoundLabel)

			EmitAdd_R64_I8(Compiler, Temp, 4)
		}

		EmitZeroRegister(Compiler, ResultRegister)
		EmitJump_Label(Compiler, DoneLabel)

		SetLabel(Compiler, FoundLabel)
		EmitMove_RX_RIX(Compiler, ResultRegister, Temp, 4)

		if (EmitObject) {
			EmitLea_R64_REL32(Compiler, Temp, 0)
			Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, Compiler->GlobalStringsSymbol, -4)
		}
		else {
			EmitLea_R64_Label(Compiler, Temp, Compiler->GlobalStringsLabel)
		}

		EmitAdd_RX_RX(Compiler, ResultRegister, Temp, 8)

		SetLabel(Compiler, DoneLabel)
	}

	PopRegisterStack(Compiler)
}

define void CompileCall(CompilerState* Compiler, i8 ResultRegister, ASTNode* Node) {
	CallExpression* CallNode := Node->CallNode
	FunctionDefine* TargetFunction := null
	
	i8 BuiltinID := CallNode->BuiltinID
	i8 IS_SYSCALL := BuiltinID = BUILTIN_SYSCALL /* Used later to decide which set of registers are for parameters */
	i8 IsFunctionPointerCall := BuiltinID = BUILTIN_FUNCTION_POINTER

	if (BuiltinID = BUILTIN_NAME_OF) {
		ASTNode* Parameter := CallNode->Parameters[0]

		CompileGetEnumeratorName(Compiler, ResultRegister, Parameter)

		return
	}
	
	FunctionPointerInfo* FunctionPointer := null
	
	i32 TargetParameterCount := CallNode->ParameterCount
	i8 TargetAttributes := 0

	i8 IsVirtualMethodCall := false
	
	if (IsFunctionPointerCall) {
		FunctionPointer := GetBaseType(CallNode->CallToFunctionPointer->ValueType)~>FunctionPointer
		
		TargetParameterCount := FunctionPointer->ParameterCount
		TargetAttributes := FunctionPointer->Attributes
	}
	else if (BuiltinID = BUILTIN_BREAKPOINT) {
		EmitInt3(Compiler)
		
		return
	}
	else if !(IS_SYSCALL) {
		TargetFunction := CallNode->TargetFunction

		if (TargetFunction->IsMethod = FUNCTION_IS_INTERFACE_METHOD) {
			;Print("Call to %func is interface method\n", TargetFunction)
			IsVirtualMethodCall := true
		}
		
		if (Compiler->Config->OutputFormat != OUTPUT_PE && TargetFunction->IsImported) {
			Node->Error("Calls to DllImported functions are not allowed when the target output format is not PE.")
		}
		else if !(TargetFunction->IsImported || TargetFunction->HasFullDefinition || TargetFunction->IsMethod = FUNCTION_IS_INTERFACE_METHOD || TargetFunction->IsMethod = FUNCTION_IS_DERIVED_METHOD) {
			Node->Error("Called function is only declared, and never defined")
		}
		
		TargetParameterCount := TargetFunction->ParameterCount
		TargetAttributes := TargetFunction->Attributes
	}
	
	i32 ParameterCount := CallNode->ParameterCount
	i32 StackParameterCount := 0
	i8 ExtraPadding := false
	i8 HasSavedRAX := false
	
	if (Compiler->NoClobberA && ResultRegister != RAX) {
		EmitPush_R64(Compiler, RAX)
		HasSavedRAX := true
		
		Compiler->NoClobberA := false
	}
	
	if (IsFunctionPointerCall) {
		CompileExpression(Compiler, RAX, CallNode->CallToFunctionPointer)
		
		Compiler->NoClobberA := true
	}
	
	/* TargetFunction is only null for syscall:(), so `!TargetFunction` will short circuit before `TargetFunction->IsImported` crashes */
	
	i8 USE_SYSTEMV := !TargetFunction || !TargetFunction->IsImported /* (Compiler->OutputELF) || (TargetFunction->Attribute = KEYWORD_ASSEMBLY) */
	i8 IS_VARIADIC := TargetAttributes & FUNCTION_ATTRIBUTE_VARIADIC
	
	if (TargetAttributes & FUNCTION_ATTRIBUTE_USE_X64) {
		USE_SYSTEMV := false
	}
	
	i8 REGISTER_PARAMETER_COUNT := 4
	
	if (USE_SYSTEMV) {
		REGISTER_PARAMETER_COUNT := 6
	}

	if (IS_VARIADIC) {
		i32 VariadicCount := (CallNode->ParameterCount - TargetParameterCount) + 1

		StackParameterCount := VariadicCount

		if (TargetParameterCount > REGISTER_PARAMETER_COUNT) {
			StackParameterCount += TargetParameterCount - REGISTER_PARAMETER_COUNT
		}
	}
	else if (ParameterCount > REGISTER_PARAMETER_COUNT) {
		StackParameterCount := ParameterCount - REGISTER_PARAMETER_COUNT
	}
	
	i8 RegisterStackIndex := Compiler->RegisterStackIndex
	i8 StackIsAligned := true

	if (RegisterStackIndex >= 8) {
		StackIsAligned := RegisterStackIndex % 2 != 0
	}

	if (HasSavedRAX) {
		StackIsAligned := !StackIsAligned
	}

	if (IS_VARIADIC) {
		if ((StackParameterCount + 1) % 2 != 0) {
			StackIsAligned := !StackIsAligned	
		}
	}
	else if (StackParameterCount % 2 != 0) {
		StackIsAligned := !StackIsAligned
	}

	if (ParameterCount = 9) {
		;Print("Remainder: %i\n", StackParameterCount % 2)

		;Print("RSI: %i\n", RegisterStackIndex)
		;Print("SPC: %i\nSIA: %i\nHSR: %i\n", StackParameterCount, StackIsAligned, HasSavedRAX)
		;EmitPush_R64(Compiler, RBX)
	}
	
	if !(StackIsAligned) {
		EmitPush_R64(Compiler, RAX)
		ExtraPadding := true
	}
	
	Compiler->RegisterStackIndex := 3
	
	i8 OldNoClobberCD89 := Compiler->NoClobberCD89
	Compiler->NoClobberCD89 := true /* Ensure none of the parameter registers are used for another operation without being saved */
	
	i32 OldMaxSave := Compiler->ParameterRegistersMaxSave
	i32 OldMinSave := Compiler->ParameterRegistersMinSave
	i8 ShouldSaveRegisters := OldMaxSave != OldMinSave

	if (ParameterCount = 9) {
		;Print("OMXS: %i\nOMNS: %i\nSSR: %i\n", OldMaxSave, OldMinSave, ShouldSaveRegisters)
	}
	
	if (ShouldSaveRegisters) {
		for (i32 SaveIndex := OldMinSave, SaveIndex < OldMaxSave, SaveIndex += 1) {
			EmitPush_R64(Compiler, GetSystemVRegister(SaveIndex))
		}
	}
	
	i32 RegisterParameterCount := ParameterCount - StackParameterCount
	Compiler->ParameterRegistersMaxSave := RegisterParameterCount
	
	i8 ParameterRegister := RBX
	
	if (ParameterCount != 0) {		
		if (IS_VARIADIC) {
			ParameterCount := TargetParameterCount - 1
			
			i32 VariadicCount := (CallNode->ParameterCount - TargetParameterCount) + 1
			i32 VariadicBase := ParameterCount
			
			for (i32 VariadicIndex := (VariadicCount - 1), VariadicIndex >= 0, VariadicIndex -= 1) {
				ASTNode* NextVariadic := (CallNode->Parameters)[VariadicBase + VariadicIndex]
				
				CompileExpression(Compiler, RBX, NextVariadic)
				
				i16 NextVariadicSize := GetTypeSize(NextVariadic->ValueType)
				
				if (NextVariadicSize <= 4) {
					/* Any parameter which is smaller than 4 bytes will not 0 the upper 32 bits of a register, so we manually cast them up */
					Cast(Compiler, RBX, NextVariadicSize As i8)
				}
				
				EmitPush_R64(Compiler, RBX)
			}
			
			EmitMove_R32_I32(Compiler, RBX, VariadicCount)
			EmitPush_R64(Compiler, RBX)
		}
		
		for (i32 ParameterIndex := (ParameterCount - 1), ParameterIndex >= 0, ParameterIndex -= 1) {
			i16 ExpectedSize := 8
			
			if !(IS_SYSCALL) {
				Type NextParameterType := TYPE_NONE
				
				if (IsFunctionPointerCall) {
					NextParameterType := FunctionPointer->ParameterTypes[ParameterIndex]
				}
				else {
					NextParameterType := TargetFunction->Parameters[ParameterIndex]->Type
				}
				
				ExpectedSize := GetTypeSize(NextParameterType)
			}
			
			ASTNode* NextParameterValue := (CallNode->Parameters)[ParameterIndex]
			
			i8 ThisParameterRegister := ParameterRegister
			
			if (IS_SYSCALL) {
				if (ParameterIndex = 0) {
					ThisParameterRegister := RAX
				}
				else {
					ThisParameterRegister := GetSystemVRegister(ParameterIndex - 1 As i8)
					
					if (ThisParameterRegister = RCX) {
						ThisParameterRegister := R10
					}
				}
			}
			else if (USE_SYSTEMV) {
				if (ParameterIndex < RegisterParameterCount) {
					ThisParameterRegister := GetSystemVRegister(ParameterIndex As i8)
				}
				else {
					ThisParameterRegister := RBX
				}
			}
			else {
				if (ParameterIndex = 3) {ThisParameterRegister := R9}
				else if (ParameterIndex = 2) {ThisParameterRegister := R8}
				else if (ParameterIndex = 1) {ThisParameterRegister := RDX}
				else if (ParameterIndex = 0) {ThisParameterRegister := RCX}
			}
			
			Compiler->ParameterRegistersMinSave := ParameterIndex + 1
			CompileExpression(Compiler, ThisParameterRegister, NextParameterValue)
			
			i16 ActualSize := GetTypeSize(NextParameterValue->ValueType)
			
			if (NextParameterValue->NodeType = NODE_TYPE_INTEGER) {
				i64 ParameterInteger := NextParameterValue->IntegerValue
				
				if (ActualSize = 4 && ParameterInteger As i32 > 0) {
					ActualSize := ExpectedSize
				}
			}
			
			if (ActualSize < ExpectedSize) {
				Cast(Compiler, ThisParameterRegister, ActualSize As i8)
			}
			
			if (ParameterIndex >= REGISTER_PARAMETER_COUNT) {
				EmitPush_R64(Compiler, ThisParameterRegister)
			}
		}
		
		if (IS_VARIADIC) {			
			i8 VariadicRegister := GetSystemVRegister(VariadicBase)
			
			EmitLea_R64_SIB(Compiler, VariadicRegister, 1, RSP, RSP)
			
			VariadicCount += 1
		}
	}

	Compiler->NoClobberCD89 := OldNoClobberCD89
	
	if (IS_SYSCALL) {
		EmitSysCall(Compiler)
	}
	else if (USE_SYSTEMV) {
		if (IsFunctionPointerCall) {
			EmitCall_R64(Compiler, RAX)
		}
		else if (IsVirtualMethodCall) {
			i32 Offset := TargetFunction->VirtualFunctionTableSlot

			EmitMove_RX_RIX(Compiler, RAX, GetSystemVRegister(0), 8)
			EmitMove_RX_RIX_DISPX(Compiler, RAX, RAX, Offset * 8, 8)
			EmitCall_R64(Compiler, RAX)
		}
		else if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
			ObjectSymbol* TargetSymbol := Compiler->FindOrAddFunctionObjectSymbol(TargetFunction)

			EmitCall_REL32(Compiler, 0)

			Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, TargetSymbol, -4)
		}
		else if (Compiler->Config->DebugMode & DEBUG_EMIT_OBJECT) {
			ELFSymbol* Symbol := Compiler->FindOrAddFunctionSymbol(TargetFunction)

			EmitCall_REL32(Compiler, 0)

			Compiler->ELF->ReferenceSymbol(Compiler->Index - 4, Symbol, -4)
		}
		else {
			EmitCall_Label(Compiler, TargetFunction->LabelNumber)
		}
	}
	else {
		EmitSub_R64_I8(Compiler, RSP, 0x20) /* Shadown space */
		
		if (IsFunctionPointerCall) {
			EmitCall_R64(Compiler, RAX)
		}
		else {
			EmitCall_Label(Compiler, TargetFunction->LabelNumber)
		}
		
		EmitAdd_R64_I8(Compiler, RSP, 0x20)
	}
	
	i32 StackAdd := StackParameterCount
	
	; NOTE: This causes crashes. No clue why. Removing it drops code size and the tests still
	;  pass so I don't think I really care.
	if (IS_VARIADIC) {
		StackAdd := VariadicCount
	}
	
	if (StackAdd) {
		EmitAdd_R64_IX(Compiler, RSP, StackAdd * 8)
	}
	
	if (ShouldSaveRegisters) {
		for (SaveIndex := OldMaxSave, SaveIndex > OldMinSave, SaveIndex -= 1) {
			EmitPop_R64(Compiler, GetSystemVRegister(SaveIndex - 1))
		}
	}
	
	Compiler->ParameterRegistersMaxSave := OldMaxSave
	Compiler->ParameterRegistersMinSave := OldMinSave
	
	if (ExtraPadding) {
		EmitPop_R64(Compiler, RBX)
	}
	
	if (ResultRegister != RAX) {
		Type ReturnType := TYPE_NONE
		
		if (IsFunctionPointerCall) { 
			ReturnType := FunctionPointer->ReturnType
		}
		else {
			ReturnType := TargetFunction->ReturnType
		}
		
		EmitMove_R64_RX(Compiler, ResultRegister, RAX, GetTypeSize(ReturnType) As i8)
	}
	
	if (HasSavedRAX) {
		EmitPop_R64(Compiler, RAX)
		Compiler->NoClobberA := true
	}
	
	Compiler->RegisterStackIndex := RegisterStackIndex
}

declare void CompileGetStructAccessPointer(CompilerState*, i8, StructAccessExpression*)

define void CompileStructAccessLeft(CompilerState* Compiler, i8 ResultRegister, StructAccessExpression* TargetAccess) {
	ASTNode* Left := TargetAccess->Left
	
	;if (TargetAccess->Operator->Value = OPERATOR_DOT) {
	if (GetPointerDepth(Left->ValueType) = 0) {
		if (Left->NodeType = NODE_TYPE_STRUCT_ACCESS) {
			CompileGetStructAccessPointer(Compiler, ResultRegister, Left->AccessNode)
			return
		}
		else if (Left->NodeType = NODE_TYPE_VARIABLE) {
			CompileGetVariableAddress(Compiler, ResultRegister, Left->VariableValue)
			return
		}
	}
	
	CompileExpression(Compiler, ResultRegister, Left)
}

define void CompileGetStructAccessPointer(CompilerState* Compiler, i8 ResultRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	i16 TargetFieldSize := GetTypeSize(TargetField->ValueType)
	
	CompileStructAccessLeft(Compiler, ResultRegister, TargetAccess)
	
	i32 FieldOffset := TargetField->Offset
	
	if (FieldOffset != 0) {
		EmitLea_R64_R64_DISPX(Compiler, ResultRegister, ResultRegister, FieldOffset)
	}
}

define void CompileGetStructAccess(CompilerState* Compiler, i8 ResultRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	
	if (TargetAccess->Operator->Value = OPERATOR_TILDE_GREATER || TargetField->ValueType.IsArray) {
		CompileGetStructAccessPointer(Compiler, ResultRegister, TargetAccess)
		return
	}
	
	i8 TargetFieldSize := GetTypeSize(TargetField->ValueType) As i8
	
	i32 FieldOffset := TargetField->Offset
	
	if (TargetField->BitStartIndex || TargetField->BitEndIndex) {
		if (TargetField->IsStructBitField) {
			; byte offset + bit range

			; get pointer to bits
			CompileGetStructAccessPointer(Compiler, ResultRegister, TargetAccess)

			; dereference pointer to bits
			EmitMove_RX_RIX(Compiler, ResultRegister, ResultRegister, TargetField->BitBackingSize)
		}
		else {
			; bit range

			CompileExpression(Compiler, ResultRegister, TargetAccess->Left)
		}
		
		TargetFieldSize := TargetField->BitBackingSize
		
		i32 FieldSize := (TargetFieldSize * 8) - 1
		i8 ShiftLeftBy := (FieldSize - TargetField->BitEndIndex) As i8
		i8 ShiftRightBy := (ShiftLeftBy + TargetField->BitStartIndex) As i8
		
		if (ShiftLeftBy < 0) {
			ShiftRightBy := -ShiftLeftBy
		}
		else if (ShiftLeftBy) { 
			EmitSAL_RX_I8(Compiler, ResultRegister, ShiftLeftBy, TargetFieldSize)
		}
		
		if (ShiftRightBy) {
			EmitSAR_RX_I8(Compiler, ResultRegister, ShiftRightBy, TargetFieldSize)
		}
	}
	else {
		CompileStructAccessLeft(Compiler, ResultRegister, TargetAccess)
		
		if (FieldOffset = 0 && ResultRegister != R13) {
			EmitMove_RX_RIX(Compiler, ResultRegister, ResultRegister, TargetFieldSize)
		}
		;else if (FieldOffset >= 112) {
		;	EmitMove_RX_RIX_DISP32(Compiler, ResultRegister, ResultRegister, FieldOffset, TargetFieldSize)
		;}
		else {
			;EmitMove_RX_RIX_DISP8(Compiler, ResultRegister, ResultRegister, FieldOffset As i8, TargetFieldSize)
			EmitMove_RX_RIX_DISPX(Compiler, ResultRegister, ResultRegister, FieldOffset, !(FieldOffset >= 112), TargetFieldSize) 
		}
	}
}

declare void CompileSetArrayAccess(CompilerState*, i8, ASTNode*, ASTNode*, i8)

define void CompileSetStructAccess(CompilerState* Compiler, i8 ValueRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	
	i8 ResultPointerRegister := PushRegisterStack(Compiler)
	
	i32 FieldOffset := TargetField->Offset
	i8 TargetFieldSize := GetTypeSize(TargetField->ValueType) As i8
	
	if (TargetField->BitStartIndex || TargetField->BitEndIndex) {
		if (TargetField->IsStructBitField) {
			CompileGetStructAccessPointer(Compiler, ResultPointerRegister, TargetAccess)
			EmitMove_RX_RIX(Compiler, ResultPointerRegister, ResultPointerRegister, TargetField->BitBackingSize) 
		}
		else {
			CompileExpression(Compiler, ResultPointerRegister, TargetAccess->Left)
		}
		
		i8 TargetBitSize := TargetField->BitBackingSize
		
		i8 StartIndex := TargetField->BitStartIndex
		i8 EndIndex := TargetField->BitEndIndex
		
		i32 FieldSize := (TargetBitSize * 8) - 1
		i8 ShiftLeftBy := (FieldSize - (EndIndex - StartIndex)) As i8
		i8 ShiftRightBy := (FieldSize - EndIndex) As i8
		
		i64 PartialMask := ((1 As i64) << ((EndIndex + 1) As i8)) - 1
		
		if (EndIndex = 63) {
			/* Since 1<<64 is undefined, the result of INT64_MAX needs to be hard coded */
			PartialMask := 0xFFFFFFFFFFFFFFFF
		}
		
		i64 Mask := ~(PartialMask >> StartIndex << StartIndex)
		
		EmitMove_RX_IX(Compiler, RDI, Mask, TargetBitSize)
		EmitAnd_RX_RX(Compiler, ResultPointerRegister, RDI, TargetBitSize)
		
		if (ShiftLeftBy) { 
			EmitSAL_RX_I8(Compiler, ValueRegister, ShiftLeftBy, TargetBitSize)
		}
		
		EmitSAR_RX_I8(Compiler, ValueRegister, ShiftRightBy, TargetBitSize)
		EmitOr_RX_RX(Compiler, ResultPointerRegister, ValueRegister, TargetBitSize)
		
		ASTNode* Left := TargetAccess->Left
		i8 LeftNodeType := Left->NodeType

		if (TargetField->IsStructBitField) {
			; ValueRegister is actually unused, ResultPointerRegister holds the result
			CompileGetStructAccessPointer(Compiler, ValueRegister, TargetAccess)
			EmitMove_RIX_RX(Compiler, ValueRegister, ResultPointerRegister, TargetField->BitBackingSize)
		}
		else if (LeftNodeType = NODE_TYPE_VARIABLE) {
			CompileSetVariableValue(Compiler, Left->VariableValue, ResultPointerRegister)
		}
		else if (LeftNodeType = NODE_TYPE_STRUCT_ACCESS) {
			CompileSetStructAccess(Compiler, ResultPointerRegister, Left->AccessNode)
		}
		else if (LeftNodeType = NODE_TYPE_BINARY) {
			CompileSetArrayAccess(Compiler, ValueRegister, Left->BinaryNode->Left, Left->BinaryNode->Right, ResultPointerRegister)
		}
	}
	else {
		CompileStructAccessLeft(Compiler, ResultPointerRegister, TargetAccess)
		
		i8 TargetSize := GetTypeSize(TargetField->ValueType) As i8
		
		if (FieldOffset = 0 && ResultPointerRegister != R13) {
			EmitMove_RIX_RX(Compiler, ResultPointerRegister, ValueRegister, TargetSize)
		}
		else if (FieldOffset >= 112) {
			EmitMove_RIX_DISP32_RX(Compiler, ResultPointerRegister, ValueRegister, FieldOffset, TargetSize)
		}
		else {
			EmitMove_RIX_DISP8_RX(Compiler, ResultPointerRegister, ValueRegister, FieldOffset As i8, TargetSize)
		}
	}
	
	PopRegisterStack(Compiler)
}

define void CompileArrayAccess(CompilerState* Compiler, i8 ResultRegister, ASTNode* Pointer, ASTNode* Index, i8 ValueRegister, i8 GetAddress) {
	i8 PointerRegister := ResultRegister
	CompileExpression(Compiler, PointerRegister, Pointer)
	
	Type PointerType := Pointer->ValueType
	
	i32 IndexScale := 8
	
	TypeInfo* PointerBase := GetBaseType(PointerType)
	i16 PointerDepth := GetPointerDepth(PointerType)
	
	if (PointerDepth = 1) {
		IndexScale := PointerBase->Size
		
		if (PointerBase->Is(TYPE_KIND_STRUCTURE)) {
			GetAddress := true
		}
	}
	
	i8 IsSet := !(ValueRegister < 0)
	
	if (Index->NodeType = NODE_TYPE_INTEGER) {
		i32 IndexAsDisplacement := (Index->IntegerValue * IndexScale) As i32
		i8 DisplacementSize := 4
		
		if (IndexAsDisplacement <= 112) {
			DisplacementSize := 1
		}
		
		if (IsSet || GetAddress) {
			EmitLea_R64_R64_DISPX(Compiler, ResultRegister, PointerRegister, IndexAsDisplacement)
			
			if (IsSet) {
				EmitMove_RIX_RX(Compiler, ResultRegister, ValueRegister, IndexScale As i8)
			}
		}
		else {
			EmitMove_RX_RIX_DISPX(Compiler, ResultRegister, PointerRegister, IndexAsDisplacement, DisplacementSize, IndexScale As i8)
		}
	}
	else {
		i8 IndexRegister := PushRegisterStack(Compiler)
		CompileExpression(Compiler, IndexRegister, Index)
		
		i8 IndexSize := GetTypeSize(Index->ValueType) As i8
		
		if (IndexSize < 4) {
			Cast(Compiler, IndexRegister, IndexSize)
		}
		
		if (IsSet || GetAddress) {
			if (IndexScale > 8) {
				if (IndexScale < 0x80) {
					EmitIMul_R64_I8(Compiler, IndexRegister, IndexScale As i8)
				}
				else {
					EmitIMul_R64_I32(Compiler, IndexRegister, IndexScale)
				}

				EmitAdd_RX_RX(Compiler, PointerRegister, IndexRegister, 8)
			}
			else {
				EmitLea_R64_SIB(Compiler, ResultRegister, IndexScale As i8, IndexRegister, PointerRegister)
			}
			
			if (IsSet) {
				EmitMove_RIX_RX(Compiler, ResultRegister, ValueRegister, IndexScale As i8)
			}
		}
		else {
			EmitMove_RX_SIB(Compiler, ResultRegister, IndexScale As i8, IndexRegister, PointerRegister)
		}
		
		PopRegisterStack(Compiler)
	}
}

define void CompileGetArrayAccess(CompilerState* Compiler, i8 ResultRegister, ASTNode* Pointer, ASTNode* Index, i8 GetAddress) {
	CompileArrayAccess(Compiler, ResultRegister, Pointer, Index, -1 As i8, GetAddress)
}
define void CompileSetArrayAccess(CompilerState* Compiler, i8 ResultRegister, ASTNode* Pointer, ASTNode* Index, i8 ValueRegister) {
	CompileArrayAccess(Compiler, ResultRegister, Pointer, Index, ValueRegister, false)
}

define void CompileUnary(CompilerState* Compiler, i8 ResultRegister, Type ResultType, UnaryExpression* ExpressionToCompile, i8 DiscardResult) {
	/* Compiles a unary operator and operand */
	
	i8 Operator := (ExpressionToCompile->Operator->Value) As i8
	i8 ResultSize := GetTypeSize(ResultType) As i8
	
	i8 IsIncrementDecrement := Operator = OPERATOR_PLUS_PLUS_RIGHT || Operator = OPERATOR_MINUS_MINUS_RIGHT || Operator = OPERATOR_MINUS_MINUS_LEFT || Operator = OPERATOR_PLUS_PLUS_LEFT
	
	if (Operator = OPERATOR_AND || IsIncrementDecrement) {
		ASTNode* Operand := ExpressionToCompile->Operand
		i8 OperandType := Operand->NodeType
		
		if (OperandType = NODE_TYPE_VARIABLE) {
			VariableInfo* OperandVariable := Operand->VariableValue
			
			CompileGetVariableAddress(Compiler, ResultRegister, OperandVariable)
		}
		else if (OperandType = NODE_TYPE_STRUCT_ACCESS) {
			StructAccessExpression* OperandStructAccess := Operand->AccessNode
			
			CompileGetStructAccessPointer(Compiler, ResultRegister, OperandStructAccess)
		}
		else if (OperandType = NODE_TYPE_BINARY) {
			BinaryExpression* OperandExpression := Operand->BinaryNode
			
			if (OperandExpression->Operator->Value = OPERATOR_OPEN_BRACKET) {
				CompileGetArrayAccess(Compiler, ResultRegister, OperandExpression->Left, OperandExpression->Right, true)
			}
		}
		else if (OperandType = NODE_TYPE_DEFINE) {
			FunctionDefine* OperandFunction := Operand->DefineNode
			
			if (Compiler->Config->DebugMode & DEBUG_EMIT_NEW_OBJECT) {
				ObjectSymbol* TargetSymbol := Compiler->FindOrAddFunctionObjectSymbol(OperandFunction)

				EmitLea_R64_REL32(Compiler, ResultRegister, 0)

				Compiler->ReferenceSymbolFromCode(Compiler->Index - 4, TargetSymbol, -4)
			}
			else if (Compiler->Config->DebugMode & DEBUG_EMIT_OBJECT) {
				ELFSymbol* Symbol := Compiler->FindOrAddFunctionSymbol(OperandFunction)

				EmitLea_R64_REL32(Compiler, ResultRegister, 0)

				Compiler->ELF->ReferenceSymbol(Compiler->Index - 4, Symbol, -4)
			}
			else {
				EmitLea_RAX_Label(Compiler, OperandFunction->LabelNumber)

				if (ResultRegister != RAX) {
					EmitMove_R64_R64(Compiler, ResultRegister, RAX)
				}
			}
		}
		
		i8 OperandSize := GetTypeSize(Operand->ValueType) As i8
		
		if (Operator = OPERATOR_PLUS_PLUS_RIGHT || Operator = OPERATOR_PLUS_PLUS_LEFT) {
			EmitInc_RIX(Compiler, ResultRegister, OperandSize)
			EmitMove_RX_RIX(Compiler, ResultRegister, ResultRegister, OperandSize)
			
			if (Operator = OPERATOR_PLUS_PLUS_RIGHT) {
				EmitDec_RX(Compiler, ResultRegister, OperandSize)
			}
		}
		else if (Operator = OPERATOR_MINUS_MINUS_RIGHT || Operator = OPERATOR_MINUS_MINUS_LEFT) {
			EmitDec_RIX(Compiler, ResultRegister, OperandSize)
			EmitMove_RX_RIX(Compiler, ResultRegister, ResultRegister, OperandSize)
			
			if (Operator = OPERATOR_MINUS_MINUS_RIGHT) {
				EmitInc_RX(Compiler, ResultRegister, OperandSize)
			}
		}
	}
	else {
		/* Only compile the operand when the operator isn't `&` (since it doesn't use the operand value) */
		CompileExpression(Compiler, ResultRegister, ExpressionToCompile->Operand)
		
		if (Operator = OPERATOR_STAR) {
			EmitMove_RX_RIX(Compiler, ResultRegister, ResultRegister, ResultSize)
		}
		else if (Operator = OPERATOR_MINUS) {
			EmitNeg_RX(Compiler, ResultRegister, ResultSize)
		}
		else if (Operator = OPERATOR_TILDE) {
			EmitNot_RX(Compiler, ResultRegister, ResultSize)
		}
		else if (Operator = OPERATOR_BANG) {
			EmitTest_RX_RX(Compiler, ResultRegister, ResultRegister, GetTypeSize(ExpressionToCompile->Operand->ValueType) As i8)
			
			if !(DiscardResult) {
				/* If the caller uses the FLAGS register, it doesn't need a 'true' result, and can just use what's in the FLAGS register */
				EmitSetE_R8(Compiler, ResultRegister)
			}
		}
	}
}

define void CompileBinaryOperator(CompilerState* Compiler, i8 Operator, i8 ResultSize, i8 LeftRegister, i8 RightRegister) {
	i8 ResultRegister := LeftRegister
	
	if (Operator = OPERATOR_PLUS) {
		EmitAdd_RX_RX(Compiler, LeftRegister, RightRegister, ResultSize)
	}
	else if (Operator = OPERATOR_MINUS) {
		EmitSub_RX_RX(Compiler, LeftRegister, RightRegister, ResultSize)
	}
	else if (Operator = OPERATOR_STAR) {
		if (ResultSize = 1) {
			/* Do 8 bit multiplication as 16 bit, and cast the result back down to 8 bits (since there is no imul r8, r8 instruction */
			EmitIMul_RX_RX(Compiler, LeftRegister, RightRegister, 2)
			Cast(Compiler, LeftRegister, 1)
		}
		else {	
			EmitIMul_RX_RX(Compiler, LeftRegister, RightRegister, ResultSize)
		}
	}
	else if (Operator = OPERATOR_SLASH || Operator = OPERATOR_PERCENT) {
		if (LeftRegister != RAX) {
			EmitMove_R64_R64(Compiler, RBX, RAX)
			EmitMove_R64_R64(Compiler, RAX, LeftRegister)
		}
		if (Compiler->NoClobberCD89 && LeftRegister != RDX) {
			EmitPush_R64(Compiler, RDX)
		}
		
		if (ResultSize = 1) {
			/* Handle 8 bit division through a 16 bit operation, which will have a result casted down 
				(8 bit IDIV uses AL/AH, which CodeGen isn't set up to encode)
			*/
			EmitCXX(Compiler, 2)
			EmitIDiv_RAX_RX(Compiler, RightRegister, 2)
		}
		else {
			EmitCXX(Compiler, ResultSize)
			EmitIDiv_RAX_RX(Compiler, RightRegister, ResultSize)
		}
		
		if (Operator = OPERATOR_SLASH && ResultRegister != RAX) {
			EmitMove_RX_RX(Compiler, ResultRegister, RAX, ResultSize)
		}
		else if (Operator = OPERATOR_PERCENT && ResultRegister != RDX) {
			EmitMove_RX_RX(Compiler, ResultRegister, RDX, ResultSize)
		}
		
		if (Compiler->NoClobberCD89 && LeftRegister != RDX) {
			EmitPop_R64(Compiler, RDX)
		}
		if (LeftRegister != RAX) {
			EmitMove_R64_R64(Compiler, RAX, RBX)
		}
		
		if (ResultSize = 1) {
			Cast(Compiler, ResultRegister, 1)
		}
	}
	else if (Operator = OPERATOR_EQUAL) {
		EmitSetE_R8(Compiler, ResultRegister)
	}
	else if (Operator = OPERATOR_BANG_EQUAL) {
		EmitSetNE_R8(Compiler, ResultRegister)
	}
	else if (Operator = OPERATOR_LESS) {
		EmitSetL_R8(Compiler, ResultRegister)
	}
	else if (Operator = OPERATOR_LESS_EQAUL) {
		EmitSetLE_R8(Compiler, ResultRegister)
	}
	else if (Operator = OPERATOR_GREATER) {
		EmitSetG_R8(Compiler, ResultRegister)
	}
	else if (Operator = OPERATOR_GREATER_EQAUL) {
		EmitSetGE_R8(Compiler, ResultRegister)
	}
	else if (Operator = OPERATOR_XOR) {
		EmitXor_RX_RX(Compiler, LeftRegister, RightRegister, ResultSize)
	}
	else if (Operator = OPERATOR_AND) {
		EmitAnd_RX_RX(Compiler, LeftRegister, RightRegister, ResultSize)
	}
	else if (Operator = OPERATOR_OR) {
		EmitOr_RX_RX(Compiler, LeftRegister, RightRegister, ResultSize)
	}
}

define i8 IsPowerOfTwo(i64 Number) {
	return Number && !(Number & (Number - 1))
}
define i8 FindFirstBitSet(i64 Number) asm {
	bsr, rax, rdi
	ret
}

define void CompileBinary(CompilerState* Compiler, i8 ResultRegister, Type ResultType, BinaryExpression* ExpressionToCompile, i8 DiscardResult) {
	/* Compiles a binary expression, and both operands of the expression */
	
	ASTNode* Left := ExpressionToCompile->Left
	ASTNode* Right := ExpressionToCompile->Right
	
	i8 LeftSize := GetTypeSize(Left->ValueType) As i8
	i8 RightSize := GetTypeSize(Right->ValueType) As i8
	i8 ResultSize := GetTypeSize(ResultType) As i8
	
	i8 LeftRegister := ResultRegister
	i8 RightRegister := 0
	
	i8 Operator := (ExpressionToCompile->Operator->Value) As i8
	
	if (OPERATOR_FIRST_ASSIGNMENT <= Operator && Operator <= OPERATOR_LAST_ASSIGNMENT) {
		/* This is an assignment, so we can reuse the result register for the side side, and ignore the left */
		
		i8 LeftType := (Left->NodeType) As i8
		
		VariableInfo* TargetVariable := Left->VariableValue
		StructAccessExpression* LeftAccess := Left->AccessNode
		BinaryExpression* LeftExpression := Left->BinaryNode
		UnaryExpression* LeftUnary := Left->UnaryNode
		
		i8 WorkRegister := PushRegisterStack(Compiler)
		
		if (Operator = OPERATOR_COLON_EQUAL) {
			CompileExpression(Compiler, ResultRegister, Right)
			
			if (RightSize < LeftSize) {
				Cast(Compiler, ResultRegister, RightSize)
			}
			
			if (LeftType = NODE_TYPE_VARIABLE) {
				CompileSetVariableValue(Compiler, TargetVariable, ResultRegister)
			}
			else if (LeftType = NODE_TYPE_STRUCT_ACCESS) {
				CompileSetStructAccess(Compiler, ResultRegister, LeftAccess)
			}
			else if (LeftType = NODE_TYPE_BINARY) {
				CompileSetArrayAccess(Compiler, RBX, LeftExpression->Left, LeftExpression->Right, ResultRegister)
			}
			else if (LeftType = NODE_TYPE_UNARY) {
				CompileExpression(Compiler, WorkRegister, LeftUnary->Operand)
				
				EmitMove_RIX_RX(Compiler, WorkRegister, ResultRegister, ResultSize)
			}
		}
		else {				
			CompileExpression(Compiler, WorkRegister, Right)
			
			if (RightSize < LeftSize) {
				Cast(Compiler, WorkRegister, RightSize)
			}
			
			/* Get old value of left side */
			
			if (LeftType = NODE_TYPE_VARIABLE) {
				;if !(TargetVariable->IsGlobal) {
				;	i32 Start := Compiler->Index
				;	i32 Offset := GetVariableOffset(Compiler, TargetVariable, null)
				;	
				;	if (Operator = OPERATOR_PLUS_EQUAL) {
				;		EmitAdd_RIX_DISPX_RX(Compiler, RBP, WorkRegister, Offset, ResultSize)
				;	}
				;	else if (Operator = OPERATOR_MINUS_EQUAL) {
				;		EmitSub_RIX_DISPX_RX(Compiler, RBP, WorkRegister, Offset, ResultSize)
				;	}
				;	
				;	if (Compiler->Index != Start) {
				;		PopRegisterStack(Compiler)
				;		return 0
				;	}
				;}
				
				CompileGetVariableValue(Compiler, ResultRegister, TargetVariable)
			}
			else if (LeftType = NODE_TYPE_STRUCT_ACCESS) {
				CompileGetStructAccess(Compiler, ResultRegister, LeftAccess)
			}
			else if (LeftType = NODE_TYPE_BINARY) {
				CompileGetArrayAccess(Compiler, ResultRegister, LeftExpression->Left, LeftExpression->Right, false)
			}
			else if (LeftType = NODE_TYPE_UNARY) {
				; For `*(A) X= (Y)` we save `(A)` in a temp register instead of compiling it twice, since
				;  that would raise code size, and maybe run code with side effects twice
				
				; Since `X=` operators are always alone on a line, the register stack should be
				;  totally empty, so there's no harm in using an extra temp anyways
				
				i8 DereferenceRegister := PushRegisterStack(Compiler)
				
				CompileExpression(Compiler, DereferenceRegister, LeftUnary->Operand)
				
				EmitMove_RX_RIX(Compiler, ResultRegister, DereferenceRegister, ResultSize)
			}
			
			/* Translate X= operators into just X operators, so CompileBinaryOperator does the correct operation */
			if (Operator <= OPERATOR_PERCENT_EQUAL) {	
				Operator += OPERATOR_PLUS - OPERATOR_PLUS_EQUAL
			}
			else {
				Operator += OPERATOR_AND - OPERATOR_AND_EQUAL
			}
			
			/* Do the actual operation */
			CompileBinaryOperator(Compiler, Operator, ResultSize, ResultRegister, WorkRegister)
			
			/* Store the new value for each valid left side */
			
			if (LeftType = NODE_TYPE_VARIABLE) {
				CompileSetVariableValue(Compiler, TargetVariable, ResultRegister)
			}
			else if (LeftType = NODE_TYPE_STRUCT_ACCESS) {
				CompileSetStructAccess(Compiler, ResultRegister, LeftAccess)
			}
			else if (LeftType = NODE_TYPE_BINARY) {
				CompileSetArrayAccess(Compiler, WorkRegister, LeftExpression->Left, LeftExpression->Right, ResultRegister)
			}
			else if (LeftType = NODE_TYPE_UNARY) {
				EmitMove_RIX_RX(Compiler, DereferenceRegister, ResultRegister, ResultSize)
				
				PopRegisterStack(Compiler)
			}
		}
		
		PopRegisterStack(Compiler)
	}
	else if (Operator = OPERATOR_OPEN_BRACKET) {
		CompileGetArrayAccess(Compiler, ResultRegister, Left, Right, false)
	}
	else {
		/* As long as we're not compiling an assignment, compile the left operand into the result register */
		
		CompileExpression(Compiler, LeftRegister, Left)
		
		i8 OldClobberA := Compiler->NoClobberA
		
		if (LeftRegister = RAX) {
			Compiler->NoClobberA := true
		}
		
		if (Operator = OPERATOR_AS) {
			/* For 'As', just compile the left operand, cast it, and return */
			Type RightType := Right->TypeValue
			
			if (Left->NodeType != NODE_TYPE_INTEGER) {
				/* Only emit cast instructions for values which aren't integers, since integer casts are done at compile time */
				
				Cast(Compiler, LeftRegister, GetTypeSize(RightType) As i8)
			}
		}
		else if (OPERATOR_FIRST_SHORT_CIRCUIT <= Operator && Operator <= OPERATOR_LAST_SHORT_CIRCUIT) {
			if (NodeHasSideEffects(Right)) {
				i32 End := NextLabel(Compiler)
				
				EmitTest_RX_RX(Compiler, LeftRegister, LeftRegister, LeftSize)
				
				if !(DiscardResult) {
					EmitSetNE_R8(Compiler, ResultRegister)
				}
				
				if (Operator = OPERATOR_LOGICAL_AND) {
					EmitJEZ_Label(Compiler, End)
				}
				else if (Operator = OPERATOR_LOGICAL_OR) {
					EmitJNZ_Label(Compiler, End)
				}
				
				CompileExpression(Compiler, LeftRegister, Right)
				
				EmitTest_RX_RX(Compiler, LeftRegister, LeftRegister, RightSize)
				
				if !(DiscardResult) {
					EmitSetNE_R8(Compiler, ResultRegister)
				}
				
				SetLabel(Compiler, End)
			}
			else {
				RightRegister := PushRegisterStack(Compiler)
				CompileExpression(Compiler, RightRegister, Right)
				
				i8 MaxOperandSize := LeftSize
				
				if (RightSize > LeftSize) {
					MaxOperandSize := RightSize
					Cast(Compiler, LeftRegister, LeftSize)
				}
				else if (RightSize < LeftSize) {
					Cast(Compiler, RightRegister, RightSize)
				}
				
				if (Operator = OPERATOR_LOGICAL_AND) {
					EmitIMul_RX_RX(Compiler, LeftRegister, RightRegister, MaxOperandSize)
				}
				else if (Operator = OPERATOR_LOGICAL_OR) {
					EmitAdd_RX_RX(Compiler, LeftRegister, RightRegister, MaxOperandSize)
				}
				
				EmitOr_RX_RX(Compiler, LeftRegister, LeftRegister, MaxOperandSize)
				
				if !(DiscardResult) {
					EmitSetNE_R8(Compiler, ResultRegister)
				}
				
				PopRegisterStack(Compiler)
				
				return
			}
		}
		else if (Operator = OPERATOR_LESS_LESS || Operator = OPERATOR_GREATER_GREATER) {
			if (Right->NodeType = NODE_TYPE_INTEGER) {
				if (Operator = OPERATOR_LESS_LESS) {
					EmitSAL_RX_I8(Compiler, LeftRegister, Right->IntegerValue As i8, ResultSize)
				}
				else {
					EmitSAR_RX_I8(Compiler, LeftRegister, Right->IntegerValue As i8, ResultSize)
				}
			}
			else {
				i8 LeftWasRCX := LeftRegister = RCX
				
				if (LeftWasRCX) {
					LeftRegister := PushRegisterStack(Compiler)
					EmitMove_RX_RX(Compiler, LeftRegister, RCX, ResultSize)
				}
				else if (Compiler->NoClobberCD89) {
					EmitPush_R64(Compiler, RCX)
				}
				
				CompileExpression(Compiler, RCX, Right)
				
				if (Operator = OPERATOR_LESS_LESS) {
					EmitSHL_RX_CL(Compiler, LeftRegister, ResultSize)
				}
				else if (Operator = OPERATOR_GREATER_GREATER) {
					EmitSHR_RX_CL(Compiler, LeftRegister, ResultSize)
				}
				
				if (LeftWasRCX) {
					EmitMove_RX_RX(Compiler, RCX, LeftRegister, ResultSize)
					PopRegisterStack(Compiler)
				}
				else if (Compiler->NoClobberCD89) {
					EmitPop_R64(Compiler, RCX)
				}
			}
		}
		else {
			i8 IsComparison := IsComparison(ExpressionToCompile->Operator)
			
			if (IsComparison) {
				; TODO: UPDATE
				Type TrueResultType := Left->ValueType
				
				ResultSize := GetTypeSize(TrueResultType) As i8
			}
			
			/* If either operand is smaller than the result type, cast it up to the R64 (aka any possible size) */
			if (LeftSize < ResultSize) {
				Cast(Compiler, LeftRegister, LeftSize)
			}
			
			i8 IsDivision := (Operator = OPERATOR_SLASH || Operator = OPERATOR_PERCENT)
			
			if (IsDivision && Right->NodeType = NODE_TYPE_INTEGER && IsPowerOfTwo(Right->IntegerValue)) {
				if (Operator = OPERATOR_SLASH) {
					EmitSAR_RX_I8(Compiler, LeftRegister, FindFirstBitSet(Right->IntegerValue), LeftSize)
				}
				else {
					i64 Mask := Right->IntegerValue - 1
					
					if (LeftSize <= 4) {
						EmitAnd_RX_IX(Compiler, LeftRegister, Mask As i32, LeftSize)
					}
					else {
						EmitMove_R64_I64(Compiler, RBX, Mask)
						EmitAnd_RX_RX(Compiler, LeftRegister, RBX, 8)
					}
				}
				
				return
			}
			
			i8 IsPlusMinus := (Operator = OPERATOR_PLUS || Operator = OPERATOR_MINUS)
			
			if (IsPlusMinus && Right->NodeType = NODE_TYPE_INTEGER) {
				/* Since some instructions for simple operations have encodings for sign-extended immediates 
					We can check for an operator+operand combo which can be optimized into a single instruction
				*/
				
				i64 RightInteger := Right->IntegerValue
				
				i8 OperandSize := GetNumberSize(RightInteger)
				
				if (OperandSize <= 4) {
					/* There are no imm64 encodings, only imm8 and imm32 */
					
					if (Operator = OPERATOR_PLUS) {
						EmitAdd_R64_IX(Compiler, ResultRegister, RightInteger As i32)
					}
					else if (Operator = OPERATOR_MINUS) {
						EmitSub_R64_IX(Compiler, ResultRegister, RightInteger As i32)
					}
					
					/* When we optimized this expression, we need to return early to skip it being
						compiled like normal
					*/
					
					Compiler->NoClobberA := OldClobberA
					return
				}
			}
			
			/* Allocate a new register for the right operand */
			
			RightRegister := PushRegisterStack(Compiler)
			CompileExpression(Compiler, RightRegister, Right)
			
			if (RightSize < ResultSize) {
				Cast(Compiler, RightRegister, RightSize)
			}
			
			if (IsComparison) {
				EmitCmp_RX_RX(Compiler, LeftRegister, RightRegister, ResultSize)
			}
			
			/* Also uses uses the correct instruction for two ResultType sized operands (casting should be done this is called) */
			
			if (DiscardResult) {
				/* Since comparison expressions can technically store a result in the FLAGS register, sometimes
					 a comparison can have the "real" result discarded, and the caller can just use FLAGS.
					So, this is a dummy branch to prevent code from being generated to grab the result of an
					 expression out of FLAGS.
				*/
			}
			else {
				CompileBinaryOperator(Compiler, Operator, ResultSize, LeftRegister, RightRegister)
			}
			
			PopRegisterStack(Compiler) /* Pop the right register */
		}
		
		Compiler->NoClobberA := OldClobberA
	}
}

define void CompileUnwindTry(CompilerState* Compiler, i8 ForReturn) {
	; Ensures that the current function's stack frame is restored
	; 	For `return`, this means all `Try` stack frame modifications 
	; 	For `continue`/`break`, this means only `Try` stack frame modifications inside of the current loop
	
	i32 Total := Compiler->ScopedTryDepth
	
	if (ForReturn) {
		Total := Compiler->TotalTryDepth
	}
	
	for (i32 Index := 0, Index < Total, Index += 1) {
		EmitPop_R64_DISP8(Compiler, RBP, 0)	; Restore saved stack frame
		EmitPop_R64_DISP8(Compiler, RBP, 8)
	}
}

define void CompileTry(CompilerState* Compiler, TryCatch* TryToCompile) {
	i32 AfterCatchLabel := NextLabel(Compiler)
	i32 TryEndLabel := NextLabel(Compiler)
	
	; try {
	EmitPush_R64_DISP8(Compiler, RBP, 8) ; Save the old stack frame
	EmitPush_R64_DISP8(Compiler, RBP, 0)
	
	EmitMove_R64_R64(Compiler, RBX, RSP)		; Save (RSP | Magic) into stack frame
	EmitAdd_R64_I8(Compiler, RBX, 1)
	EmitMove_RIX_DISP8_RX(Compiler, RBP, RBX, 0, 8)
	
	EmitLea_R64_Label(Compiler, RBX, TryEndLabel)		; Save (CatchLocation) into stack frame
	EmitMove_RIX_DISP8_RX(Compiler, RBP, RBX, 8, 8)
	
	Compiler->TotalTryDepth += 1
	Compiler->ScopedTryDepth += 1
	CompileBlock(Compiler, TryToCompile->Body)
	Compiler->ScopedTryDepth -= 1
	Compiler->TotalTryDepth -= 1
	
	EmitPop_R64_DISP8(Compiler, RBP, 0)	; Restore saved stack frame
	EmitPop_R64_DISP8(Compiler, RBP, 8)
	; }
	
	if (TryToCompile->CatchBody) {
		EmitJump_Label(Compiler, AfterCatchLabel)
	}
	
	; catch {
	SetLabel(Compiler, TryEndLabel)
	
	if (TryToCompile->CatchBody) {
		EmitPop_R64_DISP8(Compiler, RBP, 0)	; Restore saved stack frame
		EmitPop_R64_DISP8(Compiler, RBP, 8)
		
		if (TryToCompile->CatchCodeVariable) {
			CompileSetVariableValue(Compiler, TryToCompile->CatchCodeVariable, RDI)
		}
		
		CompileBlock(Compiler, TryToCompile->CatchBody)
		
		SetLabel(Compiler, AfterCatchLabel)
	}
	; }
}

#Require "./src/compiler/AssemblyCompile.rlx"
