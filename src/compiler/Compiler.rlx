/*
==========================================
	Backing compiler state
==========================================
*/


struct Label {
	i32 LabelNumber,
	i32 OffsetToReplace,
	i8 IsPlaceholder
}

struct CompilerState {
	BuildConfig* Config,
	ParserState* Parser,
	FunctionDefine* CurrentFunction,
	
	union {
		/* Output file builders */
		
		PEBuilder* PE,
		ELFBuilder* ELF
	},
	
	/* Address (in loaded output file) where globals will live */
	i32 GlobalBase,
	i32 CodeBase,
	
	/* Buffer containing assembled (but not linked) code */
	i8* CodeBuffer,
	i32 CodeBufferSize,
	i32 Index,
	
	/* Array of relocations */
	i32* CodeRelocations,
	i32 CodeRelocationCount,
	
	/* Record of label definitions/usages inside of CodeBuffer, for actually linking labels */
	Label** Labels,
	i32 LabelCount,
	i32 LabelBufferCapacity,
	
	i32 LabelIndex,
	
	/* Labels for `continue` and `break` statements to jump to */
	i32 CurrentLoopContinueLabel,
	i32 CurrentLoopBreakLabel,
	
	/* Label for the current function's buffer of strings used */
	i32 CurrentFunctionStringsLabel,
	
	/* Next free register number for expression evaluation/whatever */
	i8 RegisterStackIndex,
	
	/* Flags to ensure that certain registers are not clobbered */
	i8 NoClobberCD89,
	i32 ParameterRegistersMaxSave,
	i32 ParameterRegistersMinSave,
	i8 NoClobberA,
	
	/* Flags the correct return sequence for `Main()` is used when Config->OutputFormat = OUTPUT_ELF */
	i8 CompilingMain,
	
	/* Count of `Try` statements logically 'wrapping' the current area in code 
		With loops resetting ScopedTryDepth for Continue/Break
	*/
	i32 ScopedTryDepth,
	i32 TotalTryDepth
	
	i32 GlobalStringsLabel
	
	; Number of functions present in output file
	i16 FunctionCount
	
	define void Initialize(BuildConfig* Config, ParserState* Parser) {
		this->Config := Config
		this->Parser := Parser
		
		this->CodeBufferSize := 0x10000
		this->CodeBuffer := Alloc(0x10000) As i8*
		this->Index := 0
		
		this->CodeRelocations := Alloc(8) As i64*
		this->CodeRelocationCount := 0
		
		this->Labels := Alloc(80) As Label**
		this->LabelCount := 0
		this->LabelBufferCapacity := 10
		
		this->LabelIndex := (Parser->LabelCount) + 1
		this->RegisterStackIndex := 0
		
		this->ParameterRegistersMaxSave := 0
		this->ParameterRegistersMinSave := 0
		
		this->CurrentFunction := null
		
		this->ScopedTryDepth := 0
		this->TotalTryDepth := 0
		
		this->FunctionCount := 0
	}
	define void Free() {
		Free(this->CodeBuffer)
		Free(this->CodeRelocations)
		Free(this->Labels)
	}
}

/*
==========================================
	High-ish level compiling functions, along with global/function dumping
==========================================
*/

#Require "./src/compiler/ASTOptimize.rlx"
#Require "./src/compiler/CodeGen.rlx"

declare void CompileImportStub(CompilerState*, FunctionDefine*)
declare void CompileFunction(CompilerState*, FunctionDefine*, i8)

define void DumpGlobals(CompilerState* Compiler) {
	/* Walk the globals hashmap and print the offset/size of each */
	ParserState* Parser := Compiler->Parser
	
	VariableHashMap* Globals := Parser~>Globals
	HashMap* RawGlobals := Globals->Map
	
	void* Elements := RawGlobals->Elements
	
	i32 MaxOffset := Globals->NextOffset
	i32 Base := Compiler->GlobalBase
	
	i32 MaxIndex := RawGlobals->BufferMaxCount
	
	for (i32 ElementIndex := 0, ElementIndex < MaxIndex, ElementIndex += 1) {
		if (Elements[ElementIndex]) {
			HashMapElement* FoundElement := Elements[ElementIndex] As HashMapElement*
			
			while (FoundElement) {
				VariableInfo* NextGlobal := FoundElement->Value
				
				if (NextGlobal->IsGlobal = GLOBAL_IS_OPTIMIZED_AWAY) {
					Print("^60     Opimized Away    = ")
				}
				else {
					i32 ThisOffset := NextGlobal->StackOffset
					i32 ThisSize := GetTypeStorageSize(NextGlobal->Type)
					
					i32 Start := Base + ThisOffset
					i32 End := Start + ThisSize
					
					Print("%x:%x = ", Start, End)
				}
				
				NextGlobal->Name->PrintLine()
				
				ResetColors()
				
				FoundElement := FoundElement->NextElement
			}
		}
	}
}

define void PrintFunction(CompilerState* Compiler, FunctionDefine* TargetFunction, i8 IsOverload) {
	/* Print a function in the format:
			Address Of Function - Size of function (Call count of function) Name
		With the type signature of the function optionally printed afterwards, if the function is overloaded.
	*/
	
	if (TargetFunction->CallCount = 0) {
		Print("^60	 - 	(0)	")
	}
	else {
		Print("%x	 - %i	(%i)	", Compiler->CodeBase + TargetFunction->CodeOffset, Compiler->Index - TargetFunction->CodeOffset, TargetFunction->CallCount)
	}
	
	if (TargetFunction->IsMethod) {
		PrintSafeString(TargetFunction->MethodOfTypeName)
		
		if (TargetFunction->IsMethod = FUNCTION_IS_STATIC_METHOD) {
			PrintCharacter(':')
		}
		else {
			PrintCharacter('.')
		}
	}
	
	PrintSafeString(TargetFunction->Name)
	
	if (IsOverload) {
		PrintCharacter('(')
		
		for (i32 ParameterIndex := 0, ParameterIndex < TargetFunction->ParameterCount, ParameterIndex += 1) {
			VariableInfo* NextParameter := TargetFunction->Parameters[ParameterIndex]
			
			if (NextParameter->IsVariadic) {
				PrintLiteral('...')
			}
			else {
				PrintType(NextParameter->Type)
			}
			
			if (ParameterIndex + 1 != TargetFunction->ParameterCount) {
				PrintLiteral(', ')
			}
		}
		
		PrintCharacter(')')
	}
	
	Print("^F0\n")
}

define void CompileOverload(CompilerState* Compiler, FunctionDefine* BaseFunction, i8 IsOverload) {
	/* Compiles either:
		A single function (BaseFunction)
		Or an entire linked list of function overloads, starting with BaseFunction
	*/
	
	;BaseFunction->CodeOffset := Compiler->Index
	
	if (BaseFunction->IsImported) {
		if (Compiler->Config->OutputFormat = OUTPUT_PE && BaseFunction->CallCount != 0) {
			CompileImportStub(Compiler, BaseFunction)
		}
	}
	else if !(BaseFunction->HasFullDefinition) {
		ContextError(BaseFunction~>Context, "Function is declared, but never defined.")
	}
	else {
		i8 IsMain := SafeStringEqualsAString(BaseFunction->Name, "Main")
		
		if (BaseFunction->CallCount != 0) {
			Compiler->FunctionCount += 1
			BaseFunction->CodeOffset := CompileFunction(Compiler, BaseFunction, IsMain)
		}
	}
	
	if (Compiler->Config->DumpInfo & DUMP_FUNCTIONS) {
		/* If we're dumping a function in an overload chain, then print it as an overload
			Or, if we're dumping a single function and it has `->Next` set, then we've just started an overload chain
			 and still need to print it as an overload
		*/
		
		PrintFunction(Compiler, BaseFunction, BaseFunction->Next != null || IsOverload)
	}
	
	if !(IsOverload) {
		; If this is the start of an overload chain, then we need to compile any/all functions in the chain
		
		while (BaseFunction->Next) {
			BaseFunction := BaseFunction->Next
			
			CompileOverload(Compiler, BaseFunction, true)
		}
	}
}

define void CompileFunctionHashMap(CompilerState* Compiler, HashMap* Map) {
	/* Compiles a hashmap containing FunctionDefine*'s as if it were a linear array 
		Returns true if the main function was found
	*/
	
	void* Elements := Map->Elements
	
	for (i32 ElementIndex := 0, ElementIndex < (Map->BufferMaxCount), ElementIndex += 1) {
		if (Elements[ElementIndex]) {
			HashMapElement* FoundElement := Elements[ElementIndex] As HashMapElement*
			
			while (FoundElement) {
				FunctionDefine* NextFunction := (FoundElement->Value) As FunctionDefine*
				
				CompileOverload(Compiler, NextFunction, false)
				
				/* Update the current element to be the next element in the linked list */
				FoundElement := FoundElement->NextElement
			}
		}
	}
}

define void CompilerStart(BuildConfig* Config, ParserState* Parser, i8* OutputFilePath) {
	CountReferences(Parser)
	EliminateGlobals(Parser~>Globals)
	
	CompilerState C
	CompilerState* Compiler := &C
	
	Compiler->Initialize(Config, Parser)
	
	if (Config->OutputFormat = OUTPUT_BIN) {
		Compiler->GlobalBase := Config->ImageBase + 0x10
		Compiler->CodeBase := Config->ImageBase + Parser~>Globals->NextOffset + 0x10
	}
	else if (Config->OutputFormat = OUTPUT_ELF) {
		Compiler->ELF := BuildELFBuilder()
		
		Compiler->GlobalBase := Config->ImageBase + 64 + 0x1000
		Compiler->CodeBase := Parser~>Globals->NextOffset + 564 + 0x2000
	}
	else if (Config->OutputFormat = OUTPUT_PE) {
		Compiler->PE := BuildBuilder()
		
		Compiler->PE->ImportFixupBase := Compiler->CodeBuffer
		Compiler->PE->PE->ImageBase := Config->ImageBase
		
		Compiler->GlobalBase := Config->ImageBase + Compiler->PE->NextRVA
		Compiler->CodeBase := 0x3000
	}
	
	Compiler->GlobalStringsLabel := NextLabel(Compiler)

	if (Config->DumpInfo & DUMP_GLOBALS) {
		DumpGlobals(Compiler)
	}
	
	; Compile all global functions
	CompileFunctionHashMap(Compiler, Parser~>Functions)
	
	; Loop through each custom type
	HashMap* Types := Parser~>Types
	
	i32 ElementCount := Types->BufferMaxCount
	void* Elements := Types->Elements
	
	for (i32 ElementIndex := 0, ElementIndex < ElementCount, ElementIndex += 1) {
		if (Elements[ElementIndex]) {
			HashMapElement* FoundElement := Elements[ElementIndex] As HashMapElement*
			
			while (FoundElement) {
				TypeInfo* NextType := (FoundElement->Value) As TypeInfo*
				
				/* If the type is a struct then compile any methods it might have */
				if (NextType->IsStructType) {
					CompileFunctionHashMap(Compiler, NextType~>Methods)
					CompileFunctionHashMap(Compiler, NextType~>StaticMethods)
				}
				
				FoundElement := FoundElement->NextElement
			}
		}
	}
	
	if (Parser->MainFunction = null) {
		SwapOutputStream()
		Print("^C0Main function not found, aborting.^F0")
		Exit(1)
	}
	
	i32 MainOffset := Parser->MainFunction->CodeOffset
	
	ResolveAllLabels(Compiler)
	
	if (Config->DumpInfo & DUMP_FUNCTIONS) {
		Print("\t^10Globals use %i bytes\n\t%i total bytes of code generated.\n\t%i total functions compiled.^F0\n", Parser~>Globals->NextOffset, Compiler->Index, Compiler->FunctionCount)
	}
	
	FileDelete(OutputFilePath)
	
	/* Actual compiling is done, time to build the output file */
	
	i64 OutputFileHandle := FileOpen(OutputFilePath, FILE_READ | FILE_WRITE | FILE_CREATE_NEW)
	
	if (OutputFileHandle < 0) {
		SwapOutputStream()
		Print("Could not open output file, error code: %i\nAborting\n", FileGetError(OutputFileHandle))
		Exit(1)
	}
	
	i32 Result := 0
	i32 BytesWritten := 0
	
	if (Config->OutputFormat = OUTPUT_BIN) {
		; The "bin" format is pretty much a 64 bit `.com` file. Except it contains an image base
		
		i32 CodeBase := Parser~>Globals->NextOffset + 0x10
		i32 FileSize := CodeBase + Compiler->Index
		
		void* Binary := Alloc(FileSize)
		i8* BinaryBytes := Binary As i8*
		
		BinaryBytes[0] := 0xE9
		((Binary + 1) As i32*)[0] := CodeBase + MainOffset - 5
		((Binary + 8) As i64*)[0] := Config->ImageBase
		
		for (i32 CodeIndex := 0, CodeIndex < Compiler->Index, CodeIndex += 1) {
			BinaryBytes[CodeBase + CodeIndex] := Compiler->CodeBuffer[CodeIndex]
		}
		
		Result := FileWrite(OutputFileHandle, Binary, FileSize)
		BytesWritten := FileSize
	}
	else if (Config->OutputFormat = OUTPUT_ELF) {
		AddDataSection(Compiler->ELF, Parser~>Globals->NextOffset)
		AddCodeSection(Compiler->ELF, Compiler->CodeBuffer, Compiler->Index)
		
		FinalizeELFBuilder(Compiler->ELF, MainOffset, Config->ImageBase)
		
		Result := FileWrite(OutputFileHandle, Compiler->ELF->Buffer, Compiler->ELF->BufferSize)
		BytesWritten := Compiler->ELF->BufferSize
	}
	else if (Config->OutputFormat = OUTPUT_PE) {
		AddData(Compiler->PE, Parser~>Globals->NextOffset)
		
		i64 TextRVA := AddCode(Compiler->PE, Compiler->CodeBuffer, Compiler->Index, MainOffset)
		
		; for (i32 RelocationIndex := 0, RelocationIndex < (Compiler->CodeRelocationCount), RelocationIndex += 1) {
		; 	i32 NextRelocationOffset := (Compiler->CodeRelocations)[RelocationIndex]
		; 	
		; 	i32 PageRVA := TextRVA + (NextRelocationOffset / 0x1000)
		; 	i16 OffsetInPage := (NextRelocationOffset % 0x1000) As i16
		; 	
		; 	/* Todo: Decide if a 32 bit relocation is correct or not. As long as imagebase is 32 bits, this is fine for now */
		; 	
		; 	AddRelocation(Compiler->PE, PageRVA, OffsetInPage, false)
		; }
		
		FinalizeBuilder(Compiler->PE)
		
		Result := FileWrite(OutputFileHandle, Compiler->PE->Buffer, Compiler->PE->BufferSize)
		BytesWritten := Compiler->PE->BufferSize
	}
	
	if (Result < 0) {
		SwapOutputStream()
		Print("Error writing output file, error code: %i\nAborting\n", FileGetError(Result))
		Exit(1)
	}
	
	Print("^10Done writing output file, %i bytes written, file format contains %i bytes of overhead^F0\n", BytesWritten, BytesWritten - Compiler->Index)
	
	FileClose(OutputFileHandle)
}

define i8 StackIndexToRegister(i8 Index) {
	if (Index = 4) {
		return R13
	}
	else if (Index > 4) {
		return Index + 9 As i8
	}
	else {
		return Index + 8 As i8
	}
}



define i8 PushRegisterStack(CompilerState* Compiler) {
	i8 Index := Compiler->RegisterStackIndex
	
	i8 TrueIndex := Index % 7
	i8 Result := StackIndexToRegister(TrueIndex)
	
	if (Index >= 8) {
		EmitPush_R64(Compiler, Result)
	}

	Compiler->RegisterStackIndex += 1
	
	return Result
}
define i8 TopOfRegisterStack(CompilerState* Compiler) {
	return StackIndexToRegister(Compiler->RegisterStackIndex)
}
define i8 PopRegisterStack(CompilerState* Compiler) {
	Compiler->RegisterStackIndex -= 1
	
	i8 Index := Compiler->RegisterStackIndex
	
	i8 TrueIndex := Index % 7
	i8 Result := StackIndexToRegister(TrueIndex)
	
	if (Index >= 8) {
		EmitPop_R64(Compiler, Result)
	}
	
	return Result
}

define void EnsureCodeBufferSize(CompilerState* Compiler) {
	if ((Compiler->Index + 0x100) >= (Compiler->CodeBufferSize)) {
		Compiler->CodeBufferSize += 0x5000
		Compiler->CodeBuffer := ReAlloc(Compiler->CodeBuffer, Compiler->CodeBufferSize)
		
		if (Compiler->Config->OutputFormat = OUTPUT_PE) {
			Compiler->PE->ImportFixupBase := Compiler->CodeBuffer
		}
	}
}

define void AddCodeRelocation(CompilerState* Compiler, i32 Offset) {
	i32 Index := Compiler->CodeRelocationCount
	
	Compiler->CodeRelocations := ReAlloc(Compiler->CodeRelocations, (Index + 1) * 8)
	(Compiler->CodeRelocations)[Index] := Offset
	
	Compiler->CodeRelocationCount += 1
}


/*
==========================================
	Variable helpers
==========================================
*/

define i32 GetVariableOffset(CompilerState* Compiler, VariableInfo* TargetVariable, i8* FitsDisp8) {
	i32 Offset := TargetVariable->StackOffset
	
	if !(TargetVariable->IsGlobal) {
		if (Compiler->Config->DebugMode & DEBUG_EMIT_FUNCTION_NAMES) {
			Offset += 0x10
		}
	}
	
	if (FitsDisp8 != null) {
		FitsDisp8[0] := (Offset <= 112)
	}
	
	if (TargetVariable->IsGlobal) {
		return Offset
	}
	
	return -(Offset + 8)
}

/* Todo: Merge these three functions into one */

define void CompileGetVariableAddress(CompilerState* Compiler, i8 ResultRegister, VariableInfo* TargetVariable) {
	i8 UseDisp8 := false
	i32 Offset := GetVariableOffset(Compiler, TargetVariable, &UseDisp8)
	
	i8 BaseRegister := RBP
	
	if (TargetVariable->IsGlobal) {
		BaseRegister := R15
	}
	
	if (UseDisp8) {
		EmitLea_R64_R64_DISP8(Compiler, ResultRegister, BaseRegister, Offset As i8)
	}
	else {
		EmitLea_R64_R64_DISP32(Compiler, ResultRegister, BaseRegister, Offset)
	}
	
	if (BaseRegister = R15) {
		AddCodeRelocation(Compiler, (Compiler->Index) - (!UseDisp8 * 3) + 1)
	}
}

declare void CompileExpression(CompilerState*, i8, ASTNode*)


; TODO: Change this back to a 'void' function once raw 'return' statements are allowed inside of
;  functions which return 'void'
define i32 CompileGetVariableValue(CompilerState* Compiler, i8 ResultRegister, VariableInfo* TargetVariable) {
	i8 TargetSize := GetTypeSize(TargetVariable->Type) As i8
	
	if (TargetVariable->Type.IsArray) {
		CompileGetVariableAddress(Compiler, ResultRegister, TargetVariable)
		return 0
	}
	
	if (TargetVariable->IsGlobal = GLOBAL_IS_OPTIMIZED_AWAY) {
		CompileExpression(Compiler, ResultRegister, TargetVariable->LastValue)
		return 0
	}
	
	if (GetPointerDepth(TargetVariable->Type) = 0 && GetBaseType(TargetVariable->Type)->IsStructType) {
		/* If GetVariableValue is called on a struct, then we should actually result in a pointer to that struct
			So Compile(Get|Set)StructField can depending on getting a pointer, and never the struct as a number
			Any time this could be abused *should* be caught by type checking 
		*/
		
		CompileGetVariableAddress(Compiler, ResultRegister, TargetVariable)
	}
	else {
		i8 UseDisp8 := false
		i32 Offset := GetVariableOffset(Compiler, TargetVariable, &UseDisp8)
		
		i8 BaseRegister := RBP
		
		if (TargetVariable->IsGlobal) {
			BaseRegister := R15
		}
		
		;if (UseDisp8) {
		;	EmitMove_RX_RIX_DISP8(Compiler, ResultRegister, BaseRegister, Offset As i8, TargetSize)
		;}
		;else {
		;	EmitMove_RX_RIX_DISP32(Compiler, ResultRegister, BaseRegister, Offset, TargetSize)
		;}
		
		EmitMove_RX_RIX_DISPX(Compiler, ResultRegister, BaseRegister, Offset, UseDisp8, TargetSize)
		
		if (BaseRegister = R15) {
			AddCodeRelocation(Compiler, (Compiler->Index) - (!UseDisp8 * 3) + 1)
		}
	}
	
	return 0
}
define void CompileSetVariableValue(CompilerState* Compiler, VariableInfo* TargetVariable, i8 SourceRegister) {
	i8 TargetSize := GetTypeSize(TargetVariable->Type) As i8
	
	i8 UseDisp8 := false
	i32 Offset := GetVariableOffset(Compiler, TargetVariable, &UseDisp8)
	
	i8 BaseRegister := RBP
	
	if (TargetVariable->IsGlobal) {
		BaseRegister := R15
	}
	
	if (UseDisp8) {
		EmitMove_RIX_DISP8_RX(Compiler, BaseRegister, SourceRegister, Offset As i8, TargetSize)
	}
	else {
		EmitMove_RIX_DISP32_RX(Compiler, BaseRegister, SourceRegister, Offset, TargetSize)
	}
	
	if (BaseRegister = R15) {
		AddCodeRelocation(Compiler, (Compiler->Index) - (!UseDisp8 * 3) + 1)
	}
}


/*
==========================================
	Actual compile functions
==========================================
*/

define void Cast(CompilerState* Compiler, i8 Register, i8 Size) {
	EmitMove_R64_RX(Compiler, Register, Register, Size)
}

define void CompileImportStub(CompilerState* Compiler, FunctionDefine* FunctionToCompile) {
	/* Compiles an imported function by emitting a jump to the actual function */
	
	FunctionToCompile->CodeOffset := Compiler->Index
	
	SetLabel(Compiler, FunctionToCompile->LabelNumber)
	
	EmitMove_R64_I64(Compiler, RBX, 0)
	
	AddImport(Compiler->PE, FunctionToCompile->ImportFileName, FunctionToCompile->ImportFunctionName, (Compiler->Index) - 8)
	AddCodeRelocation(Compiler, Compiler->Index - 8)
	
	EmitJump_RI64(Compiler, RBX)
}

declare void CompileBlock(CompilerState*, Block*)
declare void CompileAssembly(CompilerState*, AssemblyBlock*)

define i32 CompileFunction(CompilerState* Compiler, FunctionDefine* FunctionToCompile, i8 IsMain) {
	/* Compiles a single function */
	
	if (IsMain) {
		SetLabel(Compiler, Compiler->GlobalStringsLabel)
		
		for (i32 ConstantByteIndex := 0, ConstantByteIndex < Compiler->Parser->GlobalConstantBufferSize, ConstantByteIndex += 1) {
			PushByte(Compiler, Compiler->Parser->GlobalConstantsBuffer[ConstantByteIndex])
		}
	}
	
	; First though, we'll prefix the function's code with any strings which it uses
	i32 StringsLabel := NextLabel(Compiler)
	
	if (FunctionToCompile->StringBufferSize) {
		SetLabel(Compiler, StringsLabel)
		
		for (i32 CharacterIndex := 0, CharacterIndex < FunctionToCompile->StringBufferSize, CharacterIndex += 1) {
			PushByte(Compiler, FunctionToCompile->StringBuffer[CharacterIndex])
		}
	}
	
	i32 FunctionOffset := Compiler->Index
	SetLabel(Compiler, FunctionToCompile->LabelNumber)
	
	if (FunctionToCompile->Attribute = KEYWORD_ASSEMBLY) {
		/* Assembly functions should have no extra code generated, just whatever the asm block contains. */
		
		CompileAssembly(Compiler, FunctionToCompile->AssemblyBody)
		return FunctionOffset
	}
	
	if (FunctionToCompile->Body->StatementCount = 0) {
		/* Empty functions don't deserve any prelude code. */
		
		EmitReturn(Compiler)
		return FunctionOffset
	}
	
	Compiler->RegisterStackIndex := 0
	Compiler->CurrentFunction := FunctionToCompile
	Compiler->CurrentFunctionStringsLabel := StringsLabel
	
	i8 USE_SYSTEMV := true /* Compiler->OutputELF */
	
	if (FunctionToCompile->Attribute = KEYWORD_X64) {
		; Force a function to be compiled using the x64 ABI
		USE_SYSTEMV := false
	}
	
	/* Assume 4 register parameters, and 0 stack parameters */
	i8 MAX_REGISTER_PARAMETERS := 4
	
	if (USE_SYSTEMV) {
		MAX_REGISTER_PARAMETERS := 6
	}
	
	i8 ParameterCount := FunctionToCompile->ParameterCount
	i8 RegisterParameterCount := MAX_REGISTER_PARAMETERS
	i8 StackParameterCount := 0
	
	if (ParameterCount < MAX_REGISTER_PARAMETERS) {
		/* If there are less than 4/6 parameters, then the number of register parameters is just the number of parameters */
		
		RegisterParameterCount := ParameterCount
	}
	else if (ParameterCount > MAX_REGISTER_PARAMETERS) {
		/* Else if there are 5/7+ parameters, the stack parameter count is (TotalParamCount - MAX_REGISTER_PARAMETERS) */
		
		StackParameterCount := ParameterCount - MAX_REGISTER_PARAMETERS
		
		/* Also, store RSP in RBX for extracting the stack parameters with smaller offsets */
		EmitMove_R64_R64(Compiler, RBX, RSP)
	}
	
	/* Set up the stack frame for this function */
	i16 LocalSpace := FunctionToCompile~>Locals->NextOffset
	i16 LocalSpaceRemainder := LocalSpace % 16
	
	if (LocalSpaceRemainder) {
		LocalSpace += 8
	}
	
	EmitPush_R64(Compiler, RBP)
	EmitMove_R64_R64(Compiler, RBP, RSP)
	
	if (IsMain && Compiler->Config->OutputFormat = OUTPUT_ELF  && ParameterCount <= 2) {
		/* When compiling main for SystemV, load the first two parameter registers (if they exist) 
			With ArgC and ArgV loaded from the stack since:
				RBP + 0 = ArgC
				RBP + 1..ArgC = ArgV
			so mov rdi, [rsp+8] will get argc, and
			lea rsi, [rsp+16] will get argv
			which are then moved into the local ArgC/ArgV variables by the default parameter saving behavior
		*/
		
		;EmitMove_RX_RIX_DISP8(Compiler, RDI, RBP, 8, 8)
		EmitMove_RX_RIX_DISPX(Compiler, RDI, RBP, 8, true, 8)
		EmitLea_R64_R64_DISP8(Compiler, RSI, RBP, 16)
	}
	
	if (Compiler->Config->DebugMode & DEBUG_EMIT_FUNCTION_NAMES) {
		EmitMove_R32_I32(Compiler, RAX, 0x12345678)
		EmitPush_R64(Compiler, RAX)
		EmitLea_R64_Label(Compiler, RAX, StringsLabel)
		EmitPush_R64(Compiler, RAX)
		
		; Extend LocalSpace to account for extra offset from RBP to local variables
		LocalSpace += 0x8
	}
	
	if (LocalSpace) {
		/* Only emit an instruction to allocate space for locals when we have locals */
		EmitSub_R64_IX(Compiler, RSP, LocalSpace)
	}
	
	for (i8 RegisterParameterIndex := 0, RegisterParameterIndex < RegisterParameterCount, RegisterParameterIndex += 1) {
		/* For each register parameter */
		
		/* Get the VariableInfo structure for the parameter */
		VariableInfo* NextParameter := (FunctionToCompile->Parameters)[RegisterParameterIndex]
		
		/* And which register it is in (according to the target ABI) */
		i8 NextParameterRegister := 0
		
		if (USE_SYSTEMV) {
			NextParameterRegister := GetSystemVRegister(RegisterParameterIndex)
		}
		else {
			NextParameterRegister := RegisterParameterIndex + 1
			
			if (NextParameterRegister > 2) {
				NextParameterRegister += 5
			}
		}
		
		/* And write the parameter register's value into the parameter's stack space */
		CompileSetVariableValue(Compiler, NextParameter, NextParameterRegister)
	}
	
	for (i8 StackParameterIndex := 0, StackParameterIndex < StackParameterCount, StackParameterIndex += 1) {
		/* For each stack parameter */
		
		/* Get the VariableInfo structure for the parameter */
		VariableInfo* NextStackParameter := (FunctionToCompile->Parameters)[StackParameterIndex + MAX_REGISTER_PARAMETERS]
		
		/* Load RAX with the parameter's value (using RBX/old RSP as a base) */
		
		i8 NextParameterOffset := (StackParameterIndex + 1) * 8
		i8 NextParameterSize := GetTypeSize(NextStackParameter->Type) As i8
		
		;EmitMove_RX_RIX_DISP8(Compiler, RAX, RBX, NextParameterOffset, NextParameterSize)
		EmitMove_RX_RIX_DISPX(Compiler, RAX, RBX, NextParameterOffset, true, NextParameterSize)
		
		/* Write RAX(/the parameter's value) into the parameter's stack space */
		CompileSetVariableValue(Compiler, NextStackParameter, RAX)
	}
	
	if (Compiler->Parser~>Globals->NextOffset != 0 && (FunctionToCompile->UsesGlobals || IsMain)) {
		EmitMove_R32_I32(Compiler, R15, Compiler->GlobalBase)
	}
	
	if (IsMain) {
		Compiler->CurrentFunctionStringsLabel := Compiler->GlobalStringsLabel
		
		ASTNode** GlobalDefaults := Compiler->Parser->GlobalDefaults
		i32 Length := GetArrayLength(GlobalDefaults)
		
		for (i32 GlobalDefaultIndex := 0, GlobalDefaultIndex < Length, GlobalDefaultIndex += 1) {
			ASTNode* NextGlobalDefault := GlobalDefaults[GlobalDefaultIndex]
			VariableInfo* TargetGlobal := NextGlobalDefault->BinaryNode->Left->VariableValue
			
			if (TargetGlobal->IsGlobal != GLOBAL_IS_OPTIMIZED_AWAY) {
				CompileExpression(Compiler, RAX, NextGlobalDefault)
			}
		}
		
		Compiler->CurrentFunctionStringsLabel := StringsLabel
	}
	
	/* Compile the body of the function */
	
	Block* Body := FunctionToCompile->Body
	i32 BodyCount := Body->StatementCount
	ASTNode* ReturnExpression := 0
	
	if (BodyCount >= 1) {
		/* If the last statement of the function body is a return, then don't emit a Leave;Ret combo for it 
			since every function automatically gets Leave;Ret emitted for it.
		*/
		
		ASTNode* LasLexerment := Body->Statements[BodyCount - 1]
		
		if (LasLexerment->NodeType = NODE_TYPE_RETURN) {
			ReturnExpression := LasLexerment->ReturnExpression
			Body->StatementCount -= 1
		}
	}
	
	Compiler->CompilingMain := IsMain
	
	CompileBlock(Compiler, Body)
	
	if (ReturnExpression) {
		CompileExpression(Compiler, RAX, ReturnExpression)
		
		i16 ReturnValueSize := GetTypeSize(ReturnExpression->ValueType)
		i16 ReturnTypeSize := GetTypeSize(Compiler->CurrentFunction->ReturnType)
		
		if (ReturnValueSize < ReturnTypeSize || ReturnValueSize < 4) {
			Cast(Compiler, RAX, ReturnValueSize As i8)
		}
	}
	
	EmitLeave(Compiler)
	
	if (IsMain && Compiler->Config->OutputFormat = OUTPUT_ELF) {
		EmitMove_R64_R64(Compiler, RDI, RAX)
		EmitMove_R32_I32(Compiler, RAX, 60)
		EmitSysCall(Compiler)
	}
	else {
		EmitReturn(Compiler)
	}
	
	if (Compiler->RegisterStackIndex != 0) {
		ContextError(FunctionToCompile~>Context, "[INTERNAL] Register stack not empty")
	}
	
	Compiler->CurrentFunction := null
	
	return FunctionOffset
}

declare void Compile(CompilerState*, ASTNode*)

define void CompileBlock(CompilerState* Compiler, Block* BlockToCompile) {
	/* Compiles a block of statements */
	
	for (i32 Index := 0, Index < BlockToCompile->StatementCount, Index += 1) {
		ASTNode* NexLexerment := (BlockToCompile->Statements)[Index]
		
		Compile(Compiler, NexLexerment)
	}
}

declare void CompileReturn(CompilerState*, ASTNode*)
declare void CompileIf(CompilerState*, IfGroup*)
declare void CompileFor(CompilerState*, ForLoop*)
declare void CompileLoop(CompilerState*, Block*)
declare void CompileWhile(CompilerState*, WhileLoop*)
declare void CompileTry(CompilerState*, TryCatch*)

declare void CompileUnary(CompilerState*, i8, Type, UnaryExpression*, i8)
declare void CompileBinary(CompilerState*, i8, Type, BinaryExpression*, i8)
declare void CompileGetStructAccess(CompilerState*, i8, StructAccessExpression*)
declare void CompileCall(CompilerState*, i8, ASTNode*)

declare void CompileUnwindTry(CompilerState*, i8)

define void Compile(CompilerState* Compiler, ASTNode* NodeToCompile) {
	/* Compiles some kind of statement */
	
	i8 NodeType := NodeToCompile->NodeType
	
	if (NodeType = NODE_TYPE_RETURN) {
		CompileReturn(Compiler, NodeToCompile->ReturnExpression)
	}
	else if (NodeType = NODE_TYPE_IF) {
		CompileIf(Compiler, NodeToCompile->IfNode)
	}
	else if (NodeType = NODE_TYPE_FOR) {
		CompileFor(Compiler, NodeToCompile->ForNode)
	}
	else if (NodeType = NODE_TYPE_LOOP) {
		CompileLoop(Compiler, NodeToCompile->LoopBody)
	}
	else if (NodeType = NODE_TYPE_WHILE) {
		CompileWhile(Compiler, NodeToCompile->WhileNode)
	}
	else if (NodeType = NODE_TYPE_TRY) {
		CompileTry(Compiler, NodeToCompile->TryNode)
	}
	else if (NodeType = NODE_TYPE_CONTINUEBREAK) {
		CompileUnwindTry(Compiler, false)
		
		if (NodeToCompile->IsContinue) {
			EmitJump_Label(Compiler, Compiler->CurrentLoopContinueLabel)
		}
		else {
			EmitJump_Label(Compiler, Compiler->CurrentLoopBreakLabel)
		}
	}
	else if (NodeType = NODE_TYPE_EXPRESSION) {
		CompileExpression(Compiler, RAX, NodeToCompile->ExpressionStatement)
	}
	else if (NodeType = NODE_TYPE_ASSEMBLY) {
		CompileAssembly(Compiler, NodeToCompile->AssemblyValue)
	}
}

define void CompileReturn(CompilerState* Compiler, ASTNode* ReturnExpression) {
	/* Compile the expression to return */
	
	CompileUnwindTry(Compiler, true)
	
	CompileExpression(Compiler, RAX, ReturnExpression)
	
	i16 ReturnValueSize := GetTypeSize(ReturnExpression->ValueType)
	i16 ReturnTypeSize := GetTypeSize(Compiler->CurrentFunction->ReturnType)
	
	/* And cast it up to (at least) 4 bytes, to ensure no garbage is left in RAX */
	
	if (ReturnValueSize < ReturnTypeSize || ReturnValueSize < 4) {
		Cast(Compiler, RAX, ReturnValueSize As i8)
	}
	
	EmitLeave(Compiler)
	
	if (Compiler->CompilingMain && Compiler->Config->OutputFormat = OUTPUT_ELF) {
		/* If returning from Main() on Linux, actually call sys_exit() to ensure that the program exits correctly. */
		
		EmitMove_R64_R64(Compiler, RDI, RAX)
		EmitMove_R32_I32(Compiler, RAX, 60)
		EmitSysCall(Compiler)
	}
	else {
		EmitReturn(Compiler)
	}
}

define i8 IsComparison(Token* OperatorToken) {
	i8 Operator := OperatorToken->Value As i8
	
	return (OPERATOR_FIRST_SHORT_CIRCUIT <= Operator && Operator <= OPERATOR_LAST_COMPARISON)
}

define void CompileCondition(CompilerState* Compiler, ASTNode* ConditionExpression, i32 JumpToLabel) {
	/* Checks ConditionExpression for being false, and jumps to JumpToLabel if it is 
		This might seem a bit backwards, but loops/if statements all check for false, and jump out (or to the next branch)
		 depending on their conditions being false, which eliminates lots of extra jumping
	*/
	
	i8 ConditionType := ConditionExpression->NodeType
	
	BinaryExpression* BinaryNode := ConditionExpression->BinaryNode
	UnaryExpression* UnaryNode := ConditionExpression->UnaryNode
	
	if (ConditionType = NODE_TYPE_BINARY && IsComparison(BinaryNode->Operator)) {
		/* Compile the expression without a result being stored into RAX, since we use the value in EFLAGS */
		
		i8 Operator := BinaryNode->Operator->Value As i8
		
		ASTNode* Right := BinaryNode->Right
		i8 IsEquals := (Operator = OPERATOR_EQUAL || Operator = OPERATOR_BANG_EQUAL)
		
		if (IsEquals && (Right->NodeType = NODE_TYPE_INTEGER && Right->IntegerValue = 0)) {
			CompileExpression(Compiler, RAX, BinaryNode->Left)
			
			EmitOr_RX_RX(Compiler, RAX, RAX, GetTypeSize(BinaryNode->Left->ValueType) As i8)
			
			if (Operator = OPERATOR_EQUAL) {
				EmitJNZ_Label(Compiler, JumpToLabel)
			}
			else {
				EmitJEZ_Label(Compiler, JumpToLabel)
			}
		}
		else {
			CompileBinary(Compiler, RAX, ConditionExpression->ValueType, BinaryNode, true)
			
			/* Use inverted conditions to decide if this branch had a false condition, and to jump past it or not */
			
			if (Operator = OPERATOR_EQUAL) {
				EmitJNZ_Label(Compiler, JumpToLabel)
			}
			else if (Operator = OPERATOR_BANG_EQUAL) {
				EmitJEZ_Label(Compiler, JumpToLabel)
			}
			else if (Operator = OPERATOR_LESS) {
				EmitJGE_Label(Compiler, JumpToLabel)
			}
			else if (Operator = OPERATOR_LESS_EQAUL) {
				EmitJGT_Label(Compiler, JumpToLabel)
			}
			else if (Operator = OPERATOR_GREATER) {
				EmitJLE_Label(Compiler, JumpToLabel)
			}
			else if (Operator = OPERATOR_GREATER_EQAUL) {
				EmitJLT_Label(Compiler, JumpToLabel)
			}
			else if (Operator = OPERATOR_LOGICAL_AND || Operator = OPERATOR_LOGICAL_OR) {
				EmitJEZ_Label(Compiler, JumpToLabel)
			}
		}
	}
	else if (ConditionType = NODE_TYPE_UNARY && (UnaryNode->Operator->Value As i8) = OPERATOR_BANG) {
		CompileUnary(Compiler, RAX, ConditionExpression->ValueType, UnaryNode, true)
		EmitJNZ_Label(Compiler, JumpToLabel)
	}
	else {
		/* In this case, the expression is not conditional, and we will need to check the result for being 0 or not */
		
		CompileExpression(Compiler, RAX, ConditionExpression)
		EmitTest_RX_RX(Compiler, RAX, RAX, GetTypeSize(ConditionExpression->ValueType) As i8)
		EmitJEZ_Label(Compiler, JumpToLabel)
	}
}

define void CompileIf(CompilerState* Compiler, IfGroup* IfToCompile) {
	i32 BranchCount := IfToCompile->BranchCount
	i32 HasElse := (IfToCompile->ElseBranch) != 0
	
	i32 EndLabel := NextLabel(Compiler)
	i32 NextBranch := NextLabel(Compiler)
	
	i8 ConditionResultRegister := PushRegisterStack(Compiler)
	
	for (i32 BranchIndex := 0, BranchIndex < BranchCount, BranchIndex += 1) {
		SetLabel(Compiler, NextBranch)
		NextBranch := NextLabel(Compiler)
		
		CompileCondition(Compiler, IfToCompile->Conditions[BranchIndex], NextBranch)
		CompileBlock(Compiler, IfToCompile->Bodies[BranchIndex])
		
		if (HasElse || (BranchIndex != (BranchCount - 1))) {
			/* Only emit a jump to the end label if: We have an 'else', or we are not the last branch 
				This will eliminate a single extra `jmp, endlabel` on the final 'else if' of the statement
				
			*/
			
			EmitJump_Label(Compiler, EndLabel)
		}
	}
	
	PopRegisterStack(Compiler)
	
	SetLabel(Compiler, NextBranch)
	
	if (IfToCompile->ElseBranch) {
		CompileBlock(Compiler, IfToCompile->ElseBranch)
	}
	
	SetLabel(Compiler, EndLabel)
}

/* Helpers to save/restore the current loop's continue/break labels (for nested loops) */

bits LoopLables As i64 {
	[0:31] ContinueLabel,
	[32:63] BreakLabel
}
define i64 EnterLoop(CompilerState* Compiler, i32 ContinueLabel, i32 BreakLabel) {
	LoopLables Result := Compiler->CurrentLoopContinueLabel
	Result.BreakLabel := Compiler->CurrentLoopBreakLabel
	
	Compiler->CurrentLoopContinueLabel := ContinueLabel
	Compiler->CurrentLoopBreakLabel := BreakLabel
	
	return Result As i64
}
define void ExitLoop(CompilerState* Compiler, i64 PackedLooParser) {
	LoopLables LooParser := PackedLooParser As LoopLables
	
	Compiler->CurrentLoopContinueLabel := LooParser.ContinueLabel
	Compiler->CurrentLoopBreakLabel := LooParser.BreakLabel
}


/* Actual loop compiling functions */

define void CompileFor(CompilerState* Compiler, ForLoop* ForToCompile) {
	CompileExpression(Compiler, RAX, ForToCompile->Initializer)
	
	i32 StartLabel := NextLabel(Compiler)
	i32 ContinueLabel := NextLabel(Compiler)
	i32 EndLabel := NextLabel(Compiler)
	
	SetLabel(Compiler, StartLabel)
	
	CompileCondition(Compiler, ForToCompile->Condition, EndLabel)
	
	i32 TryDepth := Compiler->ScopedTryDepth
	Compiler->ScopedTryDepth := 0
	i64 LooParser := EnterLoop(Compiler, ContinueLabel, EndLabel)

	/* Prelude stuff done, condition is checked, so now we can compile the body */	
	
	CompileBlock(Compiler, ForToCompile->Body)
	
	SetLabel(Compiler, ContinueLabel) /* On continue (or after the body ends naturally) execute the step, and jump to the condition check */
	CompileExpression(Compiler, RAX, ForToCompile->Step)
	
	EmitJump_Label(Compiler, StartLabel)
	
	SetLabel(Compiler, EndLabel) /* Jumped to on ForToCompile->Condition being false, or a break statement */
	
	ExitLoop(Compiler, LooParser)
	Compiler->ScopedTryDepth := TryDepth
}

define void CompileLoop(CompilerState* Compiler, Block* LoopBody) {
	i32 StartLabel := NextLabel(Compiler)
	i32 EndLabel := NextLabel(Compiler)
	
	i32 TryDepth := Compiler->ScopedTryDepth
	Compiler->ScopedTryDepth := 0
	i64 LooParser := EnterLoop(Compiler, StartLabel, EndLabel)
	
	SetLabel(Compiler, StartLabel)
	
	CompileBlock(Compiler, LoopBody)
	
	EmitJump_Label(Compiler, StartLabel)
	SetLabel(Compiler, EndLabel)
	
	ExitLoop(Compiler, LooParser)
	Compiler->ScopedTryDepth := TryDepth
}

define void CompileWhile(CompilerState* Compiler, WhileLoop* WhileToCompile) {
	i32 StartLabel := NextLabel(Compiler)
	i32 EndLabel := NextLabel(Compiler)
	
	i32 TryDepth := Compiler->ScopedTryDepth
	Compiler->ScopedTryDepth := 0
	i64 LooParser := EnterLoop(Compiler, StartLabel, EndLabel)
	
	SetLabel(Compiler, StartLabel)
	
	CompileCondition(Compiler, WhileToCompile->Condition, EndLabel)
	CompileBlock(Compiler, WhileToCompile->Body)
	
	EmitJump_Label(Compiler, StartLabel)
	SetLabel(Compiler, EndLabel)
	
	ExitLoop(Compiler, LooParser)
	Compiler->ScopedTryDepth := TryDepth
}

define void CompileGetStorageValue(CompilerState* Compiler, ASTNode* ValueToGet) { 
	
	
}
define void CompileSetStorageValue(CompilerState* Compiler, ASTNode* ValueToSet, i8 RegisterToSetTo) {
	
}

define void CompileGetStorageValuePointer(CompilerState* Compiler, ASTNode* ValueToGet) {
	
}


define void CompileExpression(CompilerState* Compiler, i8 ResultRegister, ASTNode* ExpressionToCompile) {
	/* Compiles some kind of expression */
	
	i8 ExpressionType := ExpressionToCompile->NodeType
	Type ResultType := ExpressionToCompile->ValueType
	
	if (ExpressionType = NODE_TYPE_INTEGER) {
		/* Simply move the integer being used into the result register */
		
		i8 ResultSize := GetTypeSize(ResultType)
		i64 IntegerValue := ExpressionToCompile->IntegerValue
		
		if (IntegerValue = 0) {
			EmitXor_RX_RX(Compiler, ResultRegister, ResultRegister, 4)
		}
		else {
			i8 IntegerSize := GetNumberSize(IntegerValue)
			
			if (ResultSize >= 4 && IntegerSize <= 4) {
				ResultSize := 4
			}
			
			EmitMove_RX_IX(Compiler, ResultRegister, IntegerValue, ResultSize)
		}
	}
	else if (ExpressionType = NODE_TYPE_ZERO) {
		EmitXor_RX_RX(Compiler, ResultRegister, ResultRegister, 4)
	}
	else if (ExpressionType = NODE_TYPE_VARIABLE) {
		VariableInfo* TargetVariable := ExpressionToCompile->VariableValue
		
		CompileGetVariableValue(Compiler, ResultRegister, TargetVariable)
	}
	else if (ExpressionType = NODE_TYPE_UNARY) {
		UnaryExpression* UnaryNode := ExpressionToCompile->UnaryNode
	
		CompileUnary(Compiler, ResultRegister, ResultType, UnaryNode, false)
	}
	else if (ExpressionType = NODE_TYPE_BINARY) {
		/* Calls into CompileBinary with the correct parameters extracted from ExpressionToCompile */
		
		BinaryExpression* BinaryNode := ExpressionToCompile->BinaryNode
		
		CompileBinary(Compiler, ResultRegister, ResultType, BinaryNode, false)
	}
	else if (ExpressionType = NODE_TYPE_STRUCT_ACCESS) {
		StructAccessExpression* AccessNode := ExpressionToCompile->AccessNode
		
		CompileGetStructAccess(Compiler, ResultRegister, AccessNode)
	}
	else if (ExpressionType = NODE_TYPE_CALL) {
		CompileCall(Compiler, ResultRegister, ExpressionToCompile)
	}
	else if (ExpressionType = NODE_TYPE_STRING) {		
		EmitLea_R64_Label(Compiler, ResultRegister, Compiler->CurrentFunctionStringsLabel)
		OffsetLabel(Compiler, ExpressionToCompile->StringOffsetValue)
	}
	else if (ExpressionType = NODE_TYPE_GET_TYPE_SIZE) {
		i32 OperandTypeSize := GetTypeStorageSize(ExpressionToCompile->TypeValue)
		
		EmitMove_RX_IX(Compiler, ResultRegister, OperandTypeSize, 4)
	}
}


; TODO: Change this back to a 'void' function once raw 'return' statements are allowed inside of
;  functions which return 'void'
define i32 CompileCall(CompilerState* Compiler, i8 ResultRegister, ASTNode* Node) {
	CallExpression* CallNode := Node->CallNode
	FunctionDefine* TargetFunction := CallNode->TargetFunction
	
	i8 BuiltinID := CallNode->BuiltinID
	i8 IS_SYSCALL := BuiltinID = BUILTIN_SYSCALL /* Used later to decide which set of registers are for parameters */
	
	if (IS_SYSCALL) {
		/* Dummy branch to stop TargetFunction (a null pointer for `syscall(X, ...)`) from being accessed */
	}
	else if (BuiltinID = BUILTIN_BREAKPOINT) {
		EmitInt3(Compiler)
		
		return 0
	}
	else if (Compiler->Config->OutputFormat != OUTPUT_PE && TargetFunction->IsImported) {
		Node->Error("Calls to DllImported functions are not allowed when the target output format is not PE.")
	}
	else if !(TargetFunction->IsImported || TargetFunction->HasFullDefinition) {
		Node->Error("Called function is only declared, and never defined")
	}
	
	i32 ParameterCount := CallNode->ParameterCount
	i32 StackParameterCount := 0
	i8 ExtraPadding := false
	i8 HasSavedRAX := false
	
	if (Compiler->NoClobberA && ResultRegister != RAX) {
		EmitPush_R64(Compiler, RAX)
		HasSavedRAX := true
		
		Compiler->NoClobberA := false
	}
	
	/* TargetFunction is only null for syscall:(), so `!TargetFunction` will short circuit before `TargetFunction->IsImported` crashes */
	
	i8 USE_SYSTEMV := !TargetFunction || !TargetFunction->IsImported /* (Compiler->OutputELF) || (TargetFunction->Attribute = KEYWORD_ASSEMBLY) */
	
	i8 REGISTER_PARAMETER_COUNT := 4
	
	if (USE_SYSTEMV) {
		REGISTER_PARAMETER_COUNT := 6
	}
	
	if (ParameterCount > REGISTER_PARAMETER_COUNT) {
		StackParameterCount := ParameterCount - REGISTER_PARAMETER_COUNT
	}
	
	i8 RegisterStackIndex := Compiler->RegisterStackIndex
	i8 StackIsAligned := RegisterStackIndex >= 8 && (RegisterStackIndex % 2 != 0)
	
	if (StackParameterCount % 2 || StackIsAligned && !HasSavedRAX) {
		EmitPush_R64(Compiler, RBX)
		ExtraPadding := true
	}
	
	Compiler->RegisterStackIndex := 3
	
	i8 OldNoClobberCD89 := Compiler->NoClobberCD89
	Compiler->NoClobberCD89 := true /* Ensure none of the parameter registers are used for another operation without being saved */
	
	i32 OldMaxSave := Compiler->ParameterRegistersMaxSave
	i32 OldMinSave := Compiler->ParameterRegistersMinSave
	i8 ShouldSaveRegisters := OldMaxSave != OldMinSave
	
	if (ShouldSaveRegisters) {
		for (i32 SaveIndex := OldMinSave, SaveIndex < OldMaxSave, SaveIndex += 1) {
			EmitPush_R64(Compiler, GetSystemVRegister(SaveIndex))
		}
	}
	
	i32 RegisterParameterCount := ParameterCount - StackParameterCount
	Compiler->ParameterRegistersMaxSave := RegisterParameterCount
	
	i8 ParameterRegister := RBX
	i8 IS_VARIADIC := (TargetFunction != 0) && (TargetFunction->Attribute = OPERATOR_DOT)
	
	if (ParameterCount != 0) {		
		if (IS_VARIADIC) {
			ParameterCount := TargetFunction->ParameterCount - 1
			
			i8 VariadicCount := ((CallNode->ParameterCount) - (TargetFunction->ParameterCount)) + 1
			i8 VariadicBase := ParameterCount
			
			for (i32 VariadicIndex := (VariadicCount - 1), VariadicIndex >= 0, VariadicIndex -= 1) {
				ASTNode* NextVariadic := (CallNode->Parameters)[VariadicBase + VariadicIndex]
				
				CompileExpression(Compiler, RBX, NextVariadic)
				
				i16 NextVariadicSize := GetTypeSize(NextVariadic->ValueType)
				
				if (NextVariadicSize <= 4) {
					/* Any parameter which is smaller than 4 bytes will not 0 the upper 32 bits of a register, so we manually cast them up */
					Cast(Compiler, RBX, NextVariadicSize As i8)
				}
				
				EmitPush_R64(Compiler, RBX)
			}
			
			EmitMove_R32_I32(Compiler, RBX, VariadicCount)
			EmitPush_R64(Compiler, RBX)
		}
		
		for (i64 ParameterIndex := (ParameterCount - 1), ParameterIndex >= 0, ParameterIndex -= 1) {
			i16 ExpectedSize := 8
			
			if !(IS_SYSCALL) {
				VariableInfo* NextParameter := (TargetFunction->Parameters)[ParameterIndex]
				ExpectedSize := GetTypeSize(NextParameter->Type)
			}
			
			ASTNode* NextParameterValue := (CallNode->Parameters)[ParameterIndex]
			
			i8 ThisParameterRegister := ParameterRegister
			
			if (IS_SYSCALL) {
				if (ParameterIndex = 0) {
					ThisParameterRegister := RAX
				}
				else {
					ThisParameterRegister := GetSystemVRegister(ParameterIndex - 1 As i8)
				}
			}
			else if (USE_SYSTEMV) {				
				ThisParameterRegister := GetSystemVRegister(ParameterIndex As i8)
			}
			else {
				if (ParameterIndex = 3) {ThisParameterRegister := R9}
				else if (ParameterIndex = 2) {ThisParameterRegister := R8}
				else if (ParameterIndex = 1) {ThisParameterRegister := RDX}
				else if (ParameterIndex = 0) {ThisParameterRegister := RCX}
			}
			
			Compiler->ParameterRegistersMinSave := ParameterIndex + 1
			CompileExpression(Compiler, ThisParameterRegister, NextParameterValue)
			
			i16 ActualSize := GetTypeSize(NextParameterValue->ValueType)
			
			if (NextParameterValue->NodeType = NODE_TYPE_INTEGER) {
				i64 ParameterInteger := NextParameterValue->IntegerValue
				
				if (ActualSize = 4 && ParameterInteger As i32 > 0) {
					ActualSize := ExpectedSize
				}
			}
			
			if (ActualSize < ExpectedSize) {
				Cast(Compiler, ThisParameterRegister, ActualSize As i8)
			}
			
			if (ParameterIndex >= REGISTER_PARAMETER_COUNT) {
				EmitPush_R64(Compiler, ThisParameterRegister)
			}
		}
		
		if (IS_VARIADIC) {			
			i8 VariadicRegister := GetSystemVRegister(VariadicBase)
			
			EmitLea_R64_SIB(Compiler, VariadicRegister, 1, RSP, RSP)
			
			VariadicCount += 1
		}
	}

	Compiler->NoClobberCD89 := OldNoClobberCD89
	
	if (IS_SYSCALL) {
		EmitSysCall(Compiler)
	}
	else if (USE_SYSTEMV || !TargetFunction->IsImported) {
		EmitCall_Label(Compiler, TargetFunction->LabelNumber)
	}
	else {
		EmitSub_R64_I8(Compiler, RSP, 0x20) /* Shadown space */
		EmitCall_Label(Compiler, TargetFunction->LabelNumber)
		EmitAdd_R64_I8(Compiler, RSP, 0x20)
	}
	
	i32 StackAdd := StackParameterCount
	
	if (IS_VARIADIC) {
		StackAdd += VariadicCount
	}
	
	if (StackAdd) {
		EmitAdd_R64_I32(Compiler, RSP, StackAdd * 8)
	}
	
	if (ShouldSaveRegisters) {
		for (SaveIndex := OldMaxSave, SaveIndex > OldMinSave, SaveIndex -= 1) {
			EmitPop_R64(Compiler, GetSystemVRegister(SaveIndex - 1))
		}
	}
	
	Compiler->ParameterRegistersMaxSave := OldMaxSave
	Compiler->ParameterRegistersMinSave := OldMinSave
	
	if (ExtraPadding) {
		EmitPop_R64(Compiler, RBX)
	}
	
	if (ResultRegister != RAX) {
		EmitMove_R64_RX(Compiler, ResultRegister, RAX, GetTypeSize(TargetFunction->ReturnType) As i8)
	}
	
	if (HasSavedRAX) {
		EmitPop_R64(Compiler, RAX)
		Compiler->NoClobberA := true
	}
	
	Compiler->RegisterStackIndex := RegisterStackIndex
	
	return 0
}

declare void CompileGetStructAccessPointer(CompilerState*, i8, StructAccessExpression*)

; TODO: Change this back to a 'void' function once raw 'return' statements are allowed inside of
;  functions which return 'void'
define i32 CompileStructAccessLeft(CompilerState* Compiler, i8 ResultRegister, StructAccessExpression* TargetAccess) {
	ASTNode* Left := TargetAccess->Left
	
	if (TargetAccess->Operator->Value = OPERATOR_DOT) {
		if (Left->NodeType = NODE_TYPE_STRUCT_ACCESS) {
			CompileGetStructAccessPointer(Compiler, ResultRegister, Left->AccessNode)
			return 0
		}
		else if (Left->NodeType = NODE_TYPE_VARIABLE) {
			CompileGetVariableAddress(Compiler, ResultRegister, Left->VariableValue)
			return 0
		}
	}
	
	CompileExpression(Compiler, ResultRegister, Left)
	
	return 0
}

define void CompileGetStructAccessPointer(CompilerState* Compiler, i8 ResultRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	i16 TargetFieldSize := GetTypeSize(TargetField->ValueType)
	
	CompileStructAccessLeft(Compiler, ResultRegister, TargetAccess)
	
	i32 FieldOffset := TargetField->Offset
	
	if (FieldOffset != 0) {
		EmitLea_R64_R64_DISPX(Compiler, ResultRegister, ResultRegister, FieldOffset)
	}
}

; TODO: Change this back to a 'void' function once raw 'return' statements are allowed inside of
;  functions which return 'void'
define i32 CompileGetStructAccess(CompilerState* Compiler, i8 ResultRegister, StructAccessExpression* TargetAccess) {
	if (TargetAccess->Operator->Value = OPERATOR_TILDE_GREATER) {
		CompileGetStructAccessPointer(Compiler, ResultRegister, TargetAccess)
		return 0
	}
	
	StructField* TargetField := TargetAccess->TargetField
	i8 TargetFieldSize := GetTypeSize(TargetField->ValueType) As i8
	
	i32 FieldOffset := TargetField->Offset
	
	if (TargetField->BitStartIndex || TargetField->BitEndIndex) {
		CompileExpression(Compiler, ResultRegister, TargetAccess->Left)
		
		TargetFieldSize := FieldOffset
		
		i32 FieldSize := (TargetFieldSize * 8) - 1
		i8 ShiftLeftBy := FieldSize - TargetField->BitEndIndex
		i8 ShiftRightBy := ShiftLeftBy + TargetField->BitStartIndex
		
		if (ShiftLeftBy < 0) {
			ShiftRightBy := -ShiftLeftBy
		}
		else if (ShiftLeftBy) { 
			EmitSAL_RX_I8(Compiler, ResultRegister, ShiftLeftBy, TargetFieldSize)
		}
		
		if (ShiftRightBy) {
			EmitSAR_RX_I8(Compiler, ResultRegister, ShiftRightBy, TargetFieldSize)
		}
	}
	else {
		CompileStructAccessLeft(Compiler, ResultRegister, TargetAccess)
		
		if (FieldOffset = 0 && ResultRegister != R13) {
			EmitMove_RX_RIX(Compiler, ResultRegister, ResultRegister, TargetFieldSize)
		}
		;else if (FieldOffset >= 112) {
		;	EmitMove_RX_RIX_DISP32(Compiler, ResultRegister, ResultRegister, FieldOffset, TargetFieldSize)
		;}
		else {
			;EmitMove_RX_RIX_DISP8(Compiler, ResultRegister, ResultRegister, FieldOffset As i8, TargetFieldSize)
			EmitMove_RX_RIX_DISPX(Compiler, ResultRegister, ResultRegister, FieldOffset, !(FieldOffset >= 112), TargetFieldSize) 
		}
	}
	
	return 0
}

declare void CompileSetArrayAccess(CompilerState*, i8, ASTNode*, ASTNode*, i8)

define void CompileSetStructAccess(CompilerState* Compiler, i8 ValueRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	
	i8 ResultPointerRegister := PushRegisterStack(Compiler)
	
	i32 FieldOffset := TargetField->Offset
	i8 TargetFieldSize := GetTypeSize(TargetField->ValueType)
	
	if (TargetField->BitStartIndex || TargetField->BitEndIndex) {
		CompileExpression(Compiler, ResultPointerRegister, TargetAccess->Left)
		
		TargetFieldSize := TargetField->Offset
		
		i8 StartIndex := TargetField->BitStartIndex
		i8 EndIndex := TargetField->BitEndIndex
		
		i32 FieldSize := (TargetFieldSize * 8) - 1
		i8 ShiftLeftBy := FieldSize - (EndIndex - StartIndex)
		i8 ShiftRightBy := FieldSize - EndIndex
		
		i64 PartialMask := ((1 As i64) << ((EndIndex + 1) As i8)) - 1
		
		if (EndIndex = 63) {
			/* Since 1<<64 is undefined, the result of INT64_MAX needs to be hard coded */
			PartialMask := 0xFFFFFFFFFFFFFFFF
		}
		
		i64 Mask := ~(PartialMask >> StartIndex << StartIndex)
		
		EmitMove_RX_IX(Compiler, RDI, Mask, TargetFieldSize)
		EmitAnd_RX_RX(Compiler, ResultPointerRegister, RDI, TargetFieldSize)
		
		if (ShiftLeftBy) { 
			EmitSAL_RX_I8(Compiler, ValueRegister, ShiftLeftBy, TargetFieldSize)
		}
		
		EmitSAR_RX_I8(Compiler, ValueRegister, ShiftRightBy, TargetFieldSize)
		EmitOr_RX_RX(Compiler, ResultPointerRegister, ValueRegister, TargetFieldSize)
		
		ASTNode* Left := TargetAccess->Left
		i8 LeftNodeType := Left->NodeType
		
		if (LeftNodeType = NODE_TYPE_VARIABLE) {
			CompileSetVariableValue(Compiler, Left->VariableValue, ResultPointerRegister)
		}
		else if (LeftNodeType = NODE_TYPE_STRUCT_ACCESS) {
			CompileSetStructAccess(Compiler, ResultPointerRegister, Left->AccessNode)
		}
		else if (LeftNodeType = NODE_TYPE_BINARY) {
			CompileSetArrayAccess(Compiler, ValueRegister, Left->BinaryNode->Left, Left->BinaryNode->Right, ResultPointerRegister)
		}
	}
	else {
		CompileStructAccessLeft(Compiler, ResultPointerRegister, TargetAccess)
		
		i8 TargetSize := GetTypeSize(TargetField->ValueType) As i8
		
		if (FieldOffset = 0 && ResultPointerRegister != R13) {
			EmitMove_RIX_RX(Compiler, ResultPointerRegister, ValueRegister, TargetSize)
		}
		else if (FieldOffset >= 112) {
			EmitMove_RIX_DISP32_RX(Compiler, ResultPointerRegister, ValueRegister, FieldOffset, TargetSize)
		}
		else {
			EmitMove_RIX_DISP8_RX(Compiler, ResultPointerRegister, ValueRegister, FieldOffset As i8, TargetSize)
		}
	}
	
	PopRegisterStack(Compiler)
}

define void CompileArrayAccess(CompilerState* Compiler, i8 ResultRegister, ASTNode* Pointer, ASTNode* Index, i8 ValueRegister, i8 GetAddress) {
	i8 PointerRegister := ResultRegister
	CompileExpression(Compiler, PointerRegister, Pointer)
	
	Type PointerType := Pointer->ValueType
	
	i8 IndexScale := 8
	
	TypeInfo* PointerBase := GetBaseType(PointerType)
	i16 PointerDepth := GetPointerDepth(PointerType)
	
	if (PointerDepth = 1) {
		IndexScale := (PointerBase->Size) As i8
	}
	
	i8 IsSet := !(ValueRegister < 0)
	
	if (Index->NodeType = NODE_TYPE_INTEGER) {
		i32 IndexAsDisplacement := Index->IntegerValue * IndexScale
		i8 DisplacementSize := 4
		
		if (IndexAsDisplacement <= 112) {
			DisplacementSize := 1
		}
		
		if (IsSet || GetAddress) {
			EmitLea_R64_R64_DISPX(Compiler, ResultRegister, PointerRegister, IndexAsDisplacement)
			
			if (IsSet) {
				EmitMove_RIX_RX(Compiler, ResultRegister, ValueRegister, IndexScale)
			}
		}
		else {
			EmitMove_RX_RIX_DISPX(Compiler, ResultRegister, PointerRegister, IndexAsDisplacement, DisplacementSize, IndexScale)
		}
	}
	else {
		i8 IndexRegister := PushRegisterStack(Compiler)
		CompileExpression(Compiler, IndexRegister, Index)
		
		i8 IndexSize := GetTypeSize(Index->ValueType) As i8
		
		if (IndexSize < 4) {
			Cast(Compiler, IndexRegister, IndexSize)
		}
		
		if (IsSet || GetAddress) {
			EmitLea_R64_SIB(Compiler, ResultRegister, IndexScale, IndexRegister, PointerRegister)
			
			if (IsSet) {
				EmitMove_RIX_RX(Compiler, ResultRegister, ValueRegister, IndexScale)
			}
		}
		else {
			EmitMove_RX_SIB(Compiler, ResultRegister, IndexScale, IndexRegister, PointerRegister)
		}
		
		PopRegisterStack(Compiler)
	}
}

define void CompileGetArrayAccess(CompilerState* Compiler, i8 ResultRegister, ASTNode* Pointer, ASTNode* Index, i8 GetAddress) {
	CompileArrayAccess(Compiler, ResultRegister, Pointer, Index, -1 As i8, GetAddress)
}
define void CompileSetArrayAccess(CompilerState* Compiler, i8 ResultRegister, ASTNode* Pointer, ASTNode* Index, i8 ValueRegister) {
	CompileArrayAccess(Compiler, ResultRegister, Pointer, Index, ValueRegister, false)
}

define void CompileUnary(CompilerState* Compiler, i8 ResultRegister, Type ResultType, UnaryExpression* ExpressionToCompile, i8 DiscardResult) {
	/* Compiles a unary operator and operand */
	
	i8 Operator := (ExpressionToCompile->Operator->Value) As i8
	i8 ResultSize := GetTypeSize(ResultType) As i8
	
	if (Operator = OPERATOR_AND) {
		ASTNode* Operand := ExpressionToCompile->Operand
		i8 OperandType := Operand->NodeType
		
		if (OperandType = NODE_TYPE_VARIABLE) {
			VariableInfo* OperandVariable := Operand->VariableValue
			
			CompileGetVariableAddress(Compiler, ResultRegister, OperandVariable)
		}
		else if (OperandType = NODE_TYPE_STRUCT_ACCESS) {
			StructAccessExpression* OperandStructAccess := Operand->AccessNode
			
			CompileGetStructAccessPointer(Compiler, ResultRegister, OperandStructAccess)
		}
		else if (OperandType = NODE_TYPE_BINARY) {
			BinaryExpression* OperandExpression := Operand->BinaryNode
			
			if (OperandExpression->Operator->Value = OPERATOR_OPEN_BRACKET) {
				CompileGetArrayAccess(Compiler, ResultRegister, OperandExpression->Left, OperandExpression->Right, true)
			}
		}
		else if (OperandType = NODE_TYPE_DEFINE) {
			FunctionDefine* OperandFunction := Operand->DefineNode
			
			EmitLea_RAX_Label(Compiler, OperandFunction->LabelNumber)
			EmitMove_R64_R64(Compiler, ResultRegister, RAX)
		}
	}
	else {
		/* Only compile the operand when the operator isn't `&` (since it doesn't use the operand value) */
		CompileExpression(Compiler, ResultRegister, ExpressionToCompile->Operand)
		
		if (Operator = OPERATOR_STAR) {
			EmitMove_RX_RIX(Compiler, ResultRegister, ResultRegister, ResultSize)
		}
		else if (Operator = OPERATOR_MINUS) {
			EmitNeg_RX(Compiler, ResultRegister, ResultSize)
		}
		else if (Operator = OPERATOR_TILDE) {
			EmitNot_RX(Compiler, ResultRegister, ResultSize)
		}
		else if (Operator = OPERATOR_BANG) {
			EmitTest_RX_RX(Compiler, ResultRegister, ResultRegister, GetTypeSize(ExpressionToCompile->Operand->ValueType) As i8)
			
			if !(DiscardResult) {
				/* If the caller uses the FLAGS register, it doesn't need a 'true' result, and can just use what's in the FLAGS register */
				EmitSetE_R8(Compiler, ResultRegister)
			}
		}
	}
}

define void CompileBinaryOperator(CompilerState* Compiler, i8 Operator, i8 ResultSize, i8 LeftRegister, i8 RightRegister) {
	i8 ResultRegister := LeftRegister
	
	if (Operator = OPERATOR_PLUS) {
		EmitAdd_RX_RX(Compiler, LeftRegister, RightRegister, ResultSize)
	}
	else if (Operator = OPERATOR_MINUS) {
		EmitSub_RX_RX(Compiler, LeftRegister, RightRegister, ResultSize)
	}
	else if (Operator = OPERATOR_STAR) {
		if (ResultSize = 1) {
			/* Do 8 bit multiplication as 16 bit, and cast the result back down to 8 bits (since there is no imul r8, r8 instruction */
			EmitIMul_RX_RX(Compiler, LeftRegister, RightRegister, 2)
			Cast(Compiler, LeftRegister, 1)
		}
		else {	
			EmitIMul_RX_RX(Compiler, LeftRegister, RightRegister, ResultSize)
		}
	}
	else if (Operator = OPERATOR_SLASH || Operator = OPERATOR_PERCENT) {
		if (LeftRegister != RAX) {
			EmitMove_R64_R64(Compiler, RBX, RAX)
			EmitMove_R64_R64(Compiler, RAX, LeftRegister)
		}
		if (Compiler->NoClobberCD89) {
			EmitPush_R64(Compiler, RDX)
		}
		
		if (ResultSize = 1) {
			/* Handle 8 bit division through a 16 bit operation, which will have a result casted down 
				(8 bit IDIV uses AL/AH, which CodeGen isn't set up to encode)
			*/
			EmitCXX(Compiler, 2)
			EmitIDiv_RAX_RX(Compiler, RightRegister, 2)
		}
		else {
			EmitCXX(Compiler, ResultSize)
			EmitIDiv_RAX_RX(Compiler, RightRegister, ResultSize)
		}
		
		if (Operator = OPERATOR_SLASH && ResultRegister != RAX) {
			EmitMove_RX_RX(Compiler, ResultRegister, RAX, ResultSize)
		}
		else if (Operator = OPERATOR_PERCENT && ResultRegister != RDX) {
			EmitMove_RX_RX(Compiler, ResultRegister, RDX, ResultSize)
		}
		
		if (Compiler->NoClobberCD89) {
			EmitPop_R64(Compiler, RDX)
		}
		if (LeftRegister != RAX) {
			EmitMove_R64_R64(Compiler, RAX, RBX)
		}
		
		if (ResultSize = 1) {
			Cast(Compiler, ResultRegister, 1)
		}
	}
	else if (Operator = OPERATOR_EQUAL) {
		EmitSetE_R8(Compiler, ResultRegister)
	}
	else if (Operator = OPERATOR_BANG_EQUAL) {
		EmitSetNE_R8(Compiler, ResultRegister)
	}
	else if (Operator = OPERATOR_LESS) {
		EmitSetL_R8(Compiler, ResultRegister)
	}
	else if (Operator = OPERATOR_LESS_EQAUL) {
		EmitSetLE_R8(Compiler, ResultRegister)
	}
	else if (Operator = OPERATOR_GREATER) {
		EmitSetG_R8(Compiler, ResultRegister)
	}
	else if (Operator = OPERATOR_GREATER_EQAUL) {
		EmitSetGE_R8(Compiler, ResultRegister)
	}
	else if (Operator = OPERATOR_XOR) {
		EmitXor_RX_RX(Compiler, LeftRegister, RightRegister, ResultSize)
	}
	else if (Operator = OPERATOR_AND) {
		EmitAnd_RX_RX(Compiler, LeftRegister, RightRegister, ResultSize)
	}
	else if (Operator = OPERATOR_OR) {
		EmitOr_RX_RX(Compiler, LeftRegister, RightRegister, ResultSize)
	}
}

define i8 IsPowerOfTwo(i64 Number) {
	return Number && !(Number & (Number - 1))
}
define i8 FindFirstBitSet(i64 Number) asm {
	bsr, rax, rdi
	ret
}

; TODO: Change this back to a 'void' function once raw 'return' statements are allowed inside of
;  functions which return 'void'
define i32 CompileBinary(CompilerState* Compiler, i8 ResultRegister, Type ResultType, BinaryExpression* ExpressionToCompile, i8 DiscardResult) {
	/* Compiles a binary expression, and both operands of the expression */
	
	ASTNode* Left := ExpressionToCompile->Left
	ASTNode* Right := ExpressionToCompile->Right
	
	i8 LeftSize := GetTypeSize(Left->ValueType) As i8
	i8 RightSize := GetTypeSize(Right->ValueType) As i8
	i8 ResultSize := GetTypeSize(ResultType) As i8
	
	i8 LeftRegister := ResultRegister
	i8 RightRegister := 0
	
	i8 Operator := (ExpressionToCompile->Operator->Value) As i8
	
	if (OPERATOR_FIRST_ASSIGNMENT <= Operator && Operator <= OPERATOR_LAST_ASSIGNMENT) {
		/* This is an assignment, so we can reuse the result register for the side side, and ignore the left */
		
		i8 LeftType := (Left->NodeType) As i8
		
		VariableInfo* TargetVariable := Left->VariableValue
		StructAccessExpression* LeftAccess := Left->AccessNode
		BinaryExpression* LeftExpression := Left->BinaryNode
		UnaryExpression* LeftUnary := Left->UnaryNode
		
		i8 WorkRegister := PushRegisterStack(Compiler)
		
		if (Operator = OPERATOR_COLON_EQUAL) {
			CompileExpression(Compiler, ResultRegister, Right)
			
			if (RightSize < LeftSize) {
				Cast(Compiler, ResultRegister, RightSize)
			}
			
			if (LeftType = NODE_TYPE_VARIABLE) {
				CompileSetVariableValue(Compiler, TargetVariable, ResultRegister)
			}
			else if (LeftType = NODE_TYPE_STRUCT_ACCESS) {
				CompileSetStructAccess(Compiler, ResultRegister, LeftAccess)
			}
			else if (LeftType = NODE_TYPE_BINARY) {
				CompileSetArrayAccess(Compiler, RBX, LeftExpression->Left, LeftExpression->Right, ResultRegister)
			}
			else if (LeftType = NODE_TYPE_UNARY) {
				CompileExpression(Compiler, WorkRegister, LeftUnary->Operand)
				
				EmitMove_RIX_RX(Compiler, WorkRegister, ResultRegister, ResultSize)
			}
		}
		else {				
			CompileExpression(Compiler, WorkRegister, Right)
			
			if (RightSize < LeftSize) {
				Cast(Compiler, WorkRegister, RightSize)
			}
			
			/* Get old value of left side */
			
			if (LeftType = NODE_TYPE_VARIABLE) {
				i32 Start := Compiler->Index
				i32 Offset := GetVariableOffset(Compiler, TargetVariable, null)
				
				i8 BaseRegister := RBP
				
				if (TargetVariable->IsGlobal) {
					BaseRegister := R15
				}
				
				if (Operator = OPERATOR_PLUS_EQUAL) {
					EmitAdd_RIX_DISPX_RX(Compiler, BaseRegister, WorkRegister, Offset, ResultSize)
				}
				else if (Operator = OPERATOR_MINUS_EQUAL) {
					EmitSub_RIX_DISPX_RX(Compiler, BaseRegister, WorkRegister, Offset, ResultSize)
				}
				
				if (Compiler->Index != Start) {
					PopRegisterStack(Compiler)
					return 0
				}
				
				CompileGetVariableValue(Compiler, ResultRegister, TargetVariable)
			}
			else if (LeftType = NODE_TYPE_STRUCT_ACCESS) {
				CompileGetStructAccess(Compiler, ResultRegister, LeftAccess)
			}
			else if (LeftType = NODE_TYPE_BINARY) {
				CompileGetArrayAccess(Compiler, ResultRegister, LeftExpression->Left, LeftExpression->Right, false)
			}
			else if (LeftType = NODE_TYPE_UNARY) {
				; For `*(A) X= (Y)` we save `(A)` in a temp register instead of compiling it twice, since
				;  that would raise code size, and maybe run code with side effects twice
				
				; Since `X=` operators are always alone on a line, the register stack should be
				;  totally empty, so there's no harm in using an extra temp anyways
				
				i8 DereferenceRegister := PushRegisterStack(Compiler)
				
				CompileExpression(Compiler, DereferenceRegister, LeftUnary->Operand)
				
				EmitMove_RX_RIX(Compiler, ResultRegister, DereferenceRegister, ResultSize)
			}
			
			/* Translate X= operators into just X operators, so CompileBinaryOperator does the correct operation */
			if (Operator <= OPERATOR_PERCENT_EQUAL) {	
				Operator += OPERATOR_PLUS - OPERATOR_PLUS_EQUAL
			}
			else {
				Operator += OPERATOR_AND - OPERATOR_AND_EQUAL
			}
			
			/* Do the actual operation */
			CompileBinaryOperator(Compiler, Operator, ResultSize, ResultRegister, WorkRegister)
			
			/* Store the new value for each valid left side */
			
			if (LeftType = NODE_TYPE_VARIABLE) {
				CompileSetVariableValue(Compiler, TargetVariable, ResultRegister)
			}
			else if (LeftType = NODE_TYPE_STRUCT_ACCESS) {
				CompileSetStructAccess(Compiler, ResultRegister, LeftAccess)
			}
			else if (LeftType = NODE_TYPE_BINARY) {
				CompileSetArrayAccess(Compiler, WorkRegister, LeftExpression->Left, LeftExpression->Right, ResultRegister)
			}
			else if (LeftType = NODE_TYPE_UNARY) {
				EmitMove_RIX_RX(Compiler, DereferenceRegister, ResultRegister, ResultSize)
				
				PopRegisterStack(Compiler)
			}
		}
		
		PopRegisterStack(Compiler)
	}
	else if (Operator = OPERATOR_OPEN_BRACKET) {
		CompileGetArrayAccess(Compiler, ResultRegister, Left, Right, false)
	}
	else {
		/* As long as we're not compiling an assignment, compile the left operand into the result register */
		
		CompileExpression(Compiler, LeftRegister, Left)
		
		i8 OldClobberA := Compiler->NoClobberA
		
		if (LeftRegister = RAX) {
			Compiler->NoClobberA := true
		}
		
		if (Operator = OPERATOR_AS) {
			/* For 'As', just compile the left operand, cast it, and return */
			Type RightType := Right->TypeValue
			
			if (Left->NodeType != NODE_TYPE_INTEGER) {
				/* Only emit cast instructions for values which aren't integers, since integer casts are done at compile time */
				
				Cast(Compiler, LeftRegister, GetTypeSize(RightType) As i8)
			}
		}
		else if (OPERATOR_FIRST_SHORT_CIRCUIT <= Operator && Operator <= OPERATOR_LAST_SHORT_CIRCUIT) {
			if (NodeHasSideEffects(Right)) {
				i32 End := NextLabel(Compiler)
				
				EmitTest_RX_RX(Compiler, LeftRegister, LeftRegister, LeftSize)
				
				if !(DiscardResult) {
					EmitSetNE_R8(Compiler, ResultRegister)
				}
				
				if (Operator = OPERATOR_LOGICAL_AND) {
					EmitJEZ_Label(Compiler, End)
				}
				else if (Operator = OPERATOR_LOGICAL_OR) {
					EmitJNZ_Label(Compiler, End)
				}
				
				CompileExpression(Compiler, LeftRegister, Right)
				
				EmitTest_RX_RX(Compiler, LeftRegister, LeftRegister, RightSize)
				
				if !(DiscardResult) {
					EmitSetNE_R8(Compiler, ResultRegister)
				}
				
				SetLabel(Compiler, End)
			}
			else {
				RightRegister := PushRegisterStack(Compiler)
				CompileExpression(Compiler, RightRegister, Right)
				
				i8 MaxOperandSize := LeftSize
				
				if (RightSize > LeftSize) {
					MaxOperandSize := RightSize
					Cast(Compiler, LeftRegister, LeftSize)
				}
				else if (RightSize < LeftSize) {
					Cast(Compiler, RightRegister, RightSize)
				}
				
				if (Operator = OPERATOR_LOGICAL_AND) {
					EmitIMul_RX_RX(Compiler, LeftRegister, RightRegister, MaxOperandSize)
				}
				else if (Operator = OPERATOR_LOGICAL_OR) {
					EmitAdd_RX_RX(Compiler, LeftRegister, RightRegister, MaxOperandSize)
				}
				
				EmitOr_RX_RX(Compiler, LeftRegister, LeftRegister, MaxOperandSize)
				
				if !(DiscardResult) {
					EmitSetNE_R8(Compiler, ResultRegister)
				}
				
				PopRegisterStack(Compiler)
				
				return 0
			}
		}
		else if (Operator = OPERATOR_LESS_LESS || Operator = OPERATOR_GREATER_GREATER) {
			if (Right->NodeType = NODE_TYPE_INTEGER) {
				if (Operator = OPERATOR_LESS_LESS) {
					EmitSAL_RX_I8(Compiler, LeftRegister, Right->IntegerValue As i8, ResultSize)
				}
				else {
					EmitSAR_RX_I8(Compiler, LeftRegister, Right->IntegerValue As i8, ResultSize)
				}
			}
			else {
				i8 LeftWasRCX := LeftRegister = RCX
				
				if (LeftWasRCX) {
					LeftRegister := PushRegisterStack(Compiler)
					EmitMove_RX_RX(Compiler, LeftRegister, RCX, ResultSize)
				}
				else if (Compiler->NoClobberCD89) {
					EmitPush_R64(Compiler, RCX)
				}
				
				CompileExpression(Compiler, RCX, Right)
				
				if (Operator = OPERATOR_LESS_LESS) {
					EmitSHL_RX_CL(Compiler, LeftRegister, ResultSize)
				}
				else if (Operator = OPERATOR_GREATER_GREATER) {
					EmitSHR_RX_CL(Compiler, LeftRegister, ResultSize)
				}
				
				if (LeftWasRCX) {
					EmitMove_RX_RX(Compiler, RCX, LeftRegister, ResultSize)
					PopRegisterStack(Compiler)
				}
				else if (Compiler->NoClobberCD89) {
					EmitPop_R64(Compiler, RCX)
				}
			}
		}
		else {
			i8 IsComparison := IsComparison(ExpressionToCompile->Operator)
			
			if (IsComparison) {
				Type TrueResultType := GetBinaryResultType(Compiler->Parser, Left->ValueType, Right->ValueType, null)
				
				ResultSize := GetTypeSize(TrueResultType)
			}
			
			/* If either operand is smaller than the result type, cast it up to the R64 (aka any possible size) */
			if (LeftSize < ResultSize) {
				Cast(Compiler, LeftRegister, LeftSize)
			}
			
			i8 IsDivision := (Operator = OPERATOR_SLASH || Operator = OPERATOR_PERCENT)
			
			if (IsDivision && Right->NodeType = NODE_TYPE_INTEGER && IsPowerOfTwo(Right->IntegerValue)) {
				if (Operator = OPERATOR_SLASH) {
					EmitSAR_RX_I8(Compiler, LeftRegister, FindFirstBitSet(Right->IntegerValue), LeftSize)
				}
				else {
					i64 Mask := Right->IntegerValue - 1
					
					if (LeftSize <= 4) {
						EmitAnd_RX_IX(Compiler, LeftRegister, Mask As i32, LeftSize)
					}
					else {
						EmitMove_R64_I64(Compiler, RBX, Mask)
						EmitAnd_RX_RX(Compiler, LeftRegister, RBX, 8)
					}
				}
				
				return 0
			}
			
			i8 IsPlusMinus := (Operator = OPERATOR_PLUS || Operator = OPERATOR_MINUS)
			
			if (IsPlusMinus && Right->NodeType = NODE_TYPE_INTEGER) {
				/* Since some instructions for simple operations have encodings for sign-extended immediates 
					We can check for an operator+operand combo which can be optimized into a single instruction
				*/
				
				i64 RightInteger := Right->IntegerValue
				
				i8 OperandSize := GetNumberSize(RightInteger)
				
				if (OperandSize <= 4) {
					/* There are no imm64 encodings, only imm8 and imm32 */
					
					if (Operator = OPERATOR_PLUS) {
						EmitAdd_R64_IX(Compiler, ResultRegister, RightInteger As i32)
					}
					else if (Operator = OPERATOR_MINUS) {
						EmitSub_R64_IX(Compiler, ResultRegister, RightInteger As i32)
					}
					
					/* When we optimized this expression, we need to return early to skip it being
						compiled like normal
					*/
					
					Compiler->NoClobberA := OldClobberA
					return 0
				}
			}
			
			/* Allocate a new register for the right operand */
			
			RightRegister := PushRegisterStack(Compiler)
			CompileExpression(Compiler, RightRegister, Right)
			
			if (RightSize < ResultSize) {
				Cast(Compiler, RightRegister, RightSize)
			}
			
			if (IsComparison) {
				EmitCmp_RX_RX(Compiler, LeftRegister, RightRegister, ResultSize)
			}
			
			/* Also uses uses the correct instruction for two ResultType sized operands (casting should be done this is called) */
			
			if (DiscardResult) {
				/* Since comparison expressions can technically store a result in the FLAGS register, sometimes
					 a comparison can have the "real" result discarded, and the caller can just use FLAGS.
					So, this is a dummy branch to prevent code from being generated to grab the result of an
					 expression out of FLAGS.
				*/
			}
			else {
				CompileBinaryOperator(Compiler, Operator, ResultSize, LeftRegister, RightRegister)
			}
			
			PopRegisterStack(Compiler) /* Pop the right register */
		}
		
		Compiler->NoClobberA := OldClobberA
	}
	
	return 0
}

define void CompileUnwindTry(CompilerState* Compiler, i8 ForReturn) {
	; Ensures that the current function's stack frame is restored
	; 	For `return`, this means all `Try` stack frame modifications 
	; 	For `continue`/`break`, this means only `Try` stack frame modifications inside of the current loop
	
	i32 Total := Compiler->ScopedTryDepth
	
	if (ForReturn) {
		Total := Compiler->TotalTryDepth
	}
	
	for (i32 Index := 0, Index < Total, Index += 1) {
		EmitPop_R64_DISP8(Compiler, RBP, 0)	; Restore saved stack frame
		EmitPop_R64_DISP8(Compiler, RBP, 8)
	}
}

define void CompileTry(CompilerState* Compiler, TryCatch* TryToCompile) {
	i32 AfterCatchLabel := NextLabel(Compiler)
	i32 TryEndLabel := NextLabel(Compiler)
	
	; try {
	EmitPush_R64_DISP8(Compiler, RBP, 8) ; Save the old stack frame
	EmitPush_R64_DISP8(Compiler, RBP, 0)
	
	EmitMove_R64_R64(Compiler, RBX, RSP)		; Save (RSP | Magic) into stack frame
	EmitAdd_R64_I8(Compiler, RBX, 1)
	EmitMove_RIX_DISP8_RX(Compiler, RBP, RBX, 0, 8)
	
	EmitLea_R64_Label(Compiler, RBX, TryEndLabel)		; Save (CatchLocation) into stack frame
	EmitMove_RIX_DISP8_RX(Compiler, RBP, RBX, 8, 8)
	
	Compiler->TotalTryDepth += 1
	Compiler->ScopedTryDepth += 1
	CompileBlock(Compiler, TryToCompile->Body)
	Compiler->ScopedTryDepth -= 1
	Compiler->TotalTryDepth -= 1
	
	EmitPop_R64_DISP8(Compiler, RBP, 0)	; Restore saved stack frame
	EmitPop_R64_DISP8(Compiler, RBP, 8)
	; }
	
	if (TryToCompile->CatchBody) {
		EmitJump_Label(Compiler, AfterCatchLabel)
	}
	
	; catch {
	SetLabel(Compiler, TryEndLabel)
	
	if (TryToCompile->CatchBody) {
		EmitPop_R64_DISP8(Compiler, RBP, 0)	; Restore saved stack frame
		EmitPop_R64_DISP8(Compiler, RBP, 8)
		
		if (TryToCompile->CatchCodeVariable) {
			CompileSetVariableValue(Compiler, TryToCompile->CatchCodeVariable, RDI)
		}
		
		CompileBlock(Compiler, TryToCompile->CatchBody)
		
		SetLabel(Compiler, AfterCatchLabel)
	}
	; }
}

#Include ./src/compiler/AssemblyCompile.rlx
