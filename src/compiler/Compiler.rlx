/*
==========================================
	aaaaaaaaaaaaa
==========================================
*/


struct Label {
	i32 LabelNumber,
	i32 OffsetToReplace,
	i8 IsPlaceholder
}

struct CompilerState {
	ParserState* pState,
	
	PEBuilder* Builder,
	ELFBuilder* ELF,
	
	i64 GlobalBase,
	
	i8* CodeBuffer,
	i32 CodeBufferSize,
	i32 Index,
	
	i32* CodeRelocations,
	i32 CodeRelocationCount,
	
	LabelPlaceholder** Labels,
	i32 LabelCount,
	i32 LabelBufferCapacity,
	
	i32 LabelIndex,
	
	i32 CurrentFunctionReturnLabel,
	i32 CurrentLoopContinueLabel,
	i32 CurrentLoopBreakLabel,
	
	Type CurrentFunctionReturnType,
	
	i32 CurrentFunctionStringBufferOffset,
	
	i8 RegisterStackIndex,
	
	i8 NoClobberCD89,
	i8 NoClobberA,
	
	i8 OutputELF
}

/*
==========================================
	aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
==========================================
*/

#Include ./src/compiler/CodeGen.rlx

declare void CompileImportStub(CompilerState*, FunctionDefine*)
declare void CompileFunction(CompilerState*, FunctionDefine*, i8)

define void CompilerStart(ParserState* pState, i16* OutputFilePath, i8 OutputELF, i8 DumpFunctionBytes) {
	CompilerState C
	
	C.pState := pState
	C.OutputELF := OutputELF
	
	C.CodeBufferSize := 0x10000
	C.CodeBuffer := Alloc(0x10000) As i8*
	C.Index := 0
	
	C.CodeRelocations := Alloc(8) As i64*
	C.CodeRelocationCount := 0
	
	C.Labels := Alloc(80) As Label**
	C.LabelCount := 0
	C.LabelBufferCapacity := 10
	
	C.LabelIndex := (pState->FunctionCount) + 1
	C.RegisterStackIndex := 0
	
	i64 CODE_BASE := 0x3000
	
	if (OutputELF) {
		C.ELF := BuildELFBuilder()
		C.GlobalBase := DEFAULT_IMAGE_BASE + 64 + 0x1000
		CODE_BASE := pState->GlobalOffset + 564 + 0x2000
	}
	else {
		C.Builder := BuildBuilder()
		C.Builder->ImportFixupBase := C.CodeBuffer
		C.GlobalBase := DEFAULT_IMAGE_BASE + C.Builder->NextRVA
	}
	
	i32 MainOffset := 0
	i8 FoundMain := false
	
	void* Elements := pState->Functions->Elements
	
	for (i32 ElementIndex := 0, ElementIndex < (pState->Functions->BufferMaxCount), ElementIndex += 1) {
		if (Elements[ElementIndex]) {
			HashMapElement* FoundElement := Elements[ElementIndex] As HashMapElement*
			
			while (FoundElement) {
				FunctionDefine* NextFunction := (FoundElement->Value) As FunctionDefine*
				i32 FunctionOffset := C.Index
				
				if (DumpFunctionBytes) {
					IWriteHex(CODE_BASE + FunctionOffset)
					AWrite(" - ")
				}
				
				if (NextFunction->IsImported) {
					if !(OutputELF) {
						CompileImportStub(&C, NextFunction)
					}
				}
				else if !(NextFunction->HasFullDefinition) {
					ASTNode* FakeNode := AllocateNewASTNode(NODE_TYPE_IDENTIFIER, NextFunction->Name, TYPE_NONE)
					FakeNode->SourceFilePath := NextFunction->SourceFilePath
					FakeNode->LineNumber := NextFunction->LineNumber
					
					ASTError(FakeNode, "Function is declared, but never defined.")
				}
				else {
					i8 IsMain := SafeStringEqualsAString(NextFunction->Name, "Main")
					
					if (IsMain) {
						FoundMain := true
						MainOffset := C.Index
						NextFunction->CallCount += 1
					}
					
					if (NextFunction->CallCount != 0) {
						CompileFunction(&C, NextFunction, IsMain)
					}
				}
				
				if (DumpFunctionBytes) {
					IWrite(C.Index - FunctionOffset)
					
					AWrite("	(")
					IWrite(NextFunction->CallCount)
					AWrite(")	")
					
					PrintSafeString(NextFunction->Name)
					WriteNewLine()
				}
				
				/* Update the current element to be the next element in the linked list */
				FoundElement := FoundElement->NextElement
			}
		}
	}
	
	if !(FoundMain) {
		TokenizerError(pState->tState, "Main function not found")
	}
	
	ResolveAllLabels(&C)
	
	if (DumpFunctionBytes) {
		TextColor(Blue)
		
		AWrite("	Globals use ")
		IWrite(C.pState->GlobalOffset)
		AWriteLine(" bytes")
		
		WriteCharacter('	')
		IWrite(C.Index)
		AWriteLine(" total bytes of code generated.")
		WriteCharacter('	')
	}
	
	/* Actual compiling is done, time to build the output file */
	
	i64 OutputFileHandle := FileOpen(OutputFilePath, FILE_READ | FILE_WRITE | FILE_CREATE_NEW)
	
	if (OutputFileHandle < 0) {
		AWrite("Could not open output file, error code: ")
		IWriteLine(FileGetError(OutputFileHandle))
		AWriteLine("Aborting")
		Exit(1)
	}
	
	i32 Result := 0
	i32 BytesWritten := 0
	
	if (OutputELF) {
		AddDataSection(C.ELF, C.pState->GlobalOffset)
		AddCodeSection(C.ELF, C.CodeBuffer, C.Index)
		
		FinalizeELFBuilder(C.ELF, MainOffset)
		
		/* WriteELFBuilder(C.ELF, OutputFilePath) */
		Result := FileWrite(OutputFileHandle, C.ELF->Buffer, C.ELF->BufferSize)
		BytesWritten := C.ELF->BufferSize
	}
	else {
		AddData(C.Builder, C.pState->GlobalOffset)
		
		i64 TextRVA := AddCode(C.Builder, C.CodeBuffer, C.Index, MainOffset)
		
		for (i32 RelocationIndex := 0, RelocationIndex < (C.CodeRelocationCount), RelocationIndex += 1) {
			i32 NextRelocationOffset := (C.CodeRelocations)[RelocationIndex]
			
			i32 PageRVA := TextRVA + (NextRelocationOffset / 0x1000)
			i16 OffsetInPage := (NextRelocationOffset % 0x1000) As i16
			
			/* Todo: Decide if a 32 bit relocation is correct or not. As long as imagebase is 32 bits, this is fine for now */
			
			AddRelocation(C.Builder, PageRVA, OffsetInPage, false)
		}
		
		FinalizeBuilder(C.Builder)
		
		/* WriteBuilder(C.Builder, OutputFilePath) */
		Result := FileWrite(OutputFileHandle, C.Builder->Buffer, C.Builder->BufferSize)
		BytesWritten := C.Builder->BufferSize
	}
	
	if (Result < 0) {
		AWrite("Error writing output file: ")
		IWriteLine(FileGetError(Result))
		AWriteLine("Aborting")
		Exit(1)
	}
	
	AWrite("Done writing output file, ")
	IWrite(BytesWritten)
	AWriteLine(" bytes written.")
	
	FileClose(OutputFileHandle)
}

define i8 StackIndexToRegister(i8 Index) {
	if (Index = 4) {
		return R13
	}
	else if (Index > 4) {
		return Index + 9 As i8
	}
	else {
		return Index + 8 As i8
	}
}



define i8 PushRegisterStack(CompilerState* cState) {
	i8 Index := cState->RegisterStackIndex
	
	i8 TrueIndex := Index % 7
	i8 Result := StackIndexToRegister(TrueIndex)
	
	if (Index >= 8) {
		EmitPush_R64(cState, Result)
	}

	cState->RegisterStackIndex += 1
	
	return Result
}
define i8 TopOfRegisterStack(CompilerState* cState) {
	return StackIndexToRegister(cState->RegisterStackIndex)
}
define i8 PopRegisterStack(CompilerState* cState) {
	cState->RegisterStackIndex -= 1
	
	i8 Index := cState->RegisterStackIndex
	
	i8 TrueIndex := Index % 7
	i8 Result := StackIndexToRegister(TrueIndex)
	
	if (Index >= 8) {
		EmitPop_R64(cState, Result)
	}
	
	return Result
}

define void EnsureCodeBufferSize(CompilerState* cState) {
	if ((cState->Index + 0x100) >= (cState->CodeBufferSize)) {
		cState->CodeBufferSize += 0x5000
		cState->CodeBuffer := ReAlloc(cState->CodeBuffer, cState->CodeBufferSize)
		cState->Builder->ImportFixupBase := cState->CodeBuffer
	}
}

define void AddCodeRelocation(CompilerState* cState, i32 Offset) {
	i32 Index := cState->CodeRelocationCount
	
	cState->CodeRelocations := ReAlloc(cState->CodeRelocations, (Index + 1) * 8)
	(cState->CodeRelocations)[Index] := Offset
	
	cState->CodeRelocationCount += 1
}


/*
==========================================
	Variable helpers
==========================================
*/

define void CompileGetVariableAddress(CompilerState* cState, i8 ResultRegister, VariableInfo* TargetVariable) {
	if (TargetVariable->IsGlobal) {
		EmitMove_R32_I32(cState, RBX, cState->GlobalBase + (TargetVariable->StackOffset))
		AddCodeRelocation(cState, (cState->Index) - 4)
	}
	else {
		if (TargetVariable->StackOffset < 112) {
			EmitLea_R64_R64_DISP8(cState, ResultRegister, RBP, -(TargetVariable->StackOffset + 8))
		}
		else {
			EmitLea_R64_R64_DISP32(cState, ResultRegister, RBP, -(TargetVariable->StackOffset + 8))
		}
	}
}
define void CompileGetVariableValue(CompilerState* cState, i8 ResultRegister, VariableInfo* TargetVariable) {
	i16 TargetSize := GetTypeSize(TargetVariable->Type)
	
	if (TargetVariable->IsGlobal) {
		EmitMove_R32_I32(cState, RBX, cState->GlobalBase + (TargetVariable->StackOffset))
		AddCodeRelocation(cState, (cState->Index) - 4)
		
		EmitMove_RX_RIX(cState, ResultRegister, RBX, TargetSize)
	}
	else {
		if (GetPointerDepth(TargetVariable->Type) = 0 && GetBaseType(TargetVariable->Type)->IsStructType) {
			/* If GetVariableValue is called on a struct, then we should actually result in a pointer to that struct
				So Compile(Get|Set)StructField can depending on getting a pointer, and never the struct as a number
				Any time this could be abused *should* be caught by type checking 
			*/
			
			CompileGetVariableAddress(cState, ResultRegister, TargetVariable)
		}
		else {
			if (TargetVariable->StackOffset < 112) {
				EmitMove_RX_RIX_DISP8(cState, ResultRegister, RBP, -(TargetVariable->StackOffset + 8), TargetSize)
			}
			else {
				EmitMove_RX_RIX_DISP32(cState, ResultRegister, RBP, -(TargetVariable->StackOffset + 8), TargetSize)
			}
		}
	}
}
define void CompileSetVariableValue(CompilerState* cState, VariableInfo* TargetVariable, i8 SourceRegister) {
	i16 TargetSize := GetTypeSize(TargetVariable->Type)
	
	if (TargetVariable->IsGlobal) {
		EmitMove_R32_I32(cState, RBX, cState->GlobalBase + (TargetVariable->StackOffset))
		AddCodeRelocation(cState, (cState->Index) - 4)
		
		EmitMove_RIX_RX(cState, RBX, SourceRegister, TargetSize)
	}
	else {
		if (TargetVariable->StackOffset < 112) {
			EmitMove_RIX_DISP8_RX(cState, RBP, SourceRegister, -(TargetVariable->StackOffset + 8), TargetSize)
		}
		else {
			EmitMove_RIX_DISP32_RX(cState, RBP, SourceRegister, -(TargetVariable->StackOffset + 8), TargetSize)
		}
	}
}


/*
==========================================
	Actual compile functions
==========================================
*/

define void Cast(CompilerState* cState, i8 Register, i8 Size) {
	EmitMove_R64_RX(cState, Register, Register, Size)
}

define void CompileImportStub(CompilerState* cState, FunctionDefine* FunctionToCompile) {
	/* Compiles an imported function by emitting a jump to the actual function */
	
	SetLabel(cState, FunctionToCompile->LabelNumber)
	
	EmitMove_R64_I64(cState, RBX, 0)
	
	AddImport(cState->Builder, FunctionToCompile->ImportFileName, FunctionToCompile->ImportFunctionName, (cState->Index) - 8)
	AddCodeRelocation(cState, cState->Index - 8)
	
	EmitJump_RI64(cState, RBX)
}

declare void CompileExpression(CompilerState*, i8, ASTNode*)
declare void CompileBlock(CompilerState*, Block*)

define void CompileFunction(CompilerState* cState, FunctionDefine* FunctionToCompile, i8 IsMain) {
	/* Compiles a single function */
	
	if (FunctionToCompile->Body->StatementCount = 0) {
		EmitReturn(cState)
		return 0
	}
	
	cState->RegisterStackIndex := 0
	
	/* Store the current return type so return can cast values to it */
	
	cState->CurrentFunctionReturnType := FunctionToCompile->ReturnType
	
	i32 ReturnLabel := NextLabel(cState)
	cState->CurrentFunctionReturnLabel := ReturnLabel
	
	SetLabel(cState, FunctionToCompile->LabelNumber)
	
	i8 USE_SYSTEMV := cState->OutputELF
	
	/* Assume 4 register parameters, and 0 stack parameters */
	i8 MAX_REGISTER_PARAMETERS := 4
	
	if (USE_SYSTEMV) {
		MAX_REGISTER_PARAMETERS := 6
	}
	
	i8 ParameterCount := FunctionToCompile->ParameterCount
	i8 RegisterParameterCount := MAX_REGISTER_PARAMETERS
	i8 StackParameterCount := 0
	
	if (ParameterCount < MAX_REGISTER_PARAMETERS) {
		/* If there are less than 4/6 parameters, then the number of register parameters is just the number of parameters */
		
		RegisterParameterCount := ParameterCount
	}
	else if (ParameterCount > MAX_REGISTER_PARAMETERS) {
		/* Else if there are 5/7+ parameters, the stack parameter count is (TotalParamCount - MAX_REGISTER_PARAMETERS) */
		
		StackParameterCount := ParameterCount - MAX_REGISTER_PARAMETERS
		
		/* Also, store RSP in RBX for extracting the stack parameters with smaller offsets */
		EmitMove_R64_R64(cState, RBX, RSP)
	}
	
	/* Set up the stack frame for this function */
	i16 LocalSpace := FunctionToCompile->LocalOffset
	
	if (FunctionToCompile->StringBufferSize) {
		i32 RoundedStringSize := (FunctionToCompile->StringBufferSize) As i16
		i32 StringRemainder := RoundedStringSize % 8
		
		if (StringRemainder) {
			RoundedStringSize += 8 - StringRemainder
		}
		
		LocalSpace += RoundedStringSize As i16
	}
	
	i16 LocalSpaceRemainder := LocalSpace % 16
	
	if (LocalSpaceRemainder) {
		LocalSpace += 8
	}
	
	EmitPush_R64(cState, RBP)
	EmitMove_R64_R64(cState, RBP, RSP)
	
	if (IsMain && USE_SYSTEMV && ParameterCount <= 2) {
		/* When compiling main for SystemV, load the first two parameter registers (if they exist) 
			With ArgC and ArgV loaded from the stack since:
				RBP + 0 = ArgC
				RBP + 1..ArgC = ArgV
			so mov rdi, [rsp+8] will get argc, and
			lea rsi, [rsp+16] will get argv
			which are then moved into the local ArgC/ArgV variables by the default parameter saving behavior
		*/
		
		EmitMove_RX_RIX_DISP8(cState, RDI, RBP, 8, 8)
		EmitLea_R64_R64_DISP8(cState, RSI, RBP, 16)
	}
	
	EmitSub_R64_IX(cState, RSP, LocalSpace)
	/* EmitEnter_I16(cState, LocalSpace) */
	
/* 	EmitPush_R64(cState, RBX)
	EmitPush_R64(cState, R13)
	EmitPush_R64(cState, R14)
	EmitPush_R64(cState, R15) */
	
	for (i8 RegisterParameterIndex := 0, RegisterParameterIndex < RegisterParameterCount, RegisterParameterIndex += 1) {
		/* For each register parameter */
		
		/* Get the VariableInfo structure for the parameter */
		VariableInfo* NextParameter := (FunctionToCompile->Parameters)[RegisterParameterIndex]
		
		/* And which register it is in (RCX/RDX/R8/R9) */
		i8 NextParameterRegister := 0
		
		if (USE_SYSTEMV) {
			if (RegisterParameterIndex = 5) {NextParameterRegister := R9}
			else if (RegisterParameterIndex = 4) {NextParameterRegister := R8}
			else if (RegisterParameterIndex = 3) {NextParameterRegister := RCX}
			else if (RegisterParameterIndex = 2) {NextParameterRegister := RDX}
			else if (RegisterParameterIndex = 1) {NextParameterRegister := RSI}
			else if (RegisterParameterIndex = 0) {NextParameterRegister := RDI}
		}
		else {
			NextParameterRegister := RegisterParameterIndex + 1
			
			if (NextParameterRegister > 2) {
				NextParameterRegister += 5
			}
		}
		
		/* And write the parameter register's value into the parameter's stack space */
		CompileSetVariableValue(cState, NextParameter, NextParameterRegister)
	}
	
	i8 StackParameterOffset := 0x8
	
	/* Shadow space is a dumb concept, which was invented by microsoft to increase RAM usage and to get you to buy more RAM from big memory. 
		(But actually, it goes unused in every function ever, so there's no point in handling it UNLESS: 
			this function is called by windows/external code, which isn't possible right now)
	*/
	
	/* if (USE_SYSTEMV) {
		SystemV doesn't have shadow space, so the stack parameters are actually at right before the saved return address
		StackParameterOffset := 0x8
	} */
	
	for (i16 StackParameterIndex := 0, StackParameterIndex < StackParameterCount, StackParameterIndex += 1) {
		/* For each stack parameter */
		
		/* Get the VariableInfo structure for the parameter */
		VariableInfo* NextStackParameter := (FunctionToCompile->Parameters)[StackParameterIndex + MAX_REGISTER_PARAMETERS]
		
		/* Load RAX with the parameter's value (using RBX as a base) */
		EmitMove_RX_RIX_DISP8(cState, RAX, RBX, StackParameterOffset + (StackParameterIndex * 8), GetTypeSize(NextStackParameter->Type))
		
		/* Write RAX(/the parameter's value) into the parameter's stack space */
		CompileSetVariableValue(cState, NextStackParameter, RAX)
	}
	
	if (IsMain) {
		ASTNode** GlobalDefaults := cState->pState->GlobalDefaults
		i32 Length := GetArrayLength(GlobalDefaults)
		
		for (i32 GlobalDefaultIndex := 0, GlobalDefaultIndex < Length, GlobalDefaultIndex += 1) {
			CompileExpression(cState, RAX, GlobalDefaults[GlobalDefaultIndex])
		}
	}
	
	if (FunctionToCompile->StringBufferSize) {
		i32 StringBufferOffset := FunctionToCompile->LocalOffset
		i32 StringBufferSize := FunctionToCompile->StringBufferSize
		
		i32 ChunkCount := StringBufferSize / 8
		i32 Remainder := StringBufferSize % 8
		
		if (Remainder) {
			ChunkCount += 1
		}
		
		cState->CurrentFunctionStringBufferOffset := StringBufferOffset + (ChunkCount * 8)
		i64* ChunkBuffer := (FunctionToCompile->StringBuffer) As i64*
		
		for (i32 ChunkIndex := 0, ChunkIndex < ChunkCount, ChunkIndex += 1) {
			i64 NextChunk := ChunkBuffer[ChunkIndex]
			EmitMove_R64_I64(cState, RAX, NextChunk)
			
			i32 ThisChunkOffset := StringBufferOffset + ((ChunkCount - 1 - ChunkIndex) * 8)
			
			if (ThisChunkOffset < 112) {
				EmitMove_RIX_DISP8_RX(cState, RBP, RAX, -(ThisChunkOffset + 8) As i8, 8)
			}
			else {
				EmitMove_RIX_DISP32_RX(cState, RBP, RAX, -(ThisChunkOffset + 8) As i32, 8)
			}
		}
	}
	
	/* Compile the body of the function */
	
	Block* Body := FunctionToCompile->Body
	i32 BodyCount := Body->StatementCount
	ASTNode* ReturnExpression := 0
	
	if (BodyCount >= 1) {
		/* If the last statement of the function body is a return, then don't emit a Leave;Ret combo for it */
		
		ASTNode* LastStatement := Body->Statements[BodyCount - 1]
		
		if (LastStatement->NodeType = NODE_TYPE_RETURN) {
			ReturnExpression := LastStatement->ReturnExpression
			Body->StatementCount -= 1
		}
	}
	
	CompileBlock(cState, Body)
	
	if (ReturnExpression) {
		CompileExpression(cState, RAX, ReturnExpression)
	}
	
	EmitLeave(cState)
	
	if (IsMain && USE_SYSTEMV) {
		EmitMove_R64_R64(cState, RDI, RAX)
		EmitMove_R32_I32(cState, RAX, 60)
		EmitSysCall(cState)
	}
	else {
		EmitReturn(cState)
	}
}

declare void Compile(CompilerState*, ASTNode*)

define void CompileBlock(CompilerState* cState, Block* BlockToCompile) {
	/* Compiles a block of statements */
	
	for (i32 Index := 0, Index < BlockToCompile->StatementCount, Index += 1) {
		ASTNode* NextStatement := (BlockToCompile->Statements)[Index]
		
		Compile(cState, NextStatement)
	}
}

declare void CompileReturn(CompilerState*, ASTNode*)
declare void CompileIf(CompilerState*, IfGroup*)
declare void CompileFor(CompilerState*, ForLoop*)
declare void CompileLoop(CompilerState*, Block*)
declare void CompileWhile(CompilerState*, WhileLoop*)

declare void CompileUnary(CompilerState*, i8, Type, UnaryExpression*, i8)
declare void CompileBinary(CompilerState*, i8, Type, BinaryExpression*, i8)
declare void CompileGetStructAccess(CompilerState*, i8, StructAccessExpression*)
declare void CompileCall(CompilerState*, i8, CallExpression*)

define void Compile(CompilerState* cState, ASTNode* NodeToCompile) {
	/* Compiles some kind of statement */
	
	i8 NodeType := NodeToCompile->NodeType
	
	if (NodeType = NODE_TYPE_RETURN) {
		CompileReturn(cState, NodeToCompile->ReturnExpression)
	}
	else if (NodeType = NODE_TYPE_IF) {
		CompileIf(cState, NodeToCompile->IfNode)
	}
	else if (NodeType = NODE_TYPE_FOR) {
		CompileFor(cState, NodeToCompile->ForNode)
	}
	else if (NodeType = NODE_TYPE_LOOP) {
		CompileLoop(cState, NodeToCompile->LoopBody)
	}
	else if (NodeType = NODE_TYPE_WHILE) {
		CompileWhile(cState, NodeToCompile->WhileNode)
	}
	else if (NodeType = NODE_TYPE_CONTINUEBREAK) {
		i8 IsContinue := NodeToCompile->IsContinue
		
		if (IsContinue) {
			EmitJump_Label(cState, cState->CurrentLoopContinueLabel)
		}
		else {
			EmitJump_Label(cState, cState->CurrentLoopBreakLabel)
		}
	}
	else if (NodeType = NODE_TYPE_EXPRESSION) {
		CompileExpression(cState, RAX, NodeToCompile->ExpressionStatement)
	}
}

define void CompileReturn(CompilerState* cState, ASTNode* ReturnExpression) {
	/* Compile the expression to return */
	
	CompileExpression(cState, RAX, ReturnExpression)
	
	i16 ReturnValueSize := GetTypeSize(ReturnExpression->ValueType)
	i16 ReturnTypeSize := GetTypeSize(cState->CurrentFunctionReturnType)
	
	/* And cast it up to (at least) 4 bytes, to ensure no garbage is left in RAX */
	
	if (ReturnValueSize < ReturnTypeSize || ReturnValueSize < 4) {
		Cast(cState, RAX, ReturnValueSize)
	}
	
	EmitLeave(cState)
	EmitReturn(cState)
}

define i8 IsComparison(Token* OperatorToken) {
	i8 Operator := OperatorToken->Value As i8
	return (OPERATOR_FIRST_COMPARISON <= Operator && Operator <= OPERATOR_LAST_COMPARISON) || (OPERATOR_FIRST_SHORT_CIRCUIT <= Operator && Operator <= OPERATOR_LAST_SHORT_CIRCUIT) 
}

define void CompileCondition(CompilerState* cState, ASTNode* ConditionExpression, i32 JumpToLabel) {
	/* Checks ConditionExpression for being false, and jumps to JumpToLabel if it is 
		This might seem a bit backwards, but loops/if statements all check for false, and jump out (or to the next branch)
		 depending on their conditions being false, which eliminates lots of extra jumping
	*/
	
	i8 ConditionType := ConditionExpression->NodeType
	
	BinaryExpression* BinaryNode := ConditionExpression->BinaryNode
	UnaryExpression* UnaryNode := ConditionExpression->UnaryNode
	
	if (ConditionType = NODE_TYPE_BINARY && IsComparison(BinaryNode->Operator)) {
		/* Compile the expression without a result being stored into RAX, since we use the value in EFLAGS */
		CompileBinary(cState, RAX, ConditionExpression->ValueType, BinaryNode, true)
		
		i8 Operator := BinaryNode->Operator->Value As i8
		
		/* Use inverted conditions to decide if this branch had a false condition, and to jump past it or not */
		
		if (Operator = OPERATOR_EQUAL) {
			EmitJNZ_Label(cState, JumpToLabel)
		}
		else if (Operator = OPERATOR_BANG_EQUAL) {
			EmitJEZ_Label(cState, JumpToLabel)
		}
		else if (Operator = OPERATOR_LESS) {
			EmitJGE_Label(cState, JumpToLabel)
		}
		else if (Operator = OPERATOR_LESS_EQAUL) {
			EmitJGT_Label(cState, JumpToLabel)
		}
		else if (Operator = OPERATOR_GREATER) {
			EmitJLE_Label(cState, JumpToLabel)
		}
		else if (Operator = OPERATOR_GREATER_EQAUL) {
			EmitJLT_Label(cState, JumpToLabel)
		}
		else if (Operator = OPERATOR_LOGICAL_AND || Operator = OPERATOR_LOGICAL_OR) {
			EmitJEZ_Label(cState, JumpToLabel)
		}
	}
	else if (ConditionType = NODE_TYPE_UNARY && (UnaryNode->Operator->Value As i8) = OPERATOR_BANG) {
		CompileUnary(cState, RAX, ConditionExpression->ValueType, UnaryNode, true)
		EmitJNZ_Label(cState, JumpToLabel)
	}
	else {
		/* In this case, the expression is not conditional, and we will need to check the result for being 0 or not */
		
		CompileExpression(cState, RAX, ConditionExpression)
		EmitTest_RX_RX(cState, RAX, RAX, GetTypeSize(ConditionExpression->ValueType))
		EmitJEZ_Label(cState, JumpToLabel)
	}
}

define void CompileIf(CompilerState* cState, IfGroup* IfToCompile) {
	i32 BranchCount := IfToCompile->BranchCount
	i32 HasElse := (IfToCompile->ElseBranch) != 0
	
	i32 EndLabel := NextLabel(cState)
	i32 NextBranch := NextLabel(cState)
	
	i8 ConditionResultRegister := PushRegisterStack(cState)
	
	for (i32 BranchIndex := 0, BranchIndex < BranchCount, BranchIndex += 1) {
		SetLabel(cState, NextBranch)
		NextBranch := NextLabel(cState)
		
		CompileCondition(cState, IfToCompile->Conditions[BranchIndex], NextBranch)
		CompileBlock(cState, IfToCompile->Bodies[BranchIndex])
		
		if (HasElse || (BranchIndex != (BranchCount - 1))) {
			/* Only emit a jump to the end label if: We have an 'else', or we are not the last branch 
				This will eliminate a single extra `jmp, endlabel` on the final 'else if' of the statement
				
			*/
			
			EmitJump_Label(cState, EndLabel)
		}
	}
	
	PopRegisterStack(cState)
	
	SetLabel(cState, NextBranch)
	
	if (IfToCompile->ElseBranch) {
		CompileBlock(cState, IfToCompile->ElseBranch)
	}
	
	SetLabel(cState, EndLabel)
}

define void CompileFor(CompilerState* cState, ForLoop* ForToCompile) {
	i32 OldContinueLabel := cState->CurrentLoopContinueLabel
	i32 OldBreakLabel := cState->CurrentLoopBreakLabel
	
	CompileExpression(cState, RAX, ForToCompile->Initializer)
	
	i32 StartLabel := NextLabel(cState)
	i32 ContinueLabel := NextLabel(cState)
	i32 EndLabel := NextLabel(cState)
	
	SetLabel(cState, StartLabel)
	
	CompileCondition(cState, ForToCompile->Condition, EndLabel)
	
	/* Prelude stuff done, condition is checked, so now we can compile the body */
	
	cState->CurrentLoopContinueLabel := ContinueLabel
	cState->CurrentLoopBreakLabel := EndLabel
	
	CompileBlock(cState, ForToCompile->Body)
	
	SetLabel(cState, ContinueLabel) /* On continue (or after the body ends naturally) execute the step, and jump to the condition check */
	CompileExpression(cState, RAX, ForToCompile->Step)
	
	EmitJump_Label(cState, StartLabel)
	
	SetLabel(cState, EndLabel) /* Jumped to on ForToCompile->Condition being false, or a break statement */
	
	cState->CurrentLoopContinueLabel := OldContinueLabel
	cState->CurrentLoopBreakLabel := OldBreakLabel
}

define void CompileLoop(CompilerState* cState, Block* LoopBody) {
	i32 OldContinueLabel := cState->CurrentLoopContinueLabel
	i32 OldBreakLabel := cState->CurrentLoopBreakLabel
	
	i32 StartLabel := NextLabel(cState)
	i32 EndLabel := NextLabel(cState)
	
	cState->CurrentLoopContinueLabel := StartLabel
	cState->CurrentLoopBreakLabel := EndLabel
	
	SetLabel(cState, StartLabel)
	
	CompileBlock(cState, LoopBody)
	
	EmitJump_Label(cState, StartLabel)
	SetLabel(cState, EndLabel)
	
	cState->CurrentLoopContinueLabel := OldContinueLabel
	cState->CurrentLoopBreakLabel := OldBreakLabel
}

define void CompileWhile(CompilerState* cState, WhileLoop* WhileToCompile) {
	i32 OldContinueLabel := cState->CurrentLoopContinueLabel
	i32 OldBreakLabel := cState->CurrentLoopBreakLabel
	
	i32 StartLabel := NextLabel(cState)
	i32 EndLabel := NextLabel(cState)
	
	cState->CurrentLoopContinueLabel := StartLabel
	cState->CurrentLoopBreakLabel := EndLabel
	
	SetLabel(cState, StartLabel)
	
	CompileCondition(cState, WhileToCompile->Condition, EndLabel)
	CompileBlock(cState, WhileToCompile->Body)
	
	EmitJump_Label(cState, StartLabel)
	SetLabel(cState, EndLabel)
	
	cState->CurrentLoopContinueLabel := OldContinueLabel
	cState->CurrentLoopBreakLabel := OldBreakLabel
}

define void CompileExpression(CompilerState* cState, i8 ResultRegister, ASTNode* ExpressionToCompile) {
	/* Compiles some kind of expression */
	
	i8 ExpressionType := ExpressionToCompile->NodeType
	Type ResultType := ExpressionToCompile->ValueType
	
	if (ExpressionType = NODE_TYPE_INTEGER) {
		/* Simply move the integer being used into the result register */
		
		i8 ResultSize := GetTypeSize(ResultType)
		i64 IntegerValue := ExpressionToCompile->IntegerValue
		
		if (IntegerValue = 0) {
			EmitXor_RX_RX(cState, ResultRegister, ResultRegister, 4)
		}
		else {
			i8 IntegerSize := GetNumberSize(IntegerValue)
			
			if (ResultSize >= 4 && IntegerSize <= 4) {
				ResultSize := 4
			}
			
			EmitMove_RX_IX(cState, ResultRegister, IntegerValue, ResultSize)
		}
	}
	else if (ExpressionType = NODE_TYPE_VARIABLE) {
		VariableInfo* TargetVariable := ExpressionToCompile->VariableValue
		
		CompileGetVariableValue(cState, ResultRegister, TargetVariable)
	}
	else if (ExpressionType = NODE_TYPE_UNARY) {
		UnaryExpression* UnaryNode := ExpressionToCompile->UnaryNode
	
		CompileUnary(cState, ResultRegister, ResultType, UnaryNode, false)
	}
	else if (ExpressionType = NODE_TYPE_BINARY) {
		/* Calls into CompileBinary with the correct parameters extracted from ExpressionToCompile */
		
		BinaryExpression* BinaryNode := ExpressionToCompile->BinaryNode
		
		CompileBinary(cState, ResultRegister, ResultType, BinaryNode, false)
	}
	else if (ExpressionType = NODE_TYPE_STRUCT_ACCESS) {
		StructAccessExpression* AccessNode := ExpressionToCompile->AccessNode
		
		CompileGetStructAccess(cState, ResultRegister, AccessNode)
	}
	else if (ExpressionType = NODE_TYPE_CALL) {
		CallExpression* CallNode := ExpressionToCompile->CallNode
		
		CompileCall(cState, ResultRegister, CallNode)
	}
	else if (ExpressionType = NODE_TYPE_STRING) {
		i32 StringOffset := ExpressionToCompile->StringOffsetValue
		
		i32 RBPOffect := (cState->CurrentFunctionStringBufferOffset) - StringOffset
		
		if (RBPOffect < 112) {
			EmitLea_R64_R64_DISP8(cState, ResultRegister, RBP, -(RBPOffect) As i8)
		}
		else {
			EmitLea_R64_R64_DISP32(cState, ResultRegister, RBP, -(RBPOffect) As i32)
		}
	}
}

define void CompileCall(CompilerState* cState, i8 ResultRegister, CallExpression* CallNode) {
	FunctionDefine* TargetFunction := CallNode->TargetFunction
	
	if (CallNode->IsSysCall) {
		/* Dummy branch */
	}
	else if (cState->OutputELF && TargetFunction->IsImported) {
		ASTError(AllocateNewASTNode(NODE_TYPE_CALL, CallNode, 0), "Calls to DllImported functions are not allowed when compiling to .elf")
	}
	else if !(TargetFunction->IsImported || TargetFunction->HasFullDefinition) {
		ASTError(AllocateNewASTNode(NODE_TYPE_CALL, CallNode, 0), "Called function is only declared, and never defined")
	}
	
	i32 ParameterCount := CallNode->ParameterCount
	i32 StackParameterCount := 0
	i8 ExtraPadding := false
	
	i8 USE_SYSTEMV := cState->OutputELF
	
	i8 REGISTER_PARAMETER_COUNT := 4
	
	if (USE_SYSTEMV) {
		REGISTER_PARAMETER_COUNT := 6
	}
	
	if (ParameterCount > REGISTER_PARAMETER_COUNT) {
		StackParameterCount := ParameterCount - REGISTER_PARAMETER_COUNT
	}
	
	i8 RegisterStackIndex := cState->RegisterStackIndex
	i8 StackIsAligned := RegisterStackIndex >= 8 && (RegisterStackIndex % 2 != 0)
	
	if (StackParameterCount % 2 || StackIsAligned) {
		EmitPush_R64(cState, RBX)
		ExtraPadding := true
	}
	
	cState->RegisterStackIndex := 3
	
	i8 OldNoClobberCD89 := cState->NoClobberCD89
	cState->NoClobberCD89 := true /* Ensure none of the parameter registers are used for another operation without being saved */
	
	if (OldNoClobberCD89) {
		EmitPush_R64(cState, R11)
		EmitPush_R64(cState, R10)
		EmitPush_R64(cState, R9)
		EmitPush_R64(cState, R8)
		EmitPush_R64(cState, RDX)
		EmitPush_R64(cState, RCX)
	}
	
	i8 ParameterRegister := RBX
	
	i8 IS_SYSCALL := CallNode->IsSysCall
	
	if (ParameterCount != 0) {
		for (i64 ParameterIndex := (ParameterCount - 1), ParameterIndex >= 0, ParameterIndex -= 1) {
			i16 ExpectedSize := 8
			
			if !(IS_SYSCALL) {
				VariableInfo* NextParameter := (TargetFunction->Parameters)[ParameterIndex]
				ExpectedSize := GetTypeSize(NextParameter->Type)
			}
			
			ASTNode* NextParameterValue := (CallNode->Parameters)[ParameterIndex]
			
			i8 ThisParameterRegister := ParameterRegister
			
			if (IS_SYSCALL) {
				if (ParameterIndex = 6) {ThisParameterRegister := R9}
				else if (ParameterIndex = 5) {ThisParameterRegister := R8}
				else if (ParameterIndex = 4) {ThisParameterRegister := RCX}
				else if (ParameterIndex = 3) {ThisParameterRegister := RDX}
				else if (ParameterIndex = 2) {ThisParameterRegister := RSI}
				else if (ParameterIndex = 1) {ThisParameterRegister := RDI}
				else if (ParameterIndex = 0) {ThisParameterRegister := RAX}
			}
			else if (USE_SYSTEMV) {
				if (ParameterIndex = 5) {ThisParameterRegister := R9}
				else if (ParameterIndex = 4) {ThisParameterRegister := R8}
				else if (ParameterIndex = 3) {ThisParameterRegister := RCX}
				else if (ParameterIndex = 2) {ThisParameterRegister := RDX}
				else if (ParameterIndex = 1) {ThisParameterRegister := RSI}
				else if (ParameterIndex = 0) {ThisParameterRegister := RDI}
			}
			else {
				if (ParameterIndex = 3) {ThisParameterRegister := R9}
				else if (ParameterIndex = 2) {ThisParameterRegister := R8}
				else if (ParameterIndex = 1) {ThisParameterRegister := RDX}
				else if (ParameterIndex = 0) {ThisParameterRegister := RCX}
			}
			
			CompileExpression(cState, ThisParameterRegister, NextParameterValue)
			
			i16 ActualSize := GetTypeSize(NextParameterValue->ValueType)
			
			if (ActualSize < ExpectedSize) {
				Cast(cState, ThisParameterRegister, ActualSize)
			}
			
			if (ParameterIndex >= REGISTER_PARAMETER_COUNT) {
				EmitPush_R64(cState, ThisParameterRegister)
			}
		}
	}

	cState->NoClobberCD89 := OldNoClobberCD89
	
/* 	if (cState->NoClobberA) {
		EmitMove_R64_R64(cState, R12, RAX)
	} */
	
	if (IS_SYSCALL) {
		EmitSysCall(cState)
	}
	else if (USE_SYSTEMV || !TargetFunction->IsImported) {
		EmitCall_Label(cState, TargetFunction->LabelNumber)
	}
	else {
		EmitSub_R64_I8(cState, RSP, 0x20) /* Shadown space */
		EmitCall_Label(cState, TargetFunction->LabelNumber)
		EmitAdd_R64_I8(cState, RSP, 0x20)
	}
	
	if (OldNoClobberCD89) {
		EmitPop_R64(cState, RCX)
		EmitPop_R64(cState, RDX)
		EmitPop_R64(cState, R8)
		EmitPop_R64(cState, R9)
		EmitPop_R64(cState, R10)
		EmitPop_R64(cState, R11)
	}
	
	if (ExtraPadding) {
		EmitPop_R64(cState, RBX)
	}
	
	if (ResultRegister != RAX) {
		EmitMove_R64_RX(cState, ResultRegister, RAX, GetTypeSize(TargetFunction->ReturnType))
	}
/* 	if (cState->NoClobberA) {
		EmitMove_R64_R64(cState, RAX, R12)
	} */
	
	cState->RegisterStackIndex := RegisterStackIndex
}

declare void CompileGetStructAccessPointer(CompilerState*, i8, StructAccessExpression*)

define void CompileStructAccessLeft(CompilerState* cState, i8 ResultRegister, StructAccessExpression* TargetAccess) {
	ASTNode* Left := TargetAccess->Left
	
	if (Left->NodeType = NODE_TYPE_STRUCT_ACCESS && TargetAccess->Operator->Value = OPERATOR_DOT) {
		CompileGetStructAccessPointer(cState, ResultRegister, Left->AccessNode)
	}
	else {
		CompileExpression(cState, ResultRegister, Left)
	}
}

define void CompileGetStructAccessPointer(CompilerState* cState, i8 ResultRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	i16 TargetFieldSize := GetTypeSize(TargetField->ValueType)
	
	CompileStructAccessLeft(cState, ResultRegister, TargetAccess)
	
	i32 FieldOffset := TargetField->Offset
	
	if (FieldOffset != 0) {
		EmitLea_R64_R64_DISPX(cState, ResultRegister, ResultRegister, FieldOffset)
	}
}

define void CompileGetStructAccess(CompilerState* cState, i8 ResultRegister, StructAccessExpression* TargetAccess) {
	if (TargetAccess->Operator->Value = OPERATOR_TILDE_GREATER) {
		return CompileGetStructAccessPointer(cState, ResultRegister, TargetAccess)
	}
	
	StructField* TargetField := TargetAccess->TargetField
	i16 TargetFieldSize := GetTypeSize(TargetField->ValueType)
	
	i32 FieldOffset := TargetField->Offset
	
	if (TargetField->BitStartIndex || TargetField->BitEndIndex) {
		CompileExpression(cState, ResultRegister, TargetAccess->Left)
		/* EmitMove_RX_RIX(cState, ResultRegister, ResultRegister, TargetFieldSize) */
		
		TargetFieldSize := FieldOffset
		
		i32 FieldSize := (TargetFieldSize * 8) - 1
		i8 ShiftLeftBy := FieldSize - TargetField->BitEndIndex
		i8 ShiftRightBy := ShiftLeftBy + TargetField->BitStartIndex
		
		if (ShiftLeftBy < 0) {
			ShiftRightBy := -ShiftLeftBy
		}
		else if (ShiftLeftBy) { 
			EmitSAL_RX_I8(cState, ResultRegister, ShiftLeftBy, TargetFieldSize)
		}
		
		if (ShiftRightBy) {
			EmitSAR_RX_I8(cState, ResultRegister, ShiftRightBy, TargetFieldSize)
		}
	}
	else {
		CompileStructAccessLeft(cState, ResultRegister, TargetAccess)
		
		if (FieldOffset = 0 && ResultRegister != R13) {
			EmitMove_RX_RIX(cState, ResultRegister, ResultRegister, TargetFieldSize)
		}
		else if (FieldOffset >= 112) {
			EmitMove_RX_RIX_DISP32(cState, ResultRegister, ResultRegister, FieldOffset, TargetFieldSize)
		}
		else {
			EmitMove_RX_RIX_DISP8(cState, ResultRegister, ResultRegister, FieldOffset, TargetFieldSize)
		}
	}
}

declare void CompileSetArrayAccess(CompilerState*, i8, ASTNode*, ASTNode*, i8)

define void CompileSetStructAccess(CompilerState* cState, i8 ValueRegister, StructAccessExpression* TargetAccess) {
	StructField* TargetField := TargetAccess->TargetField
	
	i8 ResultPointerRegister := PushRegisterStack(cState)
	
	i32 FieldOffset := TargetField->Offset
	i16 TargetFieldSize := GetTypeSize(TargetField->ValueType)
	
	if (TargetField->BitStartIndex || TargetField->BitEndIndex) {
		CompileExpression(cState, ResultPointerRegister, TargetAccess->Left)
		
		/* EmitMove_RX_RIX(cState, ResultPointerRegister, ResultPointerRegister, TargetFieldSize) */
		
		TargetFieldSize := TargetField->Offset
		
		i8 StartIndex := TargetField->BitStartIndex
		i8 EndIndex := TargetField->BitEndIndex
		
		i32 FieldSize := (TargetFieldSize * 8) - 1
		i8 ShiftLeftBy := FieldSize - (EndIndex - StartIndex)
		i8 ShiftRightBy := FieldSize - EndIndex
		
		i64 PartialMask := ((1 As i64) << ((EndIndex + 1) As i8)) - 1
		
		if (EndIndex = 63) {
			/* Since 1<<64 is undefined, the result of INT64_MAX needs to be hard coded */
			PartialMask := 0xFFFFFFFFFFFFFFFF
		}
		
		i64 Mask := ~(PartialMask >> StartIndex << StartIndex)
		
		EmitMove_RX_IX(cState, RDI, Mask, TargetFieldSize)
		EmitAnd_RX_RX(cState, ResultPointerRegister, RDI, TargetFieldSize)
		
		if (ShiftLeftBy) { 
			EmitSAL_RX_I8(cState, ValueRegister, ShiftLeftBy As i32, TargetFieldSize)
		}
		
		EmitSAR_RX_I8(cState, ValueRegister, ShiftRightBy As i32, TargetFieldSize)
		EmitOr_RX_RX(cState, ResultPointerRegister, ValueRegister, TargetFieldSize)
		
		ASTNode* Left := TargetAccess->Left
		i8 LeftNodeType := Left->NodeType
		
		if (LeftNodeType = NODE_TYPE_VARIABLE) {
			CompileSetVariableValue(cState, Left->VariableValue, ResultPointerRegister)
		}
		else if (LeftNodeType = NODE_TYPE_STRUCT_ACCESS) {
			CompileSetStructAccess(cState, ResultPointerRegister, Left->AccessNode)
		}
		else if (LeftNodeType = NODE_TYPE_BINARY) {
			CompileSetArrayAccess(cState, ValueRegister, Left->BinaryNode->Left, Left->BinaryNode->Right, ResultPointerRegister)
		}
	}
	else {
		CompileStructAccessLeft(cState, ResultPointerRegister, TargetAccess)
		
		i16 TargetSize := GetTypeSize(TargetField->ValueType)
		
		if (FieldOffset = 0 && ResultPointerRegister != R13) {
			/* 
				Fuck x86_64. WHY would R13 be used as the magic "use RIP-relative" flag?
				Was it not enough to use R12 for SIB encodings? Why couldn't this shit have been put into another prefix byte?
			*/
			
			EmitMove_RIX_RX(cState, ResultPointerRegister, ValueRegister, TargetSize)
		}
		else if (FieldOffset >= 112) {
			EmitMove_RIX_DISP32_RX(cState, ResultPointerRegister, ValueRegister, FieldOffset, TargetSize)
		}
		else {
			EmitMove_RIX_DISP8_RX(cState, ResultPointerRegister, ValueRegister, FieldOffset, TargetSize)
		}
	}
	
	PopRegisterStack(cState)
}

define void CompileArrayAccess(CompilerState* cState, i8 ResultRegister, ASTNode* Pointer, ASTNode* Index, i8 ValueRegister, i8 GetAddress) {
	i8 PointerRegister := ResultRegister
	CompileExpression(cState, PointerRegister, Pointer)
	
	i8 IndexRegister := PushRegisterStack(cState)
	CompileExpression(cState, IndexRegister, Index)
	
	i32 IndexSize := GetTypeSize(Index->ValueType)
	
	if (IndexSize < 4) {
		Cast(cState, IndexRegister, IndexSize)
	}
	
	Type PointerType := Pointer->ValueType
	
	i8 IndexScale := 8
	
	TypeInfo* PointerBase := GetBaseType(PointerType)
	i16 PointerDepth := GetPointerDepth(PointerType)
	
	if (PointerDepth = 1) {
		IndexScale := (PointerBase->Size) As i8
	}
	
	i8 IsSet := (ValueRegister != 0)
	
	if (IsSet || GetAddress) {
		EmitLea_R64_SIB(cState, ResultRegister, IndexScale, IndexRegister, PointerRegister)
		
		if (IsSet) {
			EmitMove_RIX_RX(cState, ResultRegister, ValueRegister - 1, IndexScale)
		}
	}
	else {
		EmitMove_RX_SIB(cState, ResultRegister, IndexScale, IndexRegister, PointerRegister)
	}
	
	PopRegisterStack(cState)
}

define void CompileGetArrayAccess(CompilerState* cState, i8 ResultRegister, ASTNode* Pointer, ASTNode* Index, i8 GetAddress) {
	CompileArrayAccess(cState, ResultRegister, Pointer, Index, 0, GetAddress)
}
define void CompileSetArrayAccess(CompilerState* cState, i8 ResultRegister, ASTNode* Pointer, ASTNode* Index, i8 ValueRegister) {
	CompileArrayAccess(cState, ResultRegister, Pointer, Index, ValueRegister + 1, false)
}

define void CompileUnary(CompilerState* cState, i8 ResultRegister, Type ResultType, UnaryExpression* ExpressionToCompile, i8 DiscardResult) {
	/* Compiles a unary operator and operand */
	
	i8 Operator := (ExpressionToCompile->Operator->Value) As i8
	i16 ResultSize := GetTypeSize(ResultType)
	
	if (Operator = OPERATOR_AND) {
		ASTNode* Operand := ExpressionToCompile->Operand
		i8 OperandType := Operand->NodeType
		
		if (OperandType = NODE_TYPE_VARIABLE) {
			VariableInfo* OperandVariable := Operand->VariableValue
			
			CompileGetVariableAddress(cState, ResultRegister, OperandVariable)
		}
		else if (OperandType = NODE_TYPE_STRUCT_ACCESS) {
			StructAccessExpression* OperandStructAccess := Operand->AccessNode
			
			CompileGetStructAccessPointer(cState, ResultRegister, OperandStructAccess)
		}
		else if (OperandType = NODE_TYPE_BINARY) {
			BinaryExpression* OperandExpression := Operand->BinaryNode
			
			if (OperandExpression->Operator->Value = OPERATOR_OPEN_BRACKET) {
				CompileGetArrayAccess(cState, ResultRegister, OperandExpression->Left, OperandExpression->Right, true)
			}
		}
	}
	else {
		/* Only compile the operand when the operator isn't `&` (since it doesn't use the operand value) */
		CompileExpression(cState, ResultRegister, ExpressionToCompile->Operand)
		
		if (Operator = OPERATOR_STAR) {
			EmitMove_RX_RIX(cState, ResultRegister, ResultRegister, ResultSize)
		}
		else if (Operator = OPERATOR_MINUS) {
			EmitNeg_RX(cState, ResultRegister, ResultSize)
		}
		else if (Operator = OPERATOR_TILDE) {
			EmitNot_RX(cState, ResultRegister, ResultSize)
		}
		else if (Operator = OPERATOR_BANG) {
			/* ALWAYS 100% ENSURE THAT YOU AREN'T DOING OPERATIONS WITH THE WRONG SIZE, RESULTSIZE CAN'T ALWAYS BE TRUSTED */
			/* 	Sincerely - mov r8, [some_pointer]; test r8b, r8b */
			EmitTest_RX_RX(cState, ResultRegister, ResultRegister, GetTypeSize(ExpressionToCompile->Operand->ValueType))
			
			if !(DiscardResult) {
				/* If the caller uses the FLAGS register, it doesn't need a 'true' result, and can just use what's in the FLAGS register */
				EmitSetE_R8(cState, ResultRegister)
			}
		}
	}
}

define void CompileBinary(CompilerState* cState, i8 ResultRegister, Type ResultType, BinaryExpression* ExpressionToCompile, i8 DiscardResult) {
	/* Compiles a binary expression, and both operands of the expression */
	
	ASTNode* Left := ExpressionToCompile->Left
	ASTNode* Right := ExpressionToCompile->Right
	
	i16 LeftSize := GetTypeSize(Left->ValueType)
	i16 RightSize := GetTypeSize(Right->ValueType)
	i16 ResultSize := GetTypeSize(ResultType)
	
	i8 LeftRegister := ResultRegister
	
	i8 Operator := (ExpressionToCompile->Operator->Value) As i8
	
	if (OPERATOR_FIRST_ASSIGNMENT <= Operator && Operator <= OPERATOR_LAST_ASSIGNMENT) {
		/* This is an assignment, so we can reuse the result register for the side side, and ignore the left */
		
		i8 LeftType := (Left->NodeType) As i8
		
		VariableInfo* TargetVariable := Left->VariableValue
		StructAccessExpression* LeftAccess := Left->AccessNode
		BinaryExpression* LeftExpression := Left->BinaryNode
		
		i8 WorkRegister := PushRegisterStack(cState)
		
		if (Operator = OPERATOR_COLON_EQUAL) {
			CompileExpression(cState, ResultRegister, Right)
			
			if (RightSize < LeftSize) {
				Cast(cState, ResultRegister, RightSize)
			}
			
			if (LeftType = NODE_TYPE_VARIABLE) {
				CompileSetVariableValue(cState, TargetVariable, ResultRegister)
			}
			else if (LeftType = NODE_TYPE_STRUCT_ACCESS) {
				CompileSetStructAccess(cState, ResultRegister, LeftAccess)
			}
			else if (LeftType = NODE_TYPE_BINARY) {
				CompileSetArrayAccess(cState, RBX, LeftExpression->Left, LeftExpression->Right, ResultRegister)
			}
		}
		else {				
			CompileExpression(cState, WorkRegister, Right)
			
			if (RightSize < LeftSize) {
				Cast(cState, WorkRegister, RightSize)
			}
			
			/* Prelude to get old value of all valid left side expressions */
			
			if (LeftType = NODE_TYPE_VARIABLE) {
				CompileGetVariableValue(cState, ResultRegister, TargetVariable)
			}
			else if (LeftType = NODE_TYPE_STRUCT_ACCESS) {
				CompileGetStructAccess(cState, ResultRegister, LeftAccess)
			}
			else if (LeftType = NODE_TYPE_BINARY) {
				CompileGetArrayAccess(cState, ResultRegister, LeftExpression->Left, LeftExpression->Right, false)
			}
			
			/* Actual operator implementation */
			
			if (Operator = OPERATOR_PLUS_EQUAL) {
				EmitAdd_RX_RX(cState, ResultRegister, WorkRegister, ResultSize)
			}
			else if (Operator = OPERATOR_MINUS_EQUAL) {
				EmitSub_RX_RX(cState, ResultRegister, WorkRegister, ResultSize)
			}
			
			/* Epilog to store the new value for each valid left side */
			
			if (LeftType = NODE_TYPE_VARIABLE) {
				CompileSetVariableValue(cState, TargetVariable, ResultRegister)
			}
			else if (LeftType = NODE_TYPE_STRUCT_ACCESS) {
				CompileSetStructAccess(cState, ResultRegister, LeftAccess)
			}
			else if (LeftType = NODE_TYPE_BINARY) {
				CompileSetArrayAccess(cState, WorkRegister, LeftExpression->Left, LeftExpression->Right, ResultRegister)
			}
		}
		
		PopRegisterStack(cState)
	}
	else if (Operator = OPERATOR_OPEN_BRACKET) {
		CompileGetArrayAccess(cState, ResultRegister, Left, Right, false)
	}
	else {
		/* As long as we're not compiling an assignment, compile the left operand into the result register */
		
		CompileExpression(cState, LeftRegister, Left)
		
		i8 OldClobberA := cState->NoClobberA
		
		if (LeftRegister = RAX) {
			cState->NoClobberA := true
		}
		
		if (Operator = OPERATOR_AS) {
			/* For 'As', just compile the left operand, cast it, and return */
			Type RightType := Right->TypeValue
			
			if (Left->NodeType != NODE_TYPE_INTEGER) {
				/* Only emit cast instructions for values which aren't integers, since integer casts are done at compile time */
				
				Cast(cState, LeftRegister, GetTypeSize(RightType))
			}
		}
		else if (OPERATOR_FIRST_SHORT_CIRCUIT <= Operator && Operator <= OPERATOR_LAST_SHORT_CIRCUIT) {
			i32 End := NextLabel(cState)
			
			EmitTest_RX_RX(cState, LeftRegister, LeftRegister, LeftSize)
			
			if !(DiscardResult) {
				EmitSetNE_R8(cState, ResultRegister)
			}
			
			if (Operator = OPERATOR_LOGICAL_AND) {
				EmitJEZ_Label(cState, End)
			}
			else if (Operator = OPERATOR_LOGICAL_OR) {
				EmitJNZ_Label(cState, End)
			}
			
			CompileExpression(cState, LeftRegister, Right)
			
			EmitTest_RX_RX(cState, LeftRegister, LeftRegister, RightSize)
			
			if !(DiscardResult) {
				EmitSetNE_R8(cState, ResultRegister)
			}
			
			SetLabel(cState, End)
		}
		else if (Operator = OPERATOR_LESS_LESS || Operator = OPERATOR_GREATER_GREATER) {
			i8 LeftWasRCX := LeftRegister = RCX
			
			if (LeftWasRCX) {
				LeftRegister := PushRegisterStack(cState)
				EmitMove_RX_RX(cState, LeftRegister, RCX, ResultSize)
			}
			else if (cState->NoClobberCD89) {
				EmitPush_R64(cState, RCX)
			}
			
			CompileExpression(cState, RCX, Right)
			
			if (Operator = OPERATOR_LESS_LESS) {
				EmitSHL_RX_CL(cState, LeftRegister, ResultSize)
			}
			else if (Operator = OPERATOR_GREATER_GREATER) {
				EmitSHR_RX_CL(cState, LeftRegister, ResultSize)
			}
			
			if (LeftWasRCX) {
				EmitMove_RX_RX(cState, RCX, LeftRegister, ResultSize)
				PopRegisterStack(cState)
			}
			else if (cState->NoClobberCD89) {
				EmitPop_R64(cState, RCX)
			}
		}
		else {
			i8 IsComparison := IsComparison(ExpressionToCompile->Operator)
			
			if (IsComparison) {
				i8* ErrorMessage := 0
				
				Type TrueResultType := TryGetBinaryResultType(cState->pState, Left->ValueType, Right->ValueType, &ErrorMessage)
				
				if !(ErrorMessage) {
					ResultSize := GetTypeSize(TrueResultType)
				}
				else {
					ResultSize := 8
				}
			}
			
			/* If either operand is smaller than the result type, cast it up to the R64 (aka any possible size) */
			if (LeftSize < ResultSize) {
				Cast(cState, LeftRegister, LeftSize)
			}
			
			i8 IsPlusMinus := (Operator = OPERATOR_PLUS || Operator = OPERATOR_MINUS)
			
			if (IsPlusMinus && Right->NodeType = NODE_TYPE_INTEGER) {
				/* Since some instructions for simple operations have encodings for sign-extended immediates 
					We can check for an operator+operand combo which can be optimized into a single instruction
				*/
				
				i64 RightInteger := Right->IntegerValue
				
				i8 OperandSize := GetNumberSize(RightInteger)
				
				if (OperandSize <= 4) {
					/* There are no imm64 encodings, only imm8 and imm32 */
					
					if (Operator = OPERATOR_PLUS) {
						EmitAdd_R64_IX(cState, ResultRegister, RightInteger As i32)
					}
					else if (Operator = OPERATOR_MINUS) {
						EmitSub_R64_IX(cState, ResultRegister, RightInteger As i32)
					}
					
					/* When we optimized this expression, we need to return early to skip it being
						compiled like normal
					*/
					
					cState->NoClobberA := OldClobberA
					return 0
				}
			}
			
			/* Allocate a new register for the right operand */
			
			i8 RightRegister := PushRegisterStack(cState)
			CompileExpression(cState, RightRegister, Right)
			
			if (RightSize < ResultSize) {
				Cast(cState, RightRegister, RightSize)
			}
			
			if (IsComparison) {
				EmitCmp_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			
			/* Also uses uses the correct instruction for two ResultType sized operands (casting should be done this is called) */
			
			if (DiscardResult) {
				/* Since comparison expressions can technically store a result in the FLAGS register, sometimes
					 a comparison can have the "real" result discarded, and the caller can just use FLAGS.
					So, this is a dummy branch to prevent code from being generated to grab the result of an
					 expression out of FLAGS.
				*/
			}
			else if (Operator = OPERATOR_PLUS) {
				EmitAdd_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			else if (Operator = OPERATOR_MINUS) {
				EmitSub_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			else if (Operator = OPERATOR_STAR) {
				if (ResultSize = 1) {
					/* Do 8 bit multiplication as 16 bit, and cast the result back down to 8 bits (since there is no imul r8, r8 instruction */
					EmitIMul_RX_RX(cState, LeftRegister, RightRegister, 2)
					Cast(cState, LeftRegister, 1)
				}
				else {	
					EmitIMul_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
				}
			}
			else if (Operator = OPERATOR_SLASH || Operator = OPERATOR_PERCENT) {
				if (LeftRegister != RAX) {
					EmitMove_R64_R64(cState, RBX, RAX)
					EmitMove_R64_R64(cState, RAX, LeftRegister)
				}
				if (cState->NoClobberCD89) {
					EmitPush_R64(cState, RDX)
				}
				
				if (ResultSize = 1) {
					/* Handle 8 bit division through a 16 bit operation, which will have a result casted down 
						(8 bit IDIV uses AL/AH, which CodeGen isn't set up to encode)
					*/
					EmitCXX(cState, 2)
					EmitIDiv_RAX_RX(cState, RightRegister, 2)
				}
				else {
					EmitCXX(cState, ResultSize)
					EmitIDiv_RAX_RX(cState, RightRegister, ResultSize)
				}
				
				if (Operator = OPERATOR_SLASH && ResultRegister != RAX) {
					EmitMove_RX_RX(cState, ResultRegister, RAX, ResultSize)
				}
				else if (Operator = OPERATOR_PERCENT && ResultRegister != RDX) {
					EmitMove_RX_RX(cState, ResultRegister, RDX, ResultSize)
				}
				
				if (cState->NoClobberCD89) {
					EmitPop_R64(cState, RDX)
				}
				if (LeftRegister != RAX) {
					EmitMove_R64_R64(cState, RAX, RBX)
				}
				
				if (ResultSize = 1) {
					Cast(cState, ResultRegister, 1)
				}
			}
			else if (Operator = OPERATOR_EQUAL) {
				EmitSetE_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_BANG_EQUAL) {
				EmitSetNE_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_LESS) {
				EmitSetL_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_LESS_EQAUL) {
				EmitSetLE_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_GREATER) {
				EmitSetG_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_GREATER_EQAUL) {
				EmitSetGE_R8(cState, ResultRegister)
			}
			else if (Operator = OPERATOR_XOR) {
				EmitXor_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			else if (Operator = OPERATOR_AND) {
				EmitAnd_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			else if (Operator = OPERATOR_OR) {
				EmitOr_RX_RX(cState, LeftRegister, RightRegister, ResultSize)
			}
			
			PopRegisterStack(cState) /* Pop the right register */
		}
		
		cState->NoClobberA := OldClobberA
	}
}