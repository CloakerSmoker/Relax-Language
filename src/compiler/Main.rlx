DllImport i64 GetCurrentProcess() {Kernel32.dll, GetCurrentProcess}
DllImport void TerminateProcess(i64, i32) {Kernel32.dll, TerminateProcess}

define void Exit(i32 ExitCode) {
	windows {
		TerminateProcess(GetCurrentProcess(), ExitCode)
	}
	linux {
		syscall:(60, ExitCode)
	}
}

i8 OUTPUT_PE := 0
i8 OUTPUT_ELF := 1
i8 OUTPUT_BIN := 2

i8 ABI_X64 := 1
i8 ABI_SYSTEMV := 2

i8 DUMP_FUNCTIONS := 1
i8 DUMP_GLOBALS := 2

i8 DEBUG_NONE := 0
i8 DEBUG_EMIT_FUNCTION_NAMES := 1

struct BuildConfig {
	i64 ImageBase,
	i8 OutputFormat,
	i8 TargetABI,
	i8 DumpInfo,
	i8 DebugMode
}

#Require "./src/lib/Memory.rlx"
#Require "./src/lib/File.rlx"

#Require "./src/lib/String.rlx"
#Require "./src/lib/Console.rlx"
#Require "./src/lib/SafeString.rlx"
#Require "./src/lib/HashMap.rlx"
#Require "./src/lib/Debug.rlx"

declare i16* OpenAndRead(i8*, i32*)

#Require "./src/compiler/Utility.rlx"
#Require "./src/compiler/Lexer.rlx"
#Require "./src/compiler/Parser.rlx"
#Require "./src/compiler/PEBuilder.rlx"
#Require "./src/compiler/ELFBuilder.rlx"
#Require "./src/compiler/Compiler.rlx"

define i16* OpenAndRead(i8* FilePath, i32* OutFileSize) {
	i64 FileHandle := FileOpen(FilePath, FILE_READ)
	
	if (FileHandle < 0) {
		SwapOutputStream()
		Print("Could not open file: '%s'\nError code: %i\nAborting", FilePath, FileGetError(FileHandle))
		Exit(1)
	}
	
	i32 FileSize := FileGetSize(FileHandle)
	
	if (OutFileSize != 0) {
		OutFileSize[0] := FileSize
	}
	
	void* FileBuffer := Alloc(FileSize)
	
	i64 ReadResult := FileRead(FileHandle, FileBuffer, FileSize)
	
	if (ReadResult < 0) {
		SwapOutputStream()
		Print("Could not read file: '%s'\nError code: %i\nAborting", FilePath, FileGetError(FileHandle))
		
		Exit(1)
	}
	
	i16* Source := AToW(FileBuffer As i8*, FileSize)
	
	Free(FileBuffer)
	FileClose(FileHandle)
	
	return Source
}

define i32 Main(i64 ArgC, i8** ArgV) {	
	GetArgs(&ArgC, &ArgV) /* NOP on Linux */
	
	BuildConfig* Config := Alloc(#BuildConfig)
	
	Config->DumpInfo := DUMP_FUNCTIONS
	
	windows {
		Config->OutputFormat := OUTPUT_PE
	}
	linux {
		Config->OutputFormat := OUTPUT_ELF
	}
	
	i8* InputFilePath := 0
	i8* OutputFilePath := 0
	i8 DumpFunctionBytes := true
	
	for (i32 Index := 0, Index < ArgC, Index += 1) {
		i8* NextArg := ArgV[Index]
		
		if (StringEquals(NextArg, "--elf")) {
			Config->OutputFormat := OUTPUT_ELF
		}
		else if (StringEquals(NextArg, "--pe")) {
			Config->OutputFormat := OUTPUT_PE
		}
		else if (StringEquals(NextArg, "--bin")) {
			Config->OutputFormat := OUTPUT_BIN
		}
		else if (StringEquals(NextArg, "--functions")) {
			Config->DumpInfo |= DUMP_FUNCTIONS
		}
		else if (StringEquals(NextArg, "--globals")) {
			Config->DumpInfo |= DUMP_GLOBALS
		}
		else if (StringEquals(NextArg, "--debug")) {
			Config->DebugMode |= DEBUG_EMIT_FUNCTION_NAMES
		}
		else if (StringEquals(NextArg, "--no-colors")) {
			NO_COLORS := true
		}
		else if (StringEquals(NextArg, "-i") && !InputFilePath) {			
			Index += 1
			InputFilePath := ArgV[Index]
			
			/* AWrite("Input File: ")
			AWriteLine(InputFilePath) */
			Print("Input File: '%s'\n", InputFilePath)
		}
		else if (StringEquals(NextArg, "-o") && !OutputFilePath) {
			Index += 1
			OutputFilePath := ArgV[Index]
		
			/* AWrite("Output File: ")
			AWriteLine(OutputFilePath) */
			Print("Output File: '%s'\n", OutputFilePath)
		}
	}

	if !(InputFilePath && OutputFilePath) {
		if (ArgC = 3) {
			InputFilePath := ArgV[1]
			OutputFilePath := ArgV[2]
		}
		else {
			SwapOutputStream()
			Print("No input+output file, aborting")
			Exit(1)
		}
	}
	
	Config->TargetABI := ABI_SYSTEMV
	Config->ImageBase := DEFAULT_IMAGE_BASE
	
	i32 SourceLength := 0
	i16* Source := OpenAndRead(InputFilePath, &SourceLength)
	
	TokenizerState* Tokenizer := NewTokenizer(Config, AToS(InputFilePath), Source, SourceLength)
	
	ParserState* Parser := ParserStart(Config, Tokenizer)
	
	CompilerStart(Config, Parser, OutputFilePath)
}