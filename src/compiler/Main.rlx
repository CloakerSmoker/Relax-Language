#Require "./src/lib/Memory.rlx"
#Require "./src/lib/File.rlx"

#Require "./src/lib/String.rlx"
#Require "./src/lib/Console.rlx"
#Require "./src/lib/SafeString.rlx"
#Require "./src/lib/HashMap.rlx"
#Require "./src/lib/Debug.rlx"

declare i16* OpenAndRead(i8*, i32*)

#Require "./src/compiler/Utility.rlx"
#Require "./src/compiler/Lexer.rlx"
#Require "./src/compiler/Parser.rlx"
#Require "./src/compiler/PEBuilder.rlx"
#Require "./src/compiler/ELFBuilder.rlx"
#Require "./src/compiler/Compiler.rlx"

BuildConfig* CurrentConfig := null

define void CompilerUnhandledExceptionHandler(i64 Code) {
	UnhandledExceptionHandler(Code)
	
	Print("Lexer State: \n")
	
	LexerState* Lexer := CurrentConfig->Lexer
	LexerState* Child := Lexer
	
	for (i32 Depth := 0, Child != null, Depth += 1) {
		for (i32 Tabs := 0, Tabs < Depth, Tabs += 1) {
			Print("	")
		}
		
		Print("'")
		Child->SourceFilePath->Print()
		Print("' on line %i\n", Child->CurrentLineNumber)
		
		Child := Child->Child
	}
}

define i32 Main(i64 ArgC, i8** ArgV) {	
	GetArgs(&ArgC, &ArgV) /* NOP on Linux */
	
	BuildConfig* Config := Alloc(#BuildConfig)
	
	Config->DumpInfo := 0
	
	windows {
		Config->OutputFormat := OUTPUT_PE
	}
	linux {
		Config->OutputFormat := OUTPUT_ELF
	}
	
	i8* InputFilePath := null
	i8* OutputFilePath := null
	i8 DumpFunctionBytes := false
	
	for (i32 Index := 0, Index < ArgC, Index += 1) {
		i8* NextOption := ArgV[Index]
		
		if (StringEquals(NextOption, "--elf")) {
			Config->OutputFormat := OUTPUT_ELF
		}
		else if (StringEquals(NextOption, "--pe")) {
			Config->OutputFormat := OUTPUT_PE
		}
		else if (StringEquals(NextOption, "--bin")) {
			Config->OutputFormat := OUTPUT_BIN
		}
		else if (StringEquals(NextOption, "--functions")) {
			Config->DumpInfo |= DUMP_FUNCTIONS
		}
		else if (StringEquals(NextOption, "--globals")) {
			Config->DumpInfo |= DUMP_GLOBALS
		}
		else if (StringEquals(NextOption, "--lines")) {
			Config->DumpInfo |= DUMP_LINES
		}
		else if (StringEquals(NextOption, "--debug")) {
			Config->DebugMode |= DEBUG_EMIT_FUNCTION_NAMES
		}
		else if (StringEquals(NextOption, "--dwarf")) {
			Config->DebugMode |= DEBUG_EMIT_DWARF
		}
		else if (StringEquals(NextOption, "--no-colors")) {
			NO_COLORS := true
		}
		else if (StringEquals(NextOption, "-i") && !InputFilePath) {
			Index += 1
			InputFilePath := ArgV[Index]
			
			Print("Input File: '%s'\n", InputFilePath)
		}
		else if (StringEquals(NextOption, "-o") && !OutputFilePath) {
			Index += 1
			OutputFilePath := ArgV[Index]
			
			Print("Output File: '%s'\n", OutputFilePath)
		}
	}

	if !(InputFilePath && OutputFilePath) {
		if (ArgC = 3) {
			InputFilePath := ArgV[1]
			OutputFilePath := ArgV[2]
		}
		else {
			SwapOutputStream()
			Print("No input+output file, aborting")
			Exit(1)
		}
	}
	
	if (Config->OutputFormat != OUTPUT_ELF && Config->DebugMode & DEBUG_EMIT_DWARF) {
		Print("^60Warning: `--dwarf` flag is only implemented for ELF files.^F0\n")
	}
	
	CurrentConfig := Config
	UnhandledExceptionHandler := &CompilerUnhandledExceptionHandler
	
	Config->SourceFile := InputFilePath
	Config->TargetABI := ABI_SYSTEMV
	Config->ImageBase := DEFAULT_IMAGE_BASE
	
	i32 SourceLength := 0
	i16* Source := OpenAndRead(InputFilePath, &SourceLength)
	
	LexerState* Lexer := LexerState:New(Config, Source, SourceLength, AToS(InputFilePath))
	Config->Lexer := Lexer
	
	ParserState* Parser := ParserState:New(Config, Lexer)
	Parser->ParseProgram()
	
	CompilerStart(Config, Parser, OutputFilePath)
	
	; Todo: Make the exit code consistent
	
	windows {
		return 1
	}
	linux {
		return 0
	}
}
