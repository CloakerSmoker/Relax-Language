
i8 REX_BASE := 0x40

i8 REX_W := 8
i8 REX_R := 4
i8 REX_X := 2
i8 REX_B := 1

i8 NO_REGISTER := 0
i8 RAX := 0
i8 RBX := 3
i8 RCX := 1
i8 RDX := 2
i8 RSP := 4
i8 RBP := 5
i8 RSI := 6
i8 RDI := 7

; Although R8-R15 actually have the same numbers of RAX-RDI, REX.B is encoded as bit 3 
;  (which is removed and replaced with a REX prefix while actually encoding)

i8 R8 := 8
i8 R9 := 9
i8 R10 := 10
i8 R11 := 11
i8 R12 := 12
i8 R13 := 13
i8 R14 := 14
i8 R15 := 15

i8 MODE_PTOR := 0
i8 MODE_PTOR_DISP8 := 1
i8 MODE_PTOR_DISP32 := 2

i8 MODE_RTOR := 3

i8 LEGACY_SIZE_PREFIX := 0x66

struct X64Generator {
	union {
		void* CodeBuffer
		i8* CodeBufferBytes
	}
	
	i32 CodeBufferCapacity
	i32 CodeBufferIndex
	
	static X64Generator* New() {
		X64Generator* this := Alloc(#X64Generator)
		
		this->CodeBufferCapacity := 0x1000
		this->CodeBuffer := Alloc(this->CodeBufferCapacity)
		
		return this
	}
	
	define void EnsureCodeBufferCapacity() {
		if ((this->CodeBufferIndex + 0x100) >= this->CodeBufferCapacity) {
			this->CodeBufferCapacity += 0x1000
			this->CodeBuffer := ReAlloc(this->CodeBuffer, this->CodeBufferCapacity)
		}
	}
	
	define void* GetPointerToTail() {
		return this->CodeBuffer + this->CodeBufferIndex
	}
	
	define void WriteI8(i16 Number) {
		this->EnsureCodeBufferCapacity()
		this->CodeBufferBytes[this->CodeBufferIndex++] := Number As i8
	}
	define void WriteI16(i16 Number) {
		this->EnsureCodeBufferCapacity()
		
		*(this->GetPointerToTail() As i16*) := Number
		
		this->CodeBufferIndex += 2
	}
	define void WriteI32(i32 Number) {
		this->EnsureCodeBufferCapacity()
		
		*(this->GetPointerToTail() As i32*) := Number
		
		this->CodeBufferIndex += 4
	}
	define void WriteI64(i64 Number) {
		this->EnsureCodeBufferCapacity()
		
		*(this->GetPointerToTail() As i64*) := Number
		
		this->CodeBufferIndex += 8
	}
	
	define i8 RegisterRequiresREX(i8 RegisterNumber) {
		return RegisterNumber >= 8
	}
	
	define void WriteREX(i8 Destination, i8 Source, i8 Extra) {
		i8 Prefix := REX_BASE | Extra
		
		if (this->RegisterRequiresREX(Destination)) {
			Prefix |= REX_R
		}
		
		if (this->RegisterRequiresREX(Source)) {
			Prefix |= REX_B
		}
		
		if (Prefix != REX_BASE || Extra != 0) {
			this->WriteI8(Prefix)
		}
	}
	
	define i8 ClampRegisterNumber(i8 RegisterNumber) {
		if (this->RegisterRequiresREX(RegisterNumber)) {
			return (RegisterNumber - 8) As i8
		}
		
		return RegisterNumber
	}
	
	define void WriteModRM(i8 Mode, i8 Destination, i8 Source) {
		Mode := (Mode << 6) As i8
		i8 Reg := (this->ClampRegisterNumber(Destination) << 3) As i8
		i8 RM := this->ClampRegisterNumber(Source)
		
		this->WriteI8(Mode | Reg | RM)
	}
	
	define void WriteLegacySizePrefix() {
		this->WriteI8(LEGACY_SIZE_PREFIX)
	}
	
	define void WriteSIB(i8 Scale, i8 Index, i8 Base) {
		i8 TrueScale := 0
		
		if (Scale = 2) {TrueScale := 1}
		else if (Scale = 4) {TrueScale := 2}
		else if (Scale = 8) {TrueScale := 3}
		
		this->WriteI8(((TrueScale << 6) | (Index << 3) | Base) As i8)
	}
	
	define void WriteREXOpcode(i8 REX, i16 Opcode) {
		this->WriteREX(0, 0, REX)
		this->WriteI8(Opcode)
	}
	define void WriteREXOpcode(i8 REX, i16 Opcode, i8 Operand) {
		Opcode += this->ClampRegisterNumber(Operand)
		
		this->WriteREX(0, Operand, REX)
		this->WriteI8(Opcode & 0xFF)
	}
	
	define void WriteREXOpcodeModRM(i8 REX, i16 Opcode, i8 Mode, i8 Destination, i8 Source) {
		this->WriteREX(Destination, Source, REX)
		this->WriteI8(Opcode)
		this->WriteModRM(Mode, Destination, Source)
	}
	
	define void WriteREXBigOpcodeModRM(i16 OpcodeOne, i16 OpcodeTwo, i8 Mode, i8 Destination, i8 Source, i8 ExtraREX) {
		this->WriteREX(Destination, Source, ExtraREX)
		this->WriteI8(OpcodeOne)
		this->WriteI8(OpcodeTwo)
		this->WriteModRM(Mode, Destination, Source)
	}
	define void WriteREXOpcodeModRMSIB(i16 Opcode, i8 Mode, i8 Destination, i8 Scale, i8 Index, i8 Base, i8 ExtraREX) {
		if (this->RegisterRequiresREX(Index)) {
			ExtraREX := ExtraREX | REX_X
		}
		
		this->WriteREX(Destination, Base, ExtraREX)
		this->WriteI8(Opcode)
		this->WriteModRM(Mode, Destination, 4)
		this->WriteSIB(Scale, this->ClampRegisterNumber(Index), this->ClampRegisterNumber(Base))
	}
	
	define void WriteGenericInstructionRM(i8 Size, i16 Opcode, i8 Mode, i8 Destination, i8 Source) {
		i8 REX := 0
		
		if (Size = 1) {
			Opcode -= 1
		}
		else if (Size = 2) {
			this->WriteLegacySizePrefix()
		}
		else if (Size = 8) {
			REX |= REX_W
		}
		
		this->WriteREXOpcodeModRM(REX, Opcode, Mode, Destination, Source)
	}
	define void WriteGenericInstructionMR(i8 Size, i16 Opcode, i8 Mode, i8 Destination, i8 Source) {
		this->WriteGenericInstructionRM(Size, Opcode, Mode, Source, Destination)
	}
	
	define void WriteGenericInstructionDisplacementRM(i8 Size, i16 Opcode, i8 Destination, i8 Source, i32 Displacement) {
		i8 DisplacementSize := GetNumberSize(Displacement)
		
		if (DisplacementSize = 1) {
			this->WriteGenericInstructionRM(Size, Opcode, MODE_PTOR_DISP8, Destination, Source)
			this->WriteI8(Displacement As i8)
		}
		else {
			this->WriteGenericInstructionRM(Size, Opcode, MODE_PTOR_DISP32, Destination, Source)
			this->WriteI32(Displacement)
		}
	}
	define void WriteGenericInstructionDisplacementMR(i8 Size, i16 Opcode, i8 Destination, i32 Displacement, i8 Source) {
		this->WriteGenericInstructionDisplacementRM(Size, Opcode, Source, Destination, Displacement)
	}
	
	
	; MOV r64, r/m64 (RM)
	; 8B /r
	define void Move_RX_RIX_DISPX(i8 Size, i8 Destination, i8 Base, i32 Displacement) {
		this->WriteGenericInstructionDisplacementRM(Size, 0x8B, Destination, Base, Displacement)
	}
	define void Move_RX_RIX(i8 Size, i8 Destination, i8 Source) {
		this->WriteGenericInstructionRM(Size, 0x8B, MODE_PTOR, Destination, Source)
	}
	define void Move_RX_RX(i8 Size, i8 Destination, i8 Source) {
		this->WriteGenericInstructionRM(Size, 0x8B, MODE_RTOR, Destination, Source)
	}
	
	; MOV r/mX, rX (MR)
	; 89 /r
	define void Move_RIX_DISPX_RX(i8 Size, i8 Base, i32 Displacement, i8 Source) {
		this->WriteGenericInstructionDisplacementMR(Size, 0x89, Base, Displacement, Source)
	}
	define void Move_RIX_RX(i8 Size, i8 Destination, i8 Source) {
		this->WriteGenericInstructionMR(Size, 0x89, MODE_PTOR, Destination, Source)
	}
	
	; MOV rX, immX
	; B0+ rb ib
	define void Move_R8_I8(i8 Destination, i8 Value) {
		this->WriteREXOpcode(REX_BASE, 0xB0, Destination)
		this->WriteI8(Value)
	}
	; B8+ rX iX
	define void Move_R16_I16(i8 Destination, i16 Value) {
		this->WriteLegacySizePrefix()
		this->WriteREXOpcode(0, 0xB8, Destination)
		this->WriteI16(Value)
	}
	define void Move_R32_I32(i8 Destination, i32 Value) {
		this->WriteREXOpcode(0, 0xB8, Destination)
		this->WriteI32(Value)
	}
	define void Move_R64_I64(i8 Destination, i64 Value) {
		this->WriteREXOpcode(REX_B, 0xB8, Destination)
		this->WriteI64(Value)
	}
	define void Move_RX_IX(i8 Size, i8 Destination, i64 Value) {
		if      (Size = 1) {   this->Move_R8_I8(Destination, Value As i8 ) }
		else if (Size = 2) { this->Move_R16_I16(Destination, Value As i16) }
		else if (Size = 4) { this->Move_R32_I32(Destination, Value As i32) }
		else if (Size = 8) { this->Move_R64_I64(Destination, Value As i64) }
	}
	
	; MOV r/mX, immX (MI)
	; C7 /0 iX
	define void Move_RIX_DISPX_IX(i8 Size, i8 Destination, i32 Displacement, i32 Value) {
		this->WriteGenericInstructionDisplacementMR(Size, 0xC7, Destination, Displacement, 0)
		
		if      (Size = 1) {  this->WriteI8(Value As i8 ) }
		else if (Size = 2) { this->WriteI16(Value As i16) }
		else if (Size = 4) { this->WriteI32(Value As i32) }
	}
	
	
	; ADD rX, r/mX (RM)
	; 03 /r
	define void Add_RX_RX(i8 Size, i8 Left, i8 Right) {
		this->WriteGenericInstructionRM(Size, 0x03, MODE_RTOR, Left, Right)
	}
	define void Add_RX_RIX(i8 Size, i8 Left, i8 Right) {
		this->WriteGenericInstructionRM(Size, 0x03, MODE_PTOR, Left, Right)
	}
	define void Add_RX_RIX_DISPX(i8 Size, i8 Left, i8 Base, i32 Displacement) {
		this->WriteGenericInstructionDisplacementRM(Size, 0x03, Left, Base, Displacement)
	}
	
	; ADD r/mX, rX (MR)
	; 01 /r
	define void Add_RIX_RX(i8 Size, i8 Left, i8 Right) {
		this->WriteGenericInstructionMR(Size, 0x01, MODE_PTOR, Left, Right)
	}
	define void Add_RIX_DISPX_RX(i8 Size, i8 Base, i32 Displacement, i8 Right) {
		this->WriteGenericInstructionDisplacementMR(Size, 0x01, Base, Displacement, Right)
	}
	
	
	
	
	
	; RET
	; C3
	define void Ret() {
		this->WriteI8(0xC3)
	}
	
	; NEG r/mX (M)
	; F7 /3
	define void Neg_RX(i8 Size, i8 Target) {
		this->WriteGenericInstructionMR(Size, 0xF7, MODE_RTOR, Target, 3)
	}
	define void Neg_RIX(i8 Size, i8 Target) {
		this->WriteGenericInstructionMR(Size, 0xF7, MODE_PTOR, Target, 3)
	}
	define void Neg_RIX_DISPX(i8 Size, i8 Base, i32 Displacement) {
		this->WriteGenericInstructionDisplacementMR(Size, 0xF7, Base, Displacement, 3)
	}
}