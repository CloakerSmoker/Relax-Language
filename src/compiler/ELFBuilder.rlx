i32 ELF_MAGIC               := 0x464C457F ; 0x7f 'ELF' magic
i8  ELF_BITNESS_64          := 2          ; 1 = 32 bit, 2 = 64 bit
i8  ELF_ENDIAN_LITTLE       := 1          ; 1 = Little endian

i8  ELF_ABI_SYSTEMV         := 0          ; 0 = SystemV
i8  ELF_ABI_VERSION_SYSTEMV := 0

i8 ELF_ABI_LINUX := 3
i8 ELF_ABI_VERSION_LINUX := 0

i8 ELF_ABI_FREEBSD := 9
i8 ELF_ABI_VERSION_FREEBSD := 0

i16 ELF_FILETYPE_EXECUTABLE := 0x02
i16 ELF_FILETYPE_DYNAMIC    := 0x03
i16 ELF_MACHINE_AMD64       := 0x3E
i32 ELF_VERSION             := 1

i64 ELF_ALIGN_NONE := 0 ; Used for both segments and sections

i32 ELF_SEGMENT_FLAGS_EXECUTE := 1
i32 ELF_SEGMENT_FLAGS_WRITE   := 2
i32 ELF_SEGMENT_FLAGS_READ    := 4

i32 ELF_SEGMENT_TYPE_LOAD := 0x01
i32 ELF_SEGMENT_TYPE_DYNAMIC := 0x2
i32 ELF_SEGMENT_TYPE_INTERP := 0x3
i32 ELF_SEGMENT_TYPE_PHDR := 0x06

struct ELFProgramHeader {
	i32 SegmentType
	i32 Flags
	i64 FileOffset
	i64 VirtualAddress
	i64 PhysicalAddress
	i64 FileSize
	i64 MemorySize
	i64 Alignment
}

i32 ELF_SECTION_TYPE_DATA         := 0x01
i32 ELF_SECTION_TYPE_SYMBOL_TABLE := 0x02
i32 ELF_SECTION_TYPE_STRING_TABLE := 0x03
i32 ELF_SECTION_TYPE_DYNAMIC      := 0x06
i32 ELF_SECTION_TYPE_NODATA       := 0x08

i64 ELF_SECTION_FLAGS_WRITE    := 0x01
i64 ELF_SECTION_FLAGS_ALLOCATE := 0x02
i64 ELF_SECTION_FLAGS_EXECUTE  := 0x04
i64 ELF_SECTION_FLAGS_STRINGS  := 0x20


; Custom flag, used to mark that a section only exists for the purpose of mapping a name to some
;  data which isn't loaded (like debug info)
i64 ELF_SECTION_FLAGS_HAS_DATA := 0x2222

struct ELFSectionHeader {
	i32 NameOffset
	i32 Type
	i64 Flags
	i64 VirtualAddress
	i64 FileOffset
	i64 FileSize
	i32 AssociatedSectionIndex
	i32 ExtraInfo
	i64 Alignment
	i64 EntrySize
}

i8 ELF_STB_LOCAL   := 0x00
i8 ELF_STB_GLOBAL  := 0x10
i8 ELF_STB_WEAK    := 0x20

i8 ELF_STT_NONE    := 0x00
i8 ELF_STT_OBJECT  := 0x01
i8 ELF_STT_FUNC    := 0x02
i8 ELF_STT_SECTION := 0x03
i8 ELF_STT_FILE    := 0x04
i8 ELF_STT_COMMON  := 0x05
i8 ELF_STT_TLS     := 0x06

i8 ELF_STV_DEFAULT   := 0
i8 ELF_STV_INTERNAL  := 1
i8 ELF_STV_HIDDEN    := 3
i8 ELF_STV_PROTECTED := 4

i16 ELF_SHN_UNDEF := 0
i16 ELF_SHN_ABS := 0xFFF1 As i16
i16 ELF_SHN_COMMON := 0xFFF2 As i16

struct ELFSymbol unaligned {
	i32 Name
	i8 Info
	i8 Other
	i16 SectionIndex
	i64 Value
	i64 Size

	static self* New() {
		return Alloc(#self)
	}

	define void Binding(i8 Binding) {
		this->Info := (this->Info & 0xF) | Binding
	}
	define void Type(i8 SymbolType) {
		this->Info := ((this->Info & 0xF0) | SymbolType) As i8
	}
	define i8 Type() {
		return this->Info & 0xF
	}
	define void Visibility(i8 Visibility) {
		this->Other := Visibility
	}
}

i32 ELF_NOTE_TYPE_FREEBSD_ABI_TAG := 1
i32 ELF_NOTE_DATA_FREEBSD_ABI_TAG_13_1 :=  1301000

struct ELFNoteSection {
	i32 NameLength
	i32 DescriptionLength
	i32 Type
	i8[0] Name
	
	define void* Body() {
		return this~>Name +this->NameLength 
	}
}

i64 ELF_DYNAMIC_TAG_NULL := 0
i64 ELF_DYNAMIC_TAG_NEEDED := 1
i64 ELF_DYNAMIC_TAG_HASH := 4
i64 ELF_DYNAMIC_TAG_STRTAB := 5
i64 ELF_DYNAMIC_TAG_SYMTAB := 6
i64 ELF_DYNAMIC_TAG_RELA := 7
i64 ELF_DYNAMIC_TAG_RELASZ := 8
i64 ELF_DYNAMIC_TAG_RELAENT := 9
i64 ELF_DYNAMIC_TAG_STRSZ := 10
i64 ELF_DYNAMIC_TAG_SYMENT := 11
i64 ELF_DYNAMIC_TAG_REL := 17
i64 ELF_DYNAMIC_TAG_RELSZ := 18
i64 ELF_DYNAMIC_TAG_RELENT := 19

struct ELFDynamicSectionEntry {
	i64 Tag
	i64 Value

	static self* New(i64 Tag, i64 Value) {
		self* this := Alloc(#self)

		this->Tag := Tag
		this->Value := Value

		return this
	}
}

struct ELFHeader unaligned {
	i32 Magic
	i8 Bitness
	i8 Endianness
	i8 UseCurrentVersion
	i8 ABI
	
	union {
		; This byte is followed by 7 unused ones, so we pad out to the correct offset with this union

		i8 ABIVersion
		i64 Unused
	}
	
	i16 FileType
	i16 MachineType
	
	i32 ELFVersion
	i64 EntryPoint

	i64 ProgramHeadersOffset
	i64 SectionHeadersOffset

	i32 Flags
	i16 HeaderSize

	i16 ProgramHeaderSize
	i16 ProgramHeaderEntryCount
	i16 SectionHeaderSize
	i16 SectionHeaderEntryCount

	i16 SectionNameSectionIndex

	define void Populate(i8 ABI, i8 ABIVersion) {
		; Default values for a statically linked little endian 64 bit x86-64 executable using the specified ABI
		
		this->Magic             := ELF_MAGIC
		this->Bitness           := ELF_BITNESS_64
		this->Endianness        := ELF_ENDIAN_LITTLE
		this->UseCurrentVersion := true
		this->ABI               := ABI
		this->ABIVersion        := ABIVersion
		this->FileType          := ELF_FILETYPE_EXECUTABLE
		this->MachineType       := ELF_MACHINE_AMD64
		this->ELFVersion        := ELF_VERSION
		
		this->HeaderSize                    := #ELFHeader As i16
		this->ProgramHeaderSize             := #ELFProgramHeader As i16
		this->SectionHeaderSize             := #ELFSectionHeader As i16

		this->SectionNameSectionIndex := 1
	}
}

#Require "$/PointerArray.rlx"

; For efficient mapping executable and shared object files must have segments whose file offsets and virtual addresses 
;  are congruent modulo the page size.
; From: https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf

struct ELFBuilder {
	union {
		void* Buffer
		ELFHeader* Header
	}
	
	i32 BufferSize
	
	ELFProgramHeader* PHDR                ; Segment for segment headers
	ELFProgramHeader* LoadPHDR            ; Segment which loads the segment containing the segment headers
	ELFSectionHeader* StringSection       ; Section which holds section names (Fuck this format)
	
	ELFProgramHeader* CodeProgramHeader   ; Segment for code
	ELFSectionHeader* CodeSectionHeader   ; Section for code
	
	ELFProgramHeader* DataProgramHeader   ; Segment for data
	ELFSectionHeader* DataSectionHeader   ; Segment for code
	
	i8* StringBuffer
	i8* CodeBuffer
	
	PointerArray* ProgramHeaders ; <ELFProgramHeader*>
	PointerArray* SectionHeaders ; <ELFSectionHeader*>

	define i16 SectionIndex(ELFSectionHeader* Header) {
		return this->SectionHeaders->Find(Header) As i16
	}
	
	i32 DataSize

	define i32 AppendString(i8* String) {
		i32 StringOffset := this->StringSection->FileSize As i32
		i32 StringLength := StringLength(String)
		
		i32 NewSize := StringOffset + StringLength + 1
		
		this->StringBuffer := ReAlloc(this->StringBuffer, NewSize)
		this->StringSection->FileSize := NewSize
		
		for (i32 Index := 0, Index < StringLength, Index += 1) {
			this->StringBuffer[StringOffset + Index] := String[Index]
		}
		
		return StringOffset
	}

	define ELFProgramHeader* AppendProgramHeader() {
		this->Header->ProgramHeaderEntryCount += 1
		
		ELFProgramHeader* Result := Alloc(#ELFProgramHeader)
		
		this->ProgramHeaders->Push(Result)
		
		return Result
	}
	define ELFSectionHeader* AppendSectionHeader() {
		this->Header->SectionHeaderEntryCount += 1
		
		ELFSectionHeader* Result := Alloc(#ELFSectionHeader)
		
		this->SectionHeaders->Push(Result)
		
		return Result
	}

	define ELFSectionHeader* AppendNamedSection(i8* Name) {
		ELFSectionHeader* NewSection := this->AppendSectionHeader()
		
		NewSection->NameOffset := this->AppendString(Name)
		
		return NewSection
	}

	define void AddCodeSection(i8* CodeBytes, i32 CodeLength) {
		ELFProgramHeader* LoadCode := this->AppendProgramHeader()
		
		LoadCode->SegmentType := ELF_SEGMENT_TYPE_LOAD
		LoadCode->Flags       := ELF_SEGMENT_FLAGS_READ | ELF_SEGMENT_FLAGS_EXECUTE
		LoadCode->Alignment   := ELF_ALIGN_NONE
		LoadCode->FileSize    := CodeLength
		LoadCode->MemorySize  := CodeLength
		
		ELFSectionHeader* TextSection := this->AppendNamedSection(".text")
		
		TextSection->Type  := ELF_SECTION_TYPE_DATA
		TextSection->Flags := ELF_SECTION_FLAGS_ALLOCATE | ELF_SECTION_FLAGS_EXECUTE
		TextSection->Alignment    := ELF_ALIGN_NONE
		TextSection->FileSize     := CodeLength
		
		this->CodeBuffer        := CodeBytes
		this->CodeProgramHeader := LoadCode
		this->CodeSectionHeader := TextSection
	}

	define void AddEmptyDataSection(i32 ReserveBytes) {
		ELFProgramHeader* LoadData := this->AppendProgramHeader()
		
		LoadData->SegmentType := ELF_SEGMENT_TYPE_LOAD
		LoadData->Flags       := ELF_SEGMENT_FLAGS_READ | ELF_SEGMENT_FLAGS_WRITE
		LoadData->Alignment   := ELF_ALIGN_NONE
		LoadData->FileSize    := 0
		LoadData->MemorySize  := ReserveBytes
		
		ELFSectionHeader* DataSection := this->AppendNamedSection(".bss")
		
		DataSection->Type         := ELF_SECTION_TYPE_NODATA
		DataSection->Flags        := ELF_SECTION_FLAGS_ALLOCATE | ELF_SECTION_FLAGS_WRITE
		DataSection->Alignment    := ELF_ALIGN_NONE
		DataSection->FileSize     := ReserveBytes
		
		this->DataProgramHeader := LoadData
		this->DataSectionHeader := DataSection
	}
	define ELFSectionHeader* AddDataSection(i8* Name, void* Data, i32 Size) {
		ELFSectionHeader* DataSection := this->AppendNamedSection(Name)
		
		DataSection->Type           := ELF_SECTION_TYPE_DATA
		DataSection->Flags          := ELF_SECTION_FLAGS_HAS_DATA
		DataSection->Alignment      := ELF_ALIGN_NONE
		DataSection->VirtualAddress := Data As i64
		DataSection->FileSize       := Size

		return DataSection
	}

	PointerArray* SymbolTable ; <ELFSymbol*>

	define void SetupSymbolTable() {
		this->SymbolTable := PointerArray:New()

		ELFSymbol* First := ELFSymbol:New()

		this->SymbolTable->Push(First)
	}

	define ELFSymbol* AddSymbol(i8* Name, i8 SymbolType, i64 Start, i64 End) {
		i32 NameOffset := this->AppendString(Name)

		ELFSymbol* Result := ELFSymbol:New()

		this->SymbolTable->Push(Result)

		Result->Name := NameOffset
		Result->Type(SymbolType)
		Result->Binding(ELF_STB_LOCAL)
		Result->Visibility(ELF_STV_DEFAULT)

		Result->Value := Start
		Result->Size := End - Start

		return Result
	}
	define ELFSymbol* AddFunctionSymbol(i8* Name, i64 Start, i64 End) {
		return this->AddSymbol(Name, ELF_STT_FUNC, Start, End)
	}
	define ELFSymbol* AddGlobalSymbol(i8* Name, i64 Start, i64 End) {
		return this->AddSymbol(Name, ELF_STT_OBJECT, Start, End)
	}

	define void FinalizeSymbolTable() {
		i32 Size := this->SymbolTable->Count() * #ELFSymbol
		ELFSymbol* SymbolTable := Alloc(Size)

		for (i32 Index := 0, Index < this->SymbolTable->Count(), Index++) {
			ELFSymbol* Next := this->SymbolTable->At(Index)

			if (Next->Type() = ELF_STT_FUNC) {
				Next->SectionIndex := this->SectionIndex(this->CodeSectionHeader)
			}
			else if (Next->Type() = ELF_STT_OBJECT) {
				Next->SectionIndex := this->SectionIndex(this->DataSectionHeader)
			}

			MoveMemory(SymbolTable[Index], Next, #ELFSymbol)
		}

		ELFSectionHeader* Section := this->AddDataSection(".symtab", SymbolTable, Size)

		Section->Type := ELF_SECTION_TYPE_SYMBOL_TABLE
		Section->AssociatedSectionIndex := this->SectionIndex(this->StringSection)
		Section->ExtraInfo := this->SymbolTable->Count()
	}

	static ELFBuilder* New(i8 ABI, i8 ABIVersion) {
		ELFBuilder* this := Alloc(#ELFBuilder)

		this->SetupSymbolTable()

		this->BufferSize := #ELFHeader
		this->Buffer := Alloc(this->BufferSize)
		
		this->ProgramHeaders := PointerArray:New()
		this->SectionHeaders := PointerArray:New()
		
		this->Header->Populate(ABI, ABIVersion)
		
		ELFProgramHeader* PHDR := this->AppendProgramHeader()
		this->PHDR := PHDR
		
		PHDR->SegmentType    := ELF_SEGMENT_TYPE_PHDR
		PHDR->Flags          := ELF_SEGMENT_FLAGS_READ
		PHDR->Alignment      := ELF_ALIGN_NONE
		PHDR->FileOffset     := #ELFHeader
		PHDR->VirtualAddress := #ELFHeader
		
		ELFProgramHeader* LoadPHDR := this->AppendProgramHeader()
		this->LoadPHDR := LoadPHDR
		
		LoadPHDR->SegmentType    := ELF_SEGMENT_TYPE_LOAD
		LoadPHDR->Flags          := ELF_SEGMENT_FLAGS_READ | ELF_SEGMENT_FLAGS_WRITE
		LoadPHDR->Alignment      := ELF_ALIGN_NONE
		LoadPHDR->FileOffset     := 0x00
		LoadPHDR->VirtualAddress := 0x00
		
		ELFSectionHeader* NullSection := this->AppendSectionHeader()
		
		ELFSectionHeader* StringSection := this->AppendSectionHeader()
		this->StringSection := StringSection
		
		StringSection->Type := ELF_SECTION_TYPE_STRING_TABLE
		StringSection->Alignment := 0x01
		
		this->StringBuffer := Alloc(8)
		StringSection->FileSize := 1
		
		StringSection->NameOffset := this->AppendString(".strtab")
		
		return this
	}
	
	define void Finalize(i32 CodeOffset, i32 MainOffset, i64 ImageBase, i64 PhysicalImageBase) {
		; Note: the data section is excluded from the size, since a program header with a FileSize of 0 and non-zero 
		;  MemorySize will have MemorySize zero bytes loaded into memory
		
		i32 ProgramHeaderCount := this->Header->ProgramHeaderEntryCount
		i32 SectionHeaderCount := this->Header->SectionHeaderEntryCount
		
		i32 ProgramHeadersSize := ProgramHeaderCount * #ELFProgramHeader
		i32 SectionHeadersSize := SectionHeaderCount * #ELFSectionHeader
		i32 CodeSize := this->CodeProgramHeader->FileSize As i32
		i32 StringSectionSize := this->StringSection->FileSize As i32
		i32 DataSize := 0
		
		for (i32 Index := 0, Index < SectionHeaderCount, Index += 1) {
			ELFSectionHeader* NextSectionHeader := this->SectionHeaders->At(Index)
			
			if (NextSectionHeader->Flags = ELF_SECTION_FLAGS_HAS_DATA) {
				DataSize += NextSectionHeader->FileSize As i32
			}
		}
		
		i32 PHDRSize := ProgramHeadersSize + SectionHeadersSize
		i32 HeadersSize := #ELFHeader + PHDRSize
		i32 CodePaddingSize := CodeOffset - HeadersSize
		
		i32 FinalSize := HeadersSize + CodePaddingSize + CodeSize + DataSize + StringSectionSize
		
		this->BufferSize := FinalSize
		this->Buffer := ReAlloc(this->Buffer, FinalSize)
		
		void* Buffer := this->Buffer
		i8* ByteBuffer := Buffer As i8*
		
		; Calculate the offset of each segment inside the file
		i32 ProgramHeadersOffset := #ELFHeader
		i32 SectionHeadersOffset := ProgramHeadersOffset + ProgramHeadersSize
		i32 StringsOffset := CodeOffset + CodeSize
		i32 ExtraOffset := StringsOffset + StringSectionSize
		
		; Update the ELF header to contain the program/section header offsets, and entry-point
		this->Header->ProgramHeadersOffset := ProgramHeadersOffset
		this->Header->SectionHeadersOffset := SectionHeadersOffset
		
		this->PHDR->FileSize := PHDRSize
		this->PHDR->MemorySize := PHDRSize
		this->PHDR->FileOffset := ProgramHeadersOffset
		this->PHDR->VirtualAddress := ImageBase + ProgramHeadersOffset
		this->PHDR->PhysicalAddress := this->PHDR->VirtualAddress + PhysicalImageBase
		
		this->LoadPHDR->FileSize := PHDRSize
		this->LoadPHDR->MemorySize := PHDRSize
		this->LoadPHDR->FileOffset := ProgramHeadersOffset
		this->LoadPHDR->VirtualAddress := ImageBase + ProgramHeadersOffset
		this->LoadPHDR->PhysicalAddress := this->LoadPHDR->VirtualAddress + PhysicalImageBase

		this->StringSection->FileOffset := StringsOffset
		
		; Copy the bytes of all the program/section headers into the ELF buffer after the ELF header
		;  (Which will line up with the offsets written into the header above)
		
		i64 GlobalBytes := this->DataProgramHeader->MemorySize
		i64 GlobalPages := GlobalBytes / 0x1000
		
		if (GlobalBytes % 0x1000) {
			GlobalPages += 1
		}
		
		if (this->DataProgramHeader) {
			; Update the data segment/section. Todo: If 1kb of globals are used, push the code segment back
			this->DataProgramHeader->VirtualAddress := ImageBase + 0x1000
			this->DataProgramHeader->PhysicalAddress := PhysicalImageBase + 0x1000
			this->DataSectionHeader->VirtualAddress := ImageBase + 0x1000
		}
		
		; Update the code segment+section with the code file offset, and entry-point
		; Note: the code segment is loaded with the `CodeOffset` offset since AMD64 ELF requires the file offset
		;  and virtual address to be equal modulo 1024
		i64 ImageBaseToCode := 0x1000 + (GlobalPages * 0x1000) + CodeOffset

		i64 CodeBase := ImageBase + ImageBaseToCode
		i64 PhysicalCodeBase := PhysicalImageBase + ImageBaseToCode
		
		i64 EntryPoint := CodeBase + MainOffset
		
		this->Header->EntryPoint := EntryPoint
		this->CodeProgramHeader->FileOffset := CodeOffset
		this->CodeProgramHeader->VirtualAddress := CodeBase
		this->CodeProgramHeader->PhysicalAddress := PhysicalCodeBase
		this->CodeSectionHeader->FileOffset := CodeOffset
		this->CodeSectionHeader->VirtualAddress := CodeBase
		
		ELFProgramHeader* ProgramHeadersBuffer := (ByteBuffer + ProgramHeadersOffset) As ELFProgramHeader*
		ELFSectionHeader* SectionHeadersBuffer := (ByteBuffer + SectionHeadersOffset) As ELFSectionHeader*
		
		i32 NextDataSectionOffset := ExtraOffset
		
		for (Index := 0, Index < SectionHeaderCount, Index += 1) {
			NextSectionHeader := this->SectionHeaders->At(Index)
			
			if (NextSectionHeader->Flags = ELF_SECTION_FLAGS_HAS_DATA) {
				NextSectionHeader->FileOffset := NextDataSectionOffset
	
				MoveMemory(&ByteBuffer[NextDataSectionOffset], NextSectionHeader->VirtualAddress As void*, NextSectionHeader->FileSize As i32)
				
				NextSectionHeader->VirtualAddress := ImageBase + NextDataSectionOffset
				NextSectionHeader->Flags := 0

				NextDataSectionOffset += NextSectionHeader->FileSize As i32
			}
			
			MoveMemory(SectionHeadersBuffer[Index], NextSectionHeader, #ELFSectionHeader)
		}

		for (Index := 0, Index < ProgramHeaderCount, Index += 1) {
			ELFProgramHeader* NextProgramHeader := this->ProgramHeaders->At(Index)
			
			MoveMemory(ProgramHeadersBuffer[Index], NextProgramHeader, #ELFProgramHeader)
		}
		
		MoveMemory(&ByteBuffer[StringsOffset], this->StringBuffer, StringSectionSize)
		MoveMemory(&ByteBuffer[CodeOffset], this->CodeBuffer, CodeSize)
	}
}
