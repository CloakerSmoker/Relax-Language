


define void SetupAssembly(ParserState* Parser) {
	HashMap* I := Parser~>Instructions
	
	I->Initialize()
	I->IgnoreCase := true
	
	Instruction* PackedInstruction := {Instruction file: "./build/Instructions.bin"}
	
	loop {
		InstructionListEntry* NewListHead := Alloc(#InstructionListEntry)
		MoveMemory(NewListHead~>Instruction, PackedInstruction, #Instruction)
		
		HashMapElement* OldListHeadElement := I->Get(PackedInstruction~>Name)
		
		if (OldListHeadElement) {
			InstructionListEntry* OldListHead := OldListHeadElement->Value
			
			NewListHead->Next := OldListHead
		}
		
		I->Set(PackedInstruction~>Name, NewListHead)
		
		PackedInstruction := PackedInstruction->Next()
		
		if (PackedInstruction->PackedOpcode = 0) {
			break
		}
	}
}

define Instruction* FindInstruction(ParserState* Parser, SafeWideString* Name, i32 EncodedOperands) {
	HashMapElement* ListHeadElement := Parser~>Instructions->Get(Name)
	
	if !(ListHeadElement) {
		return 0 As Instruction*
	}
	
	InstructionListEntry* ListHead := ListHeadElement->Value As InstructionListEntry*
	
	while (ListHead) {
		Instruction* Instruction := ListHead~>Instruction
		
		if (EncodedOperands = 0) {
			if (Instruction->OperandMask = 0) {
				return Instruction
			}
		}
		else if (Instruction->OperandMask & EncodedOperands = EncodedOperands) {
			return Instruction
		}
		
		ListHead := ListHead->Next
	}
	
	return 0 As Instruction*
}

define i32 LookupRegister(ParserState* Parser, Token* NameToken, i8 RequiredSize, i8** ErrorMessage) {
	i8* InvalidName := "Invalid register name."
	
	i32 RegisterSize := 0
	i32 RegisterNumber := 0
	
	SafeWideString* NameString := NameToken->StringValue
	
	/* Any one register name is maximum four characters long. */
	if (NameString->Length > 4) {
		*ErrorMessage := InvalidName
		return 0
	}
	
	i8 FirstCharacter := NameString->ASCIICharacterAt(0, ' ')
	i8 SecondCharacter := NameString->ASCIICharacterAt(1, ' ')
	
	i32 Offset := 0
	
	i8 SecondIsNumber := IsNumber(SecondCharacter)
	
	if (FirstCharacter = 'r') {
		/* All RDD registers must start with an R */
		
		if (SecondIsNumber) {
			/* If the character after the 'R' is number */
			
			if (SecondCharacter = '8' || SecondCharacter = '9') {
				/* If it is R8 or R9, we can set RegisterNumber, since there is no R80+ or R90+ */
				
				Offset += 1
				RegisterNumber := SecondCharacter - '0'
			}
			else if (SecondCharacter = '1') {
				/* Else we can skip past the '1' before 0-5, since it doesn't help us get the number */
				
				Offset += 2
			}
		}
		else {
			/* If this is not an RDD register, then the 'r' prefix means it is 64 bit */
			
			Offset += 1
			RegisterSize := 8
		}
	}
	else if (FirstCharacter = 'e' && !SecondIsNumber) {
		/* If the first character is a 'e', then it means the following register is 32 bit */
		
		Offset += 1
		RegisterSize := 4
	}
	
	FirstCharacter := NameString->ASCIICharacterAt(Offset, ' ')
	SecondCharacter := NameString->ASCIICharacterAt(Offset + 1, ' ')
	
	if (IsNumber(FirstCharacter)) {
		/* RDD, DD = digits */
		
		if !(RegisterNumber) {
			/* R8 and R9 are resolved above, so we need to get 10-15 here (FirstCharacter = 0-5) */
			RegisterNumber := (FirstCharacter - '0') + 10
		}
		
		/* Advance past the register number+suffix */
		Offset += 2
		
		/* RDD register sizes are denoted by the b/w/d suffix, with no suffix for 64 bit */
		if (SecondCharacter = 'b') {
			RegisterSize := 1
		}
		else if (SecondCharacter = 'w') {
			RegisterSize := 2
		}
		else if (SecondCharacter = 'd') {
			RegisterSize := 4
		}
		else {
			/* No suffix, backtrack by one */
			Offset -= 1
			RegisterSize := 8
		}
	}
	else if ((FirstCharacter = 's' || FirstCharacter = 'b') && SecondCharacter = 'p') {
		/* For sp/bp */
		
		Offset += 2 /* Advance past the register name */
		RegisterNumber := 4 + (FirstCharacter = 'b') /* Numbers 4 and 5, 4 for SP, 5 for BP */
		
		SecondCharacter := NameString->ASCIICharacterAt(Offset, ' ')
		
		if !(RegisterSize) {
			/* Custom 'x' suffix for the word version of each */
			if (SecondCharacter = 'x') {
				Offset += 1
				RegisterSize := 2
			}
			else {
				/* sp/bp = 8 bit, spx/bpx = 16 bit, esp/ebp = 32 bit, rsp/rbp = 64 bit */
				RegisterSize := 1
			}
		}
	}
	else if ((FirstCharacter = 's' || FirstCharacter = 'd') && SecondCharacter = 'i') {
		/* For si/di */
		
		Offset += 2 /* Advance past the register name */
		RegisterNumber := 6 + (FirstCharacter = 'd') /* Numbers 6 and 7, 6 for SI, 7 for DI */
		
		SecondCharacter := NameString->ASCIICharacterAt(Offset, ' ')
		
		if !(RegisterSize) {
			/* Custom 'x' suffix for the word version of each */
			if (SecondCharacter = 'x') {
				Offset += 1
				RegisterSize := 2
			}
			else {
				/* si/di = 8 bit, six/dix = 16 bit, esi/edi = 32 bit, rsi/rdi = 64 bit */
				RegisterSize := 1
			}
		}
	}
	else if (FirstCharacter >= 'a' && FirstCharacter <= 'd') {
		/* a-d registers */
		
		Offset += 1
		
		if (SecondCharacter = 'x') {
			/* The 'x' suffix, either for a eOx/rOx/Ox combo. Since E/R are handled, we can use RegisterSize to decide 16 bit or not */
			
			if !(RegisterSize) {
				RegisterSize := 2
			}
			
			Offset += 1
		}
		else if !(RegisterSize) {
			RegisterSize := 1
		}
		
		if (FirstCharacter = 'a') {
			RegisterNumber := 0
		}
		else if (FirstCharacter = 'b') {
			RegisterNumber := 3
		}
		else if (FirstCharacter = 'c') {
			RegisterNumber := 1
		}
		else if (FirstCharacter = 'd') {
			RegisterNumber := 2
		}
	}
	else {
		*ErrorMessage := InvalidName
	}
	
	if (RegisterSize = 0) {
		*ErrorMessage := InvalidName
	}
	else if (Offset != NameString->Length) {
		*ErrorMessage := "Malformed register name."
	}
	else if (RequiredSize && (RegisterSize != RequiredSize)) {
		*ErrorMessage := "Incorrect register size."
	}
	
	return RegisterNumber | (RegisterSize << 8)
}
define i32 LookupRegister(ParserState* Parser, Token* NameToken, i8 RequiredSize) {
	i8* ErrorMessage := null
	i32 Result := LookupRegister(Parser, NameToken, RequiredSize, &ErrorMessage)
	
	if (ErrorMessage != null) {
		TokenError(NameToken, ErrorMessage)
	}
	
	return Result
}



define InstructionOperand* ParseAssemblyOperand(ParserState* Parser, AssemblyBlock* ThisBlock) {
	InstructionOperand* Next := Alloc(#InstructionOperand)
	
	Token* NextToken := ParserNextToken(Parser)
	
	if (TokenMatches(NextToken, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
		/* A memory reference, through a register or SIB (plus displacements) */
		
		Token* MaybeBase := Consume(Parser, TOKEN_TYPE_IDENTIFIER, 0, "Expected register name.")
		
		if (ParserNextMatches(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET)) {
			/* Register[ = SIB, so parse the SIB */
			
			Next->HasSIB := true
			Next->SIBValue.BaseRegister := LookupRegister(Parser, MaybeBase, 8) As i8
			
			Token* Index := Consume(Parser, TOKEN_TYPE_IDENTIFIER, 0, "Expected index register name.")
			
			Next->SIBValue.IndexRegister := LookupRegister(Parser, Index, 8) As i8
			
			if (ParserNextMatches(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_STAR)) {
				Token* Scale := Consume(Parser, TOKEN_TYPE_INTEGER, 0, "Expected scale value.")
				i64 ScaleValue := Scale->IntegerValue
				
				if (ScaleValue = 8 || ScaleValue = 4 || ScaleValue = 2 || ScaleValue = 1) {
					Next->SIBValue.Scale := ScaleValue As i8
				}
				else {
					TokenError(Scale, "Invalid scale value.")
				}
			}
			
			Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected closing ']' for SIB.")
		}
		else {
			/* No [ following the register, just a regular register reference */
			
			Next->RegisterNumber := LookupRegister(Parser, MaybeBase, 8) As i8
		}
		
		i8 IsPlus := ParserNextMatches(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_PLUS)
		i8 IsMinus := false
		
		if !(IsPlus) {
			IsMinus := ParserNextMatches(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_MINUS)
		}
		
		/* If the next token is + or -, then parse the displacement */
		if (IsPlus || IsMinus) {
			Token* DispToken := Consume(Parser, TOKEN_TYPE_INTEGER, 0, "Expected displacement value.")
			i8 DispSize := GetNumberSize(DispToken->IntegerValue)
			
			if (DispSize > 4) {
				/* 64 bit displacements are invalid */
				TokenError(DispToken, "Displacement too big, must be 1-4 bytes.")
			}
			else if (DispSize = 2) {
				/* 16 bit displacements are just 32 bit displacements with some padding */
				DispSize := 4
			}
			
			Next->DispSize := DispSize
			Next->DispValue := DispToken->IntegerValue As i32
			
			if (IsMinus) {
				Next->DispValue := 0 - (Next->DispValue)
			}
		}
		
		Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing brace for operand.")
		Consume(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_AS, "Expected 'as' for memory operand size.")
		
		Token* TypeNameToken := Consume(Parser, TOKEN_TYPE_IDENTIFIER, 0, "Expected memory operand type name.")
		Token* PointerStar := Consume(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_STAR, "Expected '*' after operand type name.")
		
		MergeContexts(NextToken~>Context, PointerStar~>Context, Next~>Context)
		
		SafeWideString* TypeName := TypeNameToken->StringValue
		
		i32 I := TypeName->ASCIICharacterAt(0, ' ') /* i i i i */
		i32 L := TypeName->ASCIICharacterAt(1, ' ') /* 8 1 3 6 */
		i32 R := TypeName->ASCIICharacterAt(2, ' ') /*   6 2 4 */
		
		i32 NameCharacters := I | (L << 8) | (R << 16)
		
		if (NameCharacters = 'i8 ') {
			Next->Type := OP_M8
		}
		else if (NameCharacters = 'i16') {
			Next->Type := OP_M16
		}
		else if (NameCharacters = 'i32') {
			Next->Type := OP_M32
		}
		else if (NameCharacters = 'i64') {
			Next->Type := OP_M64
		}
		else {
			TokenError(TypeNameToken, "Unknown memory operand type name.")
		}
		
		Next->Size := Next->Type << OP_M_OFFSET
	}
	else if (TokenMatches(NextToken, TOKEN_TYPE_IDENTIFIER, 0)) {
		i8* Error := null
		
		i32 Register := LookupRegister(Parser, NextToken, 0, &Error)
		
		if (Error != null) {
			Next->Type := O_L
			
			SafeWideString* LabelName := NextToken->StringValue
			
			HashMapElement* FoundLabelElement := ThisBlock~>Labels->Get(LabelName)
			InstructionNode* FoundLabel := 0
			
			if (FoundLabelElement) {
				FoundLabel := FoundLabelElement->Value As InstructionNode*
			}
			else {
				FoundLabel := Alloc(#InstructionNode)
				
				FoundLabel->Type := INSTRUCTION_LABEL_INCOMPLETE
				FoundLabel->LabelName := LabelName
				FoundLabel->LabelNumber := ParserNextLabel(Parser)
				
				ThisBlock~>Labels->Set(LabelName, FoundLabel)
			}
			
			Next->LabelNumber := FoundLabel->LabelNumber
		}
		else {
			Next->Size := ((Register >> 8) & 0x0F)
			Next->Type := Next->Size << OP_R_OFFSET
			
			Next->RegisterNumber := Register & 0x0F
		}
		
		CopyContext(NextToken~>Context, Next~>Context)
	}
	else if (TokenMatches(NextToken, TOKEN_TYPE_INTEGER, 0)) {
		/* Integer types are OP_I8 - OP_I64, are defined as 1,2,4,8 bit shifted left by 9 */
		
		Next->Size := GetNumberSize(NextToken->IntegerValue)
		Next->Type := Next->Size << OP_I_OFFSET
		
		Next->IntegerValue := NextToken->IntegerValue
		CopyContext(NextToken~>Context, Next~>Context)
	}
	else if (TokenMatches(NextToken, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_AT)) {
		Next->Type := O_L
		Next->ReferencesFunction := true
		
		Token* FunctionToken := Consume(Parser, TOKEN_TYPE_IDENTIFIER, 0, "Expected label name.")
		SafeWideString* FunctionName := FunctionToken->StringValue
		
		HashMapElement* FoundFunction := Parser~>Functions->Get(FunctionName)
		
		if !(FoundFunction) {
			TokenError(FunctionToken, "Function definition/declaration not found.")
		}
		
		FunctionDefine* FoundDefine := (FoundFunction->Value) As FunctionDefine*
		
		Next->FunctionReference := FoundDefine
		
		MergeContexts(NextToken~>Context, FunctionToken~>Context, Next~>Context)
	}
	else {
		TokenError(NextToken, "Unexpected token.")
	}
	
	return Next
}

define InstructionNode* ParseInstruction(ParserState* Parser, AssemblyBlock* ThisBlock) {
	Token* InstructionToken := Consume(Parser, TOKEN_TYPE_IDENTIFIER, 0, "Expected instruction name.")
	SafeWideString* InstructionName := InstructionToken->StringValue
	
	if (ParserNextMatches(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_COLON)) {
		HashMapElement* FoundLabelElement := ThisBlock~>Labels->Get(InstructionName)
		InstructionNode* FoundLabel := 0
		
		if (FoundLabelElement) {
			FoundLabel := FoundLabelElement->Value As InstructionNode*
			
			if (FoundLabel->Type != INSTRUCTION_LABEL_INCOMPLETE) {
				TokenError(InstructionToken, "Duplicate label definition")
			}
		}
		else {
			FoundLabel := Alloc(#InstructionNode)
			FoundLabel->LabelNumber := ParserNextLabel(Parser)
			
			ThisBlock~>Labels->Set(InstructionName, FoundLabel)
		}
		
		FoundLabel->Type := INSTRUCTION_LABEL
		FoundLabel->LabelName := InstructionName
		
		return FoundLabel
	}
	else {
		InstructionNode* Result := Alloc(#InstructionNode)
		
		i32 OperandTypes := 0
		i32 OperandSize := 0
		InstructionOperand** Operands := Alloc(2 * #InstructionOperand)
		
		if (ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
			for (i32 OperandIndex := 0, OperandIndex < 2, OperandIndex += 1) {
				InstructionOperand* Next := ParseAssemblyOperand(Parser, ThisBlock)
				i32 NextType := Next->Type
				
				if !(OperandSize) {
					OperandSize := Next->Size
				}
				else if (Next->Size != OperandSize) {
					if (NextType & O_I) {
						Next->Type := OperandSize << OP_I_OFFSET
					}
					else {
						SwapOutputStream()
						
						Print("Incompatible operand sizes, expected a %i bit operand, got a %i bit operand.\n", OperandSize * 8, Next->Size * 8)
						
						ContextError(Next~>Context, null)
					}
				}
				
				Operands[OperandIndex] := Next
				
				OperandTypes := OperandTypes | (Next->Type << (16 * OperandIndex As i8))
				
				if !(ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
					break
				}
			}
			
			MergeContexts(InstructionToken~>Context, Next~>Context, Result~>Context)
		}
		else {
			CopyContext(InstructionToken~>Context, Result~>Context)
		}
		
		Instruction* Found := FindInstruction(Parser, InstructionName, OperandTypes)
		
		if !(Found) {
			SwapOutputStream()
			
			Print("No encoding for operand type(s).\n")
			
			ContextError(Result~>Context, null)
		}
		
		i32 LowType := OperandTypes & 0xFFFF
		i32 HighType := (OperandTypes >> 16) & 0xFFFF
		
		if ((LowType & OP_R) && (HighType & OP_R)) {
			if !(Found->Flags & E_DIF_SIZES) {
				if (LowType != HighType) {
					ContextError(Result~>Context, "Incompatible operand types.")
				}
			}
		}
		
		Result->Base := Found
		Result->Operands := Operands
		
		return Result
	}
}

define ASTNode* ParseAssembly(ParserState* Parser, i8 InFunction) {
	AssemblyBlock* ThisBlock := Alloc(#AssemblyBlock)
	
	ThisBlock~>Labels->Initialize()
	
	if (InFunction && ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)) {
		loop {
			Token* RegisterNameToken := Consume(Parser, TOKEN_TYPE_IDENTIFIER, 0, "Expected register name")
			i32 TargetRegister := LookupRegister(Parser, RegisterNameToken, 0) & 0x0F
			
			Consume(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL, "Expected register value assignment")
			
			ThisBlock~>RegisterValues[TargetRegister] := ParseExpression(Parser, 0)
			
			if !(ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
				break
			}
		}
		
		Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing ')' for register value list")
	}
	
	InstructionNode** Instructions := Alloc(16 * #InstructionNode)
	i32 InstructionCapacity := 16
	i32 InstructionCount := 0
	
	Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open '{' for assembly block.")
	
	loop {
		if (InstructionCount >= InstructionCapacity) {
			InstructionCapacity += 16
			Instructions := ReAlloc(Instructions, InstructionCapacity * #InstructionNode)
		}
		
		Instructions[InstructionCount] := ParseInstruction(Parser, ThisBlock)
		InstructionCount += 1
		
		if (ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
			break
		}
	}
	
	ThisBlock->Instructions := Instructions
	ThisBlock->InstructionCount := InstructionCount
	
	return ASTNode:New(NODE_TYPE_ASSEMBLY, ThisBlock, TYPE_NONE)
}