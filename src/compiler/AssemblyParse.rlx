
/* Operand type flags, R = register, M = register indirect or SIB (with a disp on either) */

i8 OP_M_OFFSET := 0
i32 OP_M8 := 0x1
i32 OP_M16 := 0x2
i32 OP_M32 := 0x4
i32 OP_M64 := 0x8

i8 OP_R_OFFSET := 4
i32 OP_R8 := 0x10
i32 OP_R16 := 0x20
i32 OP_R32 := 0x40
i32 OP_R64 := 0x80

i8 OP_I_OFFSET := 8
i32 OP_I8 := 0x100
i32 OP_I16 := 0x200
i32 OP_I32 := 0x400
i32 OP_I64 := 0x800
i32 OP_LABEL := 0x1000

i32 OP_M := OP_M8 | OP_M16 | OP_M32 | OP_M64
i32 OP_R := OP_R8 | OP_R16 | OP_R32 | OP_R64
i32 OP_HR := OP_R16 | OP_R32 | OP_R64

/* Prepacked operand types */
i32 O_M := OP_R | OP_M 				/* Register or memory reference */
i32 O_RM := OP_R | (O_M << 16)		/* RM encoding */
i32 O_MR := O_M | (OP_R << 16)		/* MR encoding */
i32 O_I := OP_I8 | OP_I16 | OP_I32 	/* Imm8,Imm16,Imm32 encoding */
i32 O_MI := O_M | (O_I << 16) 		/* MI encoding */
i32 O_L := OP_LABEL					/* rel32 encoding, references a label */

struct Instruction {
	Instruction* Next,
	i16 Opcode,
	i16 Flags,
	i8 Extra,
	i32 EncodingMask
}

i32 E_NO_RM := 0x1				/* The instruction does not use the ModRM byte */
i32 E_RM_IS_OP1 := 0x2			/* The RM field of the ModRM byte encodes the first operand */
i32 E_RM_IS_OP2 := 0x4			/* The RM field of the ModRM byte encodes the second operand */
i32 E_OP_EXT := 0x8				/* The Reg field of the ModRM byte is an opcode extension contained in Instruction.Extra */
i32 E_IMM8 := 0x10				/* Encode a 8 bit immediate value */
i32 E_IMM32 := 0x20				/* Encode a 32 bit immediate value */
i32 E_IMM64 := 0x40				/* Encode a 64 bit immediate value */
i32 E_REG_IN_OPCODE := 0x80		/* Encode the register operand in the opcode */
i32 E_DIF_SIZES := 0x100 		/* Allow two different register sizes to be used */
i32 E_BYTE_OPCODE_N1 := 0x200 	/* The byte opcode for this instruction is not the regular opcode minus 1 */
i32 E_IMM_X := 0x400			/* The immediate operand is the size of the operand  */
i32 E_LABEL := 0x800			/* The operand is a label */
i32 E_2_BYTE_OPCODE := 0x1000 	/* The instruction has a two byte opcode */
i32 E_REX_W := 0x2000			/* The instruction needs REX.W */
i32 E_NEEDS_66 := 0x3000		/* The instruction needs the 0x66 prefix */

i32 E_1OP_WEXT := E_RM_IS_OP1 | E_OP_EXT	/* The instruction has one operand, and an opcode extension */
i32 E_CJMP := E_2_BYTE_OPCODE | E_LABEL		/* The instruction is a conditional jump */

define Instruction* MakeInstruction(Instruction* Base, i32 Opcode, i32 Encoding, i32 Flags, i8 Extra) {
	Instruction* Next := Alloc(#Instruction)
	
	Next->Opcode := Opcode As i16
	Next->EncodingMask := Encoding
	Next->Flags := Flags As i16
	Next->Extra := Extra
	
	if (Base) {
		while (Base->Next) {
			Base := Base->Next
		}
		
		Base->Next := Next
	}
	
	return Next
}

define void SetupAssembly(ParserState* pState) {
	HashMap* I := NewHashMap()
	pState->Instructions := I
	
	I->IgnoreCase := true
	
	/* Ret */
	HashMapASet(I, "ret", MakeInstruction(null, 0xC3, 0, E_NO_RM, 0))
	
	/* Not */
	HashMapASet(I, "not", MakeInstruction(null, 0xF7, O_M, E_1OP_WEXT, 2)) /* Not, memory */
	
	/* Neg */
	HashMapASet(I, "neg", MakeInstruction(null, 0xF7, O_M, E_1OP_WEXT, 3)) /* Neg, memory */
	
	/* And */
	Instruction* And := MakeInstruction(null, 0x23, O_RM, E_RM_IS_OP2, 0) /* And, register, memory  */
	MakeInstruction(And, 0x20, O_MR, E_RM_IS_OP1, 0) /* And, memory, register */
	MakeInstruction(And, 0x80, O_MI, E_RM_IS_OP1 | E_IMM8 | E_OP_EXT, 4) /* And, memory, byte */
	MakeInstruction(And, 0x81, O_MI, E_RM_IS_OP1 | E_IMM32 | E_OP_EXT, 4) /* And, memory, dword */
	HashMapASet(I, "and", And)
	
	/* Mov */
	Instruction* Mov := MakeInstruction(null, 0xC7, O_MI, E_RM_IS_OP1 | E_IMM_X | E_OP_EXT, 0) /* Mov, register, <i32 */
	MakeInstruction(Mov, 0xB8, O_M | (OP_I64 << 16), E_NO_RM | E_REG_IN_OPCODE | E_IMM64, 0) /* Mov, register, i64 */
	MakeInstruction(Mov, 0x8B, O_RM, E_RM_IS_OP2, 0) /* Mov, register, memory */
	MakeInstruction(Mov, 0x89, O_MR, E_RM_IS_OP1, 0) /* Mov, memory, register */
	HashMapASet(I, "mov", Mov)
	
	/* Inc */
	HashMapASet(I, "inc", MakeInstruction(null, 0xFF, O_M, E_1OP_WEXT, 0)) /* Inc, memory */
	
	/* Dec */
	HashMapASet(I, "dec", MakeInstruction(null, 0xFF, O_M, E_1OP_WEXT, 1)) /* Dec, memory */
	
	/* Jumps (including conditionals) */
	
	/* Jmp */
	Instruction* Jmp := MakeInstruction(null, 0xE9, O_L, E_LABEL, 0) /* Jmp, :label */
	MakeInstruction(Jmp, 0xFF, O_M, E_1OP_WEXT, 4) /* Jmp, register */
	HashMapASet(I, "jmp", Jmp)
	
	/* Je */
	Instruction* JE := MakeInstruction(null, 0x0F84, O_L, E_CJMP, 0)
	HashMapASet(I, "je", JE)
	HashMapASet(I, "jz", JE)
	
	/* Jcc */
	HashMapASet(I, "jgt", MakeInstruction(null, 0x0F8F, O_L, E_CJMP, 0))
	HashMapASet(I, "jge", MakeInstruction(null, 0x0F8D, O_L, E_CJMP, 0))
	HashMapASet(I, "jlt", MakeInstruction(null, 0x0F8C, O_L, E_CJMP, 0))
	HashMapASet(I, "jle", MakeInstruction(null, 0x0F8E, O_L, E_CJMP, 0))
	
	/* Jne */
	Instruction* JNE := MakeInstruction(null, 0x0F85, O_L, E_CJMP, 0)
	HashMapASet(I, "jne", JNE)
	HashMapASet(I, "jnz", JNE)
	
	/* Call */
	Instruction* Call := MakeInstruction(null, 0xE8, O_L, E_LABEL, 0) /* Call, :label */
	MakeInstruction(Call, 0xFF, OP_M64 | OP_R64, E_1OP_WEXT, 2) /* Call, memory64 */
	HashMapASet(I, "call", Call)
	
	
	/* Comparisons */
	
	/* Test */
	Instruction* Test := MakeInstruction(null, 0xF7, O_M | (O_I << 16), E_1OP_WEXT, 0) /* Test, memory, immX */
	MakeInstruction(Test, 0x85, O_MR, E_RM_IS_OP1, 0) /* Test, memory, register */
	HashMapASet(I, "test", Test)
	
	Instruction* Cmp := MakeInstruction(null, 0x83, (OP_HR | OP_M) | (OP_I8 << 16), E_RM_IS_OP1, 0)
	
	/* Misc (again) */

	/* XChg */
	Instruction* XChg := MakeInstruction(null, 0x87, O_MR, E_RM_IS_OP1, 0) /* XChg, memory, register */
	MakeInstruction(XChg, 0x87, O_RM, E_RM_IS_OP2, 0) /* XChg, register, memory */
	HashMapASet(I, "xchg", XChg) /* Yes, I know both of these encode to the same thing, but I'm not adding another encoding flag just for this single instruction where operand order doesn't matter */
	
	/* IRet */
	HashMapASet(I, "iret", MakeInstruction(null, 0xCF, 0, E_NO_RM | E_REX_W, 0))
	
	/* Lea */
	HashMapASet(I, "lea", MakeInstruction(null, 0x8D, O_RM, E_RM_IS_OP2, 0))
	
	/* Xor */
	Instruction* Xor := MakeInstruction(null, 0x81, O_MI, E_RM_IS_OP1 | E_IMM_X | E_OP_EXT, 6)
	MakeInstruction(Xor, 0x31, O_MR, E_RM_IS_OP1, 0)
	MakeInstruction(Xor, 0x33, O_RM, E_RM_IS_OP2, 0)
	HashMapASet(I, "xor", Xor)
	
	/* Stack */
	
	/* Push */
	Instruction* Push := MakeInstruction(null, 0x50, OP_R64, E_REG_IN_OPCODE | E_NO_RM, 0)
	MakeInstruction(Push, 0xFF, OP_M64 | OP_R64, E_1OP_WEXT, 6)
	HashMapASet(I, "push", Push)
	
	/* Pop */
	Instruction* Pop := MakeInstruction(null, 0x58, OP_R64, E_REG_IN_OPCODE | E_NO_RM, 0)
	MakeInstruction(Pop, 0x8F, OP_M64 | OP_R64, E_1OP_WEXT, 0)
	HashMapASet(I, "pop", Pop)
	
	/* IO */
	
	/* In */
	HashMapASet(I, "inb", MakeInstruction(null, 0xEC, 0, E_NO_RM, 0))
	HashMapASet(I, "inw", MakeInstruction(null, 0xED, 0, E_NO_RM | E_NEEDS_66, 0))
	HashMapASet(I, "ind", MakeInstruction(null, 0xED, 0, E_NO_RM, 0))
	
	/* Out */
	HashMapASet(I, "outb", MakeInstruction(null, 0xEE, 0, E_NO_RM, 0))
	HashMapASet(I, "outw", MakeInstruction(null, 0xEF, 0, E_NO_RM | E_NEEDS_66, 0))
	HashMapASet(I, "outd", MakeInstruction(null, 0xEF, 0, E_NO_RM, 0))
	
	/* Uh */
	
	HashMapASet(I, "lidt", MakeInstruction(null, 0x0F01, OP_M64, E_1OP_WEXT | E_2_BYTE_OPCODE, 3))
	HashMapASet(I, "cli", MakeInstruction(null, 0xFA, 0, E_NO_RM, 0))
	HashMapASet(I, "sti", MakeInstruction(null, 0xFB, 0, E_NO_RM, 0))
	
	/* Prefixes (which are actually considered instr */
}

define Instruction* FindInstruction(ParserState* pState, SafeWideString* Name, i32 EncodedOperands) {
	HashMapElement* FoundBaseElement := HashMapGetValue(pState->Instructions, Name)
	
	if !(FoundBaseElement) {
		return 0 As Instruction*
	}
	
	Instruction* FoundBase := FoundBaseElement->Value As Instruction*
	
	while (FoundBase) {
		if (EncodedOperands = 0) {
			if (FoundBase->EncodingMask = 0) {
				return FoundBase
			}
		}
		else if (FoundBase->EncodingMask & EncodedOperands = EncodedOperands) {
			return FoundBase
		}
		
		FoundBase := FoundBase->Next
	}
	
	return 0 As Instruction*
}

define i8 GetCharacter(SafeWideString* NameString, i32 CharacterIndex) {
	if (CharacterIndex >= NameString->Length) {
		return ' '
	}
	
	return NameString->Buffer[CharacterIndex] As i8
}

define i32 LookupRegister(ParserState* pState, Token* NameToken, i8 RequiredSize) {
	i8* InvalidName := "Invalid register name."
	
	i32 RegisterSize := 0
	i32 RegisterNumber := 0
	
	SafeWideString* NameString := NameToken->StringValue
	
	/* Any one register name is maximum four characters long. */
	if (NameString->Length > 4) {
		TokenError(NameToken, InvalidName)
	}
	
	i8 FirstCharacter := GetCharacter(NameString, 0)
	i8 SecondCharacter := GetCharacter(NameString, 1)
	
	i32 Offset := 0
	
	i8 SecondIsNumber := IsNumber(SecondCharacter)
	
	if (FirstCharacter = 'r') {
		/* All RDD registers must start with an R */
		
		if (SecondIsNumber) {
			/* If the character after the 'R' is number */
			
			if (SecondCharacter = '8' || SecondCharacter = '9') {
				/* If it is R8 or R9, we can set RegisterNumber, since there is no R80+ or R90+ */
				
				Offset += 1
				RegisterNumber := SecondCharacter - '0'
			}
			else if (SecondCharacter = '1') {
				/* Else we can skip past the '1' before 0-5, since it doesn't help us get the number */
				
				Offset += 2
			}
		}
		else {
			/* If this is not an RDD register, then the 'r' prefix means it is 64 bit */
			
			Offset += 1
			RegisterSize := 8
		}
	}
	else if (FirstCharacter = 'e' && !SecondIsNumber) {
		/* If the first character is a 'e', then it means the following register is 32 bit */
		
		Offset += 1
		RegisterSize := 4
	}
	
	FirstCharacter := GetCharacter(NameString, Offset)
	SecondCharacter := GetCharacter(NameString, Offset + 1)
	
	if (IsNumber(FirstCharacter)) {
		/* RDD, DD = digits */
		
		if !(RegisterNumber) {
			/* R8 and R9 are resolved above, so we need to get 10-15 here (FirstCharacter = 0-5) */
			RegisterNumber := (FirstCharacter - '0') + 10
		}
		
		/* Advance past the register number+suffix */
		Offset += 2
		
		/* RDD register sizes are denoted by the b/w/d suffix, with no suffix for 64 bit */
		if (SecondCharacter = 'b') {
			RegisterSize := 1
		}
		else if (SecondCharacter = 'w') {
			RegisterSize := 2
		}
		else if (SecondCharacter = 'd') {
			RegisterSize := 4
		}
		else {
			/* No suffix, backtrack by one */
			Offset -= 1
			RegisterSize := 8
		}
	}
	else if ((FirstCharacter = 's' || FirstCharacter = 'b') && SecondCharacter = 'p') {
		/* For sp/bp */
		
		Offset += 2 /* Advance past the register name */
		RegisterNumber := 4 + (FirstCharacter = 'b') /* Numbers 4 and 5, 4 for SP, 5 for BP */
		
		SecondCharacter := GetCharacter(NameString, Offset)
		
		if !(RegisterSize) {
			/* Custom 'x' suffix for the word version of each */
			if (SecondCharacter = 'x') {
				Offset += 1
				RegisterSize := 2
			}
			else {
				/* sp/bp = 8 bit, spx/bpx = 16 bit, esp/ebp = 32 bit, rsp/rbp = 64 bit */
				RegisterSize := 1
			}
		}
	}
	else if ((FirstCharacter = 's' || FirstCharacter = 'd') && SecondCharacter = 'i') {
		/* For si/di */
		
		Offset += 2 /* Advance past the register name */
		RegisterNumber := 6 + (FirstCharacter = 'd') /* Numbers 6 and 7, 6 for SI, 7 for DI */
		
		SecondCharacter := GetCharacter(NameString, Offset)
		
		if !(RegisterSize) {
			/* Custom 'x' suffix for the word version of each */
			if (SecondCharacter = 'x') {
				Offset += 1
				RegisterSize := 2
			}
			else {
				/* si/di = 8 bit, six/dix = 16 bit, esi/edi = 32 bit, rsi/rdi = 64 bit */
				RegisterSize := 1
			}
		}
	}
	else if (FirstCharacter >= 'a' && FirstCharacter <= 'd') {
		/* a-d registers */
		
		Offset += 1
		
		if (SecondCharacter = 'x') {
			/* The 'x' suffix, either for a eOx/rOx/Ox combo. Since E/R are handled, we can use RegisterSize to decide 16 bit or not */
			
			if !(RegisterSize) {
				RegisterSize := 2
			}
			
			Offset += 1
		}
		else if !(RegisterSize) {
			RegisterSize := 1
		}
		
		if (FirstCharacter = 'a') {
			RegisterNumber := 0
		}
		else if (FirstCharacter = 'b') {
			RegisterNumber := 3
		}
		else if (FirstCharacter = 'c') {
			RegisterNumber := 1
		}
		else if (FirstCharacter = 'd') {
			RegisterNumber := 2
		}
	}
	else {
		TokenError(NameToken, InvalidName)
	}
	
	if (RegisterSize = 0) {
		TokenError(NameToken, InvalidName)
	}
	else if (Offset != NameString->Length) {
		TokenError(NameToken, "Malformed register name.")
	}
	else if (RequiredSize && (RegisterSize != RequiredSize)) {
		TokenError(NameToken, "Incorrect register size.")
	}
	
	return RegisterNumber | (RegisterSize << 8)
}

struct SIBInfo {
	i8 BaseRegister,
	i8 IndexRegister,
	i8 Scale
}

struct InstructionOperand {
	ErrorContext Context,
	
	i32 Type,
	i32 Size,
	i8 HasSIB,
	i8 DispSize,
	
	union {
		i8 RegisterNumber,
		SIBInfo SIBValue
	},
	
	union {
		i32 DispValue,
		i64 IntegerValue,
		i32 LabelNumber
	}
}

struct AssemblyBlock {
	i32 InstructionCount,
	InstructionNode** Instructions,
	HashMap* Labels
}

i8 INSTRUCTION_REGULAR := 0
i8 INSTRUCTION_LABEL := 1
i8 INSTRUCTION_LABEL_INCOMPLETE := 2

struct InstructionNode {
	ErrorContext Context,
	i8 Type,
	
	union {
		Instruction* Base,
		SafeWideString* LabelName
	},
	
	union {
		InstructionOperand** Operands,
		i32 LabelNumber
	}
}

define InstructionOperand* ParseAssemblyOperand(ParserState* pState, AssemblyBlock* ThisBlock) {
	InstructionOperand* Next := Alloc(#InstructionOperand)
	
	Token* NextToken := ParserNextToken(pState)
	
	if (TokenMatches(NextToken, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
		/* A memory reference, through a register or SIB (plus displacements) */
		
		Token* MaybeBase := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Expected register name.")
		
		if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET)) {
			/* Register[ = SIB, so parse the SIB */
			
			Next->HasSIB := true
			Next->SIBValue.BaseRegister := LookupRegister(pState, MaybeBase, 8) As i8
			
			Token* Index := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Expected index register name.")
			
			Next->SIBValue.IndexRegister := LookupRegister(pState, Index, 8) As i8
			
			if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_STAR)) {
				Token* Scale := Consume(pState, TOKEN_TYPE_INTEGER, 0, "Expected scale value.")
				i64 ScaleValue := Scale->IntegerValue
				
				if (ScaleValue = 8 || ScaleValue = 4 || ScaleValue = 2 || ScaleValue = 1) {
					Next->SIBValue.Scale := ScaleValue As i8
				}
				else {
					TokenError(Scale, "Invalid scale value.")
				}
			}
			
			Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected closing ']' for SIB.")
		}
		else {
			/* No [ following the register, just a regular register reference */
			
			Next->RegisterNumber := LookupRegister(pState, MaybeBase, 8) As i8
		}
		
		i8 IsPlus := ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_PLUS)
		i8 IsMinus := false
		
		if !(IsPlus) {
			IsMinus := ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_MINUS)
		}
		
		/* If the next token is + or -, then parse the displacement */
		if (IsPlus || IsMinus) {
			Token* DispToken := Consume(pState, TOKEN_TYPE_INTEGER, 0, "Expected displacement value.")
			i8 DispSize := GetNumberSize(DispToken->IntegerValue)
			
			if (DispSize > 4) {
				/* 64 bit displacements are invalid */
				TokenError(DispToken, "Displacement too big, must be 1-4 bytes.")
			}
			else if (DispSize = 2) {
				/* 16 bit displacements are just 32 bit displacements with some padding */
				DispSize := 4
			}
			
			Next->DispSize := DispSize
			Next->DispValue := DispToken->IntegerValue As i32
			
			if (IsMinus) {
				Next->DispValue := 0 - (Next->DispValue)
			}
		}
		
		Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing brace for operand.")
		Consume(pState, TOKEN_TYPE_OPERATOR, OPERATOR_AS, "Expected 'as' for memory operand size.")
		
		Token* TypeNameToken := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Expected memory operand type name.")
		Token* PointerStar := Consume(pState, TOKEN_TYPE_OPERATOR, OPERATOR_STAR, "Expected '*' after operand type name.")
		
		MergeContexts(NextToken~>Context, PointerStar~>Context, Next~>Context)
		
		SafeWideString* TypeName := TypeNameToken->StringValue
		
		i32 I := GetCharacter(TypeName, 0) /* i/i/i/i */
		i32 L := GetCharacter(TypeName, 1) /* 8/1/3/6 */
		i32 R := GetCharacter(TypeName, 2) /*  /6/2/4 */
		
		i32 NameCharacters := I | (L << 8) | (R << 16)
		
		if (NameCharacters = 'i8 ') {
			Next->Type := OP_M8
		}
		else if (NameCharacters = 'i16') {
			Next->Type := OP_M16
		}
		else if (NameCharacters = 'i32') {
			Next->Type := OP_M32
		}
		else if (NameCharacters = 'i64') {
			Next->Type := OP_M64
		}
		else {
			TokenError(TypeNameToken, "Unknown memory operand type name.")
		}
		
		Next->Size := Next->Type << OP_M_OFFSET
	}
	else if (TokenMatches(NextToken, TOKEN_TYPE_IDENTIFIER, 0)) {
		i32 Register := LookupRegister(pState, NextToken, 0)
		
		Next->Size := ((Register >> 8) & 0x0F)
		Next->Type := Next->Size << OP_R_OFFSET
		
		Next->RegisterNumber := Register & 0x0F
		
		CopyContext(NextToken~>Context, Next~>Context)
	}
	else if (TokenMatches(NextToken, TOKEN_TYPE_INTEGER, 0)) {
		/* Integer types are OP_I8 - OP_I64, are defined as 1,2,4,8 bit shifted left by 9 */
		
		Next->Size := GetNumberSize(NextToken->IntegerValue)
		Next->Type := Next->Size << OP_I_OFFSET
		
		Next->IntegerValue := NextToken->IntegerValue
		CopyContext(NextToken~>Context, Next~>Context)
	}
	else if (TokenMatches(NextToken, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_AT)) {
		Next->Type := O_L
		
		Token* FunctionToken := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Expected label name.")
		SafeWideString* FunctionName := FunctionToken->StringValue
		
		HashMapElement* FoundFunction := HashMapGetValue(pState->Functions, FunctionName)
		
		if !(FoundFunction) {
			TokenError(FunctionToken, "Function definition/declaration not found.")
		}
		
		FunctionDefine* FoundDefine := (FoundFunction->Value) As FunctionDefine*
		
		FoundDefine->CallCount += 1
		
		Next->LabelNumber := FoundDefine->LabelNumber
		
		MergeContexts(NextToken~>Context, FunctionToken~>Context, Next~>Context)
	}
	else if (TokenMatches(NextToken, TOKEN_TYPE_OPERATOR, OPERATOR_COLON)) {
		Next->Type := O_L
		
		Token* LabelToken := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Expected label name.")
		SafeWideString* LabelName := LabelToken->StringValue
		
		HashMapElement* FoundLabelElement := HashMapGetValue(ThisBlock->Labels, LabelName)
		InstructionNode* FoundLabel := 0
		
		if (FoundLabelElement) {
			FoundLabel := FoundLabelElement->Value As InstructionNode*
		}
		else {
			FoundLabel := Alloc(#InstructionNode)
			
			FoundLabel->Type := INSTRUCTION_LABEL_INCOMPLETE
			FoundLabel->LabelName := LabelName
			FoundLabel->LabelNumber := ParserNextLabel(pState)
		}
		
		Next->LabelNumber := FoundLabel->LabelNumber
		
		MergeContexts(NextToken~>Context, LabelToken~>Context, Next~>Context)
	}
	else {
		TokenError(NextToken, "Unexpected token.")
	}
	
	return Next
}

define InstructionNode* ParseInstruction(ParserState* pState, AssemblyBlock* ThisBlock) {
	InstructionNode* Result := 0
	
	if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_COLON)) {
		Token* LabelToken := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Expected label name.")
		SafeWideString* LabelName := LabelToken->StringValue
		
		HashMapElement* FoundLabelElement := HashMapGetValue(ThisBlock->Labels, LabelName)
		InstructionNode* FoundLabel := 0
		
		if (FoundLabelElement) {
			FoundLabel := FoundLabelElement->Value As InstructionNode*
			
			if (FoundLabel->Type != INSTRUCTION_LABEL_INCOMPLETE) {
				TokenError(LabelToken, "Duplicate label definition")
			}
		}
		else {
			FoundLabel := Alloc(#InstructionNode)
			FoundLabel->LabelNumber := ParserNextLabel(pState)
			
			HashMapAddValue(ThisBlock->Labels, LabelName, FoundLabel)
		}
		
		FoundLabel->Type := INSTRUCTION_LABEL
		FoundLabel->LabelName := LabelName
		
		Result := FoundLabel
	}
	else {
		Result := Alloc(#InstructionNode)
		
		Token* InstructionToken := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Expected instruction name.")
		SafeWideString* InstructionName := InstructionToken->StringValue
		
		i32 OperandTypes := 0
		i32 OperandSize := 0
		InstructionOperand** Operands := Alloc(2 * #InstructionOperand)
		
		if (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
			for (i32 OperandIndex := 0, OperandIndex < 2, OperandIndex += 1) {
				InstructionOperand* Next := ParseAssemblyOperand(pState, ThisBlock)
				i32 NextType := Next->Type
				
				if !(OperandSize) {
					OperandSize := Next->Size
				}
				else if (Next->Size != OperandSize) {
					if (NextType & O_I) {
						Next->Type := OperandSize << OP_I_OFFSET
					}
					else {
						SwapOutputStream()
						
						Print("Incompatible operand sizes, expected a %i bit operand, got a %i bit operand.\n", OperandSize * 8, Next->Size * 8)
						
						/* AWrite("Incompatible operand size, expected a ")
						IWrite(OperandSize * 8)
						AWrite(" bit operand, got a ")
						IWrite(Next->Size * 8)
						AWriteLine(" bit operand.") */
						
						ContextError(Next~>Context, null)
					}
				}
				
				Operands[OperandIndex] := Next
				
				OperandTypes := OperandTypes | (Next->Type << (16 * OperandIndex As i8))
				
				if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
					break
				}
			}
			
			MergeContexts(InstructionToken~>Context, Next~>Context, Result~>Context)
		}
		else {
			CopyContext(InstructionToken~>Context, Result~>Context)
		}
		
		Instruction* Found := FindInstruction(pState, InstructionName, OperandTypes)
		
		if !(Found) {
			SwapOutputStream()
			/* IWriteHexLine(OperandTypes) */
			Print("No encoding for operand type(s).")
			
			ContextError(Result~>Context, null)
		}
		
		i32 LowType := OperandTypes & 0xFFFF
		i32 HighType := (OperandTypes >> 16) & 0xFFFF
		
		if ((LowType & OP_R) && (HighType & OP_R)) {
			if !(Found->Flags & E_DIF_SIZES) {
				if (LowType != HighType) {
					ContextError(Result~>Context, "Incompatible operand types.")
				}
			}
		}
		
		Result->Base := Found
		Result->Operands := Operands
	}
	
	return Result
}

define ASTNode* ParseAssembly(ParserState* pState) {
	AssemblyBlock* ThisBlock := Alloc(#AssemblyBlock)
	
	ThisBlock->Labels := NewHashMap()
	
	InstructionNode** Instructions := Alloc(16 * #InstructionNode)
	i32 InstructionCapacity := 16
	i32 InstructionCount := 0
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open '{' for assembly block.")
	
	loop {
		if (InstructionCount >= InstructionCapacity) {
			InstructionCapacity += 16
			Instructions := ReAlloc(Instructions, InstructionCapacity * #InstructionNode)
		}
		
		Instructions[InstructionCount] := ParseInstruction(pState, ThisBlock)
		InstructionCount += 1
		
		if (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
			break
		}
	}
	
	ThisBlock->Instructions := Instructions
	ThisBlock->InstructionCount := InstructionCount
	
	return AllocateNewASTNode(NODE_TYPE_ASSEMBLY, ThisBlock As void*, TYPE_NONE)
}