
/* Operand type flags, R = register, M = register indirect or SIB (with a disp on either) */

i32 OP_M := 1
i32 OP_R8 := 2
i32 OP_R16 := 4
i32 OP_R32 := 8
i32 OP_R64 := 16
i32 OP_I8 := 32
i32 OP_I16 := 64
i32 OP_I32 := 128
i32 OP_I64 := 256

i32 OP_R := OP_R8 | OP_R16 | OP_R32 | OP_R64

/* Prepacked operand types */
i32 O_M := OP_R | OP_M 			/* Register or memory reference */
i32 O_RM := OP_R | (O_M << 16)	/* RM encoding */
i32 O_MR := O_M | (OP_R << 16)	/* MR encoding */
i32 O_I := OP_I8 | OP_I16 | OP_I32 /* Imm8,Imm16,Imm32 encoding */
i32 O_MI := O_M | (O_I << 16) 	/* MI encoding */

struct Instruction {
	Instruction* Next,
	i8 Opcode,
	i16 Flags,
	i8 Extra,
	i32 EncodingMask
}

i16 E_NO_RM := 1			/* The instruction does not use the ModRM byte */
i16 E_RM_IS_OP1 := 2		/* The RM field of the ModRM byte encodes the first operand */
i16 E_RM_IS_OP2 := 4		/* The RM field of the ModRM byte encodes the second operand */
i16 E_OP_EXT := 8			/* The Reg field of the ModRM byte is an opcode extension contained in Instruction.Extra */
i16 E_IMM8 := 16			/* Encode a 8 bit immediate value */
i16 E_IMM32 := 32			/* Encode a 32 bit immediate value */
i16 E_IMM64 := 64			/* Encode a 64 bit immediate value */
i16 E_REG_IN_OPCODE := 128	/* Encode the register operand in the opcode */
i16 E_DIF_SIZES := 256 		/* Allow two different register sizes to be used */
i16 E_BYTE_OPCODE_N1 := 512 /* The byte opcode for this instruction is not the regular opcode minus 1 */
i16 E_IMM_X := 1024			/* The immediate operand is the size of the operand  */

define Instruction* MakeInstruction(Instruction* Base, i16 Opcode, i32 Encoding, i16 Flags, i8 Extra) {
	Instruction* Next := Alloc(#Instruction)
	
	Next->Opcode := Opcode As i8
	Next->EncodingMask := Encoding
	Next->Flags := Flags
	Next->Extra := Extra
	
	if (Base) {
		while (Base->Next) {
			Base := Base->Next
		}
		
		Base->Next := Next
	}
	
	return Next
}

define void SetupAssembly(ParserState* pState) {
	HashMap* I := NewHashMap()
	pState->Instructions := I
	
	I->IgnoreCase := true
	
	HashMapASet(I, "not", MakeInstruction(0, 0xF7, O_M, E_RM_IS_OP1 | E_OP_EXT, 2)) /* Not, memory */
	HashMapASet(I, "neg", MakeInstruction(0, 0xF7, O_M, E_RM_IS_OP1 | E_OP_EXT, 3)) /* Neg, memory */
	
	Instruction* And := MakeInstruction(0, 0x23, O_RM, E_RM_IS_OP2, 0) /* And, register, memory  */
	MakeInstruction(And, 0x20, O_MR, E_RM_IS_OP1, 0) /* And, memory, register */
	MakeInstruction(And, 0x80, O_MI, E_RM_IS_OP1 | E_IMM8 | E_OP_EXT, 4) /* And, memory, byte */
	MakeInstruction(And, 0x81, O_MI, E_RM_IS_OP1 | E_IMM32 | E_OP_EXT, 4) /* And, memory, dword */
	
	HashMapASet(I, "and", And)
	
	Instruction* Mov := MakeInstruction(0, 0xC7, O_MI, E_RM_IS_OP1 | E_IMM_X | E_OP_EXT, 0) /* Mov, register, <i32 */
	MakeInstruction(Mov, 0xB8, O_M | (OP_I64 << 16), E_NO_RM | E_REG_IN_OPCODE | E_IMM64, 0) /* Mov, register, i64 */
	MakeInstruction(Mov, 0x8B, O_RM, E_RM_IS_OP2, 0) /* Mov, register, memory */
	MakeInstruction(Mov, 0x89, O_MR, E_RM_IS_OP1, 0) /* Mov, memory, register */
	
	HashMapASet(I, "mov", Mov)
}

define Instruction* FindInstruction(ParserState* pState, SafeWideString* Name, i32 EncodedOperands) {
	HashMapElement* FoundBaseElement := HashMapGetValue(pState->Instructions, Name)
	
	if !(FoundBaseElement) {
		return 0 As Instruction*
	}
	
	Instruction* FoundBase := FoundBaseElement->Value As Instruction*
	
	while (FoundBase) {
		if (FoundBase->EncodingMask = 0 && EncodedOperands = 0) {
			return FoundBase
		}
		else if (EncodedOperands = 0) {
			/* Dummy branch */
		}
		else if ((FoundBase->EncodingMask & EncodedOperands) = EncodedOperands) {
			return FoundBase
		}
		
		FoundBase := FoundBase->Next
	}
	
	return 0 As Instruction*
}

define i8 GetCharacter(SafeWideString* NameString, i32 CharacterIndex) {
	if (CharacterIndex >= NameString->Length) {
		return ' '
	}
	
	return NameString->Buffer[CharacterIndex] As i8
}

define i32 LookupRegister(ParserState* pState, Token* NameToken, i8 RequiredSize) {
	i8* InvalidName := "Invalid register name."
	
	i32 RegisterSize := 0
	i32 RegisterNumber := 0
	
	SafeWideString* NameString := NameToken->StringValue
	
	/* Any one register name is maximum four characters long. */
	if (NameString->Length > 4) {
		TokenError(NameToken, InvalidName)
	}
	
	i8 FirstCharacter := GetCharacter(NameString, 0)
	i8 SecondCharacter := GetCharacter(NameString, 1)
	
	i32 Offset := 0
	
	if (FirstCharacter = 'r') {
		/* All RDD registers must start with an R */
		
		if (IsNumber(SecondCharacter)) {
			/* If the character after the 'R' is number */
			
			if (SecondCharacter = '8' || SecondCharacter = '9') {
				/* If it is R8 or R9, we can set RegisterNumber, since there is no R80+ or R90+ */
				
				Offset += 1
				RegisterNumber := SecondCharacter - '0'
			}
			else if (SecondCharacter = '1') {
				/* Else we can skip past the '1' before 0-5, since it doesn't help us get the number */
				
				Offset += 2
			}
		}
		else {
			/* If this is not an RDD register, then the 'r' prefix means it is 64 bit */
			
			Offset += 1
			RegisterSize := 8
		}
	}
	else if (FirstCharacter = 'e' && !IsNumber(SecondCharacter)) {
		/* If the first character is a 'e', then it means the following register is 32 bit */
		
		Offset += 1
		RegisterSize := 4
	}
	
	FirstCharacter := GetCharacter(NameString, Offset)
	SecondCharacter := GetCharacter(NameString, Offset + 1)
	
	if (IsNumber(FirstCharacter)) {
		/* RDD, DD = digits */
		
		if !(RegisterNumber) {
			/* R8 and R9 are resolved above, so we need to get 10-15 here (FirstCharacter = 0-5) */
			RegisterNumber := (FirstCharacter - '0') + 10
		}
		
		/* Advance past the register number+suffix */
		Offset += 2
		
		/* RDD register sizes are denoted by the b/w/d suffix, with no suffix for 64 bit */
		if (SecondCharacter = 'b') {
			RegisterSize := 1
		}
		else if (SecondCharacter = 'w') {
			RegisterSize := 2
		}
		else if (SecondCharacter = 'd') {
			RegisterSize := 4
		}
		else {
			/* No suffix, backtrack by one */
			Offset -= 1
			RegisterSize := 8
		}
	}
	else if ((FirstCharacter = 's' || FirstCharacter = 'd') && SecondCharacter = 'i') {
		/* For si/di */
		
		Offset += 2 /* Advance past the register name */
		RegisterNumber := 6 + (FirstCharacter = 'd') /* Numbers 6 and 7, 6 for SI, 7 for DI */
		
		SecondCharacter := GetCharacter(NameString, Offset)
		
		if !(RegisterSize) {
			/* Custom 'x' suffix for the word version of each */
			if (SecondCharacter = 'x') {
				Offset += 1
				RegisterSize := 1
			}
			else {
				/* si/di = 8 bit, six/dix = 16 bit, esi/edi = 32 bit, rsi/rdi = 64 bit */
				RegisterSize := 2
			}
		}
	}
	else if (FirstCharacter >= 'a' && FirstCharacter <= 'd') {
		/* a-d registers */
		
		Offset += 1
		
		if (SecondCharacter = 'x') {
			/* The 'x' suffix, either for a eOx/rOx/Ox combo. Since E/R are handled, we can use RegisterSize to decide 16 bit or not */
			
			if !(RegisterSize) {
				RegisterSize := 2
			}
			
			Offset += 1
		}
		else if !(RegisterSize) {
			RegisterSize := 1
		}
		
		if (FirstCharacter = 'a') {
			RegisterNumber := 0
		}
		else if (FirstCharacter = 'b') {
			RegisterNumber := 3
		}
		else if (FirstCharacter = 'c') {
			RegisterNumber := 1
		}
		else if (FirstCharacter = 'd') {
			RegisterNumber := 2
		}
	}
	else {
		TokenError(NameToken, InvalidName)
	}
	
	if (RegisterSize = 0) {
		TokenError(NameToken, InvalidName)
	}
	else if (Offset != NameString->Length) {
		TokenError(NameToken, "Malformed register name.")
	}
	else if (RequiredSize && (RegisterSize != RequiredSize)) {
		TokenError(NameToken, "Incorrect register size.")
	}
	
	return RegisterNumber | (RegisterSize << 8)
}

struct SIBInfo {
	i8 BaseRegister,
	i8 IndexRegister,
	i8 Scale
}

struct InstructionOperand {
	ErrorContext Context,
	
	i32 Type,
	i8 HasSIB,
	i8 DispSize,
	
	union {
		i8 RegisterNumber,
		SIBInfo SIBValue
	},
	
	union {
		i32 DispValue,
		i64 IntegerValue
	}
}

define InstructionOperand* ParseAssemblyOperand(ParserState* pState) {
	InstructionOperand* Next := Alloc(#InstructionOperand)
	
	Token* NextToken := ParserNextToken(pState)
	
	if (TokenMatches(NextToken, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
		/* A memory reference, through a register or SIB (plus displacements) */
		Next->Type := OP_M
		
		Token* MaybeBase := Consume(pState, TOKEN_TYPE_IDENTIFER, 0, "Expected register name.")
		
		if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET)) {
			/* Register[ = SIB, so parse the SIB */
			
			Next->HasSIB := true
			Next->SIBValue.BaseRegister := LookupRegister(pState, MaybeBase, 8) As i8
			
			Token* Index := Consume(pState, TOKEN_TYPE_IDENTIFER, 0, "Expected index register name.")
			
			Next->SIBValue.IndexRegister := LookupRegister(pState, Index, 8) As i8
			
			if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_STAR)) {
				Token* Scale := Consume(pState, TOKEN_TYPE_INTEGER, 0, "Expected scale value.")
				i64 ScaleValue := Scale->IntegerValue
				
				if (ScaleValue = 8 || ScaleValue = 4 || ScaleValue = 2 || ScaleValue = 1) {
					Next->SIBValue.Scale := ScaleValue As i8
				}
				else {
					TokenError(Scale, "Invalid scale value.")
				}
			}
			
			Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected closing ']' for SIB.")
		}
		else {
			/* No [ following the register, just a regular register reference */
			
			Next->RegisterNumber := LookupRegister(pState, MaybeBase, 8) As i8
		}
		
		i8 IsPlus := ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_PLUS)
		i8 IsMinus := false
		
		if !(IsPlus) {
			IsMinus := ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_MINUS)
		}
		
		/* If the next token is + or -, then parse the displacement */
		if (IsPlus || IsMinus) {
			Token* DispToken := Consume(pState, TOKEN_TYPE_INTEGER, 0, "Expected displacement value.")
			i8 DispSize := GetNumberSize(DispToken->IntegerValue)
			
			if (DispSize > 4) {
				/* 64 bit displacements are invalid */
				TokenError(DispSize, "Displacement too big, must be 1-4 bytes.")
			}
			else if (DispSize = 2) {
				/* 16 bit displacements are just 32 bit displacements with some padding */
				DispSize := 4
			}
			
			Next->DispSize := DispSize
			Next->DispValue := DispToken->IntegerValue As i32
			
			if (IsMinus) {
				Next->DispValue := 0 - (Next->DispValue)
			}
		}
		
		Token* CloseBrace := Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing brace for operand.")
		
		MergeContexts(NextToken~>Context, CloseBrace~>Context, Next~>Context)
	}
	else if (TokenMatches(NextToken, TOKEN_TYPE_IDENTIFER, 0)) {
		i32 Register := LookupRegister(pState, NextToken, 0)
		
		Next->Type := ((Register >> 8) & 0xFF) << 1
		Next->RegisterNumber := Register & 0xFF
		
		CopyContext(NextToken~>Context, Next~>Context)
	}
	else if (TokenMatches(NextToken, TOKEN_TYPE_INTEGER, 0)) {
		/* Integer types are OP_I8 - OP_I64, are defined as 1,2,4,8 bit shifted left by 5 */
		
		Next->Type := GetNumberSize(NextToken->IntegerValue) << 5
		
		Next->IntegerValue := NextToken->IntegerValue
		CopyContext(NextToken~>Context, Next~>Context)
	}
	else {
		TokenError(NextToken, "Unexpected token.")
	}
	
	return Next
}

i8 INSTRUCTION_REGULAR := 0
i8 INSTRUCTION_LABEL := 1

struct InstructionNode {
	ErrorContext Context,
	i8 Type,
	
	union {
		Instruction* Base,
		SafeWideString* LabelName
	},
	
	union {
		InstructionOperand** Operands,
		i32 LabelNumber
	}
}

struct AssemblyBlock {
	i32 InstructionCount,
	InstructionNode** Instructions,
	HashMap* Labels
}

define InstructionNode* ParseInstruction(ParserState* pState, AssemblyBlock* ThisBlock) {
	InstructionNode* Result := Alloc(#InstructionNode)
	
	if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_COLON)) {
		Token* LabelToken := Consume(pState, TOKEN_TYPE_IDENTIFER, 0, "Expected label name.")
		SafeWideString* LabelName := LabelToken->StringValue
		
		if (HashMapGetValue(ThisBlock->Labels, LabelName)) {
			TokenError(LabelToken, "Duplicate label definition")
		}
		
		Result->Type := INSTRUCTION_LABEL
		Result->LabelName := LabelName
		Result->LabelNumber := ParserNextLabel(pState)
		
		HashMapAddValue(ThisBlock->Labels, LabelName, Result As void)
	}
	else {
		Token* InstructionToken := Consume(pState, TOKEN_TYPE_IDENTIFER, 0, "Expected instruction name.")
		SafeWideString* InstructionName := InstructionToken->StringValue
		
		i32 OperandTypes := 0
		InstructionOperand** Operands := Alloc(2 * #ASTNode)
		
		if (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
			for (i32 OperandIndex := 0, OperandIndex < 2, OperandIndex += 1) {
				InstructionOperand* Next := ParseAssemblyOperand(pState)
				
				Operands[OperandIndex] := Next
				
				OperandTypes := OperandTypes | (Next->Type << (16 * OperandIndex As i8))
				
				if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
					break
				}
			}
			
			MergeContexts(InstructionToken~>Context, Next~>Context, Result~>Context)
		}
		else {
			CopyContext(InstructionToken~>Context, Result~>Context)
		}
		
		Instruction* Found := FindInstruction(pState, InstructionName, OperandTypes)
		
		if !(Found) {
			SwapOutputStream()
			IWriteHexLine(OperandTypes)
			AWriteLine("No encoding for operand type(s).")
			
			ContextError(Result~>Context, 0)
		}
		
		i32 LowType := OperandTypes & 0xFFFF
		i32 HighType := (OperandTypes >> 16) & 0xFFFF
		
		if ((LowType & OP_R) && (HighType & OP_R)) {
			if !(Found->Flags & E_DIF_SIZES) {
				if (LowType != HighType) {
					ContextError(Result~>Context, "Incompatible operand types.")
				}
			}
		}
		
		Result->Base := Found
		Result->Operands := Operands
	}
	
	return Result
}

define ASTNode* ParseAssembly(ParserState* pState) {
	AssemblyBlock* ThisBlock := Alloc(#AssemblyBlock)
	
	ThisBlock->Labels := NewHashMap()
	
	InstructionNode** Instructions := Alloc(16 * #InstructionNode)
	i32 InstructionCapacity := 16
	i32 InstructionCount := 0
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open '{' for assembly block.")
	
	loop {
		if (InstructionCount >= InstructionCapacity) {
			InstructionCapacity += 16
			Instructions := ReAlloc(Instructions, InstructionCapacity * #InstructionNode)
		}
		
		Instructions[InstructionCount] := ParseInstruction(pState, ThisBlock)
		InstructionCount += 1
		
		if (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
			break
		}
	}
	
	ThisBlock->Instructions := Instructions
	ThisBlock->InstructionCount := InstructionCount
	
	return AllocateNewASTNode(NODE_TYPE_ASSEMBLY, ThisBlock As void*, TYPE_NONE)
}