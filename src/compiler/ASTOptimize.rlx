
declare void CountReferencesVisitFunction(ASTVisitor*, FunctionDefine*)

define void CountReferencesVisitAssembly(ASTVisitor* Visitor, AssemblyBlock* Target) {
	for (i32 InstructionIndex := 0, InstructionIndex < Target->InstructionCount, InstructionIndex += 1) {
		InstructionNode* NextInstruction := Target->Instructions[InstructionIndex]
		
		if (NextInstruction->Type = INSTRUCTION_REGULAR) {
			for (i32 OperandIndex := 0, OperandIndex < 2, OperandIndex += 1) {
				InstructionOperand* NextOperand := NextInstruction->Operands[OperandIndex]
				
				if (NextOperand != null && NextOperand->ReferencesFunction) {
					CountReferencesVisitFunction(Visitor, NextOperand->FunctionReference)
				}
			}
		}
	}
}

define void CountReferencesVisitFunction(ASTVisitor* Visitor, FunctionDefine* Target) {
	Target->CallCount += 1
	
	if (Target->IsImported = false) {
		if (Target->Attribute = KEYWORD_ASSEMBLY) {
			CountReferencesVisitAssembly(Visitor, Target->AssemblyBody)
		}
		else {
			Visitor->VisitBlocks(Target->Body)
		}
	}
}

define i8 IsAssignment(Token* OperatorToken) {
	i8 Operator := OperatorToken->Value As i8
	
	return (OPERATOR_FIRST_ASSIGNMENT <= Operator && Operator <= OPERATOR_LAST_ASSIGNMENT)
}

define void CountReferencesVisit(ASTVisitor* Visitor, ASTNode* Node) {
	i8 NodeType := Node->NodeType
	
	if (NodeType = NODE_TYPE_CALL) {
		CallExpression* CallNode := Node->CallNode
		
		if (CallNode->BuiltinID = BUILTIN_NONE) {
			CountReferencesVisitFunction(Visitor, CallNode->TargetFunction)
		}
		
		Visitor->RawVisitNodes(CallNode->ParameterCount, CallNode->Parameters)
	}
	else if (NodeType = NODE_TYPE_UNARY) {
		UnaryExpression* UnaryNode := Node->UnaryNode
		ASTNode* Operand := UnaryNode->Operand
		
		if (UnaryNode->Operator->Value = OPERATOR_AND) {
			if (Operand->NodeType = NODE_TYPE_DEFINE) {
				CountReferencesVisitFunction(Visitor, Operand->DefineNode)
			}
			else if (Operand->NodeType = NODE_TYPE_VARIABLE) {
				Operand->VariableValue->SetCount += 1
			}
		}
		
		Visitor->VisitNodes(Operand)
	}
	else if (NodeType = NODE_TYPE_BINARY) {
		ASTNode* Left := Node->BinaryNode->Left
		ASTNode* Right := Node->BinaryNode->Right
		Token* BinaryOperator := Node->BinaryNode->Operator
		
		if (Left->NodeType = NODE_TYPE_VARIABLE && IsAssignment(BinaryOperator)) {
			VariableInfo* LeftVariable := Left->VariableValue
			
			if (BinaryOperator->Value != OPERATOR_COLON_EQUAL) {
				LeftVariable->GetCount += 1
			}
			
			LeftVariable->SetCount += 1
			LeftVariable->LastValue := Right
			
			if (Right->NodeType = NODE_TYPE_CALL) {
				LeftVariable->SetCount += 1
			}
			
			Visitor->VisitNodes(Right)
		}
		else {
			Visitor->VisitChildren(Node)
		}
	}
	else if (NodeType = NODE_TYPE_VARIABLE) {
		Node->VariableValue->GetCount += 1
	}
	else if (NodeType = NODE_TYPE_ASSEMBLY) {
		CountReferencesVisitAssembly(Visitor, Node->AssemblyValue)
	}
}

define void CountReferences(ParserState* pState) {
	ASTVisitor* Visitor := Alloc(#ASTVisitor)
	
	Visitor->AllowType(NODE_TYPE_CALL)
	Visitor->AllowType(NODE_TYPE_UNARY)
	Visitor->AllowType(NODE_TYPE_BINARY)
	Visitor->AllowType(NODE_TYPE_VARIABLE)
	Visitor->AllowType(NODE_TYPE_ASSEMBLY)
	
	Visitor->SetVisitFunction(&CountReferencesVisit)
	
	Visitor->VisitBlocks(pState->MainFunction->Body)
	Visitor->RawVisitNodes(GetArrayLength(pState->GlobalDefaults), pState->GlobalDefaults)
	
	pState->MainFunction->CallCount += 1
	
	Free(Visitor)
}

define void NodeHasSideEffectsVisitor(ASTVisitor* Visitor, ASTNode* Node) {
	i8 NodeType := Node->NodeType
	
	if (NodeType = NODE_TYPE_CALL || NodeType = NODE_TYPE_STRUCT_ACCESS) {
		Visitor->SetState(true)
	}
	else if (NodeType = NODE_TYPE_UNARY) {
		UnaryExpression* UnaryNode := Node->UnaryNode
		ASTNode* Operand := UnaryNode->Operand
		
		if (UnaryNode->Operator->Value = OPERATOR_STAR) {
			Visitor->SetState(true)
		}
		
		Visitor->VisitNodes(Operand)
	}
	else if (NodeType = NODE_TYPE_BINARY) {
		ASTNode* Left := Node->BinaryNode->Left
		ASTNode* Right := Node->BinaryNode->Right
		
		i8 Operator := Node->BinaryNode->Operator->Value
		
		if (Operator = OPERATOR_OPEN_BRACKET) {
			Visitor->SetState(true)
		}
		
		Visitor->VisitChildren(Node)
	}
}

define i8 NodeHasSideEffects(ASTNode* Node) {
	ASTVisitor* Visitor := Alloc(#ASTVisitor)
	
	Visitor->AllowType(NODE_TYPE_CALL)
	Visitor->AllowType(NODE_TYPE_UNARY)
	Visitor->AllowType(NODE_TYPE_BINARY)
	Visitor->AllowType(NODE_TYPE_STRUCT_ACCESS)
	
	Visitor->SetVisitFunction(&NodeHasSideEffectsVisitor)
	
	Visitor->VisitNodes(Node)
	
	i8 Result := Visitor->GetState() As i8
	
	Free(Visitor)
	
	return Result
}

define void EliminateGlobals(VariableHashMap* Globals) {
	HashMap* RawGlobals := Globals->Map
	
	void* Elements := RawGlobals->Elements
	i32 MaxIndex := RawGlobals->BufferMaxCount
	
	i32 NewNextOffset := 0
	
	for (i32 ElementIndex := 0, ElementIndex < MaxIndex, ElementIndex += 1) {
		if (Elements[ElementIndex]) {
			HashMapElement* FoundElement := Elements[ElementIndex] As HashMapElement*
			
			while (FoundElement) {
				VariableInfo* NextGlobal := FoundElement->Value
				
				if (NextGlobal->SetCount = 1 && NextGlobal->LastValue != null) {
					if !(NodeHasSideEffects(NextGlobal->LastValue)) {
						NextGlobal->IsGlobal := GLOBAL_IS_OPTIMIZED_AWAY
					}
				}
				
				if (NextGlobal->IsGlobal != GLOBAL_IS_OPTIMIZED_AWAY) {
					NextGlobal->StackOffset := NewNextOffset
					
					i16 NextGlobalSize := GetTypeStorageSize(NextGlobal->Type)
					
					if (NextGlobalSize <= 8) {
						NewNextOffset += 8
					}
					else {
						i16 RoundedSize := RoundTo(NextGlobalSize, 8) As i16
						
						NewNextOffset += RoundedSize + 8
					}
				}
				
				FoundElement := FoundElement->NextElement
			}
		}
	}
	
	Globals->NextOffset := NewNextOffset
}