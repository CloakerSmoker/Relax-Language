define void PushIX(CompilerState* cState, i64 Number, i8 Size) {
	if (Size = 1) {PushByte(cState, Number As i8)}
	else if (Size = 2) {PushI16(cState, Number As i16)}
	else if (Size = 4) {PushI32(cState, Number As i32)}
	else {PushI64(cState, Number)}
}
define void PushOpcode(CompilerState* cState, Instruction* I) {
	if (I->Flags & E_2_BYTE_OPCODE) {
		PushByte(cState, (I->Opcode >> 8) & 0xFF As i16)
		PushByte(cState, I->Opcode & 0xFF As i16)
	}
	else {
		PushByte(cState, I->Opcode)
	}
}

define void EmitAssembly(CompilerState* cState, Instruction* I, InstructionOperand* ForOperand, InstructionOperand* Other) {
	i8 Mode := 0
	i8 Reg := 0
	i8 RM := 0
	i8 REX := REX_BASE
	i8 SIB := 0
	i8 DispSize := 0
	i8 DispValue := 0
	i8 OperationSize := 0
	
	if (ForOperand->Type & OP_R) {
		Mode := 3
		RM := ClampRegisterNumber(ForOperand->RegisterNumber)
		
		if (RegisterRequiresREX(ForOperand->RegisterNumber)) {
			REX := REX | REX_B
		}
		
		OperationSize := (ForOperand->Type) >> OP_R_OFFSET
	}
	else {
		/* OP_MX map directly to 1/2/4/8, so the OperationSize is directly dependent on the type of the memory operand */
		OperationSize := ForOperand->Type As i8
		
		if (ForOperand->HasSIB) {
			SIBInfo* S := ForOperand~>SIBValue
			
			SIB := MakeSIB(S->Scale, ClampRegisterNumber(S->IndexRegister), ClampRegisterNumber(S->BaseRegister))
			
			if (RegisterRequiresREX(S->BaseRegister)) {
				REX := REX | REX_B
			}
			if (RegisterRequiresREX(S->IndexRegister)) {
				REX := REX | REX_X
			}
			
			Mode := 0
			RM := 4
		}
		else {
			RM := ForOperand->RegisterNumber
			
			if (RM = RSP) {
				SIB := MakeSIB(1, RSP, RSP)
			}
		}
		
		if (ForOperand->DispSize) {
			i8 Size := ForOperand->DispSize
			
			if (Size = 1) {
				Mode := 1
			}
			else if (Size = 4) {
				Mode := 2
			}
			
			DispSize := ForOperand->DispSize
			DispValue := ForOperand->DispValue
		}
	}
	
	if (I->Flags & E_OP_EXT) {
		Reg := I->Extra
	}
	else if (Other->Type & OP_R) {
		Reg := ClampRegisterNumber(Other->RegisterNumber)
		
		if (RegisterRequiresREX(Other->RegisterNumber)) {
			REX := REX | REX_R
		}
		
		if !(OperationSize) {
			OperationSize := (Other->Type) >> OP_R_OFFSET
		}
	}
	
	if (OperationSize = 8) {
		/* REX_W for 64 bit operations */
		
		REX := REX | REX_W
	}
	else if (OperationSize = 2) {
		/* 0x66 for 16 bit operations */
		
		EmitLegacySizePrefix(cState)
	}
	
	/* Nothing for 32 bit operations, they are default */
	
	if (OperationSize = 1) {
		/* For byte operations, emit REX_BASE to ensure sil/dil/spl/bpl can be accessed, and not ah/bh/dh/ch */
		
		PushByte(cState, REX | REX_BASE)
	}
	else if (REX != REX_BASE) {
		PushByte(cState, REX)
	}
	
	if (OperationSize = 1 && !(I->Flags & E_BYTE_OPCODE_N1)) {
		PushByte(cState, (I->Opcode - 1) As i16)
	}
	else {
		PushOpcode(cState, I)
	}
	
	EmitModRM(cState, Mode, Reg, RM)
	
	if (RM = 4 && SIB != 0) {
		PushByte(cState, SIB)
	}
	
	if (DispSize = 1) {
		PushByte(cState, DispValue As i8)
	}
	else if (DispSize = 4) {
		PushI32(cState, DispValue)
	}
	
	
	if (I->Flags & E_IMM_X) {
		if (OperationSize = 8) {
			/* Even if we're working with a 64 bit register, the max imm size is 32, since only movabs gets a 64 bit imm */
			
			OperationSize := 4
		}
		
		PushIX(cState, Other->IntegerValue, OperationSize)
	}
	else {
		if (I->Flags & E_IMM8) {
			PushByte(cState, Other->IntegerValue As i8)
		}
		else if (I->Flags & E_IMM32) {
			PushI32(cState, Other->IntegerValue As i32)
		}
	}
}

define void CompileInstruction(CompilerState* cState, InstructionNode* ToCompile) {
	if (ToCompile->Type = INSTRUCTION_LABEL) {
		SetLabel(cState, ToCompile->LabelNumber)
		return 0
	}
	
	InstructionOperand* OperandOne := ToCompile->Operands[0]
	InstructionOperand* OperandTwo := ToCompile->Operands[1]
	InstructionOperand* MemoryOperand := 0
	InstructionOperand* OtherOperand := 0
	
	Instruction* Base := ToCompile->Base
	
	if (Base->Flags & E_RM_IS_OP1) {
		MemoryOperand := OperandOne
		OtherOperand := OperandTwo
	}
	else if (Base->Flags & E_RM_IS_OP2) {
		MemoryOperand := OperandTwo
		OtherOperand := OperandOne
	}
	
	i8 REX := REX_BASE | REX_W
	
	if (MemoryOperand) {
		EmitAssembly(cState, Base, MemoryOperand, OtherOperand)
	}
	else {		
		if (Base->Flags & E_LABEL) {
			if (Base->Flags & E_REX_W) {
				PushByte(cState, REX)
			}
			
			PushOpcode(cState, Base)
			UseLabel(cState, OperandOne->LabelNumber)
		}
		else if (Base->Flags & E_REG_IN_OPCODE) {
			i8 TargetRegister := OperandOne->RegisterNumber
			
			PushByte(cState, REX)
			PushByte(cState, Base->Opcode + ClampRegisterNumber(TargetRegister))
			
			if (Base->Flags & E_IMM8) {
				PushByte(cState, OperandTwo->IntegerValue As i8)
			}
			else if (Base->Flags & E_IMM32) {
				PushI32(cState, OperandTwo->IntegerValue As i32)
			}
			else if (Base->Flags & E_IMM64) {
				PushI64(cState, OperandTwo->IntegerValue)
			}
		}
		else {
			if (Base->Flags & E_REX_W) {
				PushByte(cState, REX)
			}
			
			PushOpcode(cState, Base)
		}
	}
}

define void CompileAssembly(CompilerState* cState, AssemblyBlock* ToCompile) {
	for (i32 InstructionIndex := 0, InstructionIndex < ToCompile->InstructionCount, InstructionIndex += 1) {
		CompileInstruction(cState, ToCompile->Instructions[InstructionIndex])
	}
}