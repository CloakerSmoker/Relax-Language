#Require "$/Memory.rlx"
#Require "$/File.rlx"

#Require "$/String.rlx"
#Require "$/Console.rlx"
#Require "$/SafeString.rlx"
#Require "$/HashMap.rlx"
#Require "$/Debug.rlx"

#Require "$/AVLTree.rlx"

#Require "./src/compiler/IR2/PointerArray.rlx"

#Require "./src/compiler/Utility.rlx"
#Require "./src/compiler/Lexer.rlx"
#Require "./src/compiler/Parser.rlx"

enum TACAddressKind As i8 {
	Variable,
	Temporary,
	Integer
}

enum TACAddressSize As i8 {
	Word,
	Long
}

struct TACVariable {
	VariableInfo* Base
	
	i32 Generation
	
	i64 LastValue
	
	static self* New(VariableInfo* Base) {
		self* this := Alloc(#self)
		
		this->Base := Base
		
		return this
	}
}

bits TACAddress As i64 {
	TACVariable* [0:47] Variable

	i32 [0:32] BlockNumber
	i32 [33:47] InstructionNumber

	i64* [0:47] IntegerPointer
	i64 [0:47] Integer

	void* [0:47] Value
	
	i32 [48:55] Web
	TACAddressKind [56:59] Kind
	TACAddressSize [60:63] Size
	
	define void Web(i32 WebNumber) {
		this->Web := WebNumber
	}
	define i32 Web() {
		return this->Web
	}
	
	static self WrapLong(TACAddressKind Kind, void* Value) {
		self this := 0 As self
		
		this->Kind := Kind
		this->Size := TACAddressSize:Long
		this->Value := Value
		
		return this
	}
	static self WrapLong(TACAddressKind Kind, i64 Value) {
		return self:WrapLong(Kind, Value As void*)
	}
	
	static self WrapWord(TACAddressKind Kind, void* Value) {
		self this := 0 As self
		
		this->Kind := Kind
		this->Size := TACAddressSize:Long
		this->Value := Value
		
		return this
	}
	static self WrapWord(TACAddressKind Kind, i64 Value) {
		return self:WrapWord(Kind, Value As void*)
	}
	
	static self Integer(i32 Value) {
		return self:WrapWord(TACAddressKind:Integer, Value As void*)
	}
	static self Integer(i64 Value) {
		return self:WrapLong(TACAddressKind:Integer, Value As void*)
	}

	static self Temporary(i32 BlockNumber, i32 InstructionNumber) {
		self Result := self:WrapLong(TACAddressKind:Temporary, BlockNumber)

		Result.InstructionNumber := InstructionNumber

		return Result
	}
	
	define i8 Is(TACAddressKind Kind) {
		return this->Kind = Kind
	}
	
	define i8 Equals(TACAddress Other) {
		if (this = 0 && Other = 0) {
			return true
		}
		else if (this = 0 || Other = 0) {
			return false
		}
		
		if (Other->Kind != this->Kind) {
			return false
		}
		
		if (Other->Value != this->Value) {
			return false
		}
		
		return true
	}
	
	define void Print() {
		if (this = 0) {
			return
		}

		if (this->Web) {
			Print("[%i]", this->Web)
		}
		
		if (this->Is(TACAddressKind:Integer)) {
			Print("%i", this->Integer)
		}
		else {
			if (this->Is(TACAddressKind:Variable)) {
				this->Variable->Base->Name->Print()
				
			}
			else if (this->Is(TACAddressKind:Temporary)) {
				Print("@%i.%i", this->BlockNumber, this->InstructionNumber)
			}
		}
		
		if (this->Size = TACAddressSize:Word) {
			;Print("_w")
		}
		else {
			;Print("_l")
		}
	}
}

TACAddress TAC_ADDRESS_NULL := 0 As TACAddress

define void DoAddressPrint(PrintOutputAdapterPrototype* this, i8* Format, i32* FormatIndex, void* Parameters, i32 ParameterCount, i32* ParameterIndex) {
	TACAddress Address := Parameters[*ParameterIndex] As TACAddress
	
	Address->Print()
	
	*ParameterIndex += 1
}

PrintFormatPrototype AddressPrintPrototype {
	Name: "a",
	Format: &DoAddressPrint
}

i32 ADDRESS_PRINT_PROTOTYPE_ID := AddPrintFormat(&AddressPrintPrototype)

i32 TAC_MOVE := 0

i32 TAC_LOAD_INDIRECT_1 := 1
i32 TAC_LOAD_INDIRECT_2 := 2
i32 TAC_LOAD_INDIRECT_4 := 3
i32 TAC_LOAD_INDIRECT_8 := 4
i32 TAC_STORE_INDIRECT_1 := 5
i32 TAC_STORE_INDIRECT_2 := 6
i32 TAC_STORE_INDIRECT_4 := 7
i32 TAC_STORE_INDIRECT_8 := 8

i32 TAC_LOAD_ADDRESS := 9
i32 TAC_JUMP_TRUE := 10
i32 TAC_JUMP_FALSE := 11
i32 TAC_JUMP := 12

i32 TAC_RETURN := 13
i32 TAC_PHI := 14

i32 TAC_REMOVED := 15

i32 TAC_ALU_FIRST := 20

define i32 SizedOpcode(i32 Opcode, i32 Size) {
	if (Size = 8) {
		return Opcode + 3
	}
	else if (Size = 4) {
		return Opcode + 2
	}
	else if (Size = 2) {
		return Opcode + 1
	}
	else {
		return Opcode
	}
}

define i8* GetOperatorName(i32 Operator) {
	i8*[40] Operators {
		":=", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=",
		"&&", "||",
		"eq", "neq", "lt", "lt_e", "gt", "gt_e",
		"as",
		"+", "-",
		"*", "/", "%",
		"&", "|", "^",
		"<<", ">>",
		"!", "~",
		"++", "--", "++", "--",
		"[",
		".", "->", "~>",
		":", "#"
	}
	
	return Operators[Operator]
}

define i8* GetOpcodeName(i32 Opcode) {
	i8*[15] Names {
		":=",
		"* As i8",
		"* As i16",
		"* As i32",
		"* As i64",
		"* As i8 :=",
		"* As i16 := ",
		"* As i32 :=",
		"* As i64 :=",
		"&",
		"jnz",
		"jez",
		"jmp",
		"return",
		"phi"
	}
	
	if (Opcode >= TAC_ALU_FIRST) {
		return GetOperatorName(Opcode - TAC_ALU_FIRST)
	}
	
	return Names[Opcode]
}

struct TACPhiDefinition {
	TACAddress Address
	i32 BlockNumber

	static self* New(i32 BlockNumber, TACAddress Address) {
		self* this := Alloc(#self)

		this->BlockNumber := BlockNumber
		this->Address := Address

		return this
	}
}

struct TACPhiInfo {
	i32 Web

	i8* Name
	i64 Hash

	PointerArray Definitions ; <TACAddress>

	static self* New(i8* Name, i64 Hash) {
		self* this := Alloc(#self)

		this->Name := Name
		this->Hash := Hash
		this~>Definitions->Initialize()

		return this
	}

	define void AddDefinition(i32 BlockNumber, TACAddress Address) {
		TACPhiDefinition* Definition := TACPhiDefinition:New(BlockNumber, Address)

		this~>Definitions->Push(Definition As void*)
	}

	define void RemoveDefinition(i32 BlockNumber, TACAddress Address) {
		for (i32 Index := 0, Index < this~>Definitions->Count(), Index++) {
			TACPhiDefinition* Next := this~>Definitions->At(Index)

			if (Next->BlockNumber = BlockNumber && Next->Address->Equals(Address)) {
				this~>Definitions->Remove(Index)

				return
			}
		}
	}

	define i32 Count() {
		return this~>Definitions->Count()
	}
	define TACPhiDefinition* At(i32 Index) {
		return this~>Definitions->At(Index)
	}
}

struct TACTriple {
	i32 Opcode
	
	union {
		TACAddress Left
		TACAddress Operand
		TACAddress Source
		TACPhiInfo* Phi
	}
	
	union {
		TACAddress Right
	}

	PointerArray Uses ; <TACAddress>
	
	static self* New(i32 Opcode, TACAddress Left, TACAddress Right) {
		self* this := Alloc(#self)
		
		this->Opcode := Opcode
		this->Left := Left
		this->Right := Right

		this~>Uses->Initialize()
		
		return this
	}
	
	static self* New(i32 Opcode, TACAddress Operand) {
		self* this := Alloc(#self)
		
		this->Opcode := Opcode
		this->Operand := Operand
		
		return this
	}

	define void Remove() {
		this->Opcode := TAC_REMOVED
	}

	define i8 Is(i32 Opcode) {
		return this->Opcode = Opcode
	}

	define void Print() {
		if (this->Is(TAC_PHI)) {
			Print("phi\t")

			if (this->Phi->Web) {
				Print("[%i]", this->Phi->Web)
			}

			Print("%s", this->Phi->Name)

			for (i32 Index := 0, Index < this->Phi->Count(), Index++) {
				TACPhiDefinition* Next := this->Phi->At(Index)
				
				Print("\t%i: %a", Next->BlockNumber, Next->Address)

				if (Index + 1 != this->Phi->Count()) {
					Print(",")
				}
			}
		}
		else if (this->Right) {
			Print("%s\t%a,\t%a", GetOpcodeName(this->Opcode), this->Left, this->Right)
		}
		else {
			Print("%s\t%a", GetOpcodeName(this->Opcode), this->Left)
		}
	}
}

struct TACDefinition {
	i8* Name
	TACAddress Value
}

struct TACBlock {
	i32 Number

	PointerArray Parents ; <TACBlock*>
	PointerArray Children ; <TACBlock*>

	PointerArray IncompletePhi ; <TACAddress>
	PointerArray Body ; <TACTriple*>

	AVLTree Definitions ; <i64, TACDefinition>

	i8 Sealed
	i8 Deleted

	define void Initialize(i32 Number) {
		this->Number := Number

		this~>Parents->Initialize()
		this~>Children->Initialize()

		this~>IncompletePhi->Initialize()
		this~>Body->Initialize()

		this~>Definitions->ValueSize := #TACDefinition
	}

	define void Push(TACTriple* Triple) {
		this~>Body->Push(Triple)
	}
	define i32 Count() {
		return this~>Body->Count()
	}
	define TACTriple* At(i32 Index) {
		if (Index < 0) {
			return this~>Body->At(this->Count() + Index)
		}

		return this~>Body->At(Index)
	}
	define TACTriple* Last() {
		return this~>Body->Last()
	}
	define TACTriple* Pop() {
		return this~>Body->Pop()
	}
	define void Remove(i32 Index) {
		this~>Body->Remove(Index)
	}

	define void Print() {
		Print("%i: ", this->Number, this->Sealed)

		i32 ParentCount := this~>Parents->Count()

		if (ParentCount) {
			Print("[parents: ")

			for (i32 Index := 0, Index < ParentCount, Index++) {
				TACBlock* Parent := this~>Parents->At(Index)

				Print("%i", Parent->Number)

				if (Index + 1 != ParentCount) {
					Print(", ")
				}
			}

			Print("] ")
		}

		i32 ChildCount := this~>Children->Count()

		if (ChildCount) {
			Print("(children: ")

			for (i32 Index := 0, Index < ChildCount, Index++) {
				TACBlock* Child := this~>Children->At(Index)

				Print("%i", Child->Number)

				if (Index + 1 != ChildCount) {
					Print(", ")
				}
			}

			Print(")")
		}

		Print("\n")

		i32 DefinitionCount := this~>Definitions->Count()

		for (i32 Index := 0, Index < DefinitionCount, Index++) {
			TACDefinition* Definition := this~>Definitions->ValueAt(Index)

			Print("\t%s: %a\n", Definition->Name, Definition->Value)
		}

		Print("\t====\n")

		for (i32 Index := 0, Index < this->Count(), Index++) {
			TACTriple* Next := this->At(Index)

			if (Next->Opcode = TAC_REMOVED) {
				continue
			}

			Print("\t.%i:\t", Index)
			Next->Print()
			Print("\n")
		}
	}

	define void PrintGraphViz(i8* Name) {
		i32 ChildCount := this~>Children->Count()

		if (ChildCount) {
			for (i32 Index := 0, Index < ChildCount, Index++) {
				TACBlock* Child := this~>Children->At(Index)

				Print("\t%s_%i -> %s_%i;\n", Name, this->Number, Name, Child->Number)
			}
		}

		Print("\t%s_%i [fontname=\"Courier\",shape=record,label=\"{%i: | - definitions -\\n", Name, this->Number, this->Number)

		i32 DefinitionCount := this~>Definitions->Count()

		for (i32 Index := 0, Index < DefinitionCount, Index++) {
			TACDefinition* Definition := this~>Definitions->ValueAt(Index)

			Print("\t%s: %a\\l", Definition->Name, Definition->Value)
		}

		Print(" | - uses -\\n")

		for (i32 Index := 0, Index < this->Count(), Index++) {
			TACTriple* Next := this->At(Index)

			if (Next->Opcode = TAC_REMOVED) {
				continue
			}

			i32 UseCount := Next~>Uses->Count()

			if (UseCount) {
				Print(".%i:", Index)

				for (i32 UseIndex := 0, UseIndex < UseCount, UseIndex++) {
					TACAddress NextUse := Next~>Uses->At(UseIndex) As TACAddress

					Print(" %a", NextUse)
				}

				Print("\\l")
			}
		}

		Print(" | ")

		for (i32 Index := 0, Index < this->Count(), Index++) {
			TACTriple* Next := this->At(Index)

			if (Next->Opcode = TAC_REMOVED) {
				continue
			}

			Print("\t.%i:\t", Index)
			Next->Print()
			Print("\\l")
		}

		Print("}\"];\n")
	}
}

struct TACBuilder {
	union {
		void* Buffer
		TACTriple** Triples
	}
	
	i32 Length
	
	TACBlock* CurrentBlock
	
	PointerArray* Blocks ; <TACBlock*>
	
	static TACBuilder* New() {
		self* this := Alloc(#self)
		
		this->Buffer := Alloc(100 * #TACTriple*)
		
		this->Blocks := PointerArray:New()
		
		return this
	}

	define TACTriple* GetTemporary(TACAddress TemporaryAddress) {
		i32 BlockNumber := TemporaryAddress.BlockNumber
		i32 InstructionNumber := TemporaryAddress.InstructionNumber

		TACBlock* InBlock := this->Blocks->At(BlockNumber)

		return InBlock->At(InstructionNumber)
	}

	define void UseAt(TACAddress Where, TACAddress Value) {
		if (Value->Is(TACAddressKind:Temporary)) {
			Print("use %a at %a\n", Value, Where)

			TACTriple* Definer := this->GetTemporary(Value)

			Definer~>Uses->Push(Where As void*)
		}
	}
	define void RemoveUseAt(TACAddress Where, TACAddress Value) {
		if (Value->Is(TACAddressKind:Temporary)) {
			TACTriple* Definer := this->GetTemporary(Value)

			Definer~>Uses->RemoveValue(Where As void*)
		}
	}
	
	define TACAddress Emit(TACBlock* InBlock, i32 Opcode, TACAddress Left, TACAddress Right) {
		i32 Index := InBlock->Count()

		TACTriple* New := TACTriple:New(Opcode, Left, Right)
		InBlock->Push(New)
		
		TACAddress Result := TACAddress:Temporary(InBlock->Number, Index)
		
		if (Opcode = TAC_JUMP || Opcode = TAC_JUMP_TRUE || Opcode = TAC_JUMP_FALSE) {
			TACBlock* Destination := null

			if (Opcode = TAC_JUMP) {
				Destination := this->Blocks->At(Left.Integer As i32)
			}
			else {
				this->UseAt(Result, Left)

				Destination := this->Blocks->At(Right.Integer As i32)
			}

			InBlock~>Children->Add(Destination)
			Destination~>Parents->Add(InBlock)
		}
		else {
			if (Left != TAC_ADDRESS_NULL) {
				this->UseAt(Result, Left)
			}

			if (Right != TAC_ADDRESS_NULL) {
				this->UseAt(Result, Right)
			}
		}
		
		return Result
	}

	define TACAddress Emit(i32 Opcode, TACAddress Left, TACAddress Right) {
		return this->Emit(this->CurrentBlock, Opcode, Left, Right)
	}

	define TACAddress Emit(TACBlock* InBlock, i32 Opcode, TACAddress Operand) {
		return this->Emit(InBlock, Opcode, Operand, TAC_ADDRESS_NULL)
	}

	define TACAddress Emit(i32 Opcode, TACAddress Operand) {
		return this->Emit(Opcode, Operand, TAC_ADDRESS_NULL)
	}

	define void Remove(TACAddress TemporaryAddress) {
		this->GetTemporary(TemporaryAddress)->Remove()
	}

	define void SetName(TACBlock* InBlock, i8* Name, TACAddress Value) {
		Print("Set %i.%s to %a\n", InBlock->Number, Name, Value)

		i64 Hash := FNV1A(Name)

		TACDefinition Definition {
			Name: Name,
			Value: Value
		}

		InBlock~>Definitions->Insert(Hash, &Definition)
	}
	define void SetName(i8* Name, TACAddress Value) {
		this->SetName(this->CurrentBlock, Name, Value)
	}

	define void ReplacePhiSource(TACPhiInfo* Phi, TACAddress Old, TACAddress New) {
		i32 DefinitionCount := Phi~>Definitions->Count()

		for (i32 Index := 0, Index < DefinitionCount, Index++) {
			TACPhiDefinition* Definition := Phi~>Definitions->At(Index) As TACPhiDefinition*
			TACAddress Next := Definition->Address

			if (Next->Equals(Old)) {
				this->RemoveUseAt(Next, Old)
				this->UseAt(Next, New)

				Definition->Address := New
				return
			}
		}
	}

	define TACAddress RemoveTrivialPhi(TACAddress PhiAddress, TACTriple* Triple, TACPhiInfo* Phi) {
		TACAddress Same := TAC_ADDRESS_NULL
		i32 DefinitionCount := Phi~>Definitions->Count()

		for (i32 Index := 0, Index < DefinitionCount, Index++) {
			TACPhiDefinition* Definition := Phi~>Definitions->At(Index)
			TACAddress Next := Definition->Address

			if (Next->Equals(Same) || Next->Equals(PhiAddress)) {
				continue
			}
			else if (Same != null) {
				return PhiAddress
			}

			Same := Next
		}

		if (Same = TAC_ADDRESS_NULL) {
			this->Remove(PhiAddress)
		}

		return PhiAddress

		;Print("Replace %a with %a\n", PhiAddress, Same)

		i32 UseCount := Triple~>Uses->Count()

		for (i32 Index := 0, Index < UseCount, Index++) {
			TACAddress NextUser := Triple~>Uses->At(Index) As TACAddress
			TACTriple* NextTriple := this->GetTemporary(NextUser)
			
			if (NextTriple->Is(TAC_PHI)) {
				this->ReplacePhiSource(NextTriple->Phi, PhiAddress, Same)
			}
			else {
				if (NextTriple->Left->Equals(PhiAddress)) {
					this->RemoveUseAt(NextUser, PhiAddress)
					this->UseAt(NextUser, Same)

					NextTriple->Left := Same
				}

				if (NextTriple->Right->Equals(PhiAddress)) {
					this->RemoveUseAt(NextUser, PhiAddress)
					this->UseAt(NextUser, Same)

					NextTriple->Right := Same
				}
			}
		}

		for (i32 Index := 0, Index < UseCount, Index++) {
			TACAddress NextUser := Triple~>Uses->At(Index) As TACAddress
			TACTriple* NextTriple := this->GetTemporary(NextUser)
			
			if (NextTriple->Is(TAC_PHI)) {
				this->RemoveTrivialPhi(NextUser, NextTriple, NextTriple->Phi)
			}
		}

		/*
		Phi->RemoveDefinition(PhiAddress.BlockNumber, PhiAddress)

		for (i32 Index := 0, Index < Phi~>Definitions->Count(), Index++) {
			TACAddress Address := Phi~>Definitions->At(Index) As TACAddress

			if (Address.Is(TACAddressKind:Temporary)) {
				TACTriple* Triple := this->GetTemporary(Address)

				if (Triple->Is(TAC_PHI)) {
					this->RemoveTrivialPhi(Triple->Phi, Address)
				}
			}
		}
		;*/

		return Same
	}

	declare TACAddress LookupName(TACBlock*, i8*, i64)

	define TACAddress AddPhiOperands(TACBlock* InBlock, TACAddress PhiAddress) {
		TACTriple* Triple := this->GetTemporary(PhiAddress)
		TACPhiInfo* Phi := Triple->Phi
		
		for (i32 Index := 0, Index < InBlock~>Parents->Count(), Index++) {
			TACBlock* Parent := InBlock~>Parents->At(Index)

			TACAddress ParentDefinition := this->LookupName(Parent, Phi->Name, Phi->Hash)

			if (ParentDefinition != TAC_ADDRESS_NULL) {
				Phi->AddDefinition(Parent->Number, ParentDefinition)
				this->UseAt(PhiAddress, ParentDefinition)
			}
		}

		return this->RemoveTrivialPhi(PhiAddress, Triple, Phi)

		;return PhiAddress
	}
	
	define TACAddress LookupName(TACBlock* InBlock, i8* Name, i64 Hash) {
		if (InBlock~>Definitions->Has(Hash)) {
			TACDefinition* Definition := InBlock~>Definitions->Get(Hash)

			Print("Get %i.%s is %a\n", InBlock->Number, Name, Definition->Value)

			return Definition->Value
		}
		else {
			Print("No such %i.%s (sealed? %i)\n", InBlock->Number, Name, InBlock->Sealed)
		}
		
		TACAddress Result := TAC_ADDRESS_NULL
		
		if !(InBlock->Sealed) {
			TACPhiInfo* Phi := TACPhiInfo:New(Name, Hash)
			Result := this->Emit(InBlock, TAC_PHI, Phi As TACAddress)

			InBlock~>IncompletePhi->Push(Result As void*)
		}
		else if (InBlock~>Parents->Count() = 1) {
			TACBlock* Parent := InBlock~>Parents->At(0)

			return this->LookupName(Parent, Name, Hash)
		}
		else {
			Print("new phi\n")
			TACPhiInfo* Phi := TACPhiInfo:New(Name, Hash)
			Result := this->Emit(InBlock, TAC_PHI, Phi As TACAddress)
			this->SetName(InBlock, Name, Result)

			Result := this->AddPhiOperands(InBlock, Result)
		}

		this->SetName(InBlock, Name, Result)

		return Result
	}

	define TACAddress LookupName(TACBlock* InBlock, i8* Name) {
		return this->LookupName(InBlock, Name, FNV1A(Name))
	}

	define TACAddress LookupName(i8* Name) {
		return this->LookupName(this->CurrentBlock, Name, FNV1A(Name))
	}

	define void SealBlock(TACBlock* InBlock) {
		if !(InBlock->Sealed) {
			InBlock->Sealed := true

			i32 PhiCount := InBlock~>IncompletePhi->Count()

			for (i32 Index := 0, Index < PhiCount, Index++) {
				TACAddress PhiAddress := InBlock~>IncompletePhi->At(Index) As TACAddress

				TACPhiInfo* Phi := this->GetTemporary(PhiAddress)->Phi

				Print("\nSeal %a %i.%s\n", PhiAddress, InBlock->Number, Phi->Name)

				this->AddPhiOperands(InBlock, PhiAddress)

				Print("\n")
			}
		}
	}
	
	define void EndBlock() {
		if (this->CurrentBlock) {
			this->CurrentBlock := null
		}
	}
	
	define i32 StartBlock(i32 Index) {
		this->EndBlock()
		
		this->CurrentBlock := this->Blocks->Get(Index)
		
		return Index
	}
	
	define i32 ReserveLabel() {
		i32 Result := this->Blocks->Count()

		TACBlock* New := Alloc(#TACBlock)
		
		New->Initialize(this->Blocks->Count())
		this->Blocks->Push(New)
		
		return Result
	}
	
	define i32 SetLabel() {
		return this->StartBlock(this->ReserveLabel())
	}
	define i32 SetLabel(i32 Number) {
		return this->StartBlock(Number)
	}
	
	define void Print() {
		for (i32 BlockIndex := 0, BlockIndex < this->Blocks->Count(), BlockIndex++) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)

			InBlock->Print()
		}
	}
	define void PrintGraphViz(i8* Name, i8* Description) {
		Print("subgraph cluster_%i {\n", FNV1A(Name) & 0x7FFF_FFFF)
		Print("\tstyle=filled;\n")
		Print("\tcolor=lightgrey;\n")
		Print("\tlabel=\"%s:\n%s\";\n", Name, Description)

		for (i32 BlockIndex := 0, BlockIndex < this->Blocks->Count(), BlockIndex++) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)
			
			InBlock->PrintGraphViz(Name)
		}

		Print("}\n")
	}

	define void ReplaceJumpTarget(TACBlock* InBlock, i32 OldTarget, i32 NewTarget) {
		for (i32 Index := 0, Index < InBlock->Count(), Index++) {
			TACTriple* Next := InBlock->At(Index)

			if (Next->Is(TAC_JUMP)) {
				if (Next->Left.Integer = OldTarget) {
					Next->Left.Integer := NewTarget
				}
			}
			else if (Next->Is(TAC_JUMP_TRUE) || Next->Is(TAC_JUMP_FALSE)) {
				if (Next->Right.Integer = OldTarget) {
					Next->Right.Integer := NewTarget
				}
			}
		}
	}

	define void ReplaceJumpsTo(TACBlock* Child, TACBlock* NewTarget) {
		i32 ParentCount := Child~>Parents->Count()

		for (i32 Index := ParentCount - 1, Index >= 0, Index--) {
			TACBlock* Parent := Child~>Parents->At(Index)

			this->ReplaceJumpTarget(Parent, Child->Number, NewTarget->Number)

			Parent~>Children->RemoveValue(Child)
			Child~>Parents->RemoveValue(Parent)

			Parent~>Children->Push(NewTarget)
			NewTarget~>Parents->Push(Parent)
		}
	}

	define void RecomputePhi(TACBlock* InBlock, TACPhiInfo* Phi, TACAddress PhiAddress) {
		i32 DefinitionCount := Phi~>Definitions->Count()

		for (i32 Index := 0, Index < DefinitionCount, Index++) {
			Free(Phi~>Definitions->At(Index))
		}

		Phi~>Definitions->Clear()

		;this->GetTemporary(PhiAddress)->Print()
		;Print("\n")

		this->AddPhiOperands(InBlock, PhiAddress)

		;this->GetTemporary(PhiAddress)->Print()
		;Print("\n\n")
	}

	define void RecomputeAllPhi(TACBlock* InBlock, i32 RemovedBlock) {
		for (i32 Index := 0, Index < InBlock->Count(), Index++) {
			TACTriple* Next := InBlock->At(Index)

			if (Next->Is(TAC_PHI)) {
				TACPhiInfo* Phi := Next->Phi
				i32 DefinitionCount := Phi~>Definitions->Count()

				for (i32 PhiIndex := 0, PhiIndex < DefinitionCount, PhiIndex++) {
					TACPhiDefinition* Definition := Phi~>Definitions->At(PhiIndex)

					if (Definition->BlockNumber = RemovedBlock) {
						this->RecomputePhi(InBlock, Phi, TACAddress:Temporary(InBlock->Number, Index))
					}
				}
			}
		}
	}

	define void ReplaceJumpsFrom(TACBlock* Parent, TACBlock* NewParent) {
		i32 ChildCount := Parent~>Children->Count()

		for (i32 Index := ChildCount - 1, Index >= 0, Index--) {
			TACBlock* Child := Parent~>Children->At(Index)

			Parent~>Children->RemoveValue(Child)
			Child~>Parents->RemoveValue(Parent)

			this->RecomputeAllPhi(Child, Parent->Number)
		}
	}
	
	define void RemoveExtraJumps() {
		i32 BlockCount := this->Blocks->Count()

		for (i32 BlockIndex := BlockCount - 1, BlockIndex >= 0, BlockIndex--) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)
			i32 Count := InBlock->Count()
			i32 JumpCount := 0

			if (InBlock~>Definitions->Count() != 0) {
				continue
			}

			for (i32 Index := 0, Index < Count, Index++) {
				TACTriple* Next := InBlock->At(Index)

				if (Next->Is(TAC_JUMP)) {
					JumpCount += 1
				}
				;else if (Next->Is(TAC_JUMP_TRUE) || Next->Is(TAC_JUMP_FALSE)) {
				;	JumpCount += 1
				;}
			}

			if (Count = JumpCount) {
				TACTriple* First := InBlock->At(0)

				TACBlock* NewTarget := this->Blocks->At(First->Left.Integer As i32)

				this->ReplaceJumpsTo(InBlock, NewTarget)
				this->ReplaceJumpsFrom(InBlock, NewTarget)
			}
		}

		for (i32 BlockIndex := BlockCount - 1, BlockIndex >= 0, BlockIndex--) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)

			;InBlock->Print()
			;this->SealBlock(InBlock)
		}
	}

	define void RemoveAllTrivialPhi() {
		i32 BlockCount := this->Blocks->Count()

		for (i32 BlockIndex := BlockCount - 1, BlockIndex >= 0, BlockIndex--) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)
			i32 Count := InBlock->Count()

			for (i32 Index := 0, Index < Count, Index++) {
				TACTriple* Next := InBlock->At(Index)

				if (Next->Is(TAC_PHI)) {
					TACAddress PhiAddress := TACAddress:Temporary(BlockIndex, Index)

					this->RemoveTrivialPhi(PhiAddress, Next, Next->Phi)
				}
			}
		}
	}

	declare void AssignPhiWeb(TACAddress, i32)

	define void AssignWeb(TACAddress Origin, i32 Web) {
		TACTriple* Triple := this->GetTemporary(Origin)
		i32 UseCount := Triple~>Uses->Count()

		for (i32 UseIndex := 0, UseIndex < UseCount, UseIndex++) {
			TACAddress NextUse := Triple~>Uses->At(UseIndex) As TACAddress
			TACTriple* NextTriple := this->GetTemporary(NextUse)

			if (NextTriple->Is(TAC_PHI)) {
				this->AssignPhiWeb(NextUse, Web)
			}
			else {
				if (NextTriple->Left->Equals(Origin)) {
					NextTriple->Left->Web := Web
				}

				if (NextTriple->Right->Equals(Origin)) {
					NextTriple->Right->Web := Web
				}
			}
		}
	}

	define void AssignPhiWeb(TACAddress PhiAddress, i32 Web) {
		TACTriple* Triple := this->GetTemporary(PhiAddress)
		TACPhiInfo* Phi := Triple->Phi

		if (Phi->Web = Web) {
			return
		}

		if (Phi->Web != 0) {
			Throw('badweb')
			return
		}

		Phi->Web := Web

		i32 DefinitionCount := Phi~>Definitions->Count()

		for (i32 Index := 0, Index < DefinitionCount, Index++) {
			TACPhiDefinition* Next := Phi~>Definitions->At(Index)

			i32 NextWeb := Next->Address->Web

			if (NextWeb != 0 && NextWeb != Web) {
				Throw('badweb2')
				return
			}
			else {
				Next->Address->Web := Web

				TACAddress NextAddress := Next->Address

				if (NextAddress->Is(TACAddressKind:Temporary)) {
					TACTriple* Definer := this->GetTemporary(NextAddress)

					if (Definer->Is(TAC_PHI)) {
						this->AssignPhiWeb(NextAddress, Web)
					}
					else {
						this->AssignWeb(NextAddress, Web)
					}
				}
			}
		}
		
		this->AssignWeb(PhiAddress, Web)
	}

	i32 NextPhiWeb

	define i32 FindOrAddPhiWeb(TACTriple* Triple) {
		TACPhiInfo* Phi := Triple->Phi

		if (Phi->Web != 0) {
			return Phi->Web
		}

		Phi->Web := -1
		i32 Web := 0

		i32 DefinitionCount := Phi~>Definitions->Count()

		for (i32 Index := 0, Index < DefinitionCount, Index++) {
			TACPhiDefinition* Next := Phi~>Definitions->At(Index)

			Web := Next->Address->Web

			if (Web != 0) {
				break
			}
			else {
				if (Next->Address->Is(TACAddressKind:Temporary)) {
					TACTriple* Definer := this->GetTemporary(Next->Address)

					if (Definer->Is(TAC_PHI)) {
						Web := this->FindOrAddPhiWeb(Definer)
					}
				}
				
				if (Web = 0) {
					Web := Next->Address->Web
				}

				if (Web > 0) {
					break
				}
			}
		}

		if (Web <= 0) {
			Web := ++this->NextPhiWeb
		}

		Phi->Web := 0

		return Web
	}

	define void AssignPhiWebs(TACBlock* InBlock) {
		i32 Count := InBlock->Count()

		for (i32 Index := 0, Index < Count, Index++) {
			TACAddress Address := TACAddress:Temporary(InBlock->Number, Index)
			TACTriple* Next := InBlock->At(Index)

			if (Next->Is(TAC_PHI)) {
				i32 Web := this->FindOrAddPhiWeb(Next)

				Next->Print()
				Print(" is in web %i\n", Web)

				this->AssignPhiWeb(Address, Web)
			}
		}
	}

	define void AssignPhiWebs() {
		i32 BlockCount := this->Blocks->Count()

		for (i32 BlockIndex := 0, BlockIndex < BlockCount, BlockIndex++) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)
			
			this->AssignPhiWebs(InBlock)
		}
	}
}

bits LoopLables As i64 {
	[0:31] BreakLabel
	[32:63] ContinueLabel
}

#Require "./src/compiler/IR2/TACFromAST.rlx"

define void Main(i64 ArgC, i8** ArgV) {
	GetArgs(&ArgC, &ArgV)
	
	if (ArgC != 2) {
		Print("No input file\n")
		Exit(1)
	}
	
	BuildConfig* Config := Alloc(#BuildConfig)
	
	Config->DumpInfo := 0
	Config->LineEnding := LINE_ENDING_DEFAULT
	Config->OutputFormat := OUTPUT_ELF
	
	i8* InputFilePath := ArgV[1]
	
	i32 SourceLength := 0
	i8* Source := OpenAndRead(InputFilePath, &SourceLength)
	
	LexerState* Lexer := LexerState:New(Config, Source, SourceLength, AToS(InputFilePath))
	Config->Lexer := Lexer
	
	ParserState* Parser := ParserState:New(Config, Lexer)
	
	TACFromAST* TFA := TACFromAST:New()
	
	Parser->ParseProgram()
	
	TFA->CompileFunctionHashMap(Parser~>Functions)

	;TFA->Builder->Print()
	
	;/*
	Print("digraph CFG {\n")
	TFA->Builder->PrintGraphViz("original", "Unoptimized SSA")
	;TFA->Builder->RemoveExtraJumps()
	;TFA->Builder->PrintGraphViz("opt1", "SSA with jumps cleaned")
	TFA->Builder->AssignPhiWebs()
	TFA->Builder->PrintGraphViz("rak", "Phi webs assigned")
	Print("}\n")
	;*/
}
