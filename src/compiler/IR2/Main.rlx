#Require "$/Memory.rlx"
#Require "$/File.rlx"

#Require "$/String.rlx"
#Require "$/Console.rlx"
#Require "$/SafeString.rlx"
#Require "$/HashMap.rlx"
#Require "$/Debug.rlx"

#Require "$/AVLTree.rlx"

#Require "./src/compiler/IR2/PointerArray.rlx"

#Require "./src/compiler/Utility.rlx"
#Require "./src/compiler/Lexer.rlx"
#Require "./src/compiler/Parser.rlx"

#Require "./src/compiler/IR2/Structures.rlx"

struct TACBuilder {
	TACBlock* CurrentBlock
	
	PointerArray* Triples ; <TACTriple*>
	PointerArray* Blocks ; <TACBlock*>
	
	static TACBuilder* New() {
		self* this := Alloc(#self)
		
		this->Triples := PointerArray:New()
		this->Blocks := PointerArray:New()
		
		return this
	}

	define TACTriple* GetTemporary(TACAddress Value) {
		return Value.TemporaryTriple
	}

	define void UseAt(TACAddress Where, TACAddress Value) {
		if (Value->Is(TACAddressKind:Temporary)) {
			Print("use %a at %a\n", Value, Where)

			TACTriple* Definer := Value.TemporaryTriple

			Definer~>Uses->Push(Where As void*)
		}
	}
	define void RemoveUseAt(TACAddress Where, TACAddress Value) {
		if (Value->Is(TACAddressKind:Temporary)) {
			TACTriple* Definer := this->GetTemporary(Value)

			Definer~>Uses->RemoveValue(Where As void*)
		}
	}
	
	define TACAddress Emit(TACBlock* InBlock, i32 Opcode, TACAddress Left, TACAddress Right) {
		if (Opcode = TAC_JUMP) {
			TACBlock* Destination := this->Blocks->At(Left.Integer As i32)

			InBlock->Fallthrough := Destination->Number

			InBlock~>Children->Add(Destination)
			Destination~>Parents->Add(InBlock)

			return TAC_ADDRESS_NULL
		}

		TACTriple* New := TACTriple:New(Opcode, Left, Right)

		if (Opcode = TAC_PHI) {
			InBlock~>Body->Insert(0, New)
			InBlock->PhiCount += 1
		}
		else {
			InBlock->Push(New)
		}

		New->BlockNumber := InBlock->Number
		New->Number := this->Triples->Count()

		this->Triples->Push(New)
		
		TACAddress Result := TACAddress:Temporary(New)
		
		if (Opcode = TAC_JUMP_TRUE || Opcode = TAC_JUMP_FALSE) {
			TACBlock* Destination := null

			if (Opcode = TAC_JUMP) {
				Destination := this->Blocks->At(Left.Integer As i32)
			}
			else {
				this->UseAt(Result, Left)

				Destination := this->Blocks->At(Right.Integer As i32)
			}

			InBlock~>Children->Add(Destination)
			Destination~>Parents->Add(InBlock)
		}
		else {
			if (Left != TAC_ADDRESS_NULL) {
				this->UseAt(Result, Left)
			}

			if (Right != TAC_ADDRESS_NULL) {
				this->UseAt(Result, Right)
			}
		}
		
		return Result
	}

	define TACAddress Emit(i32 Opcode, TACAddress Left, TACAddress Right) {
		return this->Emit(this->CurrentBlock, Opcode, Left, Right)
	}

	define TACAddress Emit(TACBlock* InBlock, i32 Opcode, TACAddress Operand) {
		return this->Emit(InBlock, Opcode, Operand, TAC_ADDRESS_NULL)
	}

	define TACAddress Emit(i32 Opcode, TACAddress Operand) {
		return this->Emit(Opcode, Operand, TAC_ADDRESS_NULL)
	}

	define void Remove(TACAddress TemporaryAddress) {
		this->GetTemporary(TemporaryAddress)->Remove()
	}

	define void SetName(TACBlock* InBlock, i8* Name, TACAddress Value) {
		Print("Set %i.%s to %a\n", InBlock->Number, Name, Value)

		i64 Hash := FNV1A(Name)

		TACDefinition Definition {
			Name: Name,
			Value: Value
		}

		InBlock~>Definitions->Insert(Hash, &Definition)
	}
	define void SetName(i8* Name, TACAddress Value) {
		this->SetName(this->CurrentBlock, Name, Value)
	}

	define void ReplacePhiSource(TACPhiInfo* Phi, TACAddress Old, TACAddress New) {
		i32 DefinitionCount := Phi~>Definitions->Count()

		for (i32 Index := 0, Index < DefinitionCount, Index++) {
			TACPhiDefinition* Definition := Phi~>Definitions->At(Index) As TACPhiDefinition*
			TACAddress Next := Definition->Address

			if (Next->Equals(Old)) {
				this->RemoveUseAt(Next, Old)
				this->UseAt(Next, New)

				Definition->Address := New
				return
			}
		}
	}

	define TACAddress RemoveTrivialPhi(TACAddress PhiAddress, TACTriple* Triple, TACPhiInfo* Phi) {
		TACAddress Same := TAC_ADDRESS_NULL
		i32 DefinitionCount := Phi~>Definitions->Count()

		for (i32 Index := 0, Index < DefinitionCount, Index++) {
			TACPhiDefinition* Definition := Phi~>Definitions->At(Index)
			TACAddress Next := Definition->Address

			if (Next->Equals(Same) || Next->Equals(PhiAddress)) {
				continue
			}
			else if (Same != null) {
				return PhiAddress
			}

			Same := Next
		}

		if (Same = TAC_ADDRESS_NULL) {
			this->Remove(PhiAddress)
		}

		return PhiAddress

		;Print("Replace %a with %a\n", PhiAddress, Same)

		i32 UseCount := Triple~>Uses->Count()

		for (i32 Index := 0, Index < UseCount, Index++) {
			TACAddress NextUser := Triple~>Uses->At(Index) As TACAddress
			TACTriple* NextTriple := this->GetTemporary(NextUser)
			
			if (NextTriple->Is(TAC_PHI)) {
				this->ReplacePhiSource(NextTriple->Phi, PhiAddress, Same)
			}
			else {
				if (NextTriple->Left->Equals(PhiAddress)) {
					this->RemoveUseAt(NextUser, PhiAddress)
					this->UseAt(NextUser, Same)

					NextTriple->Left := Same
				}

				if (NextTriple->Right->Equals(PhiAddress)) {
					this->RemoveUseAt(NextUser, PhiAddress)
					this->UseAt(NextUser, Same)

					NextTriple->Right := Same
				}
			}
		}

		for (i32 Index := 0, Index < UseCount, Index++) {
			TACAddress NextUser := Triple~>Uses->At(Index) As TACAddress
			TACTriple* NextTriple := this->GetTemporary(NextUser)
			
			if (NextTriple->Is(TAC_PHI)) {
				this->RemoveTrivialPhi(NextUser, NextTriple, NextTriple->Phi)
			}
		}

		/*
		Phi->RemoveDefinition(PhiAddress.BlockNumber, PhiAddress)

		for (i32 Index := 0, Index < Phi~>Definitions->Count(), Index++) {
			TACAddress Address := Phi~>Definitions->At(Index) As TACAddress

			if (Address.Is(TACAddressKind:Temporary)) {
				TACTriple* Triple := this->GetTemporary(Address)

				if (Triple->Is(TAC_PHI)) {
					this->RemoveTrivialPhi(Triple->Phi, Address)
				}
			}
		}
		;*/

		return Same
	}

	declare TACAddress LookupName(TACBlock*, i8*, i64)

	define TACAddress AddPhiOperands(TACBlock* InBlock, TACAddress PhiAddress) {
		TACTriple* Triple := this->GetTemporary(PhiAddress)
		TACPhiInfo* Phi := Triple->Phi
		
		for (i32 Index := 0, Index < InBlock~>Parents->Count(), Index++) {
			TACBlock* Parent := InBlock~>Parents->At(Index)

			TACAddress ParentDefinition := this->LookupName(Parent, Phi->Name, Phi->Hash)

			if (ParentDefinition != TAC_ADDRESS_NULL) {
				Phi->AddDefinition(Parent->Number, ParentDefinition)
				this->UseAt(PhiAddress, ParentDefinition)
			}
		}

		return this->RemoveTrivialPhi(PhiAddress, Triple, Phi)

		;return PhiAddress
	}
	
	define TACAddress LookupName(TACBlock* InBlock, i8* Name, i64 Hash) {
		if (InBlock~>Definitions->Has(Hash)) {
			TACDefinition* Definition := InBlock~>Definitions->Get(Hash)

			Print("Get %i.%s is %a\n", InBlock->Number, Name, Definition->Value)

			return Definition->Value
		}
		else {
			Print("No such %i.%s (sealed? %i)\n", InBlock->Number, Name, InBlock->Sealed)
		}
		
		TACAddress Result := TAC_ADDRESS_NULL
		
		if !(InBlock->Sealed) {
			TACPhiInfo* Phi := TACPhiInfo:New(Name, Hash)
			Result := this->Emit(InBlock, TAC_PHI, Phi As TACAddress)

			InBlock~>IncompletePhi->Push(Result As void*)
		}
		else if (InBlock~>Parents->Count() = 1) {
			TACBlock* Parent := InBlock~>Parents->At(0)

			return this->LookupName(Parent, Name, Hash)
		}
		else {
			Print("new phi\n")
			TACPhiInfo* Phi := TACPhiInfo:New(Name, Hash)
			Result := this->Emit(InBlock, TAC_PHI, Phi As TACAddress)
			this->SetName(InBlock, Name, Result)

			TACTriple* NewPhi := this->GetTemporary(Result)

			; Move phi to start of block
			InBlock~>Body->RemoveValue(NewPhi)
			InBlock~>Body->Insert(0, NewPhi)

			Result := this->AddPhiOperands(InBlock, Result)
		}

		this->SetName(InBlock, Name, Result)

		return Result
	}

	define TACAddress LookupName(TACBlock* InBlock, i8* Name) {
		return this->LookupName(InBlock, Name, FNV1A(Name))
	}

	define TACAddress LookupName(i8* Name) {
		return this->LookupName(this->CurrentBlock, Name, FNV1A(Name))
	}

	define void SealBlock(TACBlock* InBlock) {
		if !(InBlock->Sealed) {
			InBlock->Sealed := true

			i32 PhiCount := InBlock~>IncompletePhi->Count()

			for (i32 Index := 0, Index < PhiCount, Index++) {
				TACAddress PhiAddress := InBlock~>IncompletePhi->At(Index) As TACAddress

				TACPhiInfo* Phi := this->GetTemporary(PhiAddress)->Phi

				Print("\nSeal %a %i.%s\n", PhiAddress, InBlock->Number, Phi->Name)

				this->AddPhiOperands(InBlock, PhiAddress)

				Print("\n")
			}
		}
	}
	
	define void EndBlock() {
		if (this->CurrentBlock) {
			this->CurrentBlock := null
		}
	}
	
	define i32 StartBlock(i32 Index) {
		this->EndBlock()
		
		this->CurrentBlock := this->Blocks->Get(Index)
		
		return Index
	}
	
	define i32 ReserveLabel() {
		i32 Result := this->Blocks->Count()

		TACBlock* New := Alloc(#TACBlock)
		
		New->Initialize(this->Blocks->Count())
		this->Blocks->Push(New)
		
		return Result
	}
	
	define i32 SetLabel() {
		return this->StartBlock(this->ReserveLabel())
	}
	define i32 SetLabel(i32 Number) {
		return this->StartBlock(Number)
	}
	
	define void Print() {
		for (i32 BlockIndex := 0, BlockIndex < this->Blocks->Count(), BlockIndex++) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)

			InBlock->Print()
		}
	}
	define void PrintGraphViz(i8* Name, i8* Description) {
		Print("subgraph cluster_%i {\n", FNV1A(Name) & 0x7FFF_FFFF)
		Print("\tstyle=filled;\n")
		Print("\tcolor=lightgrey;\n")
		Print("\tlabel=\"%s:\n%s\";\n", Name, Description)

		for (i32 BlockIndex := 0, BlockIndex < this->Blocks->Count(), BlockIndex++) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)
			
			InBlock->PrintGraphViz(Name)
		}

		Print("}\n")
	}

	define void ReplaceJumpTarget(TACBlock* InBlock, i32 OldTarget, i32 NewTarget) {
		for (i32 Index := 0, Index < InBlock->Count(), Index++) {
			TACTriple* Next := InBlock->At(Index)

			if (Next->Is(TAC_JUMP)) {
				if (Next->Left.Integer = OldTarget) {
					Next->Left.Integer := NewTarget
				}
			}
			else if (Next->Is(TAC_JUMP_TRUE) || Next->Is(TAC_JUMP_FALSE)) {
				if (Next->Right.Integer = OldTarget) {
					Next->Right.Integer := NewTarget
				}
			}
		}
	}

	define void ReplaceJumpsTo(TACBlock* Child, TACBlock* NewTarget) {
		i32 ParentCount := Child~>Parents->Count()

		for (i32 Index := ParentCount - 1, Index >= 0, Index--) {
			TACBlock* Parent := Child~>Parents->At(Index)

			this->ReplaceJumpTarget(Parent, Child->Number, NewTarget->Number)

			Parent~>Children->RemoveValue(Child)
			Child~>Parents->RemoveValue(Parent)

			Parent~>Children->Push(NewTarget)
			NewTarget~>Parents->Push(Parent)
		}
	}

	define void RecomputePhi(TACBlock* InBlock, TACPhiInfo* Phi, TACAddress PhiAddress) {
		i32 DefinitionCount := Phi~>Definitions->Count()

		for (i32 Index := 0, Index < DefinitionCount, Index++) {
			Free(Phi~>Definitions->At(Index))
		}

		Phi~>Definitions->Clear()

		;this->GetTemporary(PhiAddress)->Print()
		;Print("\n")

		this->AddPhiOperands(InBlock, PhiAddress)

		;this->GetTemporary(PhiAddress)->Print()
		;Print("\n\n")
	}

	define void RecomputeAllPhi(TACBlock* InBlock, i32 RemovedBlock) {
		for (i32 Index := 0, Index < InBlock->Count(), Index++) {
			TACTriple* Next := InBlock->At(Index)

			if (Next->Is(TAC_PHI)) {
				TACPhiInfo* Phi := Next->Phi
				i32 DefinitionCount := Phi~>Definitions->Count()

				for (i32 PhiIndex := 0, PhiIndex < DefinitionCount, PhiIndex++) {
					TACPhiDefinition* Definition := Phi~>Definitions->At(PhiIndex)

					if (Definition->BlockNumber = RemovedBlock) {
						this->RecomputePhi(InBlock, Phi, TACAddress:Temporary(Next))
					}
				}
			}
		}
	}

	define void ReplaceJumpsFrom(TACBlock* Parent, TACBlock* NewParent) {
		i32 ChildCount := Parent~>Children->Count()

		for (i32 Index := ChildCount - 1, Index >= 0, Index--) {
			TACBlock* Child := Parent~>Children->At(Index)

			Parent~>Children->RemoveValue(Child)
			Child~>Parents->RemoveValue(Parent)

			this->RecomputeAllPhi(Child, Parent->Number)
		}
	}
	
	define void RemoveExtraJumps() {
		i32 BlockCount := this->Blocks->Count()

		for (i32 BlockIndex := BlockCount - 1, BlockIndex >= 0, BlockIndex--) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)
			i32 Count := InBlock->Count()
			i32 JumpCount := 0

			if (InBlock~>Definitions->Count() != 0) {
				continue
			}

			for (i32 Index := 0, Index < Count, Index++) {
				TACTriple* Next := InBlock->At(Index)

				if (Next->Is(TAC_JUMP)) {
					JumpCount += 1
				}
				;else if (Next->Is(TAC_JUMP_TRUE) || Next->Is(TAC_JUMP_FALSE)) {
				;	JumpCount += 1
				;}
			}

			if (Count = JumpCount) {
				TACTriple* First := InBlock->At(0)

				TACBlock* NewTarget := this->Blocks->At(First->Left.Integer As i32)

				this->ReplaceJumpsTo(InBlock, NewTarget)
				this->ReplaceJumpsFrom(InBlock, NewTarget)
			}
		}

		for (i32 BlockIndex := BlockCount - 1, BlockIndex >= 0, BlockIndex--) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)

			;InBlock->Print()
			;this->SealBlock(InBlock)
		}
	}

	define void RemoveAllTrivialPhi() {
		i32 BlockCount := this->Blocks->Count()

		for (i32 BlockIndex := BlockCount - 1, BlockIndex >= 0, BlockIndex--) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)
			i32 Count := InBlock->Count()

			for (i32 Index := 0, Index < Count, Index++) {
				TACTriple* Next := InBlock->At(Index)

				if (Next->Is(TAC_PHI)) {
					TACAddress PhiAddress := TACAddress:Temporary(Next)

					this->RemoveTrivialPhi(PhiAddress, Next, Next->Phi)
				}
			}
		}
	}

	declare void AssignPhiWeb(TACAddress, i32)

	define void AssignWeb(TACAddress Origin, i32 Web) {
		TACTriple* Triple := this->GetTemporary(Origin)
		i32 UseCount := Triple~>Uses->Count()

		for (i32 UseIndex := 0, UseIndex < UseCount, UseIndex++) {
			TACAddress NextUse := Triple~>Uses->At(UseIndex) As TACAddress
			TACTriple* NextTriple := this->GetTemporary(NextUse)

			if (NextTriple->Is(TAC_PHI)) {
				this->AssignPhiWeb(NextUse, Web)
			}
			else {
				if (NextTriple->Left->Equals(Origin)) {
					NextTriple->Left->Web := Web
				}

				if (NextTriple->Right->Equals(Origin)) {
					NextTriple->Right->Web := Web
				}
			}
		}
	}

	define void AssignPhiWeb(TACAddress PhiAddress, i32 Web) {
		TACTriple* Triple := this->GetTemporary(PhiAddress)
		TACPhiInfo* Phi := Triple->Phi

		if (Phi->Web = Web) {
			return
		}

		if (Phi->Web != 0) {
			Throw('badweb')
			return
		}

		Phi->Web := Web

		i32 DefinitionCount := Phi~>Definitions->Count()

		for (i32 Index := 0, Index < DefinitionCount, Index++) {
			TACPhiDefinition* Next := Phi~>Definitions->At(Index)

			i32 NextWeb := Next->Address->Web

			if (NextWeb != 0 && NextWeb != Web) {
				Throw('badweb2')
				return
			}
			else {
				Next->Address->Web := Web

				TACAddress NextAddress := Next->Address

				if (NextAddress->Is(TACAddressKind:Temporary)) {
					TACTriple* Definer := this->GetTemporary(NextAddress)

					if (Definer->Is(TAC_PHI)) {
						this->AssignPhiWeb(NextAddress, Web)
					}
					else {
						this->AssignWeb(NextAddress, Web)
					}
				}
			}
		}
		
		this->AssignWeb(PhiAddress, Web)
	}

	i32 NextPhiWeb

	define i32 FindOrAddPhiWeb(TACTriple* Triple) {
		TACPhiInfo* Phi := Triple->Phi

		if (Phi->Web != 0) {
			return Phi->Web
		}

		Phi->Web := -1
		i32 Web := 0

		i32 DefinitionCount := Phi~>Definitions->Count()

		for (i32 Index := 0, Index < DefinitionCount, Index++) {
			TACPhiDefinition* Next := Phi~>Definitions->At(Index)

			Web := Next->Address->Web

			if (Web != 0) {
				break
			}
			else {
				if (Next->Address->Is(TACAddressKind:Temporary)) {
					TACTriple* Definer := this->GetTemporary(Next->Address)

					if (Definer->Is(TAC_PHI)) {
						Web := this->FindOrAddPhiWeb(Definer)
					}
				}
				
				if (Web = 0) {
					Web := Next->Address->Web
				}

				if (Web > 0) {
					break
				}
			}
		}

		if (Web <= 0) {
			Web := ++this->NextPhiWeb
		}

		Phi->Web := 0

		return Web
	}

	define void AssignPhiWebs(TACBlock* InBlock) {
		i32 Count := InBlock->Count()

		for (i32 Index := 0, Index < Count, Index++) {
			TACTriple* Next := InBlock->At(Index)
			TACAddress Address := Next->Address()

			if (Next->Is(TAC_PHI)) {
				i32 Web := this->FindOrAddPhiWeb(Next)

				Next->Print()
				Print(" is in web %i\n", Web)

				this->AssignPhiWeb(Address, Web)
			}
		}
	}

	define void AssignPhiWebs() {
		i32 BlockCount := this->Blocks->Count()

		for (i32 BlockIndex := 0, BlockIndex < BlockCount, BlockIndex++) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)
			
			this->AssignPhiWebs(InBlock)
		}
	}

	define void GenerateMoves() {
		i32 BlockCount := this->Blocks->Count()

		for (i32 BlockIndex := 0, BlockIndex < BlockCount, BlockIndex++) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)

			i32 ParentCount := InBlock~>Parents->Count()

			for (i32 Index := 0, Index < ParentCount, Index++) {
				TACBlock* Parent := InBlock~>Parents->At(Index)

				i32 ParentChildCount := Parent~>Children~>Count()

				TACBlock* MoveContainer := Parent

				if (ParentCount > 1 && ParentChildCount > 1) {
					i32 NewBlockID := this->ReserveLabel()

					TACBlock* NewBlock := this->Blocks->At(NewBlockID)

					Parent~>Children->RemoveValue(InBlock)
					InBlock~>Parents->RemoveValue(Parent)

					Parent~>Children->Push(NewBlock)
					NewBlock~>Parents->Push(Parent)

					NewBlock~>Children->Push(InBlock)
					InBlock~>Parents->Push(NewBlock)

					MoveContainer := NewBlock
				}

				for (i32 PhiIndex := 0, PhiIndex < InBlock->PhiCount, PhiIndex++) {
					TACTriple* Triple := InBlock->At(PhiIndex)
					TACPhiInfo* Phi := Triple->Phi

					TACPhiDefinition* Definition := Phi->FindDefinition(Parent->Number)

					TACAddress MoveAddress := this->Emit(MoveContainer, TAC_MOVE, Definition->Address)

					this->RemoveUseAt(Triple->Address(), Definition->Address)
					this->UseAt(Triple->Address(), MoveAddress)
					Definition->Address := MoveAddress
				}
			}
		}
	}

	i32 NextInstructionNumber

	define void RenumberInstructions(TACBlock* InBlock) {
		if (InBlock->Renumbered) {
			return
		}

		InBlock->Renumbered := true

		i32 ParentCount := InBlock~>Parents->Count()

		for (i32 Index := 0, Index < ParentCount, Index++) {
			this->RenumberInstructions(InBlock~>Parents->At(Index))
		}

		InBlock->First := this->NextInstructionNumber

		i32 Count := InBlock->Count()

		for (i32 Index := 0, Index < Count, Index++) {
			InBlock->At(Index)->Number := this->NextInstructionNumber++
		}

		InBlock->Last := this->NextInstructionNumber - 1
	}

	define void RenumberInstructions() {
		i32 BlockCount := this->Blocks->Count()

		for (i32 BlockIndex := 0, BlockIndex < BlockCount, BlockIndex++) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)

			this->RenumberInstructions(InBlock)
		}
	}

	define void AddRange(TACBlock* InBlock, TACTriple* Definition, i32 End) {
		TACLiveRange Range := TAC_RANGE_NULL

		if (InBlock->First <= Definition->Number && Definition->Number <= InBlock->Last) {
			Range := TACLiveRange:New(Definition->Number, End)
		}
		else {
			Range := TACLiveRange:New(InBlock->First, End)
		}

		Definition->AddRange(Range)
	}

	define void BuildIntervals() {
		i32 BlockCount := this->Blocks->Count()

		for (i32 BlockIndex := 0, BlockIndex < BlockCount, BlockIndex++) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)

			i32 PhiCount := InBlock->PhiCount
			i32 ChildCount := InBlock~>Children->Count()

			PointerArray* Live := InBlock~>Live->Clone()

			for (i32 ChildIndex := 0, ChildIndex < ChildCount, ChildIndex++) {
				TACBlock* Child := InBlock~>Children->At(ChildIndex)

				Live->UnionWith(Child~>Live)

				for (i32 ChildPhiIndex := 0, ChildPhiIndex < Child->PhiCount, ChildPhiIndex++) {

				}
			}

			for (i32 Index := PhiCount, Index < Live->Count(), Index++) {
				this->AddRange(InBlock, Live->At(Index), InBlock->Last)
			}

			for (i32 Index := InBlock->Count() - 1, Index >= PhiCount, Index--) {
				TACTriple* Next := InBlock->At(Index)
				Live->RemoveValue(Next)

				for (i32 OperandIndex := 0, OperandIndex < Next->OperandCount(), OperandIndex++) {
					TACAddress OperandAddress := Next->OperandAt(OperandIndex)

					if (OperandAddress->Is(TACAddressKind:Temporary)) {
						TACTriple* Operand := OperandAddress.TemporaryTriple

						if !(Live->Has(Operand)) {
							Live->Push(Operand)
							this->AddRange(InBlock, Operand, Next->Number)
						}
					}
				}
			}

			Live->Free()
		}
	}

	define TACTriple* FindInstruction(i32 Number) {
		i32 Count := this->Triples->Count()

		for (i32 Index := 0, Index < Count, Index++) {
			TACTriple* Next := this->Triples->At(Index)

			if (Next->Number = Number) {
				return Next
			}
		}

		return null
	}

	define void PrintLiveIntervals() {
		for (i32 Index := 0, Index < this->NextInstructionNumber, Index++) {
			TACTriple* Next := this->FindInstruction(Index)
			i32 RangeCount := Next~>Interval->Count()

			Print("%i: ", Next->Number)

			for (i32 RangeIndex := 0, RangeIndex < RangeCount, RangeIndex++) {
				TACLiveRange Range := Next~>Interval->At(RangeIndex) As TACLiveRange

				Print(" [%i - %i]", Range.Start, Range.End)
			}

			Print("\n")
		}


	}
}

bits LoopLables As i64 {
	[0:31] BreakLabel
	[32:63] ContinueLabel
}

#Require "./src/compiler/IR2/TACFromAST.rlx"

define void Main(i64 ArgC, i8** ArgV) {
	GetArgs(&ArgC, &ArgV)
	
	if (ArgC != 2) {
		Print("No input file\n")
		Exit(1)
	}
	
	BuildConfig* Config := Alloc(#BuildConfig)
	
	Config->DumpInfo := 0
	Config->LineEnding := LINE_ENDING_DEFAULT
	Config->OutputFormat := OUTPUT_ELF
	
	i8* InputFilePath := ArgV[1]
	
	i32 SourceLength := 0
	i8* Source := OpenAndRead(InputFilePath, &SourceLength)
	
	LexerState* Lexer := LexerState:New(Config, Source, SourceLength, AToS(InputFilePath))
	Config->Lexer := Lexer
	
	ParserState* Parser := ParserState:New(Config, Lexer)
	
	TACFromAST* TFA := TACFromAST:New()
	
	Parser->ParseProgram()
	
	TFA->CompileFunctionHashMap(Parser~>Functions)

	;TFA->Builder->Print()
	
	;/*
	Print("digraph CFG {\n")
	TFA->Builder->PrintGraphViz("original", "Unoptimized SSA")
	;TFA->Builder->RemoveExtraJumps()
	;TFA->Builder->PrintGraphViz("opt1", "SSA with jumps cleaned")
	TFA->Builder->GenerateMoves()
	TFA->Builder->PrintGraphViz("mov", "Moves added")
	TFA->Builder->RenumberInstructions()
	TFA->Builder->PrintGraphViz("ren", "Instructions renumbered")
	TFA->Builder->BuildIntervals()
	Print("}\n")

	TFA->Builder->PrintLiveIntervals()

	;*/
}
