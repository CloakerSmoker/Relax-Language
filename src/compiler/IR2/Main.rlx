#Require "$/Memory.rlx"
#Require "$/File.rlx"

#Require "$/String.rlx"
#Require "$/Console.rlx"
#Require "$/SafeString.rlx"
#Require "$/HashMap.rlx"
#Require "$/Debug.rlx"

#Require "$/AVLTree.rlx"

#Require "./src/compiler/IR2/PointerArray.rlx"

#Require "./src/compiler/Utility.rlx"
#Require "./src/compiler/Lexer.rlx"
#Require "./src/compiler/Parser.rlx"

enum TACAddressKind As i8 {
	Variable,
	Temporary,
	Integer
}

enum TACAddressSize As i8 {
	Word,
	Long
}

struct TACVariable {
	VariableInfo* Base
	
	i32 Generation
	
	i64 LastValue
	
	static self* New(VariableInfo* Base) {
		self* this := Alloc(#self)
		
		this->Base := Base
		
		return this
	}
}

bits TACAddress As i64 {
	TACVariable* [0:47] Variable

	i32 [0:32] BlockNumber
	i32 [33:47] InstructionNumber

	i64* [0:47] IntegerPointer
	i64 [0:47] Integer

	void* [0:47] Value
	
	i32 [48:55] Generation
	TACAddressKind [56:59] Kind
	TACAddressSize [60:63] Size
	
	define TACAddress IncrementGeneration() {
		this->Generation := this->Variable->Generation++
		
		return this
	}
	
	define TACAddress CopyGeneration() {
		this->Generation := this->Variable->Generation
		
		return this
	}
	
	static self WrapLong(TACAddressKind Kind, void* Value) {
		self this := 0 As self
		
		this->Kind := Kind
		this->Size := TACAddressSize:Long
		this->Value := Value
		
		return this
	}
	static self WrapLong(TACAddressKind Kind, i64 Value) {
		return self:WrapLong(Kind, Value As void*)
	}
	
	static self WrapWord(TACAddressKind Kind, void* Value) {
		self this := 0 As self
		
		this->Kind := Kind
		this->Size := TACAddressSize:Long
		this->Value := Value
		
		return this
	}
	static self WrapWord(TACAddressKind Kind, i64 Value) {
		return self:WrapWord(Kind, Value As void*)
	}
	
	static self Integer(i32 Value) {
		return self:WrapWord(TACAddressKind:Integer, Value As void*)
	}
	static self Integer(i64 Value) {
		return self:WrapLong(TACAddressKind:Integer, Value As void*)
	}

	static self Temporary(i32 BlockNumber, i32 InstructionNumber) {
		self Result := self:WrapLong(TACAddressKind:Temporary, BlockNumber)

		Result.InstructionNumber := InstructionNumber

		return Result
	}
	
	define i8 Is(TACAddressKind Kind) {
		return this->Kind = Kind
	}
	
	define i8 Equals(TACAddress Other) {
		if (this = 0 && Other = 0) {
			return true
		}
		else if (this = 0 || Other = 0) {
			return false
		}
		
		if (Other->Kind != this->Kind) {
			return false
		}
		
		if (Other->Value != this->Value) {
			return false
		}
		
		if (Other->Generation != this->Generation) {
			return false
		}
		
		return true
	}
	
	define void Print() {
		if (this = 0) {
			return
		}
		
		if (this->Is(TACAddressKind:Integer)) {
			Print("%i", this->Integer)
		}
		else {
			if (this->Is(TACAddressKind:Variable)) {
				this->Variable->Base->Name->Print()
				
				Print("%i", this->Generation)
			}
			else if (this->Is(TACAddressKind:Temporary)) {
				Print("@%i.%i", this->BlockNumber, this->InstructionNumber)
			}
		}
		
		if (this->Size = TACAddressSize:Word) {
			Print("_w")
		}
		else {
			Print("_l")
		}
	}
}

TACAddress TAC_ADDRESS_NULL := 0 As TACAddress

define void DoAddressPrint(PrintOutputAdapterPrototype* this, i8* Format, i32* FormatIndex, void* Parameters, i32 ParameterCount, i32* ParameterIndex) {
	TACAddress Address := Parameters[*ParameterIndex] As TACAddress
	
	Address->Print()
	
	*ParameterIndex += 1
}

PrintFormatPrototype AddressPrintPrototype {
	Name: "a",
	Format: &DoAddressPrint
}

i32 ADDRESS_PRINT_PROTOTYPE_ID := AddPrintFormat(&AddressPrintPrototype)

i32 TAC_MOVE := 0

i32 TAC_LOAD_INDIRECT_1 := 1
i32 TAC_LOAD_INDIRECT_2 := 2
i32 TAC_LOAD_INDIRECT_4 := 3
i32 TAC_LOAD_INDIRECT_8 := 4
i32 TAC_STORE_INDIRECT_1 := 5
i32 TAC_STORE_INDIRECT_2 := 6
i32 TAC_STORE_INDIRECT_4 := 7
i32 TAC_STORE_INDIRECT_8 := 8

i32 TAC_LOAD_ADDRESS := 9
i32 TAC_JUMP_TRUE := 10
i32 TAC_JUMP_FALSE := 11
i32 TAC_JUMP := 12

i32 TAC_RETURN := 13
i32 TAC_PHI := 14

i32 TAC_REMOVED := 15

i32 TAC_ALU_FIRST := 20

define i32 SizedOpcode(i32 Opcode, i32 Size) {
	if (Size = 8) {
		return Opcode + 3
	}
	else if (Size = 4) {
		return Opcode + 2
	}
	else if (Size = 2) {
		return Opcode + 1
	}
	else {
		return Opcode
	}
}

define i8* GetOperatorName(i32 Operator) {
	i8*[40] Operators {
		":=", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=",
		"&&", "||",
		"=", "!=", "<", "<=", ">", ">=",
		"as",
		"+", "-",
		"*", "/", "%",
		"&", "|", "^",
		"<<", ">>",
		"!", "~",
		"++", "--", "++", "--",
		"[",
		".", "->", "~>",
		":", "#"
	}
	
	return Operators[Operator]
}

define i8* GetOpcodeName(i32 Opcode) {
	i8*[15] Names {
		":=",
		"* As i8",
		"* As i16",
		"* As i32",
		"* As i64",
		"* As i8 :=",
		"* As i16 := ",
		"* As i32 :=",
		"* As i64 :=",
		"&",
		"jnz",
		"jez",
		"jmp",
		"return",
		"phi"
	}
	
	if (Opcode >= TAC_ALU_FIRST) {
		return GetOperatorName(Opcode - TAC_ALU_FIRST)
	}
	
	return Names[Opcode]
}

struct TACPhiInfo {
	i8* Name
	i64 Hash

	PointerArray Definitions ; <TACAddress>

	static self* New(i8* Name, i64 Hash) {
		self* this := Alloc(#self)

		this->Name := Name
		this->Hash := Hash
		this~>Definitions->Initialize()

		return this
	}

	define void AddDefinition(TACAddress Address) {
		this~>Definitions->Push(Address As void*)
	}

	define void RemoveDefinition(TACAddress Address) {
		for (i32 Index := 0, Index < this~>Definitions->Count(), Index++) {
			TACAddress Next := this~>Definitions->At(Index) As TACAddress

			if (Next->Equals(Address)) {
				this~>Definitions->Remove(Index)

				return
			}
		}
	}

	define i32 Count() {
		return this~>Definitions->Count()
	}
	define TACAddress At(i32 Index) {
		return this~>Definitions->At(Index) As TACAddress
	}
}

struct TACTriple {
	i32 Opcode
	
	union {
		TACAddress Left
		TACAddress Operand
		TACAddress Source
		TACPhiInfo* Phi
	}
	
	union {
		TACAddress Right
	}
	
	static self* New(i32 Opcode, TACAddress Left, TACAddress Right) {
		self* this := Alloc(#self)
		
		this->Opcode := Opcode
		this->Left := Left
		this->Right := Right
		
		return this
	}
	
	static self* New(i32 Opcode, TACAddress Operand) {
		self* this := Alloc(#self)
		
		this->Opcode := Opcode
		this->Operand := Operand
		
		return this
	}

	define void Remove() {
		this->Opcode := TAC_REMOVED
	}

	define i8 Is(i32 Opcode) {
		return this->Opcode = Opcode
	}
	
	define void Print() {
		if (this->Is(TAC_PHI)) {
			Print("phi\t%s", this->Phi->Name)

			for (i32 Index := 0, Index < this->Phi->Count(), Index++) {
				Print("\t%a", this->Phi->At(Index))

				if (Index + 1 != this->Phi->Count()) {
					Print(",")
				}
			}
		}
		else if (this->Right) {
			Print("%s\t%a,\t%a", GetOpcodeName(this->Opcode), this->Left, this->Right)
		}
		else {
			Print("%s\t%a", GetOpcodeName(this->Opcode), this->Left)
		}
	}
}

struct TACBlock {
	i32 Number

	PointerArray Parents ; <TACBlock*>
	PointerArray Children ; <TACBlock*>

	PointerArray IncompletePhi ; <TACAddress>
	PointerArray Body ; <TACTriple*>

	AVLTree Definitions

	i8 Sealed

	define void Initialize(i32 Number) {
		this->Number := Number

		this~>Parents->Initialize()
		this~>Children->Initialize()

		this~>IncompletePhi->Initialize()
		this~>Body->Initialize()

		this~>Definitions->ValueSize := 8
	}

	define void Push(TACTriple* Triple) {
		this~>Body->Push(Triple)
	}
	define i32 Count() {
		return this~>Body->Count()
	}
	define TACTriple* At(i32 Index) {
		return this~>Body->At(Index)
	}

	define void Print() {
		Print("%i: ", this->Number)

		i32 ParentCount := this~>Parents->Count()

		if (ParentCount) {
			Print("[")

			for (i32 Index := 0, Index < ParentCount, Index++) {
				TACBlock* Parent := this~>Parents->At(Index)

				Print("%i", Parent->Number)

				if (Index + 1 != ParentCount) {
					Print(", ")
				}
			}

			Print("] ")
		}

		i32 ChildCount := this~>Children->Count()

		if (ChildCount) {
			Print("(")

			for (i32 Index := 0, Index < ChildCount, Index++) {
				TACBlock* Child := this~>Children->At(Index)

				Print("%i", Child->Number)

				if (Index + 1 != ChildCount) {
					Print(", ")
				}
			}

			Print(")")
		}

		Print("\n")

		for (i32 Index := 0, Index < this->Count(), Index++) {
			TACTriple* Next := this->At(Index)

			if (Next->Opcode = TAC_REMOVED) {
				continue
			}

			Print("\t.%i:\t", Index)
			Next->Print()
			Print("\n")
		}
	}

}

struct TACBuilder {
	union {
		void* Buffer
		TACTriple** Triples
	}
	
	i32 Length
	
	TACBlock* CurrentBlock
	
	PointerArray* Blocks ; <TACBlock*>
	
	static TACBuilder* New() {
		self* this := Alloc(#self)
		
		this->Buffer := Alloc(100 * #TACTriple*)
		
		this->Blocks := PointerArray:New()
		
		return this
	}
	
	define TACAddress Emit(TACBlock* InBlock, i32 Opcode, TACAddress Left, TACAddress Right) {
		if (Opcode = TAC_JUMP || Opcode = TAC_JUMP_TRUE || Opcode = TAC_JUMP_FALSE) {
			TACBlock* Destination := null

			if (Opcode = TAC_JUMP) {
				Destination := this->Blocks->At(Left.Integer As i32)
			}
			else {
				Destination := this->Blocks->At(Right.Integer As i32)
			}

			InBlock~>Children->Add(Destination)
			Destination~>Parents->Add(InBlock)
		}
		
		i32 Index := InBlock->Count()

		TACTriple* New := TACTriple:New(Opcode, Left, Right)
		InBlock->Push(New)
		
		return TACAddress:Temporary(InBlock->Number, Index)
	}

	define TACAddress Emit(i32 Opcode, TACAddress Left, TACAddress Right) {
		return this->Emit(this->CurrentBlock, Opcode, Left, Right)
	}

	define TACAddress Emit(TACBlock* InBlock, i32 Opcode, TACAddress Operand) {
		return this->Emit(this->CurrentBlock, Opcode, Operand, TAC_ADDRESS_NULL)
	}

	define TACAddress Emit(i32 Opcode, TACAddress Operand) {
		return this->Emit(Opcode, Operand, TAC_ADDRESS_NULL)
	}

	define TACTriple* GetTemporary(TACAddress TemporaryAddress) {
		i32 BlockNumber := TemporaryAddress.BlockNumber
		i32 InstructionNumber := TemporaryAddress.InstructionNumber

		TACBlock* InBlock := this->Blocks->At(BlockNumber)

		return InBlock->At(InstructionNumber)
	}

	define void Remove(TACAddress TemporaryAddress) {
		this->GetTemporary(TemporaryAddress)->Remove()
	}

	define void SetName(i8* Name, TACAddress Value) {
		Print("Set %i.%s to %a\n", this->CurrentBlock->Number, Name, Value)

		i64 Hash := FNV1A(Name)

		this->CurrentBlock~>Definitions->Insert(Hash, &Value)
	}

	define TACAddress RemoveTrivialPhi(TACPhiInfo* Phi, TACAddress PhiAddress) {
		TACAddress Same := TAC_ADDRESS_NULL

		for (i32 Index := 0, Index < Phi~>Definitions->Count(), Index++) {
			TACAddress Next := Phi~>Definitions->At(Index) As TACAddress

			if (Next->Equals(Same) || Next->Equals(PhiAddress)) {
				continue
			}
			else if (Same != null) {
				return PhiAddress
			}

			Same := Next
		}

		if (Same = TAC_ADDRESS_NULL) {
			this->Remove(PhiAddress)
		}

		Phi->RemoveDefinition(PhiAddress)

		for (i32 Index := 0, Index < Phi~>Definitions->Count(), Index++) {
			TACAddress Address := Phi~>Definitions->At(Index) As TACAddress

			if (Address.Is(TACAddressKind:Temporary)) {
				TACTriple* Triple := this->GetTemporary(Address)

				if (Triple->Is(TAC_PHI)) {
					this->RemoveTrivialPhi(Triple->Phi, Address)
				}
			}
		}

		return Same
	}

	declare TACAddress LookupName(TACBlock*, i8*, i64)

	define TACAddress AddPhiOperands(TACBlock* InBlock, TACPhiInfo* Phi, TACAddress PhiAddress) {
		for (i32 Index := 0, Index < InBlock~>Parents->Count(), Index++) {
			TACBlock* Parent := InBlock~>Parents->At(Index)

			TACAddress ParentDefinition := this->LookupName(Parent, Phi->Name, Phi->Hash)

			if (ParentDefinition != TAC_ADDRESS_NULL) {
				Phi->AddDefinition(ParentDefinition)
			}
		}

		; return this->RemoveTrivialPhi(Phi, PhiAddress)

		return PhiAddress
	}
	
	define TACAddress LookupName(TACBlock* InBlock, i8* Name, i64 Hash) {
		if (InBlock~>Definitions->Has(Hash)) {
			return InBlock~>Definitions->GetPointer(Hash) As TACAddress
		}
		
		TACAddress Result := TAC_ADDRESS_NULL
		
		if !(InBlock->Sealed) {
			TACPhiInfo* Phi := TACPhiInfo:New(Name, Hash)
			Result := this->Emit(InBlock, TAC_PHI, Phi As TACAddress)

			this->CurrentBlock~>IncompletePhi->Push(Result As void*)
		}
		else if (InBlock~>Parents->Count() = 1) {
			TACBlock* Parent := InBlock~>Parents->At(0)

			return this->LookupName(Parent, Name, Hash)
		}
		else {
			TACPhiInfo* Phi := TACPhiInfo:New(Name, Hash)
			Result := this->Emit(InBlock, TAC_PHI, Phi As TACAddress)

			Result := this->AddPhiOperands(InBlock, Phi, Result)
		}

		this->SetName(Name, Result)

		return Result
	}

	define TACAddress LookupName(TACBlock* InBlock, i8* Name) {
		return this->LookupName(InBlock, Name, FNV1A(Name))
	}

	define TACAddress LookupName(i8* Name) {
		return this->LookupName(this->CurrentBlock, Name, FNV1A(Name))
	}

	define void SealBlock(TACBlock* InBlock) {
		if !(InBlock->Sealed) {
			InBlock->Sealed := true

			i32 PhiCount := InBlock~>IncompletePhi->Count()

			for (i32 Index := 0, Index < PhiCount, Index++) {
				TACAddress PhiAddress := InBlock~>IncompletePhi->At(Index) As TACAddress
				
				Print("Seal %a\n", PhiAddress)

				TACPhiInfo* Phi := this->GetTemporary(PhiAddress)->Phi

				this->AddPhiOperands(InBlock, Phi, PhiAddress)
			}
		}
	}
	
	define void EndBlock() {
		if (this->CurrentBlock) {
			this->CurrentBlock := null
		}
	}
	
	define i32 StartBlock(i32 Index) {
		this->EndBlock()
		
		this->CurrentBlock := this->Blocks->Get(Index)
		
		return Index
	}
	
	define i32 ReserveLabel() {
		i32 Result := this->Blocks->Count()

		TACBlock* New := Alloc(#TACBlock)
		
		New->Initialize(this->Blocks->Count())
		this->Blocks->Push(New)
		
		return Result
	}
	
	define i32 SetLabel() {
		return this->StartBlock(this->ReserveLabel())
	}
	define i32 SetLabel(i32 Number) {
		return this->StartBlock(Number)
	}
	
	define void Print() {
		this->SealBlock(this->Blocks->At(0))
		this->SealBlock(this->Blocks->At(3))
		this->SealBlock(this->Blocks->At(1))

		for (i32 BlockIndex := 0, BlockIndex < this->Blocks->Count(), BlockIndex++) {
			TACBlock* InBlock := this->Blocks->At(BlockIndex)

			InBlock->Print()
		}
	}
}

bits LoopLables As i64 {
	[0:31] BreakLabel
	[32:63] ContinueLabel
}

#Require "./src/compiler/IR2/TACFromAST.rlx"

define void Main(i64 ArgC, i8** ArgV) {
	GetArgs(&ArgC, &ArgV)
	
	if (ArgC != 2) {
		Print("No input file\n")
		Exit(1)
	}
	
	BuildConfig* Config := Alloc(#BuildConfig)
	
	Config->DumpInfo := 0
	Config->LineEnding := LINE_ENDING_DEFAULT
	Config->OutputFormat := OUTPUT_ELF
	
	i8* InputFilePath := ArgV[1]
	
	i32 SourceLength := 0
	i8* Source := OpenAndRead(InputFilePath, &SourceLength)
	
	LexerState* Lexer := LexerState:New(Config, Source, SourceLength, AToS(InputFilePath))
	Config->Lexer := Lexer
	
	ParserState* Parser := ParserState:New(Config, Lexer)
	
	TACFromAST* TFA := TACFromAST:New()
	
	Parser->ParseProgram()
	
	TFA->CompileFunctionHashMap(Parser~>Functions)
	
	TFA->Builder->Print()
}
