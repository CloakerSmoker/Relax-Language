#Require "$/Memory.rlx"
#Require "$/File.rlx"

#Require "$/String.rlx"
#Require "$/Console.rlx"
#Require "$/SafeString.rlx"
#Require "$/HashMap.rlx"
#Require "$/Debug.rlx"

#Require "./src/compiler/IR2/PointerArray.rlx"

#Require "./src/compiler/Utility.rlx"
#Require "./src/compiler/Lexer.rlx"
#Require "./src/compiler/Parser.rlx"

enum TACAddressKind As i8 {
	Variable,
	Temporary,
	Integer
}

enum TACAddressSize As i8 {
	Word,
	Long
}

struct TACVariable {
	VariableInfo* Base
	
	i32 Generation
	
	i64 LastValue
	
	static self* New(VariableInfo* Base) {
		self* this := Alloc(#self)
		
		this->Base := Base
		
		return this
	}
}

bits TACAddress As i64 {
	TACVariable* [0:47] Variable
	i64* [0:47] IntegerPointer
	i64 [0:47] Integer
	i32 [0:31] TemporaryNumber
	void* [0:47] Value
	
	i32 [48:55] Generation
	TACAddressKind [56:59] Kind
	TACAddressSize [60:63] Size
	
	define TACAddress IncrementGeneration() {
		this->Generation := this->Variable->Generation++
		
		return this
	}
	
	define TACAddress CopyGeneration() {
		this->Generation := this->Variable->Generation
		
		return this
	}
	
	static self WrapLong(TACAddressKind Kind, void* Value) {
		self this := 0 As self
		
		this->Kind := Kind
		this->Size := TACAddressSize:Long
		this->Value := Value
		
		return this
	}
	static self WrapLong(TACAddressKind Kind, i64 Value) {
		return self:WrapLong(Kind, Value As void*)
	}
	
	static self WrapWord(TACAddressKind Kind, void* Value) {
		self this := 0 As self
		
		this->Kind := Kind
		this->Size := TACAddressSize:Long
		this->Value := Value
		
		return this
	}
	static self WrapWord(TACAddressKind Kind, i64 Value) {
		return self:WrapWord(Kind, Value As void*)
	}
	
	static self Integer(i32 Value) {
		return self:WrapWord(TACAddressKind:Integer, Value As void*)
	}
	static self Integer(i64 Value) {
		return self:WrapLong(TACAddressKind:Integer, Value As void*)
	}
	
	define i8 Is(TACAddressKind Kind) {
		return this->Kind = Kind
	}
	
	define i8 Equals(TACAddress Other) {
		if (this = 0 && Other = 0) {
			return true
		}
		else if (this = 0 || Other = 0) {
			return false
		}
		
		if (Other->Kind != this->Kind) {
			return false
		}
		
		if (Other->Value != this->Value) {
			return false
		}
		
		if (Other->Generation != this->Generation) {
			return false
		}
		
		return true
	}
	
	define void Print() {
		if (this = 0) {
			return
		}
		
		if (this->Is(TACAddressKind:Integer)) {
			Print("%i", this->Integer)
		}
		else {
			if (this->Is(TACAddressKind:Variable)) {
				this->Variable->Base->Name->Print()
				
				Print("%i", this->Generation)
			}
			else if (this->Is(TACAddressKind:Temporary)) {
				Print("@%i", this->TemporaryNumber)
			}
		}
		
		if (this->Size = TACAddressSize:Word) {
			Print("_w")
		}
		else {
			Print("_l")
		}
	}
}

TACAddress TAC_ADDRESS_NULL := 0 As TACAddress

define void DoAddressPrint(PrintOutputAdapterPrototype* this, i8* Format, i32* FormatIndex, void* Parameters, i32 ParameterCount, i32* ParameterIndex) {
	TACAddress Address := Parameters[*ParameterIndex] As TACAddress
	
	Address->Print()
	
	*ParameterIndex += 1
}

PrintFormatPrototype AddressPrintPrototype {
	Name: "a",
	Format: &DoAddressPrint
}

i32 ADDRESS_PRINT_PROTOTYPE_ID := AddPrintFormat(&AddressPrintPrototype)

i32 TAC_MOVE := 0

i32 TAC_LOAD_INDIRECT_1 := 1
i32 TAC_LOAD_INDIRECT_2 := 2
i32 TAC_LOAD_INDIRECT_4 := 3
i32 TAC_LOAD_INDIRECT_8 := 4
i32 TAC_STORE_INDIRECT_1 := 5
i32 TAC_STORE_INDIRECT_2 := 6
i32 TAC_STORE_INDIRECT_4 := 7
i32 TAC_STORE_INDIRECT_8 := 8

i32 TAC_LOAD_ADDRESS := 9
i32 TAC_JUMP_TRUE := 10
i32 TAC_JUMP_FALSE := 11
i32 TAC_JUMP := 12

i32 TAC_RETURN := 13

i32 TAC_ALU_FIRST := 20

define i32 SizedOpcode(i32 Opcode, i32 Size) {
	if (Size = 8) {
		return Opcode + 3
	}
	else if (Size = 4) {
		return Opcode + 2
	}
	else if (Size = 2) {
		return Opcode + 1
	}
	else {
		return Opcode
	}
}

define i8* GetOperatorName(i32 Operator) {
	i8*[40] Operators {
		":=", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=",
		"&&", "||",
		"=", "!=", "<", "<=", ">", ">=",
		"as",
		"+", "-",
		"*", "/", "%",
		"&", "|", "^",
		"<<", ">>",
		"!", "~",
		"++", "--", "++", "--",
		"[",
		".", "->", "~>",
		":", "#"
	}
	
	return Operators[Operator]
}

define i8* GetOpcodeName(i32 Opcode) {
	i8*[14] Names {
		":=",
		"* As i8",
		"* As i16",
		"* As i32",
		"* As i64",
		"* As i8 :=",
		"* As i16 := ",
		"* As i32 :=",
		"* As i64 :=",
		"&",
		"jnz",
		"jez",
		"jmp",
		"return"
	}
	
	if (Opcode >= TAC_ALU_FIRST) {
		return GetOperatorName(Opcode - TAC_ALU_FIRST)
	}
	
	return Names[Opcode]
}

struct TACTriple {
	i32 Opcode
	
	union {
		TACAddress Left
		TACAddress Operand
		TACAddress Source
	}
	
	union {
		TACAddress Right
	}
	
	static self* New(i32 Opcode, TACAddress Left, TACAddress Right) {
		self* this := Alloc(#self)
		
		this->Opcode := Opcode
		this->Left := Left
		this->Right := Right
		
		return this
	}
	
	static self* New(i32 Opcode, TACAddress Operand) {
		self* this := Alloc(#self)
		
		this->Opcode := Opcode
		this->Operand := Operand
		
		return this
	}
	
	define void Print() {
		if (this->Right) {
			Print("%s\t%a,\t%a", GetOpcodeName(this->Opcode), this->Left, this->Right)
		}
		else {
			Print("%s\t%a", GetOpcodeName(this->Opcode), this->Left)
		}
	}
}

struct TACBlock {
	i32 Start
	i32 Size
}

struct TACBuilder {
	union {
		void* Buffer
		TACTriple** Triples
	}
	
	i32 Length
	
	TACBlock* CurrentBlock
	
	PointerArray* Blocks ; <TACBlock*>
	
	static TACBuilder* New() {
		self* this := Alloc(#self)
		
		this->Buffer := Alloc(100 * #TACTriple*)
		
		this->Blocks := PointerArray:New()
		
		return this
	}
	
	define TACAddress Emit(i32 Opcode, TACAddress Left, TACAddress Right) {
		i32 Result := this->Length++
		
		this->Triples[Result] := TACTriple:New(Opcode, Left, Right)
		
		return TACAddress:WrapLong(TACAddressKind:Temporary, Result)
	}
	define TACAddress Emit(i32 Opcode, TACAddress Operand) {
		return this->Emit(Opcode, Operand, TAC_ADDRESS_NULL)
	}
	
	define void EndBlock() {
		if (this->CurrentBlock) {
			i32 Length := this->Length - this->CurrentBlock->Start
			
			this->CurrentBlock->Size := Length
			
			this->CurrentBlock := null
		}
	}
	
	define i32 StartBlock(i32 Index) {
		this->EndBlock()
		
		this->CurrentBlock := this->Blocks->Get(Index)
		this->CurrentBlock->Start := this->Length
		
		return Index
	}
	
	define i32 ReserveLabel() {
		i32 Result := this->Blocks->Length
		
		this->Blocks->Append(Alloc(#TACBlock))
		
		return Result
	}
	
	define i32 SetLabel() {
		return this->StartBlock(this->ReserveLabel())
	}
	define i32 SetLabel(i32 Number) {
		return this->StartBlock(Number)
	}
	
	define void Print() {
		for (i32 Index := 0, Index < this->Length, Index++) {
			Print("%i:\t", Index)
			this->Triples[Index]->Print()
			Print("\n")
		}
	}
}

bits LoopLables As i64 {
	[0:31] BreakLabel
	[32:63] ContinueLabel
}

#Require "./src/compiler/IR2/TACFromAST.rlx"

define void Main(i64 ArgC, i8** ArgV) {
	GetArgs(&ArgC, &ArgV)
	
	if (ArgC != 2) {
		Print("No input file\n")
		Exit(1)
	}
	
	BuildConfig* Config := Alloc(#BuildConfig)
	
	Config->DumpInfo := 0
	Config->LineEnding := LINE_ENDING_DEFAULT
	Config->OutputFormat := OUTPUT_ELF
	
	i8* InputFilePath := ArgV[1]
	
	i32 SourceLength := 0
	i8* Source := OpenAndRead(InputFilePath, &SourceLength)
	
	LexerState* Lexer := LexerState:New(Config, Source, SourceLength, AToS(InputFilePath))
	Config->Lexer := Lexer
	
	ParserState* Parser := ParserState:New(Config, Lexer)
	
	TACFromAST* TFA := TACFromAST:New()
	
	Parser->ParseProgram()
	
	TFA->CompileFunctionHashMap(Parser~>Functions)
	
	TFA->Builder->Print()
}
