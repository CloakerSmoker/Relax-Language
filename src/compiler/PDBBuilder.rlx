#Require "./src/lib/Console.rlx"

#Require "./src/lib/File.rlx"

struct MSFSuperBlock {
	i8{0x20} Magic,
	i32 BlockSize,			; Should be 4096
	i32 FreeBlockMapBlock,	; Block index (only allowed to be 1 or 2)
	i32 NumberOfBlocks,		; Total block count, (NumberOfBlocks * BlockSize) = FileSize
	i32 NumberOfDirectoryBytes,	; Size of stream directory
	i32 Unknown,
	i32 BlockMapIndex	; Index of a block listing blocks which contain the stream directory
	; Number of blocks inside of BlockMapIndex block = Ceil(NumberOfDirectoryBytes / BlockSize)
	
	
	define void Print() {
		Print("MSFSuperBlock {\n")
		Print("	BlockSize = %x\n", this->BlockSize)
		Print("	FreeBlockMapBlock = %x\n", this->FreeBlockMapBlock)
		Print("	NumberOfBlocks = %x\n", this->NumberOfBlocks)
		Print("	NumberOfDirectoryBytes = %x\n", this->NumberOfDirectoryBytes)
		Print("	Unknown = %x\n", this->Unknown)
		Print("	BlockMapIndex = %x\n", this->BlockMapIndex)
		Print("}\n")
	}
}

struct MSFStreamDirectory {
	i32 NumberOfStreams
	i32 StreamSizesArrayStart
	
	define i32* GetStreamSizesArray() {
		return this~>StreamSizesArrayStart
	}
	define i32* GetStreamBlocksArray() {
		return (this->GetStreamSizesArray() + this->NumberOfStreams * 4) As i32*
	}
	
	define i32 GetStreamBlockCountFromSize(i32 Size) {
		i32 BlockCount := Size / 0x1000
		
		if (Size % 0x1000) {
			BlockCount += 1
		}
		
		return BlockCount
	}
	define i32 GetStreamBlockCount(i32 StreamIndex) {
		return this->GetStreamBlockCountFromSize(this->GetStreamSizesArray()[StreamIndex])
	}
	
	define i32 GetBlocksArraySize() {
		i32* StreamSizeArray := this->GetStreamSizesArray()
		i32 TotalBlocks := 0
		
		for (i32 StreamIndex := 0, StreamIndex < this->NumberOfStreams, StreamIndex += 1) {
			TotalBlocks += this->GetStreamBlockCountFromSize(StreamSizeArray[StreamIndex])
		}
		
		return TotalBlocks * 4
	}
	define i32 GetSize() {
		return 4 + (this->NumberOfStreams * 4) + this->GetBlocksArraySize()
	}
	
	define i32* GetStreamBlocks(i32 TargetStreamIndex) {
		i32* Start := this->GetStreamBlocksArray()
		
		for (i32 StreamIndex := 0, StreamIndex < TargetStreamIndex, StreamIndex += 1) {
			Start += this->GetStreamBlockCount(StreamIndex) * 4
		}
		
		return Start
	}
	
	define i32 StartAppendStream(i32 Size, i32* OutBlockCount, i32* OutNewSize) {
		void* BlocksArray := this->GetStreamBlocksArray()
		i32 BlocksArraySize := this->GetBlocksArraySize()
		i32 OldSize := 4 + (this->NumberOfStreams * 4) + BlocksArraySize
		
		; Shift the entire block number array to make room for another i32 stream size before it
		MoveMemory(BlocksArray + 4, BlocksArray, BlocksArraySize)
		
		i32* NewBlockSizesTail := BlocksArray
		i32 BlockNumbersCount := this->GetStreamBlockCountFromSize(Size)
		
		; Write the new stream size into the space the block number array was shifted out of
		NewBlockSizesTail[0] := Size
		
		; Update the stream count
		this->NumberOfStreams += 1
		
		; And update the output parameters
		OutBlockCount[0] := BlockNumbersCount
		OutNewSize[0] := OldSize + 4 + BlockNumbersCount * 4
		
		; Return the offset into the buffer for the caller to write the new stream's block numbers into
		return OldSize + 4
	}
}

struct MSFBuilder {
	union {
		void* Buffer
		MSFSuperBlock* SuperBlock
	}
	
	i32 StreamDirectoryBlockIndex
	
	union {
		void* StreamDirectoryBlock
		MSFStreamDirectory* StreamDirectory
	}
	
	declare void AllocateBlock()
	
	define void Initialize() {
		this->Buffer := Alloc(0x3000)
		this->SuperBlock->NumberOfBlocks := 3
		
		i8* MagicBuffer := this->SuperBlock~>Magic
		
		MoveMemory(MagicBuffer, "Microsoft C/C++ MSF 7.00", 24)
		
		(MagicBuffer + 24 As i64*)[0] := 0x53441a0a0d
		
		i8* BlockMapBuffer := this->Buffer + 0x1000
		
		for (i32 BlockMapIndex := 0, BlockMapIndex < 0x2000, BlockMapIndex += 1) {
			BlockMapBuffer[BlockMapIndex] := 0xFF
		}
		
		this->SuperBlock->BlockSize := 0x1000
		this->SuperBlock->FreeBlockMapBlock := 1
		
		; Allocate the first 3 blocks in the file (for the superblock, and free block maps)
		for (i32 Index := 0, Index < 3, Index += 1) {
			this->AllocateBlock()
		}
	}
	
	define i32 GetSize() {
		return this->SuperBlock->NumberOfBlocks * 0x1000
	}
	define void* GetBlockBuffer(i32 BlockIndex) {
		return this->Buffer + (BlockIndex * 0x1000)
	}
	define void EnsureSize(i32 ForBlockIndex) {
		ForBlockIndex += 1
		
		if (this->SuperBlock->NumberOfBlocks < ForBlockIndex) {
			this->SuperBlock->NumberOfBlocks := ForBlockIndex
			
			this->Buffer := ReAlloc(this->Buffer, ForBlockIndex * 0x1000)
			this->StreamDirectoryBlock := this->GetBlockBuffer(this->StreamDirectoryBlockIndex)
		}
	}
	define i32 AllocateBlock() {
		i8* Bitmap := this->Buffer + 0x1000 * this->SuperBlock->FreeBlockMapBlock
		
		for (i32 Index := 0, Index < 0x1000, Index += 1) {
			i32 ByteIndex := Index / 8
			i32 BitIndex := Index % 8
			i32 BitMask := 1 << (BitIndex As i8)
			
			i8 TargetByte := Bitmap[ByteIndex]
			
			if (TargetByte & BitMask) {
				Bitmap[ByteIndex] := TargetByte ^ BitMask
				
				this->EnsureSize(Index)
				return Index
			}
		}
	}
	
	define void AllocateStreamDirectory() {
		i32 StreamDirectoryIndexBlockNumber := this->AllocateBlock()
		i32 StreamDirectoryBlockNumber := this->AllocateBlock()
		
		this->SuperBlock->BlockMapIndex := StreamDirectoryIndexBlockNumber
		
		i32* StreamDirectoryIndex := this->GetBlockBuffer(StreamDirectoryIndexBlockNumber)
		
		StreamDirectoryIndex[0] := StreamDirectoryBlockNumber
		
		this->StreamDirectoryBlockIndex := StreamDirectoryBlockNumber
		this->StreamDirectoryBlock := this->GetBlockBuffer(StreamDirectoryBlockNumber)
	}
	define void AppendStream(void* StreamData, i32 StreamSize) {
		i32 BlockCount := 0
		i32 BlockBufferOffset := this->StreamDirectory->StartAppendStream(StreamSize, &BlockCount, this->SuperBlock~>NumberOfDirectoryBytes)
		
		i32 Remainder := StreamSize % 0x1000
		
		for (i32 BlockIndex := 0, BlockIndex < BlockCount, BlockIndex += 1) {
			i32 NextBlock := this->AllocateBlock()
			
			; Since the underlying buffer `this->Buffer` can be reallocated, we need to use the offset
			;  to the block buffer to 'refresh' the pointer each iteration. Especially since
			;   `this->AllocateBlock()` will reallocate `this->Buffer` if the new block hasn't
			;    already been allocated space
			i32* BlockBuffer := this->StreamDirectoryBlock + BlockBufferOffset
			BlockBuffer[BlockIndex] := NextBlock
			
			void* NextBlockBuffer := this->GetBlockBuffer(NextBlock)
			
			if (BlockIndex + 1 = BlockCount && Remainder) {
				MoveMemory(NextBlockBuffer, StreamData + BlockIndex * 0x1000, Remainder)
			}
			else {
				MoveMemory(NextBlockBuffer, StreamData + BlockIndex * 0x1000, 0x1000)
			}
		}
	}
	
	define void WriteToFile(i8* FilePath) {
		FileDelete(FilePath)
		
		i64 File := FileOpen(FilePath, FILE_WRITE | FILE_CREATE_NEW)
		
		FileWrite(File, this->Buffer, this->GetSize())
		
		FileClose(File)
	}
}

;struct PDBHashmap {
;	union {
;		PDBHashmapHeader* Header,
;		void* Buffer
;	},
;	
;	i32 BufferSize,
;	i32 PairIndex,
;	
;	define void Initialize(void* InBuffer, i32 Size, i32 BucketCount) {
;		this->BufferSize := #PDBHashmapHeader + (BucketCount * 2) + (Size * #PDBHashmapKeyValuePair)
;		
;		if (InBuffer = null) {
;			this->Buffer := Alloc(this->BufferSize)
;		}
;		else {
;			this->Buffer := InBuffer
;		}
;
;		this->Header->Size := Size
;		this->Header->BucketCount := BucketCount		
;	},
;	define void Initialize(i32 Size, i32 BucketCount) {
;		this->Initialize(null, Size, BucketCount)
;	},
;	define void AppendPair(i32 Key, i32 Value) {
;		PDBHashmapKeyValuePair* Pairs := this->Header->GetKeyValues()
;		
;		PDBHashmapKeyValuePair* NextPair := Pairs + (this->PairIndex * #PDBHashmapKeyValuePair)
;		
;		NextPair->Key := Key
;		NextPair->Value := Value
;		
;		this->PairIndex += 1
;	},
;	define void* SerializeInto(void* Buffer) {
;		MoveMemory(Buffer, this->Buffer, this->BufferSize)
;		
;		return Buffer + this->BufferSize
;	}
;}

#Require "./src/lib/Debug.rlx"

define i32 PDBHashStringV1(i8* String, i32 Length) {
	i32* Longs := String As i32*
	i32 LongCount := Length / 4
	
	i32 Result := 0
	
	for (i32 LongIndex := 0, LongIndex < LongCount, LongIndex += 1) {
		Result ^= Longs[LongIndex]
	}
	
	;Print("HSV1(%s, %i) PreResult = %x\n", String, Length, Result)
	
	i8* Remainder := Longs + LongCount * 4
	i32 RemainderSize := Length % 4
	
	;Print("HSV1(%s, %i) RemainderSize = %x\n", String, Length, RemainderSize)
	
	if (RemainderSize >= 2) {
		i32 Value := *(Remainder As i16*)
		Result ^= Value
		
		Remainder += 2
		RemainderSize -= 2
	}
	
	if (RemainderSize = 1) {
		;Print("HSV1(%s, %i) LastCharacter = %x\n", String, Length, *(Remainder))
		
		Result ^= *(Remainder)
	}
	
	;Print("HSV1(%s, %i) UpperResult = %x\n", String, Length, Result)
	
	i32 ToLowerMask := 0x20202020
	Result |= ToLowerMask
	Result ^= (Result >> 11)
	
	return Result ^ (Result >> 16)
}
define i16 PDBHashLookupKeyV1(i8* Key, i32 KeyLength) {
	return PDBHashStringV1(Key, KeyLength) As i16
}

define i16 PDBCallHasher(void* this, i8* Key, i32 KeyLength, void* Implementation) asm {
	jmp, rcx
}
define i8* PDBCallStorageKeyToLookupKey(void* this, i32 Offset, void* Implementation) asm {
	jmp, rdx
}
define i32 PDBCallLookupKeyToStorageKey(void* this, i8* Key, i32 KeyLength, void* Implementation) asm {
	jmp, rcx
}

struct PDBHashmapTraits {
	void* Hasher,
	void* StorageKeyToLookupKey,
	void* LookupKeyToStorageKey,
	void* TrueThis,
	
	define i16 Hash(i8* Key, i32 KeyLength) {
		return PDBCallHasher(this->TrueThis, Key, KeyLength, this->Hasher)
	},
	define i8* StorageKeyToLookupKey(i32 Offset) {
		return PDBCallStorageKeyToLookupKey(this->TrueThis, Offset, this->StorageKeyToLookupKey)
	},
	define i32 LookupKeyToStorageKey(i8* Key, i32 KeyLength) {
		return PDBCallLookupKeyToStorageKey(this->TrueThis, Key, KeyLength, this->LookupKeyToStorageKey)
	}
}

define i32 Ceil(i32 Dividend, i32 Divisor) {
	return (Dividend / Divisor) + !!(Dividend % Divisor)
}

i32 Zero := 0

struct PDBSparceBitVector {
	i32 WordCount,
	i32{1} Words,
	
	define i32 Count() {
		i32 Result := 0
		
		for (i32 WordIndex := 0, WordIndex < this->WordCount, WordIndex += 1) {
			i32 ThisWord := this~>Words[WordIndex]
			
			for (i8 BitIndex := 0, BitIndex < 32, BitIndex += 1) {
				i32 Mask := 1 << BitIndex
				Result += ThisWord & Mask
			}
		}
		
		return Result
	},
	define void Print() {
		Print("Bit vector dump: ")
		
		for (i32 WordIndex := 0, WordIndex < this->WordCount, WordIndex += 1) {
			i32 ThisWord := this~>Words[WordIndex]
			
			for (i8 BitIndex := 0, BitIndex < 32, BitIndex += 1) {
				i32 Mask := 1 << BitIndex
				Print("%i", !!(ThisWord & Mask))
			}
		}
		
		Print("\n")
	},
	define i32* FindWord(i32 Index) {
		i32 WordIndex := Index / 32
		
		if (WordIndex >= this->WordCount) {
			Zero := 0
			return &Zero
		}
		
		return this~>Words + WordIndex * 4
	},
	define i32 FindBitMask(i32 Index) {
		return 1 << ((Index % 32) As i8)
	},
	define i32 Get(i32 Index) {
		Index += 1
		
		i32 Value := this->FindWord(Index)[0]
		i32 Mask := this->FindBitMask(Index)
		
		return !!(Value & Mask)
	},
	define void Set(i32 Index, i8 To) {
		Index += 1
		
		i32* TargetWord := this->FindWord(Index)
		i32 Mask := this->FindBitMask(Index)
		i32 NewValue := TargetWord[0]
		
		if (To) {
			NewValue |= Mask
		}
		else {
			NewValue &= ~Mask
		}
		
		TargetWord[0] := NewValue
		
	},
	define void* GetEnd() {
		return this~>Words + (this->WordCount * 4)
	},
	define void* SerializeInto(void* TargetBuffer) {
		i32* Buffer := TargetBuffer As i32*
		
		Buffer[0] := this->WordCount
		
		for (i32 WordIndex := 0, WordIndex < this->WordCount, WordIndex += 1) {
			Buffer[WordIndex + 1] := this~>Words[WordIndex]
		}
		
		return Buffer + 4 + this->WordCount * 4
	}
}

struct PDBHashmapBucket {
	i32 Key,
	i32 Value
	
	define PDBHashmapBucket* Next() {
		return this + #PDBHashmapBucket
	}
}

struct PDBHashmapHeader {
	i32 Size,
	i32 Capacity,
	
	define PDBSparceBitVector* GetPresentVector() {
		return (this~>Capacity + 4) As PDBSparceBitVector*
	},
	define PDBSparceBitVector* GetDeletedVector() {
		return this->GetPresentVector()->GetEnd()
	},
	define PDBHashmapBucket* GetBuckets() {
		return this->GetDeletedVector()->GetEnd()
	},
	define void* SerializeInto(void* Buffer) {
		Buffer[0] := (this As void*)[0]
		return Buffer + 8
	}
}

struct PDBHashmap {
	; NOTES:
	;  The serialized on-disk format *only* contains present k:v pairs, and not deleted/non-present pairs
	;   this took an incredible number of hours to figure out, and I'm honestly only writing this
	;    comment so I can come back and remember how much it fucking sucked.
	;  Nothing about LLVM's docs explains that only present buckets are stored on-disk
	;   and even though that is perfectly logical, it's impossible to read or write *any* PDB files
	;    without that single detail. I kept wondering why a key where `Hash(Key) % Capacity` was 3 
	;     yet LLVM expected to be in bucket 0 on-disk. I was totally convinced this was a bug.
	
	union {
		PDBHashmapHeader* Header,
		void* Buffer
	},
	
	i32 BufferSize,
	PDBSparceBitVector* PresentVector,
	PDBSparceBitVector* DeletedVector,
	PDBHashmapBucket* Buckets,
	
	PDBHashmapTraits* Traits,
	
	declare PDBHashmapBucket* FindBucket(i32)
	
	static PDBHashmap* Load(void* Buffer, PDBHashmapTraits* Traits) {
		PDBHashmap* this := Alloc(#PDBHashmap)
		
		this->Buffer := Buffer
		this->PresentVector := this->Header->GetPresentVector()
		this->DeletedVector := this->Header->GetDeletedVector()
		this->Buckets := Alloc(this->Header->Capacity * #PDBHashmapBucket)
		
		PDBHashmapBucket* RawBucketBuffer := this->Header->GetBuckets()
		
		for (i32 BucketIndex := 0, BucketIndex < this->Header->Capacity, BucketIndex += 1) {
			if (this->PresentVector->Get(BucketIndex)) {
				Print("On-file bucket is in-memory bucket %i\n", BucketIndex)
				MoveMemory(this->FindBucket(BucketIndex), RawBucketBuffer, #PDBHashmapBucket)
				RawBucketBuffer := RawBucketBuffer->Next()
			}
		}
		
		Print("PV = %x\n", this->PresentVector - this->Buffer)
		Print("DV = %x\n", this->DeletedVector - this->Buffer)
		Print("BU = %x\n", this->Buckets - this->Buffer)
		
		this->Traits := Traits
		
		return this
	}
	
	define void Initialize(i32 Buckets, PDBHashmapTraits* Traits) {
		i32 BitVectorWordCount := Ceil(Buckets, 32)
		
		Print("Init %i buckets, %i bucket words\n", Buckets, BitVectorWordCount)
		
		;					  | Header			| Vector Headers  | Vector data  | Buckets
		this->BufferSize := #PDBHashmapHeader + 8 + (BitVectorWordCount * 8) + (Buckets * 8)
		this->Buffer := Alloc(this->BufferSize)
		this->Header->Capacity := Buckets
		
		this->PresentVector := this->Header->GetPresentVector()
		Print("PV = %x\n", this->PresentVector - this->Buffer)
		this->PresentVector->WordCount := BitVectorWordCount
		this->DeletedVector := this->Header->GetDeletedVector()
		Print("DV = %x\n", this->DeletedVector - this->Buffer)
		this->DeletedVector->WordCount := 0
		
		this->Buckets := this->Header->GetBuckets()
		Print("BU = %x\n", this->Buckets - this->Buffer)
		
		this->Traits := Traits
		
		Print("Size = %x, Start = %x\n", this->BufferSize, this->Buffer)
	},
	define void Initialize(PDBHashmapTraits* Traits) {
		return this->Initialize(6, Traits)
	},
	define PDBHashmapBucket* FindBucket(i32 Index) {
		return this->Buckets + (Index * #PDBHashmapBucket)
	},
	define i32 GetBucketIndex(PDBHashmapBucket* Bucket) {
		i32 Difference := Bucket - this->Buckets
		
		return Difference / #PDBHashmapBucket
	},
	define PDBHashmapBucket* FindFirst(i8* Key, i32 KeyLength) {
		i32 Hash := this->Traits->Hash(Key, KeyLength)
		i32 BaseIndex := (Hash % this->Header->Capacity) - 1
		
		Print("FindFirst(%s, %i), Hash = %x, Bi = %i\n", Key, KeyLength, Hash, BaseIndex)
		
		i32 Index := BaseIndex
		
		i32 FirstEmpty := 0
		
		loop {
			if (this->PresentVector->Get(Index)) {
				PDBHashmapBucket* FoundBucket := this->FindBucket(Index)
				i8* FoundLookupKey := this->Traits->StorageKeyToLookupKey(FoundBucket->Key)
				
				
				i32 LookupKeyHash := this->Traits->Hash(FoundLookupKey, StringLength(FoundLookupKey))
				Print("FFLK [%i] = %s, L = %x\n", Index, FoundLookupKey, StringLength(FoundLookupKey))
				
				if (LookupKeyHash = Hash) {
					Print("FB\n")
					
					return FoundBucket
				}
			}
			else {
				if !(FirstEmpty) {
					FirstEmpty := Index
				}
				
				if !(this->DeletedVector->Get(Index)) {
					break
				}
			}
			
			Index := (Index + 1) % this->Header->Capacity
			
			if (Index = BaseIndex) {
				break
			}
		}
		
		;Print("Found '%s' at %i\n", Key, Index)
		
		return this->FindBucket(FirstEmpty)
	},
	define i8 Set(i8* Key, i32 KeyLength, i32 Value, i32 InternalKey) {
		PDBHashmapBucket* Entry := this->FindFirst(Key, KeyLength)
		
		i32 Index := this->GetBucketIndex(Entry)
		
		;Print("Set %s @ %i To %i\n", Key, Index, Value)
		
		if (this->PresentVector->Get(Index)) {
			Entry->Value := Value
			return false
		}
		
		if !(InternalKey) {
			InternalKey := this->Traits->LookupKeyToStorageKey(Key, KeyLength)
		}
		
		Entry->Key := InternalKey
		Entry->Value := Value
		
		this->Header->Size += 1
		this->PresentVector->Set(Index, true)
		
		return true
	},
	define i8 Set(i8* Key, i32 KeyLength, i32 Value) {
		return this->Set(Key, KeyLength, Value, 0)
	},
	define i8 Set(i8* Key, i32 Value) {
		return this->Set(Key, StringLength(Key), Value, 0)
	},
	define i32 Get(i8* Key, i32 KeyLength) {
		PDBHashmapBucket* Entry := this->FindFirst(Key, KeyLength)
		i32 Index := this->GetBucketIndex(Entry)
		
		if (this->PresentVector->Get(Index)) {
			return Entry->Value
		}
		
		return 0
	},
	define void* SerializeInto(void* Buffer) {
		Buffer := this->Header->SerializeInto(Buffer)
		Buffer := this->PresentVector->SerializeInto(Buffer)
		Buffer := this->DeletedVector->SerializeInto(Buffer)
		
		void* RawBucketBuffer := this->Buckets As void*
		i32 PresentIndex := 0
		
		for (i32 BucketIndex := 0, BucketIndex < this->Header->Capacity, BucketIndex += 1) {
			if (this->PresentVector->Get(BucketIndex)) {
				Buffer[PresentIndex] := RawBucketBuffer[BucketIndex]
				PresentIndex += 1
			}
		}
		
		return Buffer + PresentIndex * 8
	}
	define i32 GetSize() {
		return this->BufferSize
	}
	
	define void Print() {
		for (i32 I := 0, I < this->Header->Capacity, I += 1) {
			PDBHashmapBucket* B := this->FindBucket(I)
			
			Print("	Buckets[%i] = {%x: %x}\n", I, B->Key, B->Value)
			Print("		Present? %i, Deleted? %i\n", this->PresentVector->Get(I), this->DeletedVector->Get(I))
		}
		
		this->PresentVector->Print()
		this->DeletedVector->Print()
	}
}

struct PDBNamedStreamMapHeader {
	i32 StringBufferSize,
	i8{1} StringBuffer
}

declare i16 PDBNamedStreamMapHash(PDBNamedStreamMapBuilder*, i8*, i32)
declare i8* PDBNamedStreamMapStorageKeyToLookupKey(PDBNamedStreamMapBuilder*, i32)
declare i32 PDBNamedStreamMapLookupKeyToStorageKey(PDBNamedStreamMapBuilder*, i8*, i32)

struct PDBNamedStreamMapBuilder {
	union {
		PDBNamedStreamMapHeader* Header,
		void* Buffer
	},
	
	PDBHashmapTraits* Traits,
	PDBHashmap* OffsetIndexMap,
	
	static PDBNamedStreamMapBuilder* Load(void* Buffer) {
		PDBNamedStreamMapBuilder* this := Alloc(#PDBNamedStreamMapBuilder)
		
		this->Buffer := Buffer
		
		this->Traits := Alloc(#PDBHashmapTraits)
		this->Traits->TrueThis := this
		this->Traits->Hasher := &PDBNamedStreamMapHash
		this->Traits->StorageKeyToLookupKey := &PDBNamedStreamMapStorageKeyToLookupKey
		this->Traits->LookupKeyToStorageKey := &PDBNamedStreamMapLookupKeyToStorageKey
		
		this->OffsetIndexMap := PDBHashmap:Load(Buffer + this->Header->StringBufferSize + 4, this->Traits)
		
		return this
	}
	
	define void Initialize() {
		this->Buffer := Alloc(#PDBNamedStreamMapHeader)
		this->Header->StringBufferSize := 0
		
		this->Traits := Alloc(#PDBHashmapTraits)
		this->Traits->TrueThis := this
		this->Traits->Hasher := &PDBNamedStreamMapHash
		this->Traits->StorageKeyToLookupKey := &PDBNamedStreamMapStorageKeyToLookupKey
		this->Traits->LookupKeyToStorageKey := &PDBNamedStreamMapLookupKeyToStorageKey
		
		this->OffsetIndexMap := Alloc(#PDBHashmap)
		this->OffsetIndexMap->Initialize(this->Traits)
	},
	
	static PDBNamedStreamMapBuilder* New() {
		PDBNamedStreamMapBuilder* this := Alloc(#PDBNamedStreamMapBuilder)
		
		this->Initialize()
		
		return this
	}
	
	define i8 Get(i8* String, i32 StringLength, i32* StreamNumber) {
		PDBHashmapBucket* Entry := this->OffsetIndexMap->FindFirst(String, StringLength)
		i32 Index := this->OffsetIndexMap->GetBucketIndex(Entry)
		
		Print("Got %i, p = %i\n", Index, this->OffsetIndexMap->PresentVector->Get(Index))
		
		if !(this->OffsetIndexMap->PresentVector->Get(Index)) {
			Print("NOT PRESENT\n")
			
			return false
		}
		
		StreamNumber[0] := Entry->Value
		return true
	},
	define i8 Get(i8* String, i32* StreamNumber) {
		return this->Get(String, StringLength(String), StreamNumber)
	},
	define void Set(i8* String, i32 StringLength, i32 StreamNumber) {
		this->OffsetIndexMap->Set(String, StringLength, StreamNumber)
	},
	define void Set(i8* String, i32 StreamNumber) {
		this->OffsetIndexMap->Set(String, StreamNumber)
	},
	define i8* GetString(i32 Offset) {
		return this->Header~>StringBuffer + Offset
	},
	define i32 AppendString(i8* String, i32 StringLength) {
		i32 OldSize := this->Header->StringBufferSize
		i32 NewSize := OldSize + StringLength + 1
		
		this->Buffer := ReAlloc(this->Buffer, NewSize + 4)
		this->Header->StringBufferSize := NewSize
		
		i8* OldBufferEnd := this->Header~>StringBuffer + OldSize
		MoveMemory(OldBufferEnd, String, StringLength)
		
		return OldSize
	},
	define void* SerializeInto(void* RawBuffer) {
		i32* Buffer := RawBuffer As i32*
		
		i32 StringBufferSize := this->Header->StringBufferSize
		
		Buffer[0] := StringBufferSize
		
		i8* StringBuffer := (Buffer + 4) As i8*
		
		for (i32 Index := 0, Index < StringBufferSize, Index += 1) {
			StringBuffer[Index] := this->Header~>StringBuffer[Index]
		}
		
		RawBuffer := (StringBuffer + StringBufferSize) As void*
		
		return this->OffsetIndexMap->SerializeInto(RawBuffer)
	}
	
	define i32 GetSize() {
		return 4 + this->Header->StringBufferSize + this->OffsetIndexMap->GetSize()
	}
}

define i32 AbsoluteValue(i32 Value) {
	if (Value < 0) {
		return -Value
	}
	
	return Value
}

define i32 PDBNamedStreamMapHash(PDBNamedStreamMapBuilder* this, i8* Key, i32 KeyLength) {
	i32 R := AbsoluteValue(PDBHashLookupKeyV1(Key, KeyLength) As i32)
	
	;Print("Hash(%s, %i) = %x\n", Key, KeyLength, R)
	
	return R
}
define i8* PDBNamedStreamMapStorageKeyToLookupKey(PDBNamedStreamMapBuilder* this, i32 Offset) {
	return this->GetString(Offset)
}
define i32 PDBNamedStreamMapLookupKeyToStorageKey(PDBNamedStreamMapBuilder* this, i8* Key, i32 KeyLength) {
	return this->AppendString(Key, KeyLength)
}

struct PDBStreamHeader unaligned {
	i32 Version
	i32 CreationTime
	i32 WriteCount
	i64 UUIDHigh
	i64 UUIDLow
}

i32 PDB_VERSION_VC70 := 20000404
i32 PBD_STREAM_VC140 := 20140508

struct PDBStreamBuilder {
	i32 FeatureFlags
	PDBNamedStreamMapBuilder* NameMap
	
	static PDBStreamBuilder* New() {
		PDBStreamBuilder* this := Alloc(#PDBStreamBuilder)
		
		this->NameMap := PDBNamedStreamMapBuilder:New()
		
		return this
	}
	define i32 GetSize() {
		return #PDBStreamHeader + this->NameMap->GetSize() + 8
	}
	define void* SerializeInto(void* Buffer, i64 SourcePathHash, i64 Time) {
		PDBStreamHeader* Header := Buffer As PDBStreamHeader*
		
		Header->Version := PDB_VERSION_VC70
		Header->CreationTime := Time As i32
		Header->WriteCount := 1
		Header->UUIDLow := SourcePathHash ^ Time
		Header->UUIDHigh := Time ^ Header
		
		Buffer := this->NameMap->SerializeInto(Buffer + #PDBStreamHeader)
		
		(Buffer As i32*)[0] := PBD_STREAM_VC140
		
		return Buffer + 8
	}
}

;        Buckets[0] = {0x11: 0x9}
;                Present? 1, Deleted? 0
;        Buckets[1] = {0x22: 0x180}
;                Present? 1, Deleted? 0
;        Buckets[2] = {0xA: 0xD}
;                Present? 1, Deleted? 0
;        Buckets[3] = {0x0: 0x5}
;                Present? 1, Deleted? 0
;        Buckets[4] = {0x0: 0x13351DC}
;                Present? 0, Deleted? 0
;        Buckets[5] = {0x740200: 0x10000000}

define i32 Main() {
	MSFBuilder* B := Alloc(#MSFBuilder)
	
	B->Initialize()
	B->AllocateStreamDirectory()
	
	i8* D := Alloc(0x1500)
	i8* StreamBuffer := D
	
	PDBStreamBuilder* Bu := PDBStreamBuilder:New()
	
	Bu->NameMap->Set("/LinkInfo", 5)
	;Bu->NameMap->Set("/names", 13)
	;Bu->NameMap->Set("/src/headerblock", 9)
	;Bu->NameMap->Set("/src/files/debug.natvis", 384)
	
	i32 PDBStreamSize := Bu->GetSize()
	Bu->SerializeInto(StreamBuffer, 0x123, 0x456)
	
	i32 StreamNumber := 0
	i8 R := Bu->NameMap->Get("/LinkInfo", &StreamNumber)
	
	Print("Bu->Get %i = %x\n", R, StreamNumber)
	
	Bu->NameMap->OffsetIndexMap->Print()
	
	void* Empty := Alloc(0x1000)
	
	B->AppendStream(Empty, 0x1000)
	B->AppendStream(StreamBuffer, PDBStreamSize)	; PDB Stream
	B->AppendStream(Empty, 0x1000)				; TPI Stream
	B->AppendStream(Empty, 0x1000)				; DBI Stream
	B->AppendStream(Empty, 0x1000)				; IPI Stream
	
	for (i32 I := 0, I < 400, I += 1) {
		B->AppendStream(Empty, 0x1000)				; LinkInfo
	}
	
	B->WriteToFile("C:\Users\Connor\Desktop\fuck\Relax-Language\src\compiler\dummy.pdb"r)
	
	Print("Done\n")
	
	B->SuperBlock->Print()
	
	;i64 F := FileOpen("C:\Users\Connor\Desktop\fuck\Relax-Language\src\compiler\AutoHotkey.pdb"r, FILE_READ)
	;
	;FileSeek(F, 0x96E000, SEEK_SET)
	;
	;void* Data := Alloc(0x1000)
	;FileRead(F, Data, 0x1000)
	;
	;PDBNamedStreamMapBuilder* B := PDBNamedStreamMapBuilder:Load(Data + #PDBStreamHeader)
	;
	;B->OffsetIndexMap->Print()
	;
	;i32 StreamNumber := 0
	;i8 R := B->Get("/src/files/debdug.natvis", &StreamNumber)
	;
	;Print("B->Get %i = %x\n", R, StreamNumber)
	;
	;return 0
}

i32 TPI_STREAM_VERSION_V80 := 20040203

i8 CV_POINTER_KIND_NEAR64 := 0x0C
i8 CV_POINTER_MODE_NORMAL := 0
i8 CV_POINTER_MODIFIER_NONE := 0
i32 CV_POINTER_ATTRIBUTES := 0x0C | (8 << 0xD)

i32 CV_KIND_I8 := 0x68
i32 CV_KIND_I16 := 0x21
i32 CV_KIND_I32 := 0x12
i32 CV_KIND_I64 := 0x76
i32 CV_MODE_POINTER := 0x600

struct CVTypeIndex {
	i32 RawIndex
	
	define i8 IsSimple() {
		return this->RawIndex < 0x1000
	}
	define i32 ToArrayIndex() {
		return this->RawIndex - 0x1000
	}
	define void FromArrayIndex(i32 Index) {
		this->RawIndex := Index + 0x1000
	}
	define i32 GetSimpleType() {
		return this->RawIndex & 0xFF
	}
	define i32 GetSimpleMode() {
		return this->RawIndex & 0x700
	}
}

struct CVTypeIndexHelper {
	union {
		i32 TypeIndex,
		CVTypeIndex Index
	}
}

i16 LF_POINTER := 0x1002
i16 LF_ARGLIST := 0x1201
i16 LF_PROCEDURE := 0x1008
i16 LF_STRUCT := 0x1504

struct CVTypeRecordHeader {
	i16 Length
	i16 Type
	
	define void* GetData() {
		return this + 4
	}
	define void* GetEnd() {
		return this + this->Length + 2
	}
}

i8 CV_PROCEDURE_GENERIC_CALL := 0xE

struct CVProcedureRecord {
	i32 ReturnTypeIndex
	i16 Attributes
	i16 ParameterCount
	i32 ParameterTypeListIndex
}

; Fuck Microsoft, this file format is a massive pile of shit
;  Their own tools can't even fucking read the files which their own compiler outputs
;  And the braindead shithead who wrote "Source code is the ultimate documentation :-)" in the README
;   for their garbage non-functional 'documentation' repo needs to be lobotomized. Although from what I can tell
;    that is a prerequisite for working at Microsoft.

struct CVStructRecord {
	i16 Count
	i16 Properties
	i32 FieldsTypeListIndex
	i32 DerivedTypeIndex
	i32 VTableShapeTypeIndex
	i16 Size
	
}

struct TPIStreamHeader {
	i32 Version,
	i32 HeaderSize,
	
	i32 TypeIndexStart,
	i32 TypeIndexEnd,
	i32 TypeRecordBytes,
	
	i32 HashStreamIndex,
	i32 HashAuxStreamIndex,
	i32 HashKeySize,
	i32 NumberOfHashBuckets,
	
	i32 HashValueBufferOffset,
	i32 HashValueBufferLength,
	
	i32 IndexOffsetBufferOffset,
	i32 IndexOffsetBufferLength,
	
	i32 HashTableBufferOffset,
	i32 HashTableBufferLength,
	
	define void Initialize() {
		this->Version := TPI_STREAM_VERSION_V80
		this->HeaderSize := #TPIStreamHeader
		this->TypeIndexStart := 0x1000
		this->TypeIndexEnd := 0x1000
		this->TypeRecordBytes := 0
		this->HashKeySize := 4
	}
	define CVTypeRecordHeader* GetStartOfTypeRecords() {
		return (this~>HashValueBufferLength + 4) As CVTypeRecordHeader*
	}
	define CVTypeRecordHeader* GetEndOfTypeRecords() {
		return this->GetStartOfTypeRecords() + this->TypeRecordBytes
	}
}

struct TPIStreamBuilder {
	union {
		TPIStreamHeader* Header
		void* Buffer
	}
	
	i32 BufferSize
	
	i32 RecordOffsetCount
	i32* RecordOffsetArray
	
	define void Initialize() {
		this->BufferSize := #TPIStreamHeader
		this->Buffer := Alloc(this->BufferSize)
		
		this->RecordOffsetCount := 0
		this->RecordOffsetArray := Alloc(4)
		
		this->Header->Initialize()
	}
	define void ReAlloc(i32 AdditionalSize) {
		this->BufferSize += AdditionalSize
		this->Buffer := ReAlloc(this->Buffer, this->BufferSize)
	}
	define void StoreRecordOffset(i32 TypeIndex, i32 Offset) {
		this->RecordOffsetCount += 4
		this->RecordOffsetArray := ReAlloc(this->RecordOffsetArray, this->RecordOffsetCount)
		
		this->RecordOffsetArray[TypeIndex - 0x1000] := Offset
	}
	define CVTypeRecordHeader* GetRecordFromindex(i32 TypeIndex) {
		return this->Header->GetStartOfTypeRecords() + this->RecordOffsetArray[TypeIndex - 0x1000]
	}
	define i32 AppendCVRecord(CVTypeRecordHeader* Record) {
		i32 Length := Record->Length + 2
		
		this->ReAlloc(Length)
		
		i8* EndOfRecords := this->Header->GetEndOfTypeRecords() As i8*
		i32 Offset := EndOfRecords - this->Header->GetStartOfTypeRecords()
		
		MoveMemory(EndOfRecords, Record As i8*, Length)
		
		this->Header->TypeRecordBytes += Length
		
		i32 Result := this->Header->TypeIndexEnd
		this->Header->TypeIndexEnd += 1
		
		this->StoreRecordOffset(Result, Offset)
		
		return Result
	}
	
	declare CVTypeRecordHeader* PrintSingleRecord(CVTypeRecordHeader*)
	
	define void PrintTypeIndex(i32 TypeIndex) {
		CVTypeIndex Index
		
		Index.RawIndex := TypeIndex
		
		if (Index.IsSimple()) {
			i32 Simple := Index.GetSimpleType()
			
			if (Simple = CV_KIND_I8) {
				Print("i8")
			}
			else if (Simple = CV_KIND_I16) {
				Print("i16")
			}
			else if (Simple = CV_KIND_I32) {
				Print("i32")
			}
			else if (Simple = CV_KIND_I64) {
				Print("i64")
			}
			else {
				Print("<Unknown Simple %x>", Simple)
			}
			
			if (Index.GetSimpleMode() = CV_MODE_POINTER) {
				Print("*")
			}
			
		}
		else {
			this->PrintSingleRecord(this->GetRecordFromindex(TypeIndex))
		}
	}
	define CVTypeRecordHeader* PrintSingleRecord(CVTypeRecordHeader* ThisRecord) {
		void* ThisRecordData := ThisRecord->GetData()
		
		if (ThisRecord->Type = LF_ARGLIST) {
			Print("{ArgList}(")
			
			i32 ArgListLength := *(ThisRecordData As i32*)
			i32* ArgListData := (ThisRecordData + 4) As i32*
			
			for (i32 ArgListIndex := 0, ArgListIndex < ArgListLength, ArgListIndex += 1) {
				this->PrintTypeIndex(ArgListData[ArgListIndex])
				
				if (ArgListIndex + 1 != ArgListLength) {
					Print(", ")
				}
			}
			
			Print(")")
		}
		else if (ThisRecord->Type = LF_PROCEDURE) {
			Print("{")
			
			CVProcedureRecord* ProcedureData := ThisRecordData
			
			this->PrintTypeIndex(ProcedureData->ReturnTypeIndex)
			
			Print(" Function}(")
			
			this->PrintTypeIndex(ProcedureData->ParameterTypeListIndex)
			
			Print(")")
		}
		
		return ThisRecord->GetEnd()
	}
	define void PrintTypeRecords() {
		CVTypeRecordHeader* Start := this->Header->GetStartOfTypeRecords()
		void* End := this->Header->GetEndOfTypeRecords()
		
		;Throw(0x123)
		
		while (Start != End) {
			Start := this->PrintSingleRecord(Start)
			Print("\n")
		}
		
	}
}

define CVTypeRecordHeader* AllocRecord(i16 Type, i32 Size) {
	CVTypeRecordHeader* Result := Alloc(Size + #CVTypeRecordHeader)
	
	Result->Length := Size + 2
	Result->Type := Type
	
	return Result
}

i32 DBISignature := -1
i32 DBIVersion := 19990903
i16 DBIBuildNumber := 1

struct DBIStreamHeader {
	i32 Signature
	i32 Version
	i32 Age
	
	i16 GlobalStreamIndex
	i16 BuildNumber
	i16 PublicStreamIndex
	i16 MSPDBVersion
	i16 SymbolRecordStreamIndex
	i16 Unknown
	
	i32 ModuleInfoSize
	i32 SectionContributionSize
	i32 SectionMapSize
	i32 SourceInfoSize
	i32 TypeServerMapSize
	
	i32 MFCTypeServerStreamIndex
	i32 OptionalHeaderSize
	i32 ECStreamSize
	
	i16 Flags
	i16 Machine
	i16 Padding
	
}

;define i32 Main() {
;	
;	TPIStreamBuilder* B := Alloc(#TPIStreamBuilder)
;	
;	B->Initialize()
;	
;	CVTypeRecordHeader* TList := AllocRecord(LF_ARGLIST, 20)
;	i32* Buffer := TList->GetData()
;	
;	Buffer[0] := 4
;	Buffer[1] := CV_KIND_I8 | CV_MODE_POINTER
;	Buffer[2] := CV_KIND_I16
;	Buffer[3] := CV_KIND_I16 | CV_MODE_POINTER
;	Buffer[4] := CV_KIND_I16
;	
;	Print("List Built\n")
;	
;	i32 PListI := B->AppendCVRecord(TList)
;	
;	Print("List Appended\n")
;	
;	CVTypeRecordHeader* PDef := AllocRecord(LF_PROCEDURE, #CVProcedureRecord)
;	CVProcedureRecord* PDefR := PDef->GetData()
;	
;	PDefR->ReturnTypeIndex := CV_KIND_I64
;	PDefR->ParameterTypeListIndex := PListI
;	
;	B->AppendCVRecord(PDef)
;	
;	B->PrintTypeRecords()
;	
;	
;	Print("Done\n")
;	
;	return 0
;}