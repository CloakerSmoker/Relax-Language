#Require "./src/lib/Console.rlx"

#Require "./src/lib/File.rlx"

struct MSFSuperblock {
	i8{0x20} Magic,
	i32 BlockSize,			; Should be 4096
	i32 FreeBlockMapBlock,	; Block index (only allowed to be 1 or 2)
	i32 NumberOfBlocks,		; Total block count, (NumberOfBlocks * BlockSize) = FileSize
	i32 NumberOfDirectoryBytes,	; Size of stream directory
	i32 Unknown,
	i32 BlockMapIndex	; Index of a block listing blocks which contain the stream directory
	; Number of blocks inside of BlockMapIndex block = Ceil(NumberOfDirectoryBytes / BlockSize)
}

struct MSFStreamDirectory {
	i32 NumberOfStreams
}

struct MSFStreamDirectoryBuilder {
	union {
		void* Buffer,
		MSFStreamDirectory* StreamDirectoryHeader
	},
	
	i32 Size,
	
	define i32* GetStreamSizesArray() {
		return (this->Buffer + 8) As i32*
	},
	define i32* GetStreamBlocksArray() {
		return (this->Buffer + 8 + this->StreamDirectoryHeader->NumberOfStreams) As i32*
	},
	define i32 GetStreamBlockCount(i32 StreamIndex) {
		i32 Size := this->GetStreamSizesArray()[StreamIndex]
		
		i32 BlockCount := Size / 0x1000
		i32 Remainder := Size % 0x1000
		
		if (Remainder) {
			BlockCount += 1
		}
		
		return BlockCount
	},
	define i32* GetStreamBlocks(i32 TargetStreamIndex) {
		i32* Start := this->GetStreamBlocksArray()
		
		for (i32 StreamIndex := 0, StreamIndex < TargetStreamIndex, StreamIndex += 1) {
			Start += this->GetStreamBlockCount(StreamIndex) * 4
		}
		
		return Start
	}
}

struct MSFBuilder {
	union {
		void* Buffer,
		MSFSuperblock* Superblock
	},
	
	i32 Size,
	i32 StreamDirectoryBlockIndex,
	
	union {
		void* StreamDirectoryBlock,
		MSFStreamDirectory* StreamDirectory
	},
	
	i32 StreamDirectoryTail,
	
	declare void AllocateBlock(),
	
	define void Initialize() {
		this->Size := 0x1000 * 3
		this->Buffer := Alloc(this->Size)
		
		i8* MagicBuffer := this->Superblock~>Magic
		
		MoveMemory(MagicBuffer, "Microsoft C/C++ MSF 7.00", 24)
		
		(MagicBuffer + 24 As i64*)[0] := 0x53441a0a0d
		
		i8* BlockMapBuffer := this->Buffer + 0x1000
		
		for (i32 BlockMapIndex := 0, BlockMapIndex < 0x2000, BlockMapIndex += 1) {
			BlockMapBuffer[BlockMapIndex] := 0xFF
		}
		
		this->Superblock->BlockSize := 0x1000
		this->Superblock->FreeBlockMapBlock := 1
		
		; Allocate the first 3 blocks in the file (for the superblock, and free block maps)
		for (i32 Index := 0, Index < 3, Index += 1) {
			this->AllocateBlock()
		}
	},
	define i32 AllocateBlock() {
		i8* Bitmap := this->Buffer + 0x1000 * (this->Superblock->FreeBlockMapBlock)
		
		for (i32 Index := 0, Index < 0x1000, Index += 1) {
			i32 ByteIndex := Index / 8
			i32 BitIndex := Index % 8
			i32 BitMask := 1 << (BitIndex As i8)
			
			i8 TargetByte := Bitmap[ByteIndex]
			
			if (TargetByte & BitMask) {
				Bitmap[ByteIndex] := TargetByte ^ BitMask
				
				return Index
			}
		}
	},
	define void* GetBlockBuffer(i32 BlockIndex) {
		return this->Buffer + (BlockIndex * 0x1000)
	},
	define void ReAlloc(i32 AdditionalSize) {
		this->Size += AdditionalSize
		this->Buffer := ReAlloc(this->Buffer, this->Size)
		this->StreamDirectoryBlock := this->GetBlockBuffer(this->StreamDirectoryBlockIndex)
	},
	define void AllocateStreamDirectory() {
		i32 StreamDirectoryIndexBlockNumber := this->AllocateBlock()
		i32 StreamDirectoryBlockNumber := this->AllocateBlock()
		
		this->ReAlloc(0x1000 * 2)
		
		this->Superblock->BlockMapIndex := StreamDirectoryIndexBlockNumber
		
		i32* StreamDirectoryIndex := this->GetBlockBuffer(StreamDirectoryIndexBlockNumber)
		
		StreamDirectoryIndex[0] := StreamDirectoryBlockNumber
		
		this->StreamDirectoryBlockIndex := StreamDirectoryBlockNumber
		this->StreamDirectoryBlock := this->GetBlockBuffer(StreamDirectoryBlockNumber)
		
		this->StreamDirectoryTail := 4
	},
	define void AppendStream(i32 StreamIndex, i8* StreamData, i32 StreamSize) {
		i32 TailOffset := (this->StreamDirectory->NumberOfStreams + 1) * 4
		i32* Tail := this->StreamDirectoryBlock + TailOffset
		
		; Move the actual stream block list down to make room for another stream size
		MoveMemory(Tail + 4, Tail, 0x1000 - TailOffset)
		
		; Store the size of the stream into the size array, and update the number of streams
		Tail[0] := StreamSize
		this->StreamDirectory->NumberOfStreams += 1
		
		; Update where the next stream's block array should go
		this->StreamDirectoryTail += 4
		
		; Calculate how many blocks are needed to store the stream's data
		i32 BlocksNeeded := (StreamSize / 0x1000) + !!(StreamSize % 0x1000)
		i32 RemainingSize := StreamSize
		
		for (i32 BlockIndex := 0, BlockIndex < BlocksNeeded, BlockIndex += 1) {
			; Allocate a block, and write the block into this stream's array of blocks 
			i32 ThisBlockNumber := this->AllocateBlock()
			(this->StreamDirectoryBlock + this->StreamDirectoryTail As i32*)[0] := ThisBlockNumber
			this->ReAlloc(0x1000)	; Extend our buffer to hold this block's data
			
			; Get a pointer to the block inside of our buffer
			i8* ThisBlock := this->GetBlockBuffer(ThisBlockNumber)
			
			; Default to copying 0x1000 bytes
			i32 CopySize := 0x1000
			
			if (RemainingSize < 0x1000) {
				; But if we have less than 0x1000 left, just copy however much remains
				CopySize := RemainingSize
			}
			
			RemainingSize -= CopySize
			
			for (i32 CopyIndex := 0, CopyIndex < CopySize, CopyIndex += 1) {
				ThisBlock[CopyIndex] := StreamData[CopyIndex + BlockIndex * 0x1000]
			}
			
			this->StreamDirectoryTail += 4
			
			if (RemainingSize = 0) {
				break
			}
		}
	},
	define void WriteToFile(i8* FilePath) {
		i64 File := FileOpen(FilePath, FILE_WRITE | FILE_CREATE_NEW)
		
		FileWrite(File, this->Buffer, this->Size)
		
		FileClose(File)
	}
}

;struct PDBHashmapBuilder {
;	union {
;		PDBHashmapHeader* Header,
;		void* Buffer
;	},
;	
;	i32 BufferSize,
;	i32 PairIndex,
;	
;	define void Initialize(void* InBuffer, i32 Size, i32 BucketCount) {
;		this->BufferSize := #PDBHashmapHeader + (BucketCount * 2) + (Size * #PDBHashmapKeyValuePair)
;		
;		if (InBuffer = null) {
;			this->Buffer := Alloc(this->BufferSize)
;		}
;		else {
;			this->Buffer := InBuffer
;		}
;
;		this->Header->Size := Size
;		this->Header->BucketCount := BucketCount		
;	},
;	define void Initialize(i32 Size, i32 BucketCount) {
;		this->Initialize(null, Size, BucketCount)
;	},
;	define void AppendPair(i32 Key, i32 Value) {
;		PDBHashmapKeyValuePair* Pairs := this->Header->GetKeyValues()
;		
;		PDBHashmapKeyValuePair* NextPair := Pairs + (this->PairIndex * #PDBHashmapKeyValuePair)
;		
;		NextPair->Key := Key
;		NextPair->Value := Value
;		
;		this->PairIndex += 1
;	},
;	define void* SerializeInto(void* Buffer) {
;		MoveMemory(Buffer, this->Buffer, this->BufferSize)
;		
;		return Buffer + this->BufferSize
;	}
;}

#Require "./src/lib/Debug.rlx"

define i32 PDBHashStringV1(i8* String, i32 Length) {
	i32* Longs := String As i32*
	i32 LongCount := Length / 4
	
	i32 Result := 0
	
	for (i32 LongIndex := 0, LongIndex < LongCount, LongIndex += 1) {
		Result ^= Longs[LongIndex]
	}
	
	i8* Remainder := Longs + LongCount * 4
	i32 RemainderSize := Length % 4
	
	if (RemainderSize >= 2) {
		i32 Value := *(Remainder As i16*)
		Result ^= Value
		
		Remainder += 2
		RemainderSize -= 2
	}
	
	if (RemainderSize = 1) {
		Result ^= *(Remainder + 1) As i32
	}
	
	i32 ToLowerMask := 0x20202020
	Result |= ToLowerMask
	Result ^= (Result >> 11)
	
	return Result ^ (Result >> 16)
}
define i16 PDBHashLookupKeyV1(i8* Key, i32 KeyLength) {
	return PDBHashStringV1(Key, KeyLength) As i16
}

define i16 PDBCallHasher(void* this, i8* Key, i32 KeyLength, void* Implementation) asm {
	jmp, rcx
}
define i8* PDBCallStorageKeyToLookupKey(void* this, i32 Offset, void* Implementation) asm {
	jmp, rdx
}
define i32 PDBCallLookupKeyToStorageKey(void* this, i8* Key, i32 KeyLength, void* Implementation) asm {
	jmp, rcx
}

struct PDBHashmapTraits {
	void* Hasher,
	void* StorageKeyToLookupKey,
	void* LookupKeyToStorageKey,
	void* TrueThis,
	
	define i16 Hash(i8* Key, i32 KeyLength) {
		return PDBCallHasher(this->TrueThis, Key, KeyLength, this->Hasher)
	},
	define i8* StorageKeyToLookupKey(i32 Offset) {
		return PDBCallStorageKeyToLookupKey(this->TrueThis, Offset, this->StorageKeyToLookupKey)
	},
	define i32 LookupKeyToStorageKey(i8* Key, i32 KeyLength) {
		return PDBCallLookupKeyToStorageKey(this->TrueThis, Key, KeyLength, this->LookupKeyToStorageKey)
	}
}

define i32 Ceil(i32 Dividend, i32 Divisor) {
	return (Dividend / Divisor) + !!(Dividend % Divisor)
}

struct PDBSparceBitVector {
	i32 WordCount,
	i32{1} Words,
	
	define i32 Count() {
		i32 Result := 0
		
		for (i32 WordIndex := 0, WordIndex < this->WordCount, WordIndex += 1) {
			i32 ThisWord := this~>Words[WordIndex]
			
			for (i8 BitIndex := 0, BitIndex < 32, BitIndex += 1) {
				i32 Mask := 1 << BitIndex
				Result += ThisWord & Mask
			}
		}
		
		return Result
	},
	define void Print() {
		Print("Bit vector dump: ")
		
		for (i32 WordIndex := 0, WordIndex < this->WordCount, WordIndex += 1) {
			i32 ThisWord := this~>Words[WordIndex]
			
			for (i8 BitIndex := 0, BitIndex < 32, BitIndex += 1) {
				i32 Mask := 1 << BitIndex
				Print("%i", !!(ThisWord & Mask))
			}
		}
		
		Print("\n")
	},
	define i32* FindWord(i32 Index) {
		return this~>Words + (Index / 32) * 4
	},
	define i32 FindBitMask(i32 Index) {
		return 1 << ((Index % 32) As i8)
	},
	define i32 Get(i32 Index) {
		i32 Value := this->FindWord(Index)[0]
		i32 Mask := this->FindBitMask(Index)
		
		return Value & Mask
	},
	define void Set(i32 Index, i8 To) {
		i32* TargetWord := this->FindWord(Index)
		i32 Mask := this->FindBitMask(Index)
		i32 NewValue := TargetWord[0]
		
		if (To) {
			NewValue |= Mask
		}
		else {
			NewValue &= ~Mask
		}
		
		TargetWord[0] := NewValue
		
	},
	define void* GetEnd() {
		return this~>Words + (this->WordCount * 4)
	},
	define void* SerializeInto(void* TargetBuffer) {
		i32* Buffer := TargetBuffer As i32*
		
		Buffer[0] := this->WordCount
		
		for (i32 WordIndex := 0, WordIndex < this->WordCount, WordIndex += 1) {
			Buffer[WordIndex + 1] := this~>Words[WordIndex]
		}
		
		return Buffer + 4 + this->WordCount * 4
	}
}

struct PDBHashmapBucket {
	i32 Key,
	i32 Value
}

struct PDBHashmapHeader {
	i32 Size,
	i32 Capacity,
	
	define PDBSparceBitVector* GetPresentVector() {
		return (this~>Capacity + 4) As PDBSparceBitVector*
	},
	define PDBSparceBitVector* GetDeletedVector() {
		return this->GetPresentVector()->GetEnd()
	},
	define PDBHashmapBucket* GetBuckets() {
		return this->GetDeletedVector()->GetEnd()
	},
	define void* SerializeInto(void* Buffer) {
		Buffer[0] := (this As void*)[0]
		return Buffer + 8
	}
}

struct PDBHashmapBuilder {
	union {
		PDBHashmapHeader* Header,
		void* Buffer
	},
	
	void* Hasher,
	i32 BufferSize,
	PDBSparceBitVector* PresentVector,
	PDBSparceBitVector* DeletedVector,
	PDBHashmapBucket* Buckets,
	
	PDBHashmapTraits* Traits,
	
	define void Initialize(i32 Buckets, PDBHashmapTraits* Traits) {
		i32 BitVectorWordCount := Ceil(Buckets, 32)
		
		Print("Init %i buckets, %i bucket words\n", Buckets, BitVectorWordCount)
		
		;					  | Header			| Vector Headers  | Vector data  | Buckets
		this->BufferSize := #PDBHashmapHeader + 8 + (BitVectorWordCount * 8) + (Buckets * 8)
		this->Buffer := Alloc(this->BufferSize)
		this->Header->Capacity := Buckets
		
		this->PresentVector := this->Header->GetPresentVector()
		Print("PV = %x\n", this->PresentVector - this->Buffer)
		this->PresentVector->WordCount := BitVectorWordCount
		this->DeletedVector := this->Header->GetDeletedVector()
		Print("DV = %x\n", this->DeletedVector - this->Buffer)
		this->DeletedVector->WordCount := BitVectorWordCount
		
		this->Buckets := this->Header->GetBuckets()
		Print("BU = %x\n", this->Buckets - this->Buffer)
		
		this->Traits := Traits
		
		Print("Size = %x, Start = %x\n", this->BufferSize, this->Buffer)
	},
	define void Initialize(PDBHashmapTraits* Traits) {
		return this->Initialize(8, Traits)
	},
	define PDBHashmapBucket* FindBucket(i32 Index) {
		return this->Buckets + (Index * #PDBHashmapBucket)
	},
	define i32 GetBucketIndex(PDBHashmapBucket* Bucket) {
		i32 Difference := Bucket - this->Buckets
		
		return Difference / #PDBHashmapBucket
	},
	define PDBHashmapBucket* FindFirst(i8* Key, i32 KeyLength) {
		i32 Hash := this->Traits->Hash(Key, KeyLength)
		i32 BaseIndex := Hash % this->Header->Capacity
		i32 Index := BaseIndex
		
		i32 FirstEmpty := 0
		
		loop {
			if (this->PresentVector->Get(Index)) {
				PDBHashmapBucket* FoundBucket := this->FindBucket(Index)
				i8* FoundLookupKey := this->Traits->StorageKeyToLookupKey(FoundBucket->Key)
				
				if (this->Traits->Hash(FoundLookupKey, StringLength(FoundLookupKey)) = Hash) {
					return FoundBucket
				}
			}
			else {
				if !(FirstEmpty) {
					FirstEmpty := Index
				}
				
				if !(this->DeletedVector->Get(Index)) {
					break
				}
			}
			
			Index := (Index + 1) % this->Header->Capacity
			
			if (Index = BaseIndex) {
				break
			}
		}
		
		Print("Found '%s' at %i\n", Key, Index)
		
		return this->FindBucket(Index)
	},
	define i8 Set(i8* Key, i32 KeyLength, i32 Value, i32 InternalKey) {
		PDBHashmapBucket* Entry := this->FindFirst(Key, KeyLength)
		
		i32 Index := this->GetBucketIndex(Entry)
		
		;Print("Set %s @ %i To %i\n", Key, Index, Value)
		
		if (this->PresentVector->Get(Index)) {
			Entry->Value := Value
			return false
		}
		
		if !(InternalKey) {
			InternalKey := this->Traits->LookupKeyToStorageKey(Key, KeyLength)
		}
		
		Entry->Key := InternalKey
		Entry->Value := Value
		
		this->Header->Size += 1
		this->PresentVector->Set(Index, true)
		
		return true
	},
	define i8 Set(i8* Key, i32 KeyLength, i32 Value) {
		return this->Set(Key, KeyLength, Value, 0)
	},
	define i8 Set(i8* Key, i32 Value) {
		return this->Set(Key, StringLength(Key), Value, 0)
	},
	define i32 Get(i8* Key, i32 KeyLength) {
		PDBHashmapBucket* Entry := this->FindFirst(Key, KeyLength)
		i32 Index := this->GetBucketIndex(Entry)
		
		if (this->PresentVector->Get(Index)) {
			return Entry->Value
		}
		
		return 0
	},
	define void* SerializeInto(void* Buffer) {
		Buffer := this->Header->SerializeInto(Buffer)
		Buffer := this->PresentVector->SerializeInto(Buffer)
		Buffer := this->DeletedVector->SerializeInto(Buffer)
		
		void* RawBucketBuffer := this->Buckets As void*
		
		for (i32 BucketIndex := 0, BucketIndex < this->Header->Capacity, BucketIndex += 1) {
			Buffer[BucketIndex] := RawBucketBuffer[BucketIndex]
		}
		
		return Buffer + this->Header->Capacity * 8
	}
}

struct PDBNamedStreamMapHeader {
	i32 StringBufferSize,
	i8{1} StringBuffer
}

declare i16 PDBNamedStreamMapHash(PDBNamedStreamMapBuilder*, i8*, i32)
declare i8* PDBNamedStreamMapStorageKeyToLookupKey(PDBNamedStreamMapBuilder*, i32)
declare i32 PDBNamedStreamMapLookupKeyToStorageKey(PDBNamedStreamMapBuilder*, i8*, i32)

struct PDBNamedStreamMapBuilder {
	union {
		PDBNamedStreamMapHeader* Header,
		void* Buffer
	},
	
	PDBHashmapTraits* Traits,
	PDBHashmapBuilder* OffsetIndexMap,
	
	define void Initialize() {
		this->Buffer := Alloc(#PDBNamedStreamMapHeader)
		this->Header->StringBufferSize := 0
		
		this->Traits := Alloc(#PDBHashmapTraits)
		this->Traits->TrueThis := this
		this->Traits->Hasher := &PDBNamedStreamMapHash
		this->Traits->StorageKeyToLookupKey := &PDBNamedStreamMapStorageKeyToLookupKey
		this->Traits->LookupKeyToStorageKey := &PDBNamedStreamMapLookupKeyToStorageKey
		
		this->OffsetIndexMap := Alloc(#PDBHashmapBuilder)
		this->OffsetIndexMap->Initialize(this->Traits)
	},
	define i8 Get(i8* String, i32 StringLength, i32* StreamNumber) {
		
		PDBHashmapBucket* Entry := this->OffsetIndexMap->FindFirst(String, StringLength)
		i32 Index := this->OffsetIndexMap->GetBucketIndex(Entry)
		
		Print("Got %i, p = %i\n", Index, this->OffsetIndexMap->PresentVector->Get(Index))
		
		if !(this->OffsetIndexMap->PresentVector->Get(Index)) {
			Print("NOT PRESENT\n")
			
			return false
		}
		
		StreamNumber[0] := Entry->Value
		return true
	},
	define i8 Get(i8* String, i32* StreamNumber) {
		return this->Get(String, StringLength(String), StreamNumber)
	},
	define void Set(i8* String, i32 StringLength, i32 StreamNumber) {
		this->OffsetIndexMap->Set(String, StringLength, StreamNumber)
	},
	define void Set(i8* String, i32 StreamNumber) {
		this->OffsetIndexMap->Set(String, StreamNumber)
	},
	define i8* GetString(i32 Offset) {
		return this->Header~>StringBuffer + Offset
	},
	define i32 AppendString(i8* String, i32 StringLength) {
		i32 OldSize := this->Header->StringBufferSize
		i32 NewSize := OldSize + StringLength + 1
		
		this->Buffer := ReAlloc(this->Buffer, NewSize + 4)
		this->Header->StringBufferSize := NewSize
		
		i8* OldBufferEnd := this->Header~>StringBuffer + OldSize
		MoveMemory(OldBufferEnd, String, StringLength)
		
		return OldSize
	},
	define void* SerializeInto(void* RawBuffer) {
		i32* Buffer := RawBuffer As i32*
		
		i32 StringBufferSize := this->Header->StringBufferSize
		
		Buffer[0] := StringBufferSize
		
		i8* StringBuffer := (Buffer + 4) As i8*
		
		for (i32 Index := 0, Index < StringBufferSize, Index += 1) {
			StringBuffer[Index] := this->Header~>StringBuffer[Index]
		}
		
		RawBuffer := (StringBuffer + StringBufferSize) As void*
		
		return this->OffsetIndexMap->SerializeInto(RawBuffer)
	}
}

define i32 AbsoluteValue(i32 Value) {
	if (Value < 0) {
		return -Value
	}
	
	return Value
}

define i32 PDBNamedStreamMapHash(PDBNamedStreamMapBuilder* this, i8* Key, i32 KeyLength) {
	return AbsoluteValue(PDBHashLookupKeyV1(Key, KeyLength) As i32)
}
define i8* PDBNamedStreamMapStorageKeyToLookupKey(PDBNamedStreamMapBuilder* this, i32 Offset) {
	return this->GetString(Offset)
}
define i32 PDBNamedStreamMapLookupKeyToStorageKey(PDBNamedStreamMapBuilder* this, i8* Key, i32 KeyLength) {
	return this->AppendString(Key, KeyLength)
}

struct PDBStreamHeader unaligned {
	i32 Version,
	i32 CreationTime,
	i32 WriteCount,
	i64 UUIDHigh,
	i64 UUIDLow
}

i32 PDB_VERSION_VC70 := 20000404

define void* PDBWriteStreamHeaders(void* IntoBuffer, i64 SourcePathHash, i64 Time) {
	PDBStreamHeader* Header := IntoBuffer As PDBStreamHeader*
	
	Header->Version := PDB_VERSION_VC70
	Header->CreationTime := Time As i32
	Header->WriteCount := 1
	Header->UUIDLow := SourcePathHash ^ Time
	Header->UUIDHigh := Time ^ Header
	
	return IntoBuffer + #PDBStreamHeader
}

;define i32 Main() {
;	MSFBuilder* B := Alloc(#MSFBuilder)
;	
;	B->Initialize()
;	B->AllocateStreamDirectory()
;	
;	i8* D := Alloc(0x1500)
;	i8* StreamBuffer := D
;	
;	for (i32 I := 0x800, I < 0x1200, I += 1) {
;		D[I] := 0x75
;	}
;	
;	PDBNamedStreamMapBuilder* Bu := Alloc(#PDBNamedStreamMapBuilder)
;	
;	Bu->Initialize()
;	
;	i8* HW := "Hello world!"
;	
;	Print("Set\n")
;	
;	Bu->Set(HW, 3)
;	Bu->Set("Wello horld?", 3)
;	
;	Print("Set done, get\n")
;	
;	Bu->OffsetIndexMap->PresentVector->Print()
;	Bu->OffsetIndexMap->DeletedVector->Print()
;	
;	i8* HW2 := "Google"
;	
;	i32 Value := 0
;	i8 Result := Bu->Get(HW, &Value)
;	
;	Bu->OffsetIndexMap->PresentVector->Print()
;	Bu->OffsetIndexMap->DeletedVector->Print()
;	
;	Print("C %i = %i\n", Result, Value)
;	
;	Print("Before %x\n", D)
;	D := PDBWriteStreamHeaders(D, 0x123, 0x456)
;	Print("After %x\n", D)
;	Bu->SerializeInto(D)
;	
;	B->AppendStream(0, StreamBuffer, 0x1500)
;	
;	B->WriteToFile("C:\Users\Connor\Desktop\fuck\Relax-Language\src\lib\dummy.pdb")
;	
;	Print("Done\n")
;	
;	return 0
;}

i32 TPI_STREAM_VERSION_V80 := 20040203

i8 CV_POINTER_KIND_NEAR64 := 0x0C
i8 CV_POINTER_MODE_NORMAL := 0
i8 CV_POINTER_MODIFIER_NONE := 0
i32 CV_POINTER_ATTRIBUTES := 0x0C | (8 << 0xD)

i32 CV_KIND_I8 := 0x68
i32 CV_KIND_I16 := 0x21
i32 CV_KIND_I32 := 0x12
i32 CV_KIND_I64 := 0x76
i32 CV_MODE_POINTER := 0x600

struct CVTypeIndex {
	i32 RawIndex
	
	define i8 IsSimple() {
		return this->RawIndex < 0x1000
	}
	define i32 ToArrayIndex() {
		return this->RawIndex - 0x1000
	}
	define void FromArrayIndex(i32 Index) {
		this->RawIndex := Index + 0x1000
	}
	define i32 GetSimpleType() {
		return this->RawIndex & 0xFF
	}
	define i32 GetSimpleMode() {
		return this->RawIndex & 0x700
	}
}

struct CVTypeIndexHelper {
	union {
		i32 TypeIndex,
		CVTypeIndex Index
	}
}

i16 LF_POINTER := 0x1002
i16 LF_ARGLIST := 0x1201

struct CVTypeRecordHeader {
	i16 Length
	i16 Type
	
	define void* GetData() {
		return this + 4
	}
	define void* GetEnd() {
		return this + this->Length + 2
	}
}

struct TPIStreamHeader {
	i32 Version,
	i32 HeaderSize,
	
	i32 TypeIndexStart,
	i32 TypeIndexEnd,
	i32 TypeRecordBytes,
	
	i32 HashStreamIndex,
	i32 HashAuxStreamIndex,
	i32 HashKeySize,
	i32 NumberOfHashBuckets,
	
	i32 HashValueBufferOffset,
	i32 HashValueBufferLength,
	
	i32 IndexOffsetBufferOffset,
	i32 IndexOffsetBufferLength,
	
	i32 HashTableBufferOffset,
	i32 HashTableBufferLength,
	
	define void Initialize() {
		this->Version := TPI_STREAM_VERSION_V80
		this->HeaderSize := #TPIStreamHeader
		this->TypeIndexStart := 0x1000
		this->TypeIndexEnd := 0x1000
		this->TypeRecordBytes := 0
		this->HashKeySize := 4
	}
	define CVTypeRecordHeader* GetStartOfTypeRecords() {
		return (this~>HashValueBufferLength + 4) As CVTypeRecordHeader*
	}
	define CVTypeRecordHeader* GetEndOfTypeRecords() {
		return this->GetStartOfTypeRecords() + this->TypeRecordBytes
	}
}

struct TPIStreamBuilder {
	union {
		TPIStreamHeader* Header
		void* Buffer
	}
	
	i32 BufferSize
	
	define void Initialize() {
		this->BufferSize := #TPIStreamHeader
		this->Buffer := Alloc(this->BufferSize)
		
		this->Header->Initialize()
	}
	define void ReAlloc(i32 AdditionalSize) {
		this->BufferSize += AdditionalSize
		this->Buffer := ReAlloc(this->Buffer, this->BufferSize)
	}
	define i32 AppendCVRecord(CVTypeRecordHeader* Record) {
		i32 Length := Record->Length + 2
		
		this->ReAlloc(Length)
		
		MoveMemory(this->Header->GetEndOfTypeRecords() As i8*, Record As i8*, Length)
		
		this->Header->TypeRecordBytes += Length
		
		i32 Result := this->Header->TypeIndexEnd
		this->Header->TypeIndexEnd += 1
		
		return Result
	}
	define void SimplePrintIndex(i32 DumbIndex) {
		CVTypeIndex Index
		
		Index.RawIndex := DumbIndex
		
		if (Index.IsSimple()) {
			i32 Simple := Index.GetSimpleType()
			
			if (Simple = CV_KIND_I8) {
				Print("i8")
			}
			else if (Simple = CV_KIND_I16) {
				Print("i16")
			}
			else if (Simple = CV_KIND_I32) {
				Print("i32")
			}
			else if (Simple = CV_KIND_I64) {
				Print("i64")
			}
			else {
				Print("<Unknown Simple %x>", Simple)
			}
			
			if (Index.GetSimpleMode() = CV_MODE_POINTER) {
				Print("*")
			}
			
		}
		else {
			Print("%x", DumbIndex)
		}
	}
	define CVTypeRecordHeader* PrintSingleRecord(CVTypeRecordHeader* ThisRecord) {
		void* ThisRecordData := ThisRecord + 4
		
		if (ThisRecord->Type = LF_ARGLIST) {
			Print("{ArgList}(")
			
			i32 ArgListLength := *(ThisRecordData As i32*)
			i32* ArgListData := (ThisRecordData + 4) As i32*
			
			for (i32 ArgListIndex := 0, ArgListIndex < ArgListLength, ArgListIndex += 1) {
				this->SimplePrintIndex(ArgListData[ArgListIndex])
				
				if (ArgListIndex + 1 != ArgListLength) {
					Print(", ")
				}
			}
			
			Print(")\n")
		}
		
		return ThisRecord->GetEnd()
	}
	define void PrintTypeRecords() {
		CVTypeRecordHeader* Start := this->Header->GetStartOfTypeRecords()
		void* End := this->Header->GetEndOfTypeRecords()
		
		while (Start != End) {
			Start := this->PrintSingleRecord(Start)
		}
		
	}
}

define i32 Main() {
	
	TPIStreamBuilder* B := Alloc(#TPIStreamBuilder)
	
	B->Initialize()
	
	CVTypeRecordHeader* TList := Alloc(#CVTypeRecordHeader + 4 * 5)
	
	TList->Type := LF_ARGLIST
	TList->Length := 22
	
	i32* Buffer := TList->GetData()
	
	Buffer[0] := 4
	Buffer[1] := CV_KIND_I8
	Buffer[2] := CV_KIND_I64
	Buffer[3] := CV_KIND_I16 | CV_MODE_POINTER
	Buffer[4] := CV_KIND_I32
	
	Print("List Built\n")
	
	B->AppendCVRecord(TList)
	
	Print("List Appended\n")
	
	B->PrintTypeRecords()
	
	
	Print("Done\n")
	
	return 0
}

;#Require "./src/lib/Console.rlx"
;#Require "./src/lib/HashMap.rlx"
;#Require "./src/lib/String.rlx"
;
;#Require "./src/lib/Exception.rlx"
;#Require "./src/lib/Debug.rlx"
;
;define void Dummy() {
;	try {
;		PrintStackDump()
;		Throw('Inner')
;	}
;	catch (i64 Code) {
;		Print("Inner Caught %l\n", Code)
;		Throw('Test')
;	}
;	
;	Print("Never reached\n")
;}
;
;define i32 Main() {
;	;Print("Offset = %i\n", (0 As WindowsContextRecord*)~>RIP)
;	;
;	;
;	;try {
;	;	Dummy()
;	;}
;	;catch (i64 Code) {
;	;	Print("Outer Caught %l\n", Code)
;	;}
;	;
;	;Print("Done main\n")
;	
;	Print("Before: %x\n", GetRBP())
;	
;	try {
;		PrintStackDump()
;		(0 As i32*)[0] := 99
;	}
;	catch (i64 Error) {
;		Print("Caught Windows error %x\n", Error)
;	}
;	
;	Print("After: %x\n", GetRBP())
;	
;	Print("I am officially mega smart\n")
;	
;	;(0 As i32*)[0] := 99
;	Throw(0xBEEF)
;	
;	return 0
;}