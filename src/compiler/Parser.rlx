; TODO: Add a divmod built-in, the `x / constant` with `x % constant` pattern is getting annoying.

bits Type As i64 {
	[0:47] BaseType,
	[48:49] IsArray,
	[50:63] PointerDepth
}

Type TYPE_NONE := 0 As Type

i8 GLOBAL_IS_OPTIMIZED_AWAY := 2

struct VariableInfo {
	ASTNode* LastValue,
	SafeWideString* Name,
	Type Type,
	i32 StackOffset,
	i16 GetCount,
	i16 SetCount,
	i8 IsGlobal,
	i8 IsParameter,
	i8 IsVariadic,
	i8 IsThis
}

declare i32 RoundTo(i32, i32)
declare i16 GetTypeStorageSize(Type)

struct VariableHashMap {
	HashMap BackingMap
	HashMap* Map
	i32 NextOffset
	
	define void Initialize() {
		this->Map := this~>BackingMap
		
		this->Map->BufferMaxCount := 100
		this->Map->Elements := Alloc(this->Map->BufferMaxCount * 8)
		
		this->NextOffset := 0
	}
	
	define VariableInfo* Get(SafeWideString* VariableName) {
		HashMapElement* FoundElement := this->Map->Get(VariableName)
		
		if (FoundElement) {
			return FoundElement->Value As VariableInfo*
		}
		
		return null
	}
	
	define void Add(VariableInfo* NewVariable, Token* SourceToken) {
		if (this->Get(NewVariable->Name)) {
			/* If we already have this name in the hashmap, then it's a duplicate definition */
			
			SourceToken->Error("Duplicate definition")
		}
		
		this->Map->Set(NewVariable->Name, NewVariable)
		
		NewVariable->StackOffset := this->NextOffset
		
		i16 NewVariableSize := GetTypeStorageSize(NewVariable->Type)
		
		if (NewVariableSize <= 8) {
			this->NextOffset += 8
		}
		else {
			i16 RoundedSize := RoundTo(NewVariableSize, 8) As i16
			
			NewVariable->StackOffset += RoundedSize
			
			this->NextOffset += RoundedSize + 8
		}
	}
}

#Require "./src/compiler/Parser/AST.rlx"
#Require "./src/compiler/Parser/Types.rlx"

i8 TYPE_REGULAR := 1
i8 TYPE_STRUCT := 2
i8 TYPE_INCOMPLETE := 4
i8 TYPE_BITS := 8
i8 TYPE_ARRAY := 16

; Holds the entire state of the parser

struct ParserState {
	BuildConfig* Config,
	LexerState* Lexer,
	
	HashMap Functions,
	
	VariableHashMap Globals,
	ASTNode** GlobalDefaults,
	
	HashMap Registers,
	HashMap Instructions,
	
	HashMap Types,
	
	/* Builtin types, actually added to the type list in CreateDefaultTypes */
	
	TypeInfo* i8,
	TypeInfo* i16,
	TypeInfo* i32,
	TypeInfo* i64,
	TypeInfo* void,
	
	FunctionDefine* CurrentFunction,
	FunctionDefine* MainFunction,
	
	i8* GlobalConstantsBuffer
	i32 GlobalConstantBufferSize
	
	i8 InLoop,
	
	i32 LabelCount
	
	declare TypeInfo* AddType(i8*, i16, i8)
	declare void SetupAssembly()
	
	static ParserState* New(BuildConfig* Config, LexerState* Lexer) {
		ParserState* this := Alloc(#ParserState)
		
		this->Config := Config
		this->Lexer := Lexer
		
		this~>Globals->Initialize()
		this~>Functions->Initialize()
		this~>Types->Initialize()
		
		this->GlobalDefaults := AllocArray(8, 0)
		this->GlobalConstantsBuffer := Alloc(4)
		
		this->i8 := this->AddType("i8", 1, TYPE_REGULAR)
		this->i16 := this->AddType("i16", 2, TYPE_REGULAR)
		this->i32 := this->AddType("i32", 4, TYPE_REGULAR)
		this->i64 := this->AddType("i64", 8, TYPE_REGULAR)
		this->void := this->AddType("void", 8, TYPE_REGULAR)
		
		this->SetupAssembly()
		
		return this
	}
	
	define TypeInfo* AddType(SafeWideString* Name, i16 Size, i8 Flags) {
		TypeInfo* NewType := Alloc(#TypeInfo)
		
		NewType->Name := Name
		NewType->Size := Size
	
		if (Flags & TYPE_STRUCT) {
			NewType->IsStructType := true
		}
		
		if (Flags & TYPE_INCOMPLETE) {
			NewType->IsIncomplete := true
		}
		
		if (Flags & TYPE_BITS) {
			NewType->IsBits := true
		}
		
		if (Flags & TYPE_REGULAR) {
			NewType->IsBuiltin := true
		}
		
		this~>Types->Set(Name, NewType)
		
		return NewType
	}
	define TypeInfo* AddType(i8* Name, i16 Size, i8 Flags) {
		return this->AddType(AToS(Name), Size, Flags)
	}
	
	declare Token* GetCurrentToken()
	
	define Type TryFindType(SafeWideString* TypeName, i16 PointerDepth, i8** ErrorMessage) {
		HashMapElement* FoundTypeInfoElement := this~>Types->Get(TypeName)
		TypeInfo* FoundTypeInfo := null
		
		if (FoundTypeInfoElement) {
			FoundTypeInfo := FoundTypeInfoElement->Value As TypeInfo*
		}
		else {
			if (PointerDepth = 0) {
				*ErrorMessage := "Undefined type (Incomplete types can only be pointed-to)"
				
				return TYPE_NONE
			}
			else {
				FoundTypeInfo := this->AddType(TypeName, 0, TYPE_STRUCT | TYPE_INCOMPLETE)
			}
		}
		
		return FoundTypeInfo->AsPointer(PointerDepth)
	}
	define Type FindType(SafeWideString* TypeName, i16 PointerDepth) {
		i8* ErrorMessage := null
		
		Type Result := this->TryFindType(TypeName, PointerDepth, &ErrorMessage)
		
		if (ErrorMessage) {
			this->GetCurrentToken()->Error(ErrorMessage)
		}
		
		return Result
	}
	
	define Type DereferencePointerType(Type TypeToDecrement, ErrorContext* BlameContext) {
		i16 PointerDepth := GetPointerDepth(TypeToDecrement)
		
		if (PointerDepth = 0) {
			BlameContext->Error("Pointer type expected")
		}
		
		return GetBaseType(TypeToDecrement)->AsPointer(PointerDepth - 1 As i16)
	}
	define Type PointerToType(Type TypeToIncrement) {
		return GetBaseType(TypeToIncrement)->AsPointer(GetPointerDepth(TypeToIncrement) + 1 As i16)
	}
	
	define Type GetNumberType(i64 Number) {
		if (Number & 0xFFFF_FFFF_8000_0000) {
			return this->i64->AsNonPointer()
		}
		else {
			return this->i32->AsNonPointer()
		}
	}
	
	define ASTNode* DowncastIntegerNode(ASTNode* Target) {
		if (Target->NodeType != NODE_TYPE_INTEGER) {
			return Target
		}
		
		i8 Size := GetNumberSize(Target->IntegerValue)
		TypeInfo* BaseType := this->i8
		
		if (Size = 2) {BaseType := this->i16}
		else if (Size = 4) {BaseType := this->i32}
		else if (Size = 8) {BaseType := this->i64}
		
		Target->ValueType := BaseType->AsNonPointer()
		
		return Target
	}
	
	define VariableInfo* FindVariable(Token* NameToken) {
		; Finds a variable, prioritizing locals over globals
		
		SafeWideString* VariableName := NameToken->StringValue
		
		FunctionDefine* CurrentFunction := this->CurrentFunction
		VariableInfo* FoundVariable := null
		
		if (CurrentFunction) {
			; If we are in a function, try to find the variable in the locals
			FoundVariable := CurrentFunction~>Locals->Get(VariableName)
		}
		
		if !(FoundVariable) {
			; If we didn't find the variable in the locals, then check the globals
			FoundVariable := this~>Globals->Get(VariableName)
			
			if (CurrentFunction) {
				CurrentFunction->UsesGlobals := true
			}
		}
		
		if !(FoundVariable) {
			; If we still haven't found the variable, then it is undefined
			
			NameToken->Error("Undefined variable")
		}
		
		; Variable has to have been found at some point for this to be reached
		
		return FoundVariable
	}
	define void AddGlobal(VariableInfo* NewGlobal, Token* BlameToken) {
		this~>Globals->Add(NewGlobal, BlameToken)
	}
	define void AddLocal(VariableInfo* NewLocal, Token* BlameToken) {
		this->CurrentFunction~>Locals->Add(NewLocal, BlameToken)
	}
	define void AddVariable(VariableInfo* NewVariable, Token* BlameToken) {
		if (NewVariable->IsGlobal) {
			this->AddGlobal(NewVariable, BlameToken)
		}
		else {
			this->AddLocal(NewVariable, BlameToken)
		}
	}
	
	define i32 Freeze() {
		return this->Lexer->TokenIndex
	}
	define void Unfreeze(i32 FrozenState) {
		this->Lexer->TokenIndex := FrozenState
	}
	define Token* GetCurrentToken() {
		this->Lexer->TokenIndex -= 1
		
		return this->Lexer->GetNextToken()
	}
	define ErrorContext* GetCurrentTokenContext() {
		return this->GetCurrentToken()~>Context
	}
	define Token* GetNextToken() {
		return this->Lexer->GetNextToken()
	}
	define Token* PeekNextToken() {
		i32 Before := this->Freeze()
		
		Token* Result := this->Lexer->GetNextToken()
		
		this->Unfreeze(Before)
		
		return Result
	}
	define i8 NextTokenMatches(i8 TokenType, i64 TokenValue) {
		if (this->PeekNextToken()->Is(TokenType, TokenValue)) {
			this->GetNextToken()
			
			return true
		}
		
		return false
	}
	define i8 NextTokenMatches(i8 TokenType) {
		if (this->PeekNextToken()->Is(TokenType)) {
			this->GetNextToken()
			
			return true
		}
		
		return false
	}
	define Token* TryConsume(i8 TokenType, i64 TokenValue, i8* Reason, i8** ErrorMessage) {
		Token* NextToken := this->GetNextToken()
		
		if (NextToken->Is(TOKEN_TYPE_EOF, 0)) {
			*ErrorMessage := "Unexpected end of file"
		}
		else if !(NextToken->Is(TokenType, TokenValue)) {
			*ErrorMessage := Reason
		}
		
		return NextToken
	}
	define Token* TryConsume(i8 TokenType, i8* Reason, i8** ErrorMessage) {
		return this->TryConsume(TokenType, 0, Reason, ErrorMessage)
	}
	define Token* Consume(i8 TokenType, i64 TokenValue, i8* Reason) {
		i8* ErrorMessage := null
		
		Token* Result := this->TryConsume(TokenType, TokenValue, Reason, &ErrorMessage)
		
		if (ErrorMessage) {
			Result->Error(ErrorMessage)
		}
		
		return Result
	}
	define Token* Consume(i8 TokenType, i8* Reason) {
		return this->Consume(TokenType, 0, Reason)
	}
	
	define Type TryParseType(i8 AllowArrayType, i8** ErrorMessage) {
		Token* NameToken := this->TryConsume(TOKEN_TYPE_IDENTIFIER, "Type names must be identifiers", ErrorMessage)
		
		if *(ErrorMessage) {
			return TYPE_NONE
		}
		
		i8 PointerDepth := 0
		
		while (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_STAR)) {
			PointerDepth += 1
		}
		
		Type Result := this->TryFindType(NameToken->StringValue, PointerDepth, ErrorMessage)
		
		if (AllowArrayType && this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
			Token* SizeToken := this->TryConsume(TOKEN_TYPE_INTEGER, "Expected array type size", ErrorMessage)
			
			if (*ErrorMessage = null) {
				TypeInfo* ResultBase := GetBaseType(Result)
				
				if (ResultBase->IsIncomplete && PointerDepth = 0) {
					NameToken->Error("Array types must not be incomplete")
				}
				
				Result := MakeArrayType(Result, SizeToken->IntegerValue As i16)
				Result.IsArray := true
				
				this->TryConsume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}' for array type", ErrorMessage)
			}
		}
		
		return Result
	}
	define Type ParseType(i8 AllowArrayType) {
		i8* ErrorMessage := null
		Token* BlameToken := this->PeekNextToken()
		
		Type Result := this->TryParseType(AllowArrayType, &ErrorMessage)
		
		if (ErrorMessage) {
			BlameToken->Error(ErrorMessage)
		}
		
		return Result
	}
	define Type ParseType() {
		return this->ParseType(false)
	}
	define ASTNode* ParseTypeNode() {
		Token* FirstToken := this->PeekNextToken()
		Type Result := this->ParseType()
		
		ASTNode* ResultNode := ASTNode:New(NODE_TYPE_TYPE, Result As i64, Result)
		
		ResultNode~>Context->Clone(FirstToken~>Context)->Merge(this->GetCurrentTokenContext())
		
		return ResultNode
	}
	
	define FunctionDefine* LookupStaticMethod(Token* TypeNameToken, Token* StaticMethodNameToken) {
		HashMapElement* TypeElement := this~>Types->Get(TypeNameToken->StringValue)
		
		if !(TypeElement) {
			TypeNameToken->Error("Undefined type")
		}
		
		TypeInfo* TargetType := TypeElement->Value As TypeInfo*
		
		HashMapElement* FoundFunctionElement := TargetType~>StaticMethods->Get(StaticMethodNameToken->StringValue)
		
		if !(FoundFunctionElement) {
			StaticMethodNameToken->Error("Undefined static method")
		}
		
		return FoundFunctionElement->Value As FunctionDefine*
	}
	
	#Require "./src/compiler/Parser/Expression.rlx"
	
	define ASTNode* ParseInitializer(ASTNode* ForNode) {
		Type ForType := ForNode->ValueType
		
		i8 IsArray := ForType.IsArray
		i16 ForTypeDepth := GetPointerDepth(ForType)
		TypeInfo* ForBaseType := GetBaseType(ForType)
		
		if (ForTypeDepth = 0 && ForBaseType->IsStructType) {
			i16 InitializerCapacity := 20
			ASTNode** Initializers := Alloc(InitializerCapacity * #ASTNode*) As ASTNode**
			
			i16 InitializerIndex := 0
			i8 IsFirstInitializer := true
			
			while (IsFirstInitializer || this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
				Token* FieldName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected initializer field name")
				
				this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_COLON, "Expected ':' after initializer field name")
				
				HashMapElement* FieldElement := ForBaseType~>Fields->Get(FieldName->StringValue)
				
				if (FieldElement = null) {
					FieldName->Error("Unknown struct field")
				}
				
				StructField* Field := FieldElement->Value
				i8 FieldIsStruct := GetPointerDepth(Field->ValueType) = 0 && GetBaseType(Field->ValueType)->IsStructType
				i8 FieldIsArray := Field->ValueType.IsArray
				
				; Build a node for `ForNode.Field`
				
				StructAccessExpression* Access := Alloc(#StructAccessExpression)
				
				Access->Left := ForNode
				Access->Operator := Alloc(#Token)
				Access->Operator->Type := TOKEN_TYPE_OPERATOR
				Access->Operator->IntegerValue := OPERATOR_DOT
				Access->TargetField := Field
				
				if (FieldIsArray) {
					Access->Operator->IntegerValue := OPERATOR_TILDE_GREATER
				}
				
				; Parse any initializers for `ForNode.Field`
				
				if (FieldIsStruct || FieldIsArray) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected '{' for field initializer")
				}
				
				ASTNode* AccessNode := ASTNode:New(NODE_TYPE_STRUCT_ACCESS, Access, Field->ValueType)
				ASTNode* InitializerValue := this->ParseInitializer(AccessNode)
				
				if (FieldIsStruct || FieldIsArray) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}' for field initializer")
				}
				
				; If `ForNode.Field` is a struct, then we don't want to assign `ForNode.Field` to anything, since
				;  there is no value to assign, merely a block of initializers for `ForNode.Field` itself which
				;   should be directly executed
				
				if (FieldIsStruct || FieldIsArray) {
					Initializers[InitializerIndex] := InitializerValue
				}
				else {
					BinaryExpression* Assign := Alloc(#BinaryExpression)
					
					Assign->Left := AccessNode
					Assign->Operator := Alloc(#Token)
					Assign->Operator->Type := TOKEN_TYPE_OPERATOR
					Assign->Operator->IntegerValue := OPERATOR_COLON_EQUAL
					Assign->Right := InitializerValue
					
					Initializers[InitializerIndex] := ASTNode:New(NODE_TYPE_BINARY, Assign, Field->ValueType)
				}
				
				InitializerIndex += 1
				IsFirstInitializer := false
			}
			
			Block* InitializersBlock := Alloc(#Block) As Block*
			
			InitializersBlock->Statements := Initializers
			InitializersBlock->StatementCount := InitializerIndex
			
			return ASTNode:New(NODE_TYPE_EXPRESSION_BLOCK, InitializersBlock)
		}
		else if (IsArray) {
			ArrayTypeInfo* ForArrayType := GetArrayType(ForType)
			Type ElementType := ForArrayType->BaseType->AsPointer(ForTypeDepth - 1 As i16)
			
			ASTNode** ElementInitiailizers := Alloc(ForArrayType->Length * #ASTNode*)
			
			for (i16 Index := 0, Index < ForArrayType->Length, Index += 1) {
				BinaryExpression* ArrayAccess := Alloc(#BinaryExpression)
				
				ArrayAccess->Left := ForNode
				ArrayAccess->Operator := Alloc(#Token)
				ArrayAccess->Operator->Type := TOKEN_TYPE_OPERATOR
				ArrayAccess->Operator->IntegerValue := OPERATOR_OPEN_BRACKET
				ArrayAccess->Right := ASTNode:New(NODE_TYPE_INTEGER, Index, this->i32->AsNonPointer())
				
				i8 InitializerIsStruct := GetPointerDepth(ElementType) = 0 && GetBaseType(ElementType)->IsStructType
				
				if (InitializerIsStruct) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected '{' for field initializer")
				}
				
				ASTNode* ArrayAccessNode := ASTNode:New(NODE_TYPE_BINARY, ArrayAccess, ElementType)
				ASTNode* ElementInitiailizer := this->ParseInitializer(ArrayAccessNode)
				
				if (InitializerIsStruct) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}' for field initializer")
					
					ElementInitiailizers[Index] := ElementInitiailizer
				}
				else {
					CheckTypes(this->void, ElementInitiailizer->ValueType, ElementType, ElementInitiailizer)
					
					BinaryExpression* ElementAssign := Alloc(#BinaryExpression)
					
					ElementAssign->Left := ArrayAccessNode
					ElementAssign->Operator := Alloc(#Token)
					ElementAssign->Operator->Type := TOKEN_TYPE_OPERATOR
					ElementAssign->Operator->IntegerValue := OPERATOR_COLON_EQUAL
					ElementAssign->Right := ElementInitiailizer
					
					ElementInitiailizers[Index] := ASTNode:New(NODE_TYPE_BINARY, ElementAssign, ElementType)
				}
				
				if !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
					break
				}
			}
			
			Block* ArrayInitializersBlock := Alloc(#Block) As Block*
			
			ArrayInitializersBlock->Statements := ElementInitiailizers
			ArrayInitializersBlock->StatementCount := (Index + 1) As i16
			
			return ASTNode:New(NODE_TYPE_EXPRESSION_BLOCK, ArrayInitializersBlock)
		}
		else {
			ASTNode* InitializerExpression := this->ParseExpression()
			
			if (InitializerExpression->NodeType = NODE_TYPE_INTEGER) {
				InitializerExpression := this->DowncastIntegerNode(InitializerExpression)
			}
			
			CheckTypes(this->void, InitializerExpression->ValueType, ForType, InitializerExpression)
			
			return InitializerExpression
		}
	}
	
	define ASTNode* TryParseVariableDeclaration(i8 ForGlobalVariable, i8 ForParameter, i8** ErrorMessage, VariableInfo** OutNewVariable) {
		; Try to parse the declaration of a single variable (which can be local, global, or a parameter)
		;  and returns an expression which will set that variable to an optional default value (if allowed)
		
		Token* MaybeAuto := this->PeekNextToken()
		
		if (ForParameter = false && MaybeAuto->Is(TOKEN_TYPE_IDENTIFIER) && MaybeAuto->StringValue->Equals("auto")) {
			this->GetNextToken()
			
			Token* AutoVariableName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for auto variable name")
			Token* AssignmentOperator := this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL, "Expected `:=` for auto variable declaration")
			
			; Add the variable early (as void*) just in case the expression somehow references the variable
			;  (and would throw a parse error)
			
			VariableInfo* AutoVariable := Alloc(#VariableInfo)
			
			AutoVariable->Name := AutoVariableName->StringValue
			AutoVariable->Type := this->void->AsPointer(1)
			AutoVariable->IsGlobal := ForGlobalVariable
			AutoVariable->IsParameter := ForParameter
			
			if (OutNewVariable != 0) {
				*OutNewVariable := AutoVariable
			}
			
			this->AddVariable(AutoVariable, AutoVariableName)
			
			; Parse the variable's initial value, and then update the variable's type using the type of the
			;  initial value
			
			ASTNode* AutoValue := this->ParseExpression()
			AutoVariable->Type := AutoValue->ValueType
			
			; Build an AST node to assign the variable to the initial value, and then return it for the caller
			;  to compile before this variable is used
			
			BinaryExpression* AutoAssign := Alloc(#BinaryExpression)
			
			AutoAssign->Left := ASTNode:New(NODE_TYPE_VARIABLE, AutoVariable, AutoVariable->Type)
			AutoAssign->Operator := AssignmentOperator
			AutoAssign->Right := AutoValue
			
			return ASTNode:New(NODE_TYPE_BINARY, AutoAssign, AutoVariable->Type)
		}
		
		i32 Before := this->Freeze()
		Type PotentialType := this->TryParseType(true, ErrorMessage)
		
		if (PotentialType != TYPE_NONE && *ErrorMessage = null) {
			; If we could parse a full type name, then we *might* be dealing with a variable declaration.
			;  But we're not sure yet.
			
			i32 DefaultValueExpressionStart := this->Freeze()
			
			if (this->NextTokenMatches(TOKEN_TYPE_IDENTIFIER)) {
				Token* NameToken := this->GetCurrentToken()
				
				; Alright, we've got `Type Name`, which is definitely a variable declaration.
				; So we build up a VariableInfo struct for it, and add it to the correct scope.
				
				VariableInfo* NewVariable := Alloc(#VariableInfo)
				
				NewVariable->Name := NameToken->StringValue
				NewVariable->Type := PotentialType
				NewVariable->IsGlobal := ForGlobalVariable
				NewVariable->IsParameter := ForParameter
				
				if (OutNewVariable != 0) {
					*OutNewVariable := NewVariable
				}
				
				this->AddVariable(NewVariable, NameToken)
				
				; If we're declaring a local/global (but not a parameter) allow for an optional default value
				;  expression after, marked by `Type Name` being followed by the `:=` operator.
				
				; Note: the parser needs to backtrack to before `Name :=` and parse the entire `Name := Value` 
				;  expression if it is present
				
				if (ForParameter = false && this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
					this->Unfreeze(DefaultValueExpressionStart)
					
					return this->ParseExpression()
				}
				else if (ForParameter = false && this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
					ASTNode* NewVariableNode := ASTNode:New(NODE_TYPE_VARIABLE, NewVariable, PotentialType)
					
					ASTNode* InitializersBlock := this->ParseInitializer(NewVariableNode)
					
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}'")
					
					return InitializersBlock
				}
				else {
					return null
				}
			}
			else {
				*ErrorMessage := "Variable names must be identifiers"
			}
		}
		
		this->Unfreeze(Before)
		
		return null
	}
	define ASTNode* TryParseVariableDeclaration(i8 ForGlobalVariable, i8 ForParameter, i8** ErrorMessage) {
		return this->TryParseVariableDeclaration(ForGlobalVariable, ForParameter, ErrorMessage, null As VariableInfo**)
	}
	
	#Require "./src/compiler/Parser/Assembly.rlx"
	#Require "./src/compiler/Parser/Statement.rlx"
	
	define FunctionDefine* ParseFunctionDefinition(HashMap* Namespace, Token* FirstToken, TypeInfo* ThisType) {
		i8 Mode := FirstToken->Value As i8
		
		i8 ForStatic := Mode = KEYWORD_STATIC
		i8 ForDefine := Mode = KEYWORD_DEFINE || ForStatic
		i8 ForImport := Mode = KEYWORD_DLLIMPORT
		
		Type ReturnType := this->ParseType()		
		Token* NameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected function name")
		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Expected opening '(' for function parameter list")
		
		if (ForDefine) {
			; For define statements, any parameters are added as locals, meaning that this->CurrentFunction 
			;  needs to be set to prevent `this->AddLocal` inside of the parameter list parsing from crashing
			
			; `Locals` is copied onto the actual `FunctionDefine*` for this function after the parameters have 
			; been parsed, and the matching overload has been found (if it exists)
			
			FunctionDefine TempDefine
			
			TempDefine~>Locals->Initialize()
			
			this->CurrentFunction := &TempDefine
		}
		
		i8 ParameterCount := 0
		VariableInfo** ParameterList := Alloc(16 * #VariableInfo) As VariableInfo**
		
		if (ThisType != 0) {
			; If we are defining a method, then we need to build the `this` parameter, and insert it into the 
			;  parameter list
	
			VariableInfo* ThisParameter := Alloc(#VariableInfo)
			ThisParameter->Name := AToS("this")
			ThisParameter->Type := ThisType->AsPointer(1)
			ThisParameter->IsParameter := true
			ThisParameter->IsThis := true
			
			if (ForDefine) {
				; Only actually add `this` as a local when we are defining a full function, and 
				;  have this->CurrentFunction set
				
				this->AddLocal(ThisParameter, null)
			}
			
			ParameterList[0] := ThisParameter
			ParameterCount += 1
		}
		
		i8 Attribute := 0
		
		if !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
			; Only bother parsing parameters if we actually have any
			
			loop {
				VariableInfo* NextParameter := Alloc(#VariableInfo)
				
				; Max parameter count since I cba to expand the buffer. Todo: Fix this
				if (ParameterCount >= 16) {
					this->GetNextToken()->Error("Max parameter limit reached")
				}
				
				ParameterList[ParameterCount] := NextParameter
				
				i8 ShouldBreak := false
				
				if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
					ShouldBreak := true
					
					ErrorContext* Start := this->GetCurrentTokenContext()
					
					this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected '.' for variadic marker")
					this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected '.' for variadic marker")
					
					if (ParameterCount > 4) {
						Start->Merge(this->GetCurrentTokenContext())
						Start->Error("Only >4 regular paremeters can be passed with a variable argument.")
					}
					
					Attribute := OPERATOR_DOT
					
					NextParameter->Type := this->void->AsPointer(1)
					NextParameter->IsParameter := true
				}
				else {
					NextParameter->Type := this->ParseType()
				}
				
				if (ForDefine) {
					Token* NextParameterNameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Parameter names must be identifiers")
					NextParameter->Name := NextParameterNameToken->StringValue
					this->AddLocal(NextParameter, NextParameterNameToken)
				}
				
				NextParameter->IsGlobal := false
				NextParameter->IsParameter := true
				NextParameter->StackOffset := (ParameterCount * 8)
				
				ParameterCount += 1
				
				if (ShouldBreak) {
					break
				}
				else if !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
					; If the next token isn't a comma, then break the loop, otherwise consume the command and 
					;  continue
					
					break
				}
			}
			
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing ')' for parameter list")
		}
		
		HashMapElement* FoundFunctionElement := Namespace->Get(NameToken->StringValue)
		
		FunctionDefine* NewDefine := null
		FunctionDefine* TailFunction := null
		
		if (FoundFunctionElement != null) {
			; This is a function overload, find the tail of the overload linked list, and check that
			;  our parameters aren't the same as any other definition's parameters
			
			FunctionDefine* NextFunction := FoundFunctionElement->Value As FunctionDefine*
			
			loop {
				; For each definition of this name
				
				if (NextFunction->ParameterCount = ParameterCount) {
					if (CheckTypeSignature(NextFunction, ParameterList)) {
						; Allow redefining a declared overload
						
						if (NextFunction->HasFullDefinition) {
							NameToken->Error("Duplicate function definition")
						}
						
						NewDefine := NextFunction
						
						break
					}
				}
				
				if !(NextFunction->Next) {
					break
				}
				
				NextFunction := NextFunction->Next
			}
			
			TailFunction := NextFunction
		}
		
		if (NewDefine = null) {
			; If we didn't find `declare`d version of this function with the same parameter type set, then
			;  allocate a new node instead of reusing the (non-existent) `declare`d one.
			
			NewDefine := Alloc(#FunctionDefine)
			
			if (TailFunction) {
				TailFunction->Next := NewDefine
			}
			else {
				Namespace->Set(NameToken->StringValue, NewDefine)
			}
			
			NewDefine->LabelNumber := this->LabelCount
			this->LabelCount += 1
		}
		
		; By here, NewDefine 100% holds a FunctionDefine struct for this function, which is added to whichever 
		;  scope it needs to be.
		
		NewDefine->Name := NameToken->StringValue
		NewDefine->ReturnType := ReturnType
		NewDefine->Attribute := Attribute
		NewDefine->Parameters := ParameterList
		NewDefine->ParameterCount := ParameterCount
		
		if (ForDefine) {
			; Only copy the variable map containing the parameter locals if it... exists.
			
			MoveMemory(NewDefine~>Locals, TempDefine~>Locals, #VariableHashMap)
		}
		
		NewDefine~>Context->Clone(FirstToken~>Context)->Merge(this->GetCurrentTokenContext())
		
		; We are done parsing the function's name, return type, and parameters. Now to just handle all of
		;  the different function body types.
		
		if (ForImport) {
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Import source must have a prior '{'")
			
			SafeWideString* FileName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Import source file name expected")->StringValue
			
			if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
				this->Consume(TOKEN_TYPE_IDENTIFIER, "Import source file extension expected")
			}
			
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA, "Comma expected between import source file and function names")
			
			SafeWideString* FunctionName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Import source function name expected")->StringValue
			
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}'")
			
			NewDefine->IsImported := true
			NewDefine->ImportFileName := FileName
			NewDefine->ImportFunctionName := FunctionName
		}
		else if (ForDefine) {
			this->CurrentFunction := NewDefine
			
			if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_ASSEMBLY)) {
				NewDefine->Attribute := KEYWORD_ASSEMBLY
				
				NewDefine->AssemblyBody := this->ParseAssembly(false)->AssemblyValue
			}
			else {
				if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_X64)) {
					NewDefine->Attribute := KEYWORD_X64
				}
				
				i32 Length := 4
				i8* Buffer := Alloc(Length)
				
				if (this->Config->DebugMode & DEBUG_EMIT_FUNCTION_NAMES) {
					Length := NewDefine->GetStringLength()
					Buffer := ReAlloc(Buffer, Length)
					
					NewDefine->StringifyInto(Buffer)
					
					NewDefine->StringBufferSize := Length
				}
				
				NewDefine->StringBuffer := Buffer
				
				NewDefine->Body := this->ParseBlock()
				
				if (NewDefine->ReturnType != this->void->AsNonPointer()) {
					if !(NewDefine->Body->HasUnconditionalReturn) {
						NewDefine~>Context->Error("Function has non-void return type, but no unconditional return statement")
					}
				}
			}
			
			NewDefine->HasFullDefinition := true
			this->CurrentFunction := null
		
			if (ThisType = null && NameToken->StringValue->Equals("Main")) {
				this->MainFunction := NewDefine
			}
		}
		
		return NewDefine
	}
	define FunctionDefine* ParseFunctionDefinition(HashMap* Namespace, Token* FirstToken) {
		return this->ParseFunctionDefinition(Namespace, FirstToken, null)
	}
	
	define TypeInfo* ParseCustomTypeName(Token* NameToken, i8 Flags) {
		SafeWideString* Name := NameToken->StringValue
		
		TypeInfo* NewType := null
		HashMapElement* FoundTypeElement := this~>Types->Get(Name)
		
		if (FoundTypeElement) {
			; Check for a type with this name already existing
			
			NewType := FoundTypeElement->Value As TypeInfo*
			
			if !(NewType->IsIncomplete) {
				; If the type we found isn't incomplete, then error out
				
				NameToken->Error("Duplicate struct definition")
			}
			
			NewType->IsIncomplete := false
		}
		else {
			; We didn't find a type by this name, so we can add it like normal
			
			NewType := this->AddType(Name, 0, Flags)
		}
		
		return NewType
	}
	
	define void ParseStructDefinition() {
		Token* NameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for struct name")
		
		TypeInfo* NewType := this->ParseCustomTypeName(NameToken, TYPE_STRUCT)
		
		; All of the "namespaces" a TypeInfo structure contains need to be initialized
		
		HashMap* Fields := NewType~>Fields
		HashMap* Methods := NewType~>Methods
		HashMap* StaticMethods := NewType~>StaticMethods
		
		Fields->Initialize()
		Methods->Initialize()
		StaticMethods->Initialize()
		
		i8 IsUnaligned := this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_UNALIGNED)
		
		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for struct body")
		
		i16 NextFieldOffset := 0
		i16 TotalSize := 0
		i8 InUnion := false
		i16 MaxUnionSize := 0
		
		loop {
			StructField* NextField := Alloc(#StructField) As StructField*
			
			if !(InUnion) {
				if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_UNION)) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for union body.")
					
					InUnion := true
				}
				else {
					i8 IsMethod := false
					i8 IsStaticMethod := false
					Token* MethodKeyword := this->PeekNextToken()
					
					if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD)) {
						i8 KeywordValue := MethodKeyword->Value As i8
						
						IsStaticMethod := KeywordValue = KEYWORD_STATIC
						IsMethod := IsStaticMethod || KeywordValue = KEYWORD_DECLARE || KeywordValue = KEYWORD_DEFINE
					}
					
					if (IsMethod) {
						HashMap* MethodNamespace := Methods
						TypeInfo* ThisType := NewType
						
						if (IsStaticMethod) {
							; Static methods take no `this` parameter, so we need to mark that `ThisType`
							;  isn't present to prevent `ParseFunction` from automatically adding
							;   the `this` parameter
							
							MethodNamespace := StaticMethods
							ThisType := null
						}
						
						FunctionDefine* Method := this->ParseFunctionDefinition(MethodNamespace, MethodKeyword, ThisType)
						
						; `FUNCTION_IS_METHOD` when `IsStaticMethod` is false, and
						;  `FUNCTION_IS_STATIC_METHOD` when `IsStaticMethod` is true
						Method->IsMethod := (true + IsStaticMethod) As i8
						Method->MethodOfTypeName := NameToken->StringValue
						
						; Ignore commas after methods, they aren't actually needed for parsing
						this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
						
						if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
							break
						}
						
						continue
					}
				}
			}
			
			NextField->ValueType := this->ParseType(true)
			
			Token* FieldNameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for struct field name")
			SafeWideString* FieldName := FieldNameToken->StringValue
			NextField->Name := FieldName
			
			if (Fields->Get(FieldName)) {
				FieldNameToken->Error("Duplicate definition")
			}
			
			Fields->Set(FieldName, NextField)
			
			i16 FieldSize := GetTypeStorageSize(NextField->ValueType)
			
			; Only align the field if it isn't a struct, array, union, and if this structure isn't unaligned 
			
			if (GetPointerDepth(NextField->ValueType) = 0 && GetBaseType(NextField->ValueType)->IsStructType) {
				; Dummy branch
			}
			else if (InUnion || IsUnaligned) {
				; Dummy branch
			}
			else if (NextField->ValueType.IsArray) {
				; Dummy branch
			}
			else if (NextFieldOffset % FieldSize) {
				; Pad the field's offset to a multiple of its size
				
				NextFieldOffset += FieldSize - (NextFieldOffset % FieldSize)
			}
			
			; If we're in a union, don't change the NextFieldOffset so all union fields get overlapping offsets
			
			NextField->Offset := NextFieldOffset
			
			if (InUnion) {
				if (FieldSize > MaxUnionSize) {
					MaxUnionSize := FieldSize
				}
			}
			else {
				NextFieldOffset += FieldSize
			}
			
			TotalSize := NextFieldOffset
			
			if (InUnion && this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				InUnion := false
				NextFieldOffset += MaxUnionSize
				TotalSize := NextFieldOffset
			}
			
			; Ignore commas after fields, since they aren't needed for parsing
			this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
			
			if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				break
			}
		}
		
		NewType->Size := TotalSize
		NewType->IsStructType := true
		NewType->IsIncomplete := false
	}
	
	define void ParseBitsDefinition() {
		Token* NameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for struct name")
		
		TypeInfo* NewType := this->ParseCustomTypeName(NameToken, TYPE_BITS)
		
		HashMap* Fields := NewType~>Fields
		
		Fields->Initialize()
		
		this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_AS, "Expected 'as' before bits backing type name")
		
		ASTNode* BackingTypeNode := this->ParseTypeNode()
		Type BackingType := BackingTypeNode->ValueType
		
		TypeInfo* BackingBase := GetBaseType(BackingType)
		i32 BackingDepth := GetPointerDepth(BackingType)
		
		if (BackingBase->IsStructType || BackingDepth) {
			; Invalid types for bits backing types
			
			BackingTypeNode->Error("Bits backing type must be a plain integer type.")
		}
		
		i8 BackingTypeSize := GetTypeSize(BackingType) As i8
		i8 BackingTypeSizeBits := (BackingTypeSize * 8) As i8
		
		NewType->Size := BackingTypeSize
		
		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected opening brace for bits type body.")
		
		loop {
			StructField* NextField := Alloc(#StructField) As StructField*
			
			Token* OpenBracket := this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET, "Expected open bracket for bit field range.")
			
			i8 StartIndex := this->Consume(TOKEN_TYPE_INTEGER, "Expected integer for bit field start index.")->Value As i8
			i8 EndIndex := StartIndex
			
			if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_COLON)) {
				EndIndex := this->Consume(TOKEN_TYPE_INTEGER, "Expected integer for bit field end index.")->Value As i8
			}
			
			i8 FieldSize := EndIndex - StartIndex
			
			Token* CloseBracket := this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected close bracket for bit field range.")
			
			OpenBracket~>Context->Merge(CloseBracket~>Context)
			
			if (FieldSize < 0 || FieldSize > BackingTypeSizeBits) {
				OpenBracket->Error("Field size can not be negative, or bigger than the backing type.")
			}
			
			SafeWideString* FieldName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected bit field name.")->StringValue
			
			NextField->Name := FieldName
			NextField->Offset := BackingTypeSize
			NextField->BitStartIndex := StartIndex
			NextField->BitEndIndex := EndIndex
			
			if (FieldSize <= 8) {
				NextField->ValueType := this->i8->AsNonPointer()
			}
			else if (FieldSize <= 16) {
				NextField->ValueType := this->i16->AsNonPointer()
			}
			else if (FieldSize <= 32) {
				NextField->ValueType := this->i32->AsNonPointer()
			}
			else {
				NextField->ValueType := this->i64->AsNonPointer()
			}
			
			Fields->Set(FieldName, NextField)
			
			this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
			
			if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				break
			}
		}
	}
	
	define i8 ParseProgramStatement() {
		Token* NextToken := this->PeekNextToken()
		i8 NextTokenValue := NextToken->Value As i8
		
		if (NextToken->Is(TOKEN_TYPE_KEYWORD)) {
			this->GetNextToken()
			
			if (NextTokenValue <= KEYWORD_DLLIMPORT) {
				; Handles `dllimport`/`declare`/`define`
				this->ParseFunctionDefinition(this~>Functions, NextToken)
			}
			else if (NextTokenValue = KEYWORD_STRUCT) {
				this->ParseStructDefinition()
			}
			else if (NextTokenValue = KEYWORD_BITS) {
				this->ParseBitsDefinition()
			}
			else if (NextTokenValue = KEYWORD_LINUX || NextTokenValue = KEYWORD_WINDOWS) {
				i8 IgnoreBlock := true
				
				if (NextTokenValue = KEYWORD_LINUX && this->Config->OutputFormat = OUTPUT_ELF) {
					IgnoreBlock := false
				}
				else if (NextTokenValue = KEYWORD_WINDOWS && this->Config->OutputFormat = OUTPUT_PE) {
					IgnoreBlock := false
				}
				
				if (IgnoreBlock) {
					this->IgnoreBlock()
				}
				else {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected opening '{' for block")
					
					while !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
						this->ParseProgramStatement()
					}
				}
			}
			else {
				NextToken->Error("Unexpected token")
			}
		}
		else if (NextToken->Is(TOKEN_TYPE_IDENTIFIER)) {
			; Handles global variable declarations
			
			Token* BlameToken := this->PeekNextToken()
			
			i8* ErrorMessage := null
			ASTNode* DefaultValueExpression := this->TryParseVariableDeclaration(true, false, &ErrorMessage)
			
			if (ErrorMessage) {
				BlameToken~>Context->Merge(this->GetCurrentTokenContext())
				BlameToken->Error(ErrorMessage)
			}
			
			if (DefaultValueExpression != null) {
				; Handles global variable default value expressions
				
				i32 Index := GetArrayLength(this->GlobalDefaults)
				this->GlobalDefaults := ReAllocArray(this->GlobalDefaults, 1)
				
				this->GlobalDefaults[Index] := DefaultValueExpression
			}
		}
		else if (NextToken->Is(TOKEN_TYPE_EOF)) {
			return true
		}
		else {
			NextToken->Error("Unexpected token")
		}
		
		return false
	}
	
	define void ParseProgram() {
		; Parse an entire program, aka a list of `dllimport`/`declare`/`define`, `struct`/`bits`, and global
		;  variable declarations.
		
		loop {
			if (this->ParseProgramStatement()) {
				break
			}
		}
	}
}

define i32 ParserNextLabel(ParserState* Parser) {
	i32 Result := Parser->LabelCount
	
	Parser->LabelCount += 1
	
	return Result
}

/*
define FunctionDefine* MatchFunction(ParserState* Parser, FunctionDefine* BaseFunction, ASTNode* CallerNode) {
	CallExpression* Caller := CallerNode->CallNode
	i32 CallerParameterCount := Caller->ParameterCount
	
	FunctionDefine* Next := BaseFunction
	
	/* Running rating of the last conpatible function's "generic rating", aka how specific the parameters are (as in, i64 vs SomeStruct*) */
	i32 BestFitRating := 200000
	FunctionDefine* BestFit := 0
	
	/* TODO: Rework this to have better casting rules */
	
	loop {
		i32 NextParameterCount := Next->ParameterCount
		
		i32 ThisFunctionRating := 0
		
		i8 IS_VARIADIC := false
		
		if (Next->Attribute = OPERATOR_DOT) {
			IS_VARIADIC := true
			ThisFunctionRating := 100000
			
			NextParameterCount -= 1
		}
		
		if (NextParameterCount = CallerParameterCount || IS_VARIADIC) {
			i8 BrokeInner := false
			
			for (i32 ParameterIndex := 0, ParameterIndex < NextParameterCount, ParameterIndex += 1) {
				Type ExpectedNext := Next->Parameters[ParameterIndex]->Type
				
				ASTNode* NextNode := Parser->DowncastIntegerNode(Caller->Parameters[ParameterIndex])
				Type ActualNext := NextNode->ValueType
				
				if (CheckTypes(Parser->void, ActualNext, ExpectedNext, null)) {
					BrokeInner := true
					
					Next->TempValue := ParameterIndex
					break
				}
				
				i32 ExpectedRating := GetGenericRating(ExpectedNext)
				i32 ActualRating := GetGenericRating(ActualNext)
				
				if (ExpectedRating != ActualRating) {
					if (ActualRating > ExpectedRating) {
						ThisFunctionRating += ActualRating
					}
					else {
						ThisFunctionRating += ExpectedRating
					}
				}
			}
			
			if !(BrokeInner) {
				if (ThisFunctionRating < BestFitRating) {
					BestFitRating := ThisFunctionRating
					BestFit := Next
				}
			}
		}
		
		Next := Next->Next
		
		if !(Next) {
			break
		}
	}
	
	if (BestFit && BestFitRating < 200000) {
		return BestFit
	}
	
	ManualErrorMessagePrelude()
	
	Print("No matching overload found for:\n")
	PrettyError(CallerNode~>Context, Red | Bright)
	
	Next := BaseFunction
	
	while (Next) {
		i32 LastNonMatchingParameter := Next->TempValue
		
		if (CallerParameterCount < Next->ParameterCount) {
			Print("Is missing required parameters for overload")
		}
		else if (CallerParameterCount > Next->ParameterCount) {
			Print("Has too many paramters for overload")
		}
		else {
			Print("Parameter %i should be an ", LastNonMatchingParameter + 1)
			
			PrintType(Next->Parameters[LastNonMatchingParameter]->Type)
			
			Print(" for overload, not ")
			
			if (LastNonMatchingParameter < CallerParameterCount) {
				PrintType(Caller->Parameters[LastNonMatchingParameter]->ValueType)
			}
			else {
				Print("<none>")
			}
		}
		
		PrintNewLine()
		PrettyError(Next~>Context, Red | Bright)
		
		Next := Next->Next
	}
	
	Exit(1)
	
	return null
}

/*
==========================================
	AST Node construction helpers
==========================================
*/

define Type GetBinaryResultType(ParserState* Parser, Type LeftType, Type RightType, ErrorContext* BlameContext) {
	/* Decides the result of a binary expression with the given operand types */
	
	i8 Compatible := !CheckTypes(Parser->void, RightType, LeftType, null)
	Type BestFit := LeftType
	
	if (GetGenericRating(LeftType) < GetGenericRating(RightType)) {
		BestFit := RightType
	}
	
	TypeInfo* LeftBaseType := GetBaseType(LeftType)
	TypeInfo* RightBaseType := GetBaseType(RightType)
	
	i16 LeftDepth := GetPointerDepth(LeftType)
	i16 RightDepth := GetPointerDepth(RightType)
	
	if (Compatible) {
		return BestFit
	}
	else {
		if (LeftDepth && RightDepth) {
			; If we are dealing with two pointer types, something's wrong
			
			ManualErrorMessagePrelude()
			
			Print("Operations on the types ")
			PrintType(LeftType)
			Print(" and ")
			PrintType(RightType)
			Print(" are invalid.\n")
			
			ContextError(BlameContext, null)
		}
		else if (LeftDepth) {
			/* Eles if the left side is a pointer */
			
			if (RightBaseType->IsStructType) {
				/* And the right type is a.. struct? Then something's real funky */
				
				ContextError(BlameContext, "Invalid operation types1.")
			}
			
			/* Otherwise, right type is a normal type, so return the pointer type */
			return LeftType
		}
		else if (RightDepth) {
			/* Same as above, just in the opposite direction */
			
			if (LeftBaseType->IsStructType) {
				ContextError(BlameContext, "Invalid operation types2.")
			}
			
			return RightType
		}
		else {
			if (LeftBaseType->IsStructType || RightBaseType->IsStructType) {
				/* If both types are structs, then something even more funky is going on */
				ContextError(BlameContext, "Invalid operation types3.")
			}
			
			/* Otherwise, two normal types, just pick the bigger of the two */
			if (LeftBaseType->Size >= RightBaseType->Size) {
				return LeftType
			}
			else {
				return RightType
			}
		}
	}
	
	return LeftType
}

declare Token* ParserCurrentToken(ParserState*)
declare ASTNode** ParseParameterList(ParserState*, i8*)

define ASTNode* MakeBinary(ParserState* Parser, ASTNode* Left, Token* OperatorToken, ASTNode* Right) {
	/* Name is a bit misleading, can return a NODE_TYPE_BINARY or NODE_TYPE_STRUCT_ACCESS */
	
	i8 Operator := (OperatorToken->Value) As i8
	Type ResultType := 0
	
	Type LeftType := Left->ValueType
	Type RightType := Right->ValueType
	
	TypeInfo* LeftBaseType := GetBaseType(LeftType)
	TypeInfo* RightBaseType := GetBaseType(RightType)
	i16 LeftDepth := GetPointerDepth(LeftType)
	i16 RightDepth := GetPointerDepth(RightType)
	i16 LeftSize := GetTypeSize(LeftType)
	i16 RightSize := GetTypeSize(RightType)
	
	i8 ALLOW_INTEGER_DOWNCAST := true
	
	if (Operator = OPERATOR_AS) {
		/* OPERATOR_AS does nothing, just switches the result type of the expression */
		
		ResultType := RightType
	}
	else if (Operator = OPERATOR_LESS_LESS || Operator = OPERATOR_GREATER_GREATER) {
		Parser->DowncastIntegerNode(Right)
		
		CheckTypes(Parser->void, Right->ValueType, MakeType(Parser->i8, 0), Right)
		
		if (LeftSize < 4) {
			ResultType := MakeType(Parser->i32, 0)
		}
		else {
			ResultType := LeftType
		}
	}
	else if (Operator = OPERATOR_DOT || Operator = OPERATOR_MINUS_GREATER || Operator = OPERATOR_TILDE_GREATER) {
		/* OPERATOR_DOT and OPERATOR_MINUS_GREATER are both struct accesses */
		
		if !(LeftBaseType->IsStructType || (LeftBaseType->IsBits && Operator = OPERATOR_DOT)) {
			/* Ensure the left type is a struct, otherwise something like 1.Abc is going on */
			
			TypeError(Left, TYPE_NONE, "Invalid left side operand type")
		}
		else if (LeftBaseType->IsIncomplete) {
			/* Ensure the left type is not incomplete (otherwise we don't know what the result type would be) */
			Left->Error("Fields of incomplete structs cannot be accessed.")
		}
		else if (LeftDepth != 0 && Operator = OPERATOR_DOT) {
			OperatorToken->Error("Struct pointer fields can only be accessed with the '->'/'~>' operators.")
		}
		else {
			; Look up a field with a name given by the right side's string value
			SafeWideString* FieldName := Right->StringValue
			
			HashMapElement* TargetElement := LeftBaseType~>Fields->Get(FieldName)
			
			if (TargetElement) {
				; If we found a field with the correct name, create a `StructAccessExpression` for this expression
				
				StructField* TargetField := (TargetElement->Value) As StructField*
				
				StructAccessExpression* NewAccess := Alloc(#StructAccessExpression) As StructAccessExpression*
				
				NewAccess->Left := Left
				NewAccess->Operator := OperatorToken
				NewAccess->TargetField := TargetField
				
				ResultType := TargetField->ValueType
				
				if (Operator = OPERATOR_TILDE_GREATER && !ResultType.IsArray) {
					ResultType := Parser->PointerToType(ResultType)
				}
				
				/* Wrap it in a NODE_TYPE_STRUCT_ACCESS and return */
				
				ASTNode* StructNode := ASTNode:New(NODE_TYPE_STRUCT_ACCESS, NewAccess, ResultType)
				
				MergeContexts(Left~>Context, Right~>Context, StructNode~>Context)
				
				return StructNode
			}
			else {
				/* If we didn't find a field with that name, then error out */
				
				Right->Error("Unknown struct field")
			}
		}
	}
	else if (OPERATOR_FIRST_ASSIGNMENT <= Operator && Operator <= OPERATOR_LAST_ASSIGNMENT) {
		/* If this is an assignment do some extra type checking */
		
		if (Left->NodeType = NODE_TYPE_VARIABLE && Left->VariableValue->IsThis) {
			Left->Error("'this' can't be assigned")
		}
		
		if (LeftDepth != 0 && LeftBaseType->IsStructType && RightDepth && RightSize = 8) {
			/* If the LeftType is a struct pointer, and the right is a pointer of any type, the result is just struct-pointer type */
			
			/* This allows for stuff like `MyStruct* Test := Alloc(#MyStruct)` without ugly casting */
			
			ResultType := LeftType
		}
		else if (LeftDepth = 0 && LeftBaseType->IsStructType) {
			/* Else if the left is a literal struct type, error out */
			
			Left->Error("Local structs can't be assigned")
		}
		else if !(Left->IsStorageValue) {
			Left->Error("Left side of assignment operator must be a storage value")
		}
		else if (Left->NodeType = NODE_TYPE_UNARY) {
			; Only true for `*X := Y`, result type is whatever `*X` would be. And thanks to
			;  `*X` being parsed like normal, LeftType is already correct
			
			ResultType := LeftType
		}
		else {
			/* Otherwise, the result type is the right type */
			ResultType := LeftType
		}
	}
	else if (Operator = OPERATOR_OPEN_BRACKET) {
		/* For an array access, make sure the index type isn't a pointer/struct */
		
		if (RightDepth != 0 || RightBaseType->IsStructType) {
			Right->Error("Right side operand of '[' must not be a pointer or struct type.")
		}
		else {
			/* DecrementPointerType will ensure that LeftType is a pointer type, so we don't need to */
			
			CopyContext(ParserCurrentToken(Parser)~>Context, Right~>Context)
			
			ResultType := Parser->DereferencePointerType(LeftType, Right~>Context)
		}
	}
	else if (OPERATOR_FIRST_COMPARISON <= Operator && Operator <= OPERATOR_LAST_COMPARISON) {
		ResultType := MakeType(Parser->i8, 0)
		
		ALLOW_INTEGER_DOWNCAST := false
	}
	else {
		/* Otherwise, just follow standard binary typing rules */
		
		MergeContexts(Left~>Context, Right~>Context, OperatorToken~>Context)
		
		ResultType := GetBinaryResultType(Parser, LeftType, RightType, OperatorToken~>Context)
		
		if (Operator = OPERATOR_LOGICAL_AND || Operator = OPERATOR_LOGICAL_OR) {
			/* For && and ||, GetBinaryResultType is only called for the error messages, and the actual result type is a byte */
			ResultType := MakeType(Parser->i8, 0)
		}
	}
	
	/* If the left or right operands are integers, just elevate them to the ResultType to ensure a compile-time cast (instead of a runtime cast) */
	
	if (ALLOW_INTEGER_DOWNCAST) {
		if (Left->NodeType = NODE_TYPE_INTEGER) {
			Left->ValueType := ResultType
		}
		if (Right->NodeType = NODE_TYPE_INTEGER) {
			Right->ValueType := ResultType
		}
	}
	
	/* Allocate a result node */
	
	BinaryExpression* Result := Alloc(#BinaryExpression) As BinaryExpression*
	
	/* Populate the node */
	
	Result->Left := Left
	Result->Operator := OperatorToken
	Result->Right := Right
	
	/* Wrap it, and return it */
	ASTNode* ResultNode := ASTNode:New(NODE_TYPE_BINARY, Result, ResultType)
	MergeContexts(Left~>Context, Right~>Context, ResultNode~>Context)
	
	return ResultNode
}
define ASTNode* MakeUnary(ParserState* Parser, Token* OperatorToken, ASTNode* Operand) {
	/* Builds a NODE_TYPE_UNARY for the given operand/operator combo */
	
	UnaryExpression* Result := Alloc(#UnaryExpression) As UnaryExpression*
	
	/* Get the  */
	Type ResultType := Operand->ValueType
	i8 Operator := (OperatorToken->Value) As i8
	
	Result->Operator := OperatorToken
	Result->Operand := Operand
	
	if (Operator = OPERATOR_BANG) {
		ResultType := MakeType(Parser->i8, 0)
	}
	else if (Operator = OPERATOR_AND) {	
		if !(Operand->IsStorageValue || Operand->NodeType = NODE_TYPE_DEFINE) {
			OperatorToken->Error("Operand of the '&' operator must be a storage value.")
		}
		
		ResultType := Parser->PointerToType(ResultType)
	}
	else if (Operator = OPERATOR_STAR) {
		ResultType := Parser->DereferencePointerType(ResultType, Operand~>Context)
	}
	
	ASTNode* ResultNode := ASTNode:New(NODE_TYPE_UNARY, Result, ResultType)
	MergeContexts(OperatorToken~>Context, Operand~>Context, ResultNode~>Context)
	
	return ResultNode
}

declare i32 FreezeParser(ParserState*)
declare void UnfreezeParser(ParserState*, i32)
declare Token* ParserNextToken(ParserState*)

define ASTNode* AllocateCall(ParserState* Parser, Token* NameToken, ASTNode** Parameters, i32 ParameterCount) {
	UnfreezeParser(Parser, FreezeParser(Parser) - 1) /* Manually backtrack and consume the closing ')' for this call */
	Token* CloseParen := ParserNextToken(Parser)
	
	CallExpression* Result := Alloc(#CallExpression) As CallExpression*
	Result->Parameters := Parameters
	Result->ParameterCount := ParameterCount
	
	/* Wrap the CallExpression with a NODE_TYPE_CALL for any errors */
	ASTNode* ResultNode := ASTNode:New(NODE_TYPE_CALL, Result, TYPE_NONE)
	MergeContexts(NameToken~>Context, CloseParen~>Context, ResultNode~>Context)
	
	return ResultNode
}

define ASTNode* MakeBuiltinCall(ParserState* Parser, Token* NameToken, ASTNode** Parameters, i32 ParameterCount) {
	ASTNode* ResultNode := AllocateCall(Parser, NameToken, Parameters, ParameterCount)
	CallExpression* Result := ResultNode->CallNode
	
	SafeWideString* Name := NameToken->StringValue
	
	if (SafeStringEqualsAString(Name, "syscall")) {
		Result->BuiltinID := BUILTIN_SYSCALL
		ResultNode->ValueType := MakeType(Parser->i64, 0)
		
		if (Parser->Config->OutputFormat = OUTPUT_PE) {
			ResultNode->Warn("Windows syscall numbers change near-constantly, using the native API is a bad idea.")
		}
	}
	else if (SafeStringEqualsAString(Name, "breakpoint") && ParameterCount = 0) {
		Result->BuiltinID := BUILTIN_BREAKPOINT
		ResultNode->ValueType := MakeType(Parser->i8, 0)
	}
	else {
		NameToken->Error("Builtin function not found.")
	}

	return ResultNode
}

define ASTNode* MakeCall(ParserState* Parser, HashMap* NameSpace, Token* NameToken, ASTNode** Parameters, i32 ParameterCount) {
	ASTNode* ResultNode := AllocateCall(Parser, NameToken, Parameters, ParameterCount)
	CallExpression* Result := ResultNode->CallNode
	
	SafeWideString* Name := NameToken->StringValue
	
	HashMapElement* FoundFunction := NameSpace->Get(Name)
	
	if !(FoundFunction) {
		/* And if the function was not found, then error out */
		
		NameToken->Error("Function definition not found.")
	}
	
	/* Otherwise, convert the HashMapElement* into a FunctionDefine* */
	FunctionDefine* FoundDefine := (FoundFunction->Value) As FunctionDefine*
	
	/* And walk the FunctionDefine* linked list, looking for an overload which matches our parameters */
	FoundDefine := MatchFunction(Parser, FoundDefine, ResultNode)
	
	Result->TargetFunction := FoundDefine
	ResultNode->ValueType := FoundDefine->ReturnType
	
	return ResultNode
}

/*
==========================================
	Parser + token helpers
==========================================
*/

/*
==========================================
	Actual parser + some helpers
==========================================
*/

define ParserState* ParserStart(BuildConfig* Config, LexerState* Lexer) {
	/* Initializes Parser and uses Lexer to parse a program */
	
	ParserState* Parser := ParserState:New(Config, Lexer)
	
	SetupAssembly(Parser)
	
	ParseProgram(Parser)
	
	return Parser
}

declare FunctionDefine* ParseFunction(ParserState*, HashMap*, i8)
declare FunctionDefine* ParseFunction(ParserState*, HashMap*, i8, TypeInfo*)
declare void ParseAndAddStruct(ParserState*)
declare void ParseAndAddBits(ParserState*)
declare ASTNode* ParseExpression(ParserState*, i8)
declare void ConsumeAndIgnoreBlock(ParserState*)

define void ParseProgram(ParserState* Parser) {
	/* Parse a whole program */
	
	loop {
		i32 FrozenState := FreezeParser(Parser)
		Token* NextToken := ParserNextToken(Parser)
		i8 NextType := NextToken->Type
		
		if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_DEFINE)) {
			ParseFunction(Parser, Parser~>Functions, KEYWORD_DEFINE)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_DECLARE)) {
			ParseFunction(Parser, Parser~>Functions, KEYWORD_DECLARE)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_DLLIMPORT)) {
			ParseFunction(Parser, Parser~>Functions, KEYWORD_DLLIMPORT)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_STRUCT)) {
			ParseAndAddStruct(Parser)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_BITS)) {
			ParseAndAddBits(Parser)
		}
		;else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_WINDOWS) || TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_LINUX)) {
		;	i8 TargetFormat := OUTPUT_PE
		;	
		;	if (NextToken->Value = KEYWORD_LINUX) {
		;		TargetFormat := OUTPUT_ELF
		;	}
		;	
		;	if (Parser->Config->OutputFormat = TargetFormat) {
		;		Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace.")
		;		ParseProgram(Parser)
		;		Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected close brace.")
		;	}
		;	else {
		;		ConsumeAndIgnoreBlock(Parser)
		;	}
		;}
		else if (NextType = TOKEN_TYPE_IDENTIFIER) {
			/* If the next token isn't an identifier, then it's definitely not a declaration */
			
			UnfreezeParser(Parser, FrozenState)
			
			i8* ErrorMessage := 0
			
			Type PotentialType := TryParseTypeName(Parser, true, &ErrorMessage)
			
			if ((PotentialType != 0) && (ErrorMessage = 0)) {
				/* Holds the parser state right after `Type` would have been parsed, so `PotentialType := ParseTypeName(Parser)` can still be parsed as well */
				i32 DefaultValueExpressionStart := FreezeParser(Parser)
				Token* PotentialName := ParserNextToken(Parser)
				
				if (TokenMatches(PotentialName, TOKEN_TYPE_IDENTIFIER, 0)) {
					/* If we parsed a type name, and then found another identifier after the type name, this is a declaration */

					/* This can be wrong if you had `A * B` alone on a line, but what kind of dumbass would do that? */
					SafeWideString* NameString := PotentialName->StringValue
					
					VariableInfo* NewGlobal := Alloc(#VariableInfo)
					
					NewGlobal->Name := NameString
					NewGlobal->Type := PotentialType
					NewGlobal->IsGlobal := True
					NewGlobal->IsParameter := False
					
					ParserAddGlobal(Parser, NewGlobal, PotentialName)
					
					if (ParserNextMatches(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
						UnfreezeParser(Parser, DefaultValueExpressionStart)
						
						i32 Index := GetArrayLength(Parser->GlobalDefaults)
						
						Parser->GlobalDefaults := ReAllocArray(Parser->GlobalDefaults, 1)
						
						(Parser->GlobalDefaults)[Index] := ParseExpression(Parser, 0)
					}
				}
			}
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_EOF, TOKEN_TYPE_EOF)) {
			break
		}
		else {
			NextToken->Error("Unexpected token")
		}
	}
}

define void ParseAndAddStruct(ParserState* Parser) {
	/* Parses a struct type, and adds it to Parser */
	
	/* Gets the type name */
	Token* NameToken := Consume(Parser, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE, "Expected identifier for struct name")
	SafeWideString* Name := NameToken->StringValue
	
	/* Check if there's already a type with this name */
	HashMapElement* FoundElement := Parser~>Types->Get(Name)
	TypeInfo* NewType := 0
	
	if (FoundElement) {
		/* If we did find a type, then this is either: the definition of an incomplete type, or a duplicate definition */
		
		NewType := (FoundElement->Value) As TypeInfo*
		
		if !(NewType->IsIncomplete) {
			/* If the type we found isn't incomplete, then error out */
			
			NameToken->Error("Duplicate struct definition")
		}
		
		NewType->IsIncomplete := false
	}
	else {
		/* Otherwise, just add the new type as an entirely new type, which is a struct and not incomplete */
		NewType := Parser->AddType(Name, 0, TYPE_STRUCT)
	}
	
	HashMap* Fields := NewType~>Fields
	HashMap* Methods := NewType~>Methods
	HashMap* StaticMethods := NewType~>StaticMethods
	
	Fields->Initialize()
	Methods->Initialize()
	StaticMethods->Initialize()
	
	i8 IsUnaligned := ParserNextMatches(Parser, TOKEN_TYPE_KEYWORD, KEYWORD_UNALIGNED)
	
	/* Consumes the opening '{' */
	Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for struct body")
	
	i16 NextFieldOffset := 0
	i16 TotalSize := 0
	i8 InUnion := false
	i16 MaxUnionSize := 0
	
	loop {
		/* Allocate a StructField for the next field */
		StructField* NextField := Alloc(#StructField) As StructField*
		
		if !(InUnion) {
			if (ParserNextMatches(Parser, TOKEN_TYPE_KEYWORD, KEYWORD_UNION)) {
				Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for union body.")
				
				InUnion := true
			}
			else {
				i8 IsStaticMethod := ParserNextMatches(Parser, TOKEN_TYPE_KEYWORD, KEYWORD_STATIC)
				i8 IsMethod := IsStaticMethod || (ParserNextMatches(Parser, TOKEN_TYPE_KEYWORD, KEYWORD_DEFINE) || ParserNextMatches(Parser, TOKEN_TYPE_KEYWORD, KEYWORD_DECLARE))
				
				if (IsMethod) {
					HashMap* MethodNamespace := Methods
					TypeInfo* ThisType := NewType
					
					if (IsStaticMethod) {
						; Static methods take no `this` parameter, so we need to make that `ThisType`
						;  isn't present to prevent `ParseFunction` from automatically adding
						;   the `this` parameter
						
						MethodNamespace := StaticMethods
						ThisType := null
					}
					
					i8 ParseMode := ParserCurrentToken(Parser)->Value As i8
					FunctionDefine* Method := ParseFunction(Parser, MethodNamespace, ParseMode, ThisType)
					
					; `FUNCTION_IS_METHOD` when `IsStaticMethod` is false, and
					;  `FUNCTION_IS_STATIC_METHOD` when `IsStaticMethod` is true
					Method->IsMethod := true + IsStaticMethod
					Method->MethodOfTypeName := Name
					
					; Ignore commas after methods, they aren't actually needed for parsing
					ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
					
					if (ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
						break
					}
					
					continue
				}
			}
		}
		
		/* Parse the type of the field */
		i8* ErrorMessage := 0
		NextField->ValueType := TryParseTypeName(Parser, true, &ErrorMessage)
		
		if (ErrorMessage) {
			ParserCurrentToken(Parser)->Error(ErrorMessage)
		}
		
		/* Get the name of the field */
		Token* FieldNameToken := Consume(Parser, TOKEN_TYPE_IDENTIFIER, 0, "Expected identifier for struct field name")
		SafeWideString* FieldName := (FieldNameToken->Value) As SafeWideString*
		NextField->Name := FieldName
		
		if (Fields->Get(FieldName)) {
			FieldNameToken->Error("Duplicate definition")
		}
		
		Fields->Set(FieldName, NextField)
		
		i16 FieldSize := GetTypeStorageSize(NextField->ValueType)
		
		if (GetPointerDepth(NextField->ValueType) = 0 && GetBaseType(NextField->ValueType)->IsStructType) {
			/* Dummy branch */
		}
		else if (InUnion || IsUnaligned) {
			/* Dummy branch */
		}
		else if (NextField->ValueType.IsArray) {
			/* Dummy branch */
		}
		else if (NextFieldOffset % FieldSize) {
			/* Pad the field to a multiple of its size */
			NextFieldOffset += FieldSize - (NextFieldOffset % FieldSize)
		}
		/* If we're in a union, don't change the NextFieldOffset so all union fields get overlapping offsets */
		
		NextField->Offset := NextFieldOffset
		
		if (InUnion) {
			if (FieldSize > MaxUnionSize) {
				MaxUnionSize := FieldSize
			}
		}
		else {
			NextFieldOffset += FieldSize
		}
		
		TotalSize := NextFieldOffset
		
		if (InUnion && ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
			InUnion := false
			NextFieldOffset += MaxUnionSize
			TotalSize := NextFieldOffset
		}
		
		; Ignore commas after fields, since they aren't needed for parsing
		ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
		
		if (ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
			break
		}
	}
	
	NewType->Size := TotalSize
	NewType->IsStructType := true
	NewType->IsIncomplete := false
}

define void ParseAndAddBits(ParserState* Parser) {
	Token* NameToken := Consume(Parser, TOKEN_TYPE_IDENTIFIER, 0, "Expected name for bits type.")
	SafeWideString* BitsName := NameToken->Value As SafeWideString*
	
	Consume(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_AS, "Expected 'as' before bits backing type name")
	
	i32 BeforeType := FreezeParser(Parser)
	Type BackingType := ParseTypeName(Parser)
	
	TypeInfo* BackingBase := GetBaseType(BackingType)
	i32 BackingDepth := GetPointerDepth(BackingType) As i32
	
	if (BackingBase->IsStructType || BackingDepth) {
		/* In this case, the error is caused by a Type, which doesn't hold an ErrorContext
			So by getting the first+last token of the Type, we can just merge them and use them for the error context.
		*/
		
		Token* LastTypeToken := ParserCurrentToken(Parser)
		
		UnfreezeParser(Parser, BeforeType)
		
		Token* FirstTypeToken := ParserNextToken(Parser)
		
		MergeContexts(FirstTypeToken~>Context, LastTypeToken~>Context, FirstTypeToken~>Context)
		
		FirstTypeToken->Error("Bits backing type must be a plain integer type.")
	}
	
	i8 BackingTypeSize := GetTypeSize(BackingType) As i8
	i8 BackingTypeSizeBits := BackingTypeSize * 8
	
	/* Check if there's already a type with this name */
	HashMapElement* FoundElement := Parser~>Types->Get(BitsName)
	TypeInfo* NewType := 0
	
	if (FoundElement) {
		/* If we did find a type, then this is either: the definition of an incomplete type, or a duplicate definition */
		
		NewType := (FoundElement->Value) As TypeInfo*
		
		if !(NewType->IsIncomplete) {
			/* If the type we found isn't incomplete, then error out */
			
			NameToken->Error("Duplicate type definition")
		}
		
		NewType->Size := BackingTypeSize
		NewType->IsStructType := false
		NewType->IsBits := true
		NewType->IsIncomplete := false /* And set that it is no longer incomplete */
	}
	else {
		/* Otherwise, just add the new type as an entirely new type, which is a struct and not incomplete */
		NewType := Parser->AddType(BitsName, BackingTypeSize, TYPE_BITS)
	}
	
	/* Initialize a hashmap for the bit fields */
	HashMap* Fields := NewType~>Fields
	Fields->Initialize()
	
	/* Stores where the next field will be */
	i16 NextFieldOffset := 0
	
	/* Stores the total size of the bits (in bits, obviously) */
	i16 TotalSize := 0
	
	Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected opening brace for bits type body.")
	
	loop {
		StructField* NextField := Alloc(#StructField) As StructField*
		
		Token* OpenBracket := Consume(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET, "Expected open bracket for bit field range.")
		
		i8 StartIndex := Consume(Parser, TOKEN_TYPE_INTEGER, 0, "Expected integer for bit field start index.")->Value As i8
		i8 EndIndex := StartIndex
		
		if (ParserNextMatches(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_COLON)) {
			EndIndex := Consume(Parser, TOKEN_TYPE_INTEGER, 0, "Expected integer for bit field end index.")->Value As i8
		}
		
		i8 FieldSize := EndIndex - StartIndex
		
		Token* CloseBracket := Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected close bracket for bit field range.")
		
		MergeContexts(OpenBracket~>Context, CloseBracket~>Context, OpenBracket~>Context)
		
		if (FieldSize < 0 || FieldSize > BackingTypeSizeBits) {
			OpenBracket->Error("Field size can not be negative, or bigger than the backing type.")
		}
		
		SafeWideString* FieldName := Consume(Parser, TOKEN_TYPE_IDENTIFIER, 0, "Expected bit field name.")->Value
		
		NextField->Name := FieldName
		NextField->Offset := BackingTypeSize
		NextField->BitStartIndex := StartIndex
		NextField->BitEndIndex := EndIndex
		
		if (FieldSize <= 8) {
			NextField->ValueType := MakeType(Parser->i8, 0)
		}
		else if (FieldSize <= 16) {
			NextField->ValueType := MakeType(Parser->i16, 0)
		}
		else if (FieldSize <= 32) {
			NextField->ValueType := MakeType(Parser->i32, 0)
		}
		else {
			NextField->ValueType := MakeType(Parser->i64, 0)
		}
		
		Fields->Set(FieldName, NextField)
		
		if !(ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
			/* If the next token is not a ',' break the loop */
			break
		}
	}
	
	Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing brace for bits body.")
}

declare ASTNode* ParseStatement(ParserState*)

define void ConsumeAndIgnoreBlock(ParserState* Parser) {
	/* Used for linux/windows statements to ignore code for the opposite OS.
		This allows for syntax errors inside of !ThisOS code, but that doesn't really matter.
	*/
	
	Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open '{' for block.")
	
	i32 Depth := 1
	
	loop {
		Token* Next := ParserNextToken(Parser)
		
		if (TokenMatches(Next, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
			Depth -= 1
		}
		else if (TokenMatches(Next, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
			Depth += 1
		}
		
		if (Depth = 0) {
			break
		}
	}
}

define Block* ParseBlock(ParserState* Parser) {
	/* Parses and builds a block of statements */
	
	/* Consume the { */
	Token* OpenBrace := Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace in block")
	
	/* Set up a buffer for the statements */
	i16 StatementBufferSize := 8
	ASTNode** Statements := Alloc(StatementBufferSize * 8) As ASTNode**
	i16 StatementCount := 0
	i8 HasHadUnconditionalReturn := false
	
	i32 Depth := 1
	
	if !(ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {		
		loop {
			/* Loop until NextMatches('}') */
			
			if (StatementCount * 8 <= StatementBufferSize) {
				/* If the buffer needs to be expanded, expand it */
				
				Statements := ReAlloc(Statements As void*, (StatementCount + 10) * 8) As ASTNode**
				StatementBufferSize += (10 * 8)
			}
			
			/* Parse a statement and put it into the statement list */
			
			i32 Start := FreezeParser(Parser)
			
			Token* NextToken := ParserNextToken(Parser)
			
			/* Handle `linux {` and `windows {` by ignoring both keywords, and conditionally ignoring the blocks following them */
			if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_LINUX)) {
				if (Parser->Config->OutputFormat = OUTPUT_ELF) {
					Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace.")
					Depth += 1
				}
				else {
					ConsumeAndIgnoreBlock(Parser)
				}
			}
			else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_WINDOWS)) {
				if (Parser->Config->OutputFormat = OUTPUT_PE) {
					Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace.")
					Depth += 1
				}
				else {
					ConsumeAndIgnoreBlock(Parser)
				}
			}
			else {
				UnfreezeParser(Parser, Start)
				
				ASTNode* NextStatement := ParseStatement(Parser)
				
				Statements[StatementCount] := NextStatement
				
				if (NextStatement->NodeType = NODE_TYPE_RETURN) {
					HasHadUnconditionalReturn := true
				}
				else if (NextStatement->NodeType = NODE_TYPE_IF) {
					IfGroup* NextIf := NextStatement->IfNode
					i8 AllBranchesHaveReturn := true
					
					for (i32 BranchIndex := 0, BranchIndex < NextIf->BranchCount, BranchIndex += 1) {
						AllBranchesHaveReturn &= NextIf->Bodies[BranchIndex]->HasUnconditionalReturn
					}
					
					if (NextIf->ElseBranch && AllBranchesHaveReturn) {
						HasHadUnconditionalReturn |= NextIf->ElseBranch->HasUnconditionalReturn
					}
				}
				
				StatementCount += 1
			}
			
			if (ParserNextMatches(Parser, TOKEN_TYPE_EOF, 0)) {
				OpenBrace->Error("Expected close brace for block")
			}
			
			i8 BreakOuter := false
			
			while (ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				/* Only break the outer loop once all opening `{` for this block have been matched with a closing `}` */
				
				Depth -= 1
				
				BreakOuter := Depth = 0
				
				if (BreakOuter) {
					break
				}
			}
			
			if (BreakOuter) {
				break
			}
		}
	}
	
	/* Allocate a block structure and populate it with the statement list/count */
	Block* NewBlock := Alloc(#Block) As Block*
	NewBlock->Statements := Statements
	NewBlock->StatementCount := StatementCount
	NewBlock->HasUnconditionalReturn := HasHadUnconditionalReturn
	
	return NewBlock
}

declare ASTNode* ParseAssembly(ParserState*, i8)

define VariableInfo* MakeMagicLocal(i8* Name, TypeInfo* BaseType, i8 IsParameter) {
	/* Note: All of this is technically a memory leak, but that doesn't really matter */
	
	SafeWideString* LocalName := AToS(Name)
	
	VariableInfo* ThisMagic := Alloc(#VariableInfo)
	ThisMagic->Name := LocalName
	ThisMagic->Type := MakeType(BaseType, 1)	/* TypeOf(Magic) = PointerTo(MagicStructType) */
	ThisMagic->IsParameter := IsParameter
	ThisMagic->IsThis := true
	
	return ThisMagic
}

define FunctionDefine* ParseFunction(ParserState* Parser, HashMap* Namespace, i8 Mode, TypeInfo* ThisType) {
	/* Parses:
		 Define statements
		 Declare statements
		 DllImport statements
		Since (Define|Declare|DllImport) all have ~4 tokens in common, along with a (mostly) common list of parameters
	*/
	
	Token* StartToken := ParserCurrentToken(Parser)
	
	i8 ForStatic := Mode = KEYWORD_STATIC
	i8 ForDefine := Mode = KEYWORD_DEFINE || ForStatic
	i8 ForImport := Mode = KEYWORD_DLLIMPORT
	
	Type ReturnType := ParseTypeName(Parser)
	
	Token* NameToken := Consume(Parser, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE, "Function names must be identifiers")
	SafeWideString* Name := NameToken->StringValue
	
	/* Set up a buffer for parameters */
	i8 ParameterCount := 0
	VariableInfo** ParameterList := Alloc(16 * #VariableInfo) As VariableInfo**
	
	i8 Attribute := 0
	
	HashMap* Locals := null
	
	if (ForDefine) {
		/* For define statements, the parameters are added as locals, so Parser->CurrentFunction needs to be set so
			calling `ParserAddLocal` inside of the parameter list parsing loop won't crash.
			`Locals` is copied onto the actual `FunctionDefine*` for this function after the parameters have been
			parsed, and the matching overload has been found (if it exists)
		*/
		
		FunctionDefine TempDefine
		
		TempDefine~>Locals->Initialize()
		
		Parser->CurrentFunction := &TempDefine
	}
	
	if (ThisType != 0) {
		/* If we are defining a method, then we need to build the `this` parameter, and set it to the first parameters */
		
		VariableInfo* ThisParameter := MakeMagicLocal("this", ThisType, true)
		
		if (ForDefine) {
			/* Only actually add `this` as a local when we are defining a full function, and have Parser->CurrentFunction set */
			
			Token* MagicBlameToken := ParserCurrentToken(Parser)
			
			ParserAddLocal(Parser, ThisParameter, MagicBlameToken)
		}
		
		ParameterList[0] := ThisParameter
		ParameterCount += 1
	}
	
	/* Consume the parameter list opening '(' */
	Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Function parameter lists must start with (")
	
	if !(ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
		/* If the next token isn't a ')', then parse the parameters (otherwise the function takes 0 parameters) */
		
		loop {
			/* Allocate a VariableInfo struct for the next parameter */
			VariableInfo* NextParameter := Alloc(#VariableInfo)
			
			/* Max parameter count since I cba to expand the buffer. Todo: Fix this */
			if (ParameterCount >= 16) {
				ParserNextToken(Parser)->Error("Max parameter limit reached")
			}
			
			/* Insert the VariableInfo structure into the parameter list */
			ParameterList[ParameterCount] := NextParameter
			
			if (ParserNextMatches(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
				Token* Start := ParserCurrentToken(Parser)
				
				Consume(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected '.' for variadic marker")
				Consume(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected '.' for variadic marker")
				
				MergeContexts(Start~>Context, ParserCurrentToken(Parser)~>Context, Start~>Context)
				
				if (ParameterCount > 4) {
					Start->Error("Only 4 regular paremeters can be passed with a variable argument.")
				}
				
				Attribute := OPERATOR_DOT
				NextParameter->Type := MakeType(Parser->void, 1)
				
				if (ForDefine) {
					Token* VariadicName := Consume(Parser, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE, "Parameter names must be identifiers")
					NextParameter->Name := VariadicName->StringValue
					ParserAddLocal(Parser, NextParameter, VariadicName)
				}
				
				NextParameter->IsVariadic := true
				NextParameter->IsParameter := true
				NextParameter->StackOffset := (ParameterCount * 8)
				
				ParameterCount += 1
				
				break
			}
			
			/* Parse the parameter type */
			
			NextParameter->Type := ParseTypeName(Parser)
			
			if (ForDefine) {
				/* Get the parameter name */
				Token* NextParameterNameToken := Consume(Parser, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE, "Parameter names must be identifiers")
				NextParameter->Name := NextParameterNameToken->StringValue
				ParserAddLocal(Parser, NextParameter, NextParameterNameToken)
			}
			
			NextParameter->IsGlobal := false
			NextParameter->IsParameter := true
			NextParameter->StackOffset := (ParameterCount * 8)
			
			/* Update the parameter count */
			ParameterCount += 1
			
			if !(ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
				/* If the next token isn't a comma, then break the loop, otherwise consume the command and continue */
				break
			}
		}
		
		/* If the loop was broken by any token besides a ')', then there's something wrong */
		
		if !(ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
			ParserNextToken(Parser)->Error("Expected closing paren for parameter list")
		}
	}
	
	HashMapElement* FoundFunctionElement := Namespace->Get(Name)
	
	FunctionDefine* FoundFunction := 0
	FunctionDefine* NewDefine := 0
	i8 ActuallyFound := false
	
	if (FoundFunctionElement) {
		/* If this function already has at least one definition */
		
		FoundFunction := (FoundFunctionElement->Value) As FunctionDefine*
		
		while (FoundFunction) {
			/* Loop through all definitions, and find any which match the type signature of this definition */
			
			if (FoundFunction->ParameterCount = ParameterCount) {
				if (CheckTypeSignature(FoundFunction, ParameterList)) {
					ActuallyFound := true
					break
				}
			}
			
			if !(FoundFunction->Next) {
				break
			}
			
			/* Or, find the last definition for the function (which we append this definition onto) */
			FoundFunction := FoundFunction->Next
		}
		
		if (ActuallyFound && FoundFunction->HasFullDefinition) {
			/* If we found a definition matching the type signature, and it already has a body, then this is a duplicate definition */
			
			NameToken->Error("Duplicate function definition")
		}
	}
	
	if (ActuallyFound) {
		/* If we found `declare %Name%(Exact same type signature as this definition)`, use `FoundFunction` for this definition instead of making a new `FunctionDefine` */
		
		NewDefine := FoundFunction
	}
	else {
		/* In this case, we can't reuse an existing `FunctionDefine`, so we need to allocate a new one */
		
		NewDefine := Alloc(#FunctionDefine) As FunctionDefine*
		
		if (FoundFunction) {
			/* However, if we did find a previous definition for this function, then we need to insert `NewDefine` into the linked list of this function's overloads			*/
			
			NewDefine->Next := FoundFunction->Next
			FoundFunction->Next := NewDefine
		}
		else {
			/* If this is the very first definition for this function, it needs to be inserted into the function hashmap */
			
			Namespace->Set(Name, NewDefine)
		}
		
		NewDefine->LabelNumber := ParserNextLabel(Parser)
	}
	
	/* Copy info parsed from the first part of this function into `NewDefine`, which is 100% correctly set by now */
	
	/* `(define|declare|dllimport) name(params)` will all get captured into `NewDefine~>Context`, which displays nicely */
	MergeContexts(StartToken~>Context, ParserCurrentToken(Parser)~>Context, NewDefine~>Context)
	NewDefine->Name := Name
	NewDefine->ReturnType := ReturnType
	NewDefine->Attribute := Attribute
	
	if (ForDefine) {
		/* If we are parsing a `define` statement, we need to copy the locals hashmap which already contains the parameters, along with size of the stack space needed for locals */
		
		MoveMemory(NewDefine~>Locals As i8*, TempDefine~>Locals As i8*, #VariableHashMap)
	}
	
	NewDefine->Parameters := ParameterList
	NewDefine->ParameterCount := ParameterCount
	
	if (ForImport) {
		Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Import source must have a prior '{'.")
		
		SafeWideString* FileName := Consume(Parser, TOKEN_TYPE_IDENTIFIER, 0, "Import source file name expected")->Value
		
		if (ParserNextMatches(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
			Consume(Parser, TOKEN_TYPE_IDENTIFIER, 0, "Import source file extension expected")
		}
		
		Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA, "Comma expected between import source file and function names")
		
		SafeWideString* FunctionName := Consume(Parser, TOKEN_TYPE_IDENTIFIER, 0, "Import source function name expected")->Value
		
		Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}'.")
		
		NewDefine->IsImported := true
		NewDefine->ImportFileName := FileName
		NewDefine->ImportFunctionName := FunctionName
	}
	
	/* Assume any function only has a partial definition */
	NewDefine->HasFullDefinition := false
	
	if (ForDefine) {
		Parser->CurrentFunction := NewDefine
		
		if (ParserNextMatches(Parser, TOKEN_TYPE_KEYWORD, KEYWORD_ASSEMBLY)) {
			NewDefine->Attribute := KEYWORD_ASSEMBLY
			
			NewDefine->AssemblyBody := ParseAssembly(Parser, false)->AssemblyValue
		}
		else {
			if (ParserNextMatches(Parser, TOKEN_TYPE_KEYWORD, KEYWORD_X64)) {
				NewDefine->Attribute := KEYWORD_X64
			}
			
			if (Parser->Config->DebugMode & DEBUG_EMIT_FUNCTION_NAMES) {
				i32 Length := Name->Length + 1
				
				if (ThisType != null) {
					Length += ThisType->Name->Length + 1
				}
				
				i8* StringBuffer := Alloc(Length) As i8*
				i8* NameBuffer := StringBuffer
				
				if (ThisType != null) {
					for (i32 TypeNameIndex := 0, TypeNameIndex < ThisType->Name->Length, TypeNameIndex += 1) {
						NameBuffer[TypeNameIndex] := ThisType->Name->Buffer[TypeNameIndex] As i8
					}
					
					i8 Separator := '.'
					
					if (ForStatic) {
						Separator := ':'
					}
					
					NameBuffer[TypeNameIndex] := Separator
					NameBuffer += TypeNameIndex + 1
				}
				
				for (i32 NameIndex := 0, NameIndex < Name->Length, NameIndex += 1) {
					NameBuffer[NameIndex] := Name->Buffer[NameIndex] As i8
				}
				
				NewDefine->StringBuffer := StringBuffer
				NewDefine->StringBufferSize := Length
			}
			else {
				NewDefine->StringBuffer := Alloc(4) As i8*
				NewDefine->StringBufferSize := 0
			}
			
			NewDefine->Body := ParseBlock(Parser)
			
			if (NewDefine->ReturnType != MakeType(Parser->void, 0)) {
				if !(NewDefine->Body->HasUnconditionalReturn) {
					ContextError(NewDefine~>Context, "Function has non-void return type, but no unconditional return statement")
				}
			}
		}
		
		NewDefine->HasFullDefinition := true
		Parser->CurrentFunction := false
		
		if (ThisType = null && SafeStringEqualsAString(Name, "Main")) {
			Parser->MainFunction := NewDefine
		}
	}
	
	return NewDefine
}
define FunctionDefine* ParseFunction(ParserState* Parser, HashMap* Namespace, i8 Mode) {
	return ParseFunction(Parser, Namespace, Mode, false As TypeInfo*)
}

declare ASTNode* ParseIf(ParserState*)
declare ASTNode* ParseFor(ParserState*)
declare ASTNode* ParseWhile(ParserState*)
declare ASTNode* ParseTry(ParserState*)

define ASTNode* ParseStatement(ParserState* Parser) {
	/* Parses a single statement */
	
	/* Freeze the parser just in case the next token isn't a keyword */
	i32 FrozenState := FreezeParser(Parser)
	
	Token* NextToken := ParserNextToken(Parser)
	ASTNode* Result := 0
	
	if (NextToken->Type = TOKEN_TYPE_KEYWORD) {
		i8 NextKeyword := (NextToken->Value) As i8
		
		i8 IsContinue := (NextKeyword = KEYWORD_CONTINUE)
		
		if (NextKeyword = KEYWORD_BREAK || IsContinue) {
			Result := ASTNode:New(NODE_TYPE_CONTINUEBREAK, IsContinue, TYPE_NONE)
			CopyContext(NextToken~>Context, Result~>Context)
			
			if !(Parser->InLoop) {
				Result->Error("Continue/Break must be inside loops")
			}
		}
		else if (NextKeyword = KEYWORD_RETURN) {
			/* A return is a NODE_TYPE_RETURN with a value which points to the expression to return */
			
			/* Parse the expression to return */
			ASTNode* ExpressionToReturn := null
			
			if (Parser->CurrentFunction->ReturnType = MakeType(Parser->void, 0)) {
				Result := ASTNode:New(NODE_TYPE_INTEGER, 0, MakeType(Parser->i8, 0))
				Result := ASTNode:New(NODE_TYPE_RETURN, Result, TYPE_NONE)
				
				i32 BeforeClosingBrace := FreezeParser(Parser)
				
				if !(ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
					ExpressionToReturn := ParseExpression(Parser, 0)
					
					ExpressionToReturn->Error("Unexpected expression, 'void' functions should not return a value.")
				}
				
				UnfreezeParser(Parser, BeforeClosingBrace)
			}
			else {
				ExpressionToReturn := Parser->DowncastIntegerNode(ParseExpression(Parser, 0))
				Type ExpectedReturnType := Parser->CurrentFunction->ReturnType
				
				CheckTypes(Parser->void, 0 As Type, ExpectedReturnType, ExpressionToReturn)
				
				Result := ASTNode:New(NODE_TYPE_RETURN, ExpressionToReturn, TYPE_NONE)
			}
		}
		else if (NextKeyword = KEYWORD_ASSEMBLY) {
			Result := ParseAssembly(Parser, true)
		}
		else if (NextKeyword = KEYWORD_TRY) {
			Result := ParseTry(Parser)
		}
		else if (NextKeyword = KEYWORD_IF) {
			Result := ParseIf(Parser)
		}
		else if (NextKeyword = KEYWORD_FOR) {
			Result := ParseFor(Parser)
		}
		else if (NextKeyword = KEYWORD_LOOP) {
			i8 OldInLoop := Parser->InLoop
			Parser->InLoop := true
			
			Result := ASTNode:New(NODE_TYPE_LOOP, ParseBlock(Parser), TYPE_NONE)
			
			Parser->InLoop := OldInLoop
		}
		else if (NextKeyword = KEYWORD_WHILE) {
			Result := ParseWhile(Parser)
		}
	}
	
	if (Result = 0) {
		/* When we don't have a result yet, this is either a declaration or a expression statement */
		
		UnfreezeParser(Parser, FrozenState)
		
		if (NextToken->Type = TOKEN_TYPE_IDENTIFIER) {
			/* If the next token isn't an identifier, then it's definitely not a declaration */
			
			i8* ErrorMessage := 0
			Type PotentialType := TryParseTypeName(Parser, true, &ErrorMessage)
			
			if ((PotentialType != 0) && (ErrorMessage = 0)) {
				/* Holds the parser state right after `Type` would have been parsed, so `PotentialType := ParseTypeName(Parser)` can still be parsed as well */
				i32 DefaultValueExpressionStart := FreezeParser(Parser)
				Token* PotentialName := ParserNextToken(Parser)
				
				if (TokenMatches(PotentialName, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE)) {
					/* If we parsed a type name, and then found another identifier after the type name, this is a declaration */
					/* This can be wrong if you had `A * B` alone on a line, but what kind of dumbass would do that? */
					
					SafeWideString* NameString := (PotentialName->Value) As SafeWideString*
					
					VariableInfo* NewLocal := Alloc(#VariableInfo)
					
					NewLocal->Name := NameString
					NewLocal->Type := PotentialType
					NewLocal->IsGlobal := False
					NewLocal->IsParameter := False
					
					ParserAddLocal(Parser, NewLocal, PotentialName)
					
					if (ParserNextMatches(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
						UnfreezeParser(Parser, DefaultValueExpressionStart)
					}
					else {
						/* The next token is not a `:=`, so the following tokens are not a value for this variable */
						return ASTNode:New(NODE_TYPE_NONE, 0, TYPE_NONE)
					}
				}
				else {
					/* Token after the type name was not an identifier */
					UnfreezeParser(Parser, FrozenState)
				}
			}
			else {
				UnfreezeParser(Parser, FrozenState)
			}
		}
		
		/* This expression will either be at A) The start of the line or B) After a type name (for declarations) */
		Result := ASTNode:New(NODE_TYPE_EXPRESSION, ParseExpression(Parser, 0), TYPE_NONE)
	}
	
	return Result
}

define ASTNode* ParseIf(ParserState* Parser) {
	IfGroup* NewIf := Alloc(#IfGroup) As IfGroup*
	
	NewIf->Conditions := Alloc(10 * #ASTNode*) As ASTNode**
	NewIf->Bodies := Alloc(10 * #Block*) As Block**
	i32 BranchCapacity := 10
	i32 BranchIndex := 0
	
	loop {
		if (BranchIndex = 0 || ParserNextMatches(Parser, TOKEN_TYPE_KEYWORD, KEYWORD_IF)) {
			if (BranchCapacity <= BranchIndex) {
				BranchCapacity += 10
			
				NewIf->Conditions := ReAlloc(NewIf->Conditions, BranchCapacity * 8)
				NewIf->Bodies := ReAlloc(NewIf->Bodies, BranchCapacity * 8)
			}
			
			NewIf->Conditions[BranchIndex] := ParseExpression(Parser, 0)
			NewIf->Bodies[BranchIndex] := ParseBlock(Parser)
		
			BranchIndex += 1

			if !(ParserNextMatches(Parser, TOKEN_TYPE_KEYWORD, KEYWORD_ELSE)) {
				break
			}
		}
		else {
			NewIf->ElseBranch := ParseBlock(Parser)
			break
		}
	}
	
	NewIf->BranchCount := BranchIndex

	return ASTNode:New(NODE_TYPE_IF, NewIf, TYPE_NONE)
}

define ASTNode* ParseFor(ParserState* Parser) {
	Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Expected opening '(' for for loop.")
	
	i32 InitializerStart := FreezeParser(Parser)
	
	if (ParserNextMatches(Parser, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE)) {
		UnfreezeParser(Parser, InitializerStart)
		
		i8* ErrorMessage := 0
		Type PotentialType := TryParseTypeName(Parser, false, &ErrorMessage)
		
		if ((PotentialType != 0) && (ErrorMessage = 0)) {
			i32 ExpressionStart := FreezeParser(Parser)
			Token* PotentialName := ParserNextToken(Parser)
			
			if (TokenMatches(PotentialName, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE)) {
				if (ParserNextMatches(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
					SafeWideString* NameString := (PotentialName->Value) As SafeWideString*
					
					VariableInfo* NewLocal := Alloc(#VariableInfo)
					
					NewLocal->Name := NameString
					NewLocal->Type := PotentialType
					
					ParserAddLocal(Parser, NewLocal, PotentialName)
					
					InitializerStart := ExpressionStart /* Set the initializer expression to start after the type name */
				}
			}
		}
	}
	
	UnfreezeParser(Parser, InitializerStart)
	
	ForLoop* NewLoop := Alloc(#ForLoop) As ForLoop*
	
	NewLoop->Initializer := ParseExpression(Parser, 0)
	
	Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA, "Expected comma after for loop initializer.")
	NewLoop->Condition := ParseExpression(Parser, 0)
	
	Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA, "Expected comma after for loop condition.")
	NewLoop->Step := ParseExpression(Parser, 0)
	
	Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing ')' in for loop.")
	
	i8 OldInLoop := Parser->InLoop
	Parser->InLoop := true
	
	NewLoop->Body := ParseBlock(Parser)
	
	Parser->InLoop := OldInLoop
	
	return ASTNode:New(NODE_TYPE_FOR, NewLoop, TYPE_NONE)
}

define ASTNode* ParseWhile(ParserState* Parser) {
	WhileLoop* NewWhile := Alloc(#WhileLoop) As WhileLoop*
	
	NewWhile->Condition := ParseExpression(Parser, 0)
	
	i8 OldInLoop := Parser->InLoop
	Parser->InLoop := true
	
	NewWhile->Body := ParseBlock(Parser)
	
	Parser->InLoop := OldInLoop
	
	return ASTNode:New(NODE_TYPE_WHILE, NewWhile As void*, TYPE_NONE)
}

define ASTNode* TranslateTokenToNode(ParserState* Parser, Token* TokenToTranslate) {
	/* Translates a token into an AST node with an eqaul value */
	
	ASTNode* Result := 0
	
	if (TokenToTranslate->Type = TOKEN_TYPE_INTEGER) {
		/* If the token is an integer, return a NODE_TYPE_INTEGER node with a type which is correctly size for the given integer */
		
		Type ResultType := Parser->GetNumberType(TokenToTranslate->IntegerValue)
		
		Result := ASTNode:New(NODE_TYPE_INTEGER, TokenToTranslate->Value, ResultType)
	}
	else if (TokenToTranslate->Type = TOKEN_TYPE_IDENTIFIER) {
		/* If the token is an identifier, find the variable the identifier represents, and put it into a NODE_TYPE_VARIABLE node */
		
		Result := ASTNode:New(NODE_TYPE_INTEGER, 0, MakeType(Parser->i32, 0))
		
		if (SafeStringEqualsAString(TokenToTranslate->StringValue, "true")) {
			Result->IntegerValue := 1
		}
		else if (SafeStringEqualsAString(TokenToTranslate->StringValue, "false")) {
			Result->IntegerValue := 0
		}
		else if (SafeStringEqualsAString(TokenToTranslate->StringValue, "windows")) {
			Result->IntegerValue := Parser->Config->OutputFormat = OUTPUT_PE
		}
		else if (SafeStringEqualsAString(TokenToTranslate->StringValue, "linux")) {
			Result->IntegerValue := Parser->Config->OutputFormat = OUTPUT_ELF
		}
		else if (SafeStringEqualsAString(TokenToTranslate->StringValue, "debug")) {
			Result->IntegerValue := Parser->Config->DebugMode & DEBUG_EMIT_FUNCTION_NAMES
		}
		else if (SafeStringEqualsAString(TokenToTranslate->StringValue, "null")) {
			Result->ValueType := MakeType(Parser->void, 1)
			Result->NodeType := NODE_TYPE_ZERO
		}
		else {
			VariableInfo* FoundVariable := FindVariable(Parser, TokenToTranslate)
			/* Using the found variable's type as the node type */
			
			Result->NodeType := NODE_TYPE_VARIABLE
			Result->IsStorageValue := true
			Result->VariableValue := FoundVariable
			Result->ValueType := FoundVariable->Type
		}
		
		CopyContext(TokenToTranslate As ErrorContext*, Result As ErrorContext*)
	}
	else {
		TokenToTranslate->Error("Unexpected token")
	}
	
	CopyContext(TokenToTranslate~>Context, Result~>Context)
	
	return Result
}

define ASTNode** ParseParameterList(ParserState* Parser, i8* OutParameterCount) {
	i8 ParameterIndex := *OutParameterCount
	ASTNode** Parameters := Alloc(8 * 10) As ASTNode**
	
	/* If the next token is not a ), then parse a parameter list (if it is a ')' then there are 0 parameters) */
	
	if !(ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
		i8 IsFirstParameter := true
		
		while (IsFirstParameter || ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
			Parameters[ParameterIndex] := ParseExpression(Parser, 0)
			ParameterIndex += 1
			
			IsFirstParameter := false
		}
		
		/* When we run into a token that isn't a ',' then the next token must be ')' to close the parameter group */
		
		Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing paren for function call")
	}
	
	OutParameterCount[0] := ParameterIndex
	return Parameters
}

define ASTNode* ParseExpressionOperand(ParserState* Parser) {
	/* Parses and returns a single operand of an expression */
	
	Token* NextToken := ParserNextToken(Parser)
	ASTNode* Result := 0
	
	FunctionDefine* CurrentFunction := Parser->CurrentFunction
	
	if (NextToken->Type = TOKEN_TYPE_PUNCTUATION && NextToken->Value = PUNCTUATION_OPEN_PAREN) {
		/* If the next token is an (, then parse a subexpression and consume a closing ) */
		
		Result := ParseExpression(Parser, 0)
		
		Token* CloseParen := Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing paren")
		
		MergeContexts(NextToken~>Context, CloseParen~>Context, Result~>Context)
	}
	else if (NextToken->Type = TOKEN_TYPE_IDENTIFIER) {
		/* Else if the next token is an identifier */
		
		/* This check is fine, since x:(y) is never valid, nor is x:y */
		i8 IsBuiltinOrStatic := ParserNextMatches(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_COLON)
		
		i8 ParameterCount := 0
		ASTNode** Parameters := null
		
		if (IsBuiltinOrStatic) {
			MergeContexts(NextToken~>Context, ParserCurrentToken(Parser)~>Context, NextToken~>Context)
			
			if (ParserNextMatches(Parser, TOKEN_TYPE_IDENTIFIER, 0)) {
				SafeWideString* StaticMethodType := NextToken->StringValue
				
				HashMapElement* FoundTypeElement := Parser~>Types->Get(StaticMethodType)
				
				if !(FoundTypeElement) {
					NextToken->Error("Unknown type")
				}
				
				TypeInfo* FoundType := FoundTypeElement->Value As TypeInfo*
				
				Token* StaticMethodNameToken := ParserCurrentToken(Parser)
				MergeContexts(StaticMethodNameToken~>Context, NextToken~>Context, StaticMethodNameToken~>Context)
				
				Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Expected opening '(' for static method call")
				
				Parameters := ParseParameterList(Parser, &ParameterCount)
				
				return MakeCall(Parser, FoundType~>StaticMethods, StaticMethodNameToken, Parameters, ParameterCount)
			}
		}
		
		if (ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)) {
			/* If the next-next token is an (, then this is a function call */
			
			Parameters := ParseParameterList(Parser, &ParameterCount)
			
			/* Make a NODE_TYPE_CALL node for the function call */
			
			if (IsBuiltinOrStatic) {
				Result := MakeBuiltinCall(Parser, NextToken, Parameters, ParameterCount)
			}
			else {
				Result := MakeCall(Parser, Parser~>Functions, NextToken, Parameters, ParameterCount)
			}
		}
		else {
			if (IsBuiltinOrStatic) {
				NextToken->Error("Unexpected ':' after identifier")
			}
			
			/* Else, this isn't a function call, and is just a normal variable */
			Result := TranslateTokenToNode(Parser, NextToken)
		}
	}
	else if (NextToken->Type = TOKEN_TYPE_STRING || NextToken->Type = TOKEN_TYPE_WIDE_STRING) {
		i8* Buffer := Parser->GlobalConstantsBuffer
		i32 Offset := Parser->GlobalConstantBufferSize
		
		if (CurrentFunction) {
			Offset := CurrentFunction->StringBufferSize
			Buffer := CurrentFunction->StringBuffer
		}
		
		i8 CharacterSize := (NextToken->Type - TOKEN_TYPE_STRING) + 1
		SafeWideString* StringText := NextToken->StringValue
		
		if (Offset % CharacterSize) {
			Offset += 1
		}
		
		i32 NewSize := Offset + (StringText->Length + 1) * CharacterSize
		Buffer := ReAlloc(Buffer, NewSize)
		
		if (CurrentFunction) {
			CurrentFunction->StringBufferSize := NewSize
			CurrentFunction->StringBuffer := Buffer
		}
		else {
			Parser->GlobalConstantBufferSize := NewSize
			Parser->GlobalConstantsBuffer := Buffer
		}
		
		TypeInfo* BaseType := Parser->i8
		
		if (CharacterSize = 1) {
			for (i32 Index := 0, Index < (StringText->Length), Index += 1) {
				Buffer[Offset + Index] := StringText->Buffer[Index]
			}
		}
		else {
			BaseType := Parser->i16
			MoveMemory(&Buffer[Offset], StringText->Buffer, StringText->Length * 2)
		}
		
		Result := ASTNode:New(NODE_TYPE_STRING, Offset, MakeType(BaseType, 1))
		CopyContext(NextToken~>Context, Result~>Context)
	}
	else if (NextToken->Type = TOKEN_TYPE_INTEGER) {
		/* A literal integer, just make a NODE_TYPE_INTEGER for it */
		
		Result := TranslateTokenToNode(Parser, NextToken)
	}
	else if (NextToken->Type = TOKEN_TYPE_OPERATOR && IsPrefixOperator(NextToken)) {
		/* A prefix operator, parse an expression only containing operators of a higher precedence than the prefix operator */
		
		if (NextToken->Value = OPERATOR_POUND) {
			/* Handle #TypeName by parsing a type name after the #, and setting the result to the length of TypeName as an i32 */
			
			i8 ConsumeClosingParan := ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)
			
			Type GetSizeOfType := ParseTypeName(Parser)
			
			if (ConsumeClosingParan) {
				Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing ')' around type name")
			}
			
			Result := ASTNode:New(NODE_TYPE_GET_TYPE_SIZE, GetSizeOfType As void, MakeType(Parser->i32, 0))
			
			MergeContexts(NextToken~>Context, ParserCurrentToken(Parser)~>Context, Result~>Context)
		}
		else {
			if (NextToken->Value = OPERATOR_AND) {
				i8* ErrorMessage := 0
				
				i32 Frozen := FreezeParser(Parser)
				Token* MaybeFunction := TryConsume(Parser, TOKEN_TYPE_IDENTIFIER, 0, "Dummy", &ErrorMessage)
				
				if (MaybeFunction && !ErrorMessage) {
					FunctionDefine* FoundDefine := null
					Token* TailToken := MaybeFunction
					
					if (ParserNextMatches(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_COLON)) {
						Token* StaticMethodTypeName := MaybeFunction
						Token* StaticMethodName := Consume(Parser, TOKEN_TYPE_IDENTIFIER, 0, "Expected static method name")
						
						HashMapElement* StaticMethodTypeElement := Parser~>Types->Get(StaticMethodTypeName->StringValue)
						
						if !(StaticMethodTypeElement) {
							StaticMethodTypeName->Error("Undefined type")
						}
						
						TypeInfo* TargetType := StaticMethodTypeElement->Value As TypeInfo*
						
						HashMapElement* FoundFunctionElement := TargetType~>StaticMethods->Get(StaticMethodName->StringValue)
						
						if !(FoundFunctionElement) {
							StaticMethodName->Error("Undefined static method")
						}
						
						FoundDefine := FoundFunctionElement->Value As FunctionDefine*
						
						TailToken := StaticMethodName
					}
					else {
						HashMapElement* FoundFunction := Parser~>Functions->Get(MaybeFunction->StringValue)
						
						if (FoundFunction) {
							FoundDefine := FoundFunction->Value As FunctionDefine*
						}
					}
					
					if (FoundDefine) {
						Result := ASTNode:New(NODE_TYPE_DEFINE, FoundDefine, MakeType(Parser->void, 1))
						MergeContexts(MaybeFunction~>Context, TailToken~>Context, Result~>Context)
						
						if (FoundDefine->Next != null) {
							Result->Error("Getting the address of an overloaded function is not possible")
						}
					}
					else {
						UnfreezeParser(Parser, Frozen)
					}
				}
				else {
					UnfreezeParser(Parser, Frozen)
				}
			}
			
			if !(Result) {
				Result := ParseExpression(Parser, GetPrefixPrecedence(NextToken))
			}
			
			Result := MakeUnary(Parser, NextToken, Result)
		}
	}
	else if (NextToken->Is(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
		i32 BeforeElementType := FreezeParser(Parser)
		Type ElementType := ParseTypeName(Parser)
		
		i32 ConstantOffset := Parser->GlobalConstantBufferSize
		i8* ConstantsBuffer := Parser->GlobalConstantsBuffer
		
		if (CurrentFunction) {
			ConstantOffset := CurrentFunction->ConstantBufferSize
			ConstantsBuffer := CurrentFunction->ConstantsBuffer
		}
		
		i32 NewConstantBufferSize := ConstantOffset
		
		if (ParserNextMatches(Parser, TOKEN_TYPE_IDENTIFIER, 0)) {
			Token* ShouldBeFile := ParserCurrentToken(Parser)
			
			if !(ShouldBeFile->StringValue->Equals("file")) {
				ShouldBeFile->Error("Unexpected token")
			}
			
			Consume(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_COLON, "Expected `:` after 'file'")
			Token* FilePathToken := Consume(Parser, TOKEN_TYPE_STRING, 0, "Expected file path")
			Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}'")
			
			i8* RawFilePath := FilePathToken->StringValue->ToString()
			
			i64 File := FileOpen(RawFilePath, FILE_READ)
			
			if (File < 0) {
				ManualErrorMessagePrelude()
				Print("\nCouldn't open file, error code %x\n", FileGetError(File))
				FilePathToken->Error(null)
			}
			
			i32 FileSize := FileGetSize(File)
			
			NewConstantBufferSize += FileSize + 1
			ConstantsBuffer := ReAlloc(ConstantsBuffer, NewConstantBufferSize)
			
			void* FileBuffer := ConstantsBuffer + ConstantOffset
			
			FileRead(File, FileBuffer, FileSize)
			
			FileClose(File)
			Free(RawFilePath)
		}
		else {
			if (GetBaseType(ElementType)->IsBuiltin = false || GetPointerDepth(ElementType) != 0) {
				UnfreezeParser(Parser, BeforeElementType)
				ParserNextToken(Parser)->Error("Element type must be a built in, non-pointer type")
			}
			
			Consume(Parser, TOKEN_TYPE_OPERATOR, OPERATOR_COLON, "Expected `:` after array element type")
			
			i32 ElementSize := GetTypeSize(ElementType)
			i32 BeforeElements := FreezeParser(Parser)
			i32 ElementCount := 0
			
			loop {
				Consume(Parser, TOKEN_TYPE_INTEGER, 0, "Expected array element value")
				
				ElementCount += 1
				
				if (ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
					continue
				}
				else if (ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
					break
				}
			}
			
			NewConstantBufferSize += 8 + ElementCount * ElementSize
			ConstantsBuffer := ReAlloc(ConstantsBuffer, NewConstantBufferSize)
			
			void* ElementBuffer := ConstantsBuffer + ConstantOffset
			i32 ElementIndex := 0
			
			UnfreezeParser(Parser, BeforeElements)
			
			loop {
				Token* NextElementToken := Consume(Parser, TOKEN_TYPE_INTEGER, 0, "Expected array element value")
				
				*(ElementBuffer + ElementIndex * ElementSize) := NextElementToken->IntegerValue
				ElementIndex += 1
				
				if (ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
					continue
				}
				else if (ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
					break
				}
			}
		}
		
		if (CurrentFunction) {
			CurrentFunction->ConstantBufferSize := NewConstantBufferSize
			CurrentFunction->ConstantsBuffer := ConstantsBuffer
		}
		else {
			Parser->GlobalConstantBufferSize := NewConstantBufferSize
			Parser->GlobalConstantsBuffer := ConstantsBuffer
		}
		
		Result := ASTNode:New(NODE_TYPE_STRING, ConstantOffset, Parser->PointerToType(ElementType))
		
		MergeContexts(NextToken~>Context, ParserCurrentToken(Parser)~>Context, Result~>Context)
	}
	else {
		/* Else, this token isn't something we expected here, so error out */
		
		NextToken->Error("Unexpected token in expression")
	}
	
	return Result
}

define ASTNode* ParseExpression(ParserState* Parser, i8 Precedence) {
	/* Parses and returns and expression only containing operators with higher precedence than Precedence */
	
	ASTNode* Result := ParseExpressionOperand(Parser)
	
	i32 FrozenState := FreezeParser(Parser)
	Token* OperatorToken := ParserNextToken(Parser)
	
	while (OperatorToken->Type = TOKEN_TYPE_OPERATOR && GetPrecedence(OperatorToken) >= Precedence) {
		i8 NewPrecedence := GetPrecedence(OperatorToken)
		
		if (GetAssociation(OperatorToken) = LEFT_ASSOCIATIVE) {
			NewPrecedence += 1
		}
		
		ASTNode* Operand := 0
		i8 Operator := (OperatorToken->Value) As i8
		
		i8 CouldBeMethodCall := Operator = OPERATOR_DOT || Operator = OPERATOR_MINUS_GREATER
		
		if (Operator = OPERATOR_OPEN_BRACKET) {
			/* If the next operator is [, then parse the index expression (for the right operand) and consume the closing ] */
			
			Operand := ParseExpression(Parser, 0)
			
			Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected closing bracket for array access")
		}
		else if (Operator = OPERATOR_AS) {
			/* Else if the next operator is 'as' then parse a type name as the right operand */
			
			; Note: This needs a hack to give the result node a correct context, since `ParseTypeName` doesn't
			;  produce a context
			
			i32 BeforeType := FreezeParser(Parser)
			ErrorContext* TypeStart := ParserNextToken(Parser)~>Context
			UnfreezeParser(Parser, BeforeType)
			
			Type CastToType := ParseTypeName(Parser)
			
			i32 AfterType := FreezeParser(Parser)
			UnfreezeParser(Parser, AfterType - 1)
			ErrorContext* TypeEnd := ParserNextToken(Parser)~>Context
			UnfreezeParser(Parser, AfterType)
			
			Operand := ASTNode:New(NODE_TYPE_TYPE, CastToType As void*, CastToType)
			MergeContexts(TypeStart, TypeEnd, Operand~>Context)
		}
		else if (CouldBeMethodCall || Operator = OPERATOR_TILDE_GREATER) {
			Token* Right := Consume(Parser, TOKEN_TYPE_IDENTIFIER, 0, "Struct field name expected")
			
			Operand := ASTNode:New(NODE_TYPE_IDENTIFIER, Right->Value, MakeType(Parser->i64, 0))
			CopyContext(Right~>Context, Operand~>Context)
		}
		else {
			/* Else, no special case, just parse and expression at the expected precedence level as the right operand */
			
			Operand := ParseExpression(Parser, NewPrecedence)
		}
		
		if (Operator = OPERATOR_STAR) {
			; If we have `(a) * (b) := (c)`, we can safely assume that it was intended as `(a); *(b) := (c)`, 
			;  since the original version is totally nonsensical 
			;   (as a multiplication can never result in a storage value)
			
			; Note: The ugly freezing/unfreezing here is since `ParserNextMatches` can't check for all
			;  assignment operators at once.
			
			i32 BeforeMaybeAssignment := FreezeParser(Parser)
			Token* MaybeAssignmentOperator := ParserNextToken(Parser)
			
			if (MaybeAssignmentOperator->Type = TOKEN_TYPE_OPERATOR) {
				i32 AssignmentOperator := MaybeAssignmentOperator->IntegerValue As i32
				
				if (OPERATOR_FIRST_ASSIGNMENT <= AssignmentOperator && AssignmentOperator <= OPERATOR_LAST_ASSIGNMENT) {
					; We can force the correct interpretation by backtracking to right before the last operator 
					; (which happens to be the `*`). Then, if we just return `(a)` we leave `*(b) := (c)` 
					;  to be parsed by the next call to `ParseExpression`, resulting in two 
					;   seperate expressions which are both semantically and logically correct.
					
					; Even better is that the "unfreeze and return" is default behavior for the end of an
					;  expression so we can just break out of the expression parsing loop
					
					break
				}
			}
			
			; The token after the right side of the `*` was not an assignment operator, continue like normal
			
			UnfreezeParser(Parser, BeforeMaybeAssignment)
		}
		
		/* Fold the left/operator/right into just the left */
		
		if (CouldBeMethodCall && ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)) {
			/* If there is a struct access (using `->` or `.`) followed by a `(`, then it is a method call */
			
			ASTNode* LeftAccess := Result
			
			Type LeftType := LeftAccess->ValueType
			TypeInfo* LeftBase := GetBaseType(LeftType)
			i16 LeftDepth := GetPointerDepth(LeftType)
			
			/* If a local struct is accessed using `->`, it is an error. 
				Or If a pointed-to structure is accessed via `.`, it is an error .
			*/
			if (LeftDepth != 0 && Operator = OPERATOR_DOT) || (LeftDepth = 0 && Operator = OPERATOR_MINUS_GREATER) {
				OperatorToken->Error("Wrong operator for left side pointer depth")
			}
			else if (LeftBase->IsStructType = 0 || LeftBase->IsIncomplete) {
				/* Or, if the accessed type is not a struct, or is incomplete, it is an error */
				
				OperatorToken->Error("Can't call method on non-struct or incomplete types")
			}
			
			if (LeftDepth = 0) {
				; If `this` is a local struct, we change it to a `ThisType*` so the parameter type matches
				;  and the compiler will make sure to pass the address of `this` instead of the value.
				
				Result->ValueType := Parser->PointerToType(Result->ValueType)
			}
			
			/* The first parameter is `this`, so any actual parameters are offset by 1 */
			i8 ParameterCount := 1
			ASTNode** Parameters := ParseParameterList(Parser, &ParameterCount)
			
			/* Result = the left side of the struct access, which is passed as the `this` parameter */
			Parameters[0] := Result
			
			Result := MakeCall(Parser, LeftBase~>Methods, Right, Parameters, ParameterCount)
			
			MergeContexts(LeftAccess~>Context, ParserCurrentToken(Parser)~>Context, Result~>Context)
		}
		else {
			Result := MakeBinary(Parser, Result, OperatorToken, Operand)
		}
		
		/* Update where to restore the parser to once the expression ends */
		FrozenState := FreezeParser(Parser)
		
		/* Update the next operator */
		OperatorToken := ParserNextToken(Parser)
	}
	
	UnfreezeParser(Parser, FrozenState)
	
	return Result
}

define ASTNode* ParseTry(ParserState* Parser) {
	TryCatch* Result := Alloc(#TryCatch)
	
	Result->Body := ParseBlock(Parser)
	
	if (ParserNextMatches(Parser, TOKEN_TYPE_KEYWORD, KEYWORD_CATCH)) {
		if (ParserNextMatches(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)) {
			i8* ErrorMessage := 0
			
			Type PotentialType := TryParseTypeName(Parser, true, &ErrorMessage)
			
			if ((PotentialType != 0) && (ErrorMessage = 0)) {
				/* Holds the parser state right after `Type` would have been parsed, so `PotentialType := ParseTypeName(Parser)` can still be parsed as well */
				Token* PotentialName := ParserNextToken(Parser)
				
				if (TokenMatches(PotentialName, TOKEN_TYPE_IDENTIFIER, 0)) {
					/* If we parsed a type name, and then found another identifier after the type name, this is a declaration */

					/* This can be wrong if you had `A * B` alone on a line, but what kind of dumbass would do that? */
					SafeWideString* NameString := PotentialName->StringValue
					
					VariableInfo* CatchCodeVariable := Alloc(#VariableInfo)
					
					CatchCodeVariable->Name := NameString
					CatchCodeVariable->Type := PotentialType
					CatchCodeVariable->IsGlobal := False
					CatchCodeVariable->IsParameter := False
					
					ParserAddLocal(Parser, CatchCodeVariable, PotentialName)
				}
			}
			else {
				ASTNode* CatchCodeNode := TranslateTokenToNode(Parser, ParserNextToken(Parser))
				
				if (CatchCodeNode->NodeType != NODE_TYPE_VARIABLE) {
					CatchCodeNode->Error("Expected variable name")
				}
				
				CatchCodeVariable := CatchCodeNode->VariableValue
			}
			
			Result->CatchCodeVariable := CatchCodeVariable
			
			Consume(Parser, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing ')' for 'catch ('")
		}
		
		Result->CatchBody := ParseBlock(Parser)
	}
	
	return ASTNode:New(NODE_TYPE_TRY, Result, TYPE_NONE)
}

#Include ./src/compiler/AssemblyParse.rlx


*/