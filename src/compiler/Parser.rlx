; TODO: Add a divmod built-in, the `x / constant` with `x % constant` pattern is getting annoying.

bits Type As i64 {
	[0:47] BaseType,
	[48:49] IsArray,
	[50:63] PointerDepth
}

Type TYPE_NONE := 0 As Type

i8 GLOBAL_IS_OPTIMIZED_AWAY := 2

struct VariableInfo {
	SourceContext* DefinedAt,
	
	union {
		ASTNode* LastValue
		SafeString* ExternalSymbolName
	}

	SafeString* Name,
	Type Type,

	union {
		i32 StackOffset
	}
	
	ELFSymbol* Symbol

	i16 GetCount,
	i16 SetCount,

	; whatre flags?

	i8 IsGlobal,
	i8 IsParameter,
	i8 IsVariadic,
	i8 IsThis,
	i8 IsExternal
}

declare i16 GetTypeStorageSize(Type)

struct VariableHashMap {
	HashMap BackingMap
	HashMap* Map
	i32 NextOffset
	
	define void Initialize() {
		this->Map := this~>BackingMap
		
		this->Map->BufferMaxCount := 100
		this->Map->Elements := Alloc(this->Map->BufferMaxCount * 8)
		
		this->NextOffset := 0
	}
	
	define VariableInfo* Get(SafeString* VariableName) {
		HashMapElement* FoundElement := this->Map->Get(VariableName)
		
		if (FoundElement) {
			return FoundElement->Value As VariableInfo*
		}
		
		return null
	}
	
	define void Add(VariableInfo* NewVariable, Token* SourceToken) {
		VariableInfo* LastDefinition := this->Get(NewVariable->Name)
		
		if (LastDefinition) {
			; If we already have this name in the hashmap, then it's a duplicate definition
			
			if (LastDefinition->Type = NewVariable->Type) {
				; However, if the new definition is defining that the variable is the same type as before,
				;  we just ignore the duplicate definition. Otherwise we're enforcing a rule for no reason which just
				;   makes code harder to read.
				
				return
			}
			
			SourceToken~>Context->Notify(NOTIFY_ERROR, "Duplicate definition")
			LastDefinition->DefinedAt->Notify(NOTIFY_FATAL, "Previously defined at")
		}
		
		NewVariable->DefinedAt := SourceToken~>Context
		
		this->Map->Set(NewVariable->Name, NewVariable)
		
		NewVariable->StackOffset := this->NextOffset
		
		i16 NewVariableSize := GetTypeStorageSize(NewVariable->Type)
		
		if (NewVariableSize <= 8) {
			this->NextOffset += 8
		}
		else {
			i16 RoundedSize := RoundTo(NewVariableSize, 8) As i16
			
			NewVariable->StackOffset += RoundedSize
			
			this->NextOffset += RoundedSize + 8
		}
	}
}

#Require "./src/compiler/Parser/AST.rlx"
#Require "./src/compiler/Parser/Types.rlx"

#Require "$/PointerArray.rlx"

; Holds the entire state of the parser

struct ParserState {
	BuildConfig* Config,
	LexerState* Lexer,
	
	HashMap Functions,
	
	VariableHashMap Globals,
	ASTNode** GlobalDefaults,
	
	HashMap Registers,
	HashMap Instructions,
	
	HashMap Types,
	
	HashMap NameReplacements,

	PointerArray* ExternalSources ; <Token*>
	PointerArray* ExternalDefinitions ; <VariableInfo*>
	
	/* Builtin types, actually added to the type list in CreateDefaultTypes */
	
	TypeInfo* i8,
	TypeInfo* i16,
	TypeInfo* i32,
	TypeInfo* i64,
	TypeInfo* void,
	
	FunctionDefine* CurrentFunction,
	FunctionDefine* MainFunction,
	
	i8* GlobalConstantsBuffer
	i32 GlobalConstantBufferSize
	
	i8 InLoop,
	
	i32 LabelCount
	
	declare TypeInfo* AddType(SourceContext*, SafeString*, i16, TYPE_KIND)
	declare void SetupAssembly()

	define TypeInfo* DefineBuiltinType(i8* RawName, i16 Size) {
		return this->AddType(null, AToS(RawName), Size, TYPE_KIND_BUILTIN)
	}
	
	static ParserState* New(BuildConfig* Config, LexerState* Lexer) {
		ParserState* this := Alloc(#ParserState)
		
		this->Config := Config
		this->Lexer := Lexer
		
		this~>Globals->Initialize()
		this~>Functions->Initialize()
		this~>Types->Initialize()
		this~>NameReplacements->Initialize()

		this->ExternalSources := PointerArray:New()
		this->ExternalDefinitions := PointerArray:New()
		
		this->GlobalDefaults := AllocArray(8, 0)
		this->GlobalConstantsBuffer := Alloc(4)
		
		this->i8   := this->DefineBuiltinType("i8"  , 1)
		this->i16  := this->DefineBuiltinType("i16" , 2)
		this->i32  := this->DefineBuiltinType("i32" , 4)
		this->i64  := this->DefineBuiltinType("i64" , 8)
		this->void := this->DefineBuiltinType("void", 8)
		
		this->SetupAssembly()
		
		return this
	}
	
	define TypeInfo* AddType(SourceContext* BlameContext, SafeString* Name, i16 Size, TYPE_KIND Kind, i8 IsIncomplete) {
		TypeInfo* NewType := Alloc(#TypeInfo)
		
		NewType->DefinedAt := BlameContext
		NewType->Name := Name
		NewType->Size := Size
		NewType->Kind := Kind
		NewType->IsIncomplete := IsIncomplete
	
		this~>Types->Set(Name, NewType)
		
		return NewType
	}
	define TypeInfo* AddType(SourceContext* BlameContext, SafeString* Name, i16 Size, TYPE_KIND Kind) {
		return this->AddType(BlameContext, Name, Size, Kind, false)
	}
	
	declare Token* GetCurrentToken()
	
	define Type TryFindType(SafeString* TypeName, i16 PointerDepth, i8** ErrorMessage) {
		HashMapElement* FoundTypeInfoElement := this~>Types->Get(TypeName)
		TypeInfo* FoundTypeInfo := null
		
		if (FoundTypeInfoElement) {
			FoundTypeInfo := FoundTypeInfoElement->Value As TypeInfo*
		}
		else {
			if (PointerDepth = 0) {
				*ErrorMessage := "Undefined type (Incomplete types can only be pointed-to)"
				
				return TYPE_NONE
			}
			else {
				FoundTypeInfo := this->AddType(null, TypeName, 0, TYPE_KIND_STRUCTURE, true)
			}
		}
		
		return FoundTypeInfo->AsPointer(PointerDepth)
	}
	define Type FindType(SafeString* TypeName, i16 PointerDepth) {
		i8* ErrorMessage := null
		
		Type Result := this->TryFindType(TypeName, PointerDepth, &ErrorMessage)
		
		if (ErrorMessage) {
			this->GetCurrentToken()->Error(ErrorMessage)
		}
		
		return Result
	}
	define i8 IsTypeName(Token* NameToken) {
		if !(NameToken->Is(TOKEN_TYPE_IDENTIFIER)) { return false }
		
		return this~>Types->Get(NameToken->StringValue) != null
	}
	
	define Type DereferencePointerType(Type TypeToDecrement, SourceContext* BlameContext) {
		i16 PointerDepth := GetPointerDepth(TypeToDecrement)
		
		if (PointerDepth = 0) {
			BlameContext->Error("Pointer type expected")
		}
		
		return GetBaseType(TypeToDecrement)->AsPointer(PointerDepth - 1 As i16)
	}
	define Type PointerToType(Type TypeToIncrement) {
		return GetBaseType(TypeToIncrement)->AsPointer(GetPointerDepth(TypeToIncrement) + 1 As i16)
	}
	
	define Type GetNumberType(i64 Number) {
		if (Number & 0xFFFF_FFFF_8000_0000) {
			return this->i64->AsNonPointer()
		}
		else {
			return this->i32->AsNonPointer()
		}
	}
	
	define ASTNode* DowncastIntegerNode(ASTNode* Target) {
		if (Target->NodeType != NODE_TYPE_INTEGER) {
			return Target
		}
		else if (GetPointerDepth(Target->ValueType) = 0 && GetBaseType(Target->ValueType)->Is(TYPE_KIND_ENUMERATION)) {
			return Target
		}
		
		i8 Size := GetNumberSize(Target->IntegerValue)
		TypeInfo* BaseType := this->i8
		
		if (Size = 2) {BaseType := this->i16}
		else if (Size = 4) {BaseType := this->i32}
		else if (Size = 8) {BaseType := this->i64}
		
		Target->ValueType := BaseType->AsNonPointer()
		
		return Target
	}
	
	define VariableInfo* TryFindVariable(Token* NameToken) {
		; Finds a variable, prioritizing locals over globals
		
		SafeString* VariableName := NameToken->StringValue
		
		FunctionDefine* CurrentFunction := this->CurrentFunction
		VariableInfo* FoundVariable := null
		
		if (CurrentFunction) {
			; If we are in a function, try to find the variable in the locals
			FoundVariable := CurrentFunction~>Locals->Get(VariableName)
		}
		
		if !(FoundVariable) {
			; If we didn't find the variable in the locals, then check the globals
			FoundVariable := this~>Globals->Get(VariableName)
			
			if (CurrentFunction) {
				CurrentFunction->UsesGlobals := true
			}
		}
		
		return FoundVariable
	}
	
	define VariableInfo* FindVariable(Token* NameToken) {
		VariableInfo* FoundVariable := this->TryFindVariable(NameToken)
		
		if !(FoundVariable) {
			; If we still haven't found the variable, then it is undefined
			
			NameToken->Error("Undefined variable")
		}
		
		; Variable has to have been found at some point for this to be reached
		
		return FoundVariable
	}

	define void DuplicateDefinitionError(SourceContext* New, SourceContext* Old) {
		if (Old) {
			New->Notify(NOTIFY_ERROR, "Name is already used")
			Old->Notify(NOTIFY_FATAL, "Previously defined here")
		}
		else {
			New->Error("Name is already used")
		}
	}

	define void AddGlobal(VariableInfo* NewGlobal, Token* BlameToken) {
		HashMapElement* DefinedTypeElement := this~>Types->Get(NewGlobal->Name)
		
		if (DefinedTypeElement) {
			TypeInfo* DefinedType := DefinedTypeElement->Value

			this->DuplicateDefinitionError(BlameToken~>Context, DefinedType->DefinedAt)
		}
		
		this~>Globals->Add(NewGlobal, BlameToken)
	}
	define void AddLocal(VariableInfo* NewLocal, Token* BlameToken) {
		HashMapElement* DefinedTypeElement := this~>Types->Get(NewLocal->Name)
		VariableInfo* DefinedGlobal := this~>Globals->Get(NewLocal->Name)
		
		if (DefinedTypeElement) {
			TypeInfo* DefinedType := DefinedTypeElement->Value
			
			this->DuplicateDefinitionError(BlameToken~>Context, DefinedType->DefinedAt)
		}
		else if (DefinedGlobal) {
			this->DuplicateDefinitionError(BlameToken~>Context, DefinedGlobal->DefinedAt)
		}
		
		this->CurrentFunction~>Locals->Add(NewLocal, BlameToken)
	}
	define void AddVariable(VariableInfo* NewVariable, Token* BlameToken) {
		if (NewVariable->IsGlobal) {
			this->AddGlobal(NewVariable, BlameToken)
		}
		else {
			this->AddLocal(NewVariable, BlameToken)
		}
	}
	
	define i32 Freeze() {
		return this->Lexer->TokenIndex
	}
	define void Unfreeze(i32 FrozenState) {
		this->Lexer->TokenIndex := FrozenState
	}
	define Token* GetCurrentToken() {
		return this->Lexer->GetCurrentToken()
	}
	define SourceContext* GetCurrentTokenContext() {
		return this->Lexer->GetCurrentTokenContext()
	}
	define Token* GetNextToken() {
		return this->Lexer->GetNextToken()
	}
	define Token* PeekNextToken() {
		i32 Before := this->Freeze()
		
		Token* Result := this->Lexer->GetNextToken()
		
		this->Unfreeze(Before)
		
		return Result
	}
	define i8 NextTokenMatches(i8 TokenType, i64 TokenValue) {
		if (this->PeekNextToken()->Is(TokenType, TokenValue)) {
			this->GetNextToken()
			
			return true
		}
		
		return false
	}
	define i8 NextTokenMatches(i8 TokenType) {
		if (this->PeekNextToken()->Is(TokenType)) {
			this->GetNextToken()
			
			return true
		}
		
		return false
	}
	define Token* TryConsume(i8 TokenType, i64 TokenValue, i8* Reason, i8** ErrorMessage) {
		Token* NextToken := this->GetNextToken()
		
		if (NextToken->Is(TOKEN_TYPE_EOF, 0)) {
			*ErrorMessage := "Unexpected end of file"
		}
		else if !(NextToken->Is(TokenType, TokenValue)) {
			*ErrorMessage := Reason
		}
		
		return NextToken
	}
	define Token* TryConsume(i8 TokenType, i8* Reason, i8** ErrorMessage) {
		return this->TryConsume(TokenType, 0, Reason, ErrorMessage)
	}
	define Token* Consume(i8 TokenType, i64 TokenValue, i8* Reason) {
		i8* ErrorMessage := null
		
		Token* Result := this->TryConsume(TokenType, TokenValue, Reason, &ErrorMessage)
		
		if (ErrorMessage) {
			Result->Error(ErrorMessage)
		}
		
		return Result
	}
	define Token* Consume(i8 TokenType, i8* Reason) {
		return this->Consume(TokenType, 0, Reason)
	}
	
	define Token* ThrowConsume(i8 TokenType, i64 TokenValue, i8* Reason) {
		;Print("TC %i %i %s\n", TokenType, TokenValue, Reason)
		
		i8* ErrorMessage := null
		Token* Result := this->TryConsume(TokenType, TokenValue, Reason, &ErrorMessage)
		
		if (ErrorMessage) {
			Throw(ErrorMessage As i64)
		}
		
		return Result
	}
	define Token* ThrowConsume(i8 TokenType, i8* Reason) {
		return this->ThrowConsume(TokenType, 0, Reason)
	}
	
	declare Type TryParseType(i8, i8, i8**)
	declare Type TryParseType(i8, i8**)
	
	define TypeInfo* TryParseFunctionPointer(i8 RequireParenthesis, i8** ErrorMessage) {
		;Print("TPFP, %i\n", RequireParenthesis)
		
		try {
			if (RequireParenthesis) {
				this->ThrowConsume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Expected open `(` for function pointer type")
			}
			
			Type ReturnType := this->TryParseType(true, false, ErrorMessage)
			if *(ErrorMessage) { return null }
			
			this->ThrowConsume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Expected open `(` for function pointer parameter types")
			if *(ErrorMessage) { return null }
			
			Type[10] ParameterTypes
			i32 ParameterCount := 0
			
			i8 Attributes := 0
			
			if !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
				loop {
					if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
						this->ThrowConsume(TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected `...` for variadic parameter marker")
						this->ThrowConsume(TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected `...` for variadic parameter marker")
						
						Attributes |= FUNCTION_ATTRIBUTE_VARIADIC
						
						ParameterTypes[ParameterCount++] := MakeType(this->void, 1)
						
						this->ThrowConsume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Variadic marker must be the last parameter")
						
						break
					}
					
					Type ParameterType := this->TryParseType(false, ErrorMessage)
					
					ParameterTypes[ParameterCount++] := ParameterType
					
					if *(ErrorMessage) { return null }
					
					if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
						continue
					}
					else if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
						break
					}
					else {
						Throw("Expected comma between function pointer parameter types, or closing `)` for parameter type list" As i64)
					}
				}
			}
			
			if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_X64)) {
				Attributes |= FUNCTION_ATTRIBUTE_USE_X64
			}  
			
			if (RequireParenthesis) {
				this->ThrowConsume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing `)` for function pointer type")
			}
			
			Type* RealParameterTypes := Alloc(ParameterCount * #Type)
			MoveMemory(RealParameterTypes, ParameterTypes, ParameterCount * #Type)
			
			TypeInfo* Result := Alloc(#TypeInfo)
			
			Result->Name := AToS("(function pointer)")
			Result->Size := 8
			Result->Kind := TYPE_KIND_FUNCTION_POINTER

			Result~>FunctionPointer->ReturnType := ReturnType
			Result~>FunctionPointer->ParameterCount := ParameterCount
			Result~>FunctionPointer->ParameterTypes := RealParameterTypes
			Result~>FunctionPointer->Attributes := Attributes
			
			return Result
		}
		catch (i8* RawErrorMessage) {
			*ErrorMessage := RawErrorMessage
		}
		
		return null
	}
	
	define Type TryParseType(i8 RequireFunctionPointerParenthesis, i8 AllowArrayType, i8** ErrorMessage) {
		i32 BeforeFunctionPointer := this->Freeze()
		TypeInfo* Base := this->TryParseFunctionPointer(RequireFunctionPointerParenthesis, ErrorMessage)
		Type Result := TYPE_NONE
		
		if *(ErrorMessage) {
			this->Unfreeze(BeforeFunctionPointer)
			*ErrorMessage := null
			
			Token* NameToken := this->TryConsume(TOKEN_TYPE_IDENTIFIER, "Type names must be identifiers", ErrorMessage)
			
			if *(ErrorMessage) {
				return TYPE_NONE
			}
			
			i8 PointerDepth := 0
		
			while (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_STAR)) {
				PointerDepth += 1
			}
			
			Result := this->TryFindType(NameToken->StringValue, PointerDepth, ErrorMessage)
			
			if *(ErrorMessage) {
				return TYPE_NONE
			}
		}
		else {
			i8 PointerDepth := 0
		
			while (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_STAR)) {
				PointerDepth += 1
			}
			
			Type Result := MakeType(Base, PointerDepth)
		}
		
		if (AllowArrayType && this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET)) {
			Token* SizeToken := this->TryConsume(TOKEN_TYPE_INTEGER, "Expected array type size", ErrorMessage)
			
			if (*ErrorMessage = null) {
				TypeInfo* ResultBase := GetBaseType(Result)
				
				if (ResultBase->IsIncomplete && PointerDepth = 0) {
					NameToken->Error("Array types must not be incomplete")
				}
				
				Result := MakeArrayType(Result, SizeToken->IntegerValue As i16)
				Result.IsArray := true
				
				this->TryConsume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected closing ']' for array type", ErrorMessage)
			}
		}
		
		return Result
	}
	define Type TryParseType(i8 AllowArrayType, i8** ErrorMessage) {
		return this->TryParseType(false, AllowArrayType, ErrorMessage)
	}
	define Type ParseType(i8 AllowArrayType) {
		i8* ErrorMessage := null
		Token* BlameToken := this->PeekNextToken()
		
		Type Result := this->TryParseType(AllowArrayType, &ErrorMessage)
		
		if (ErrorMessage) {
			this->GetCurrentTokenContext()->Error(ErrorMessage)
		}
		
		return Result
	}
	define Type ParseType() {
		return this->ParseType(false)
	}
	define ASTNode* ParseTypeNode() {
		Token* FirstToken := this->PeekNextToken()
		Type Result := this->ParseType()
		
		ASTNode* ResultNode := ASTNode:New(NODE_TYPE_TYPE, Result As i64, Result)
		
		ResultNode~>Context->Clone(FirstToken~>Context)->Merge(this->GetCurrentTokenContext())
		
		return ResultNode
	}
	
	define FunctionDefine* LookupStaticMethod(Token* TypeNameToken, Token* StaticMethodNameToken) {
		HashMapElement* TypeElement := this~>Types->Get(TypeNameToken->StringValue)
		
		if !(TypeElement) {
			TypeNameToken->Error("Undefined type")
		}
		
		TypeInfo* TargetType := TypeElement->Value As TypeInfo*
		
		HashMapElement* FoundFunctionElement := TargetType~>StaticMethods->Get(StaticMethodNameToken->StringValue)
		
		if !(FoundFunctionElement) {
			StaticMethodNameToken->Error("Undefined static method")
		}
		
		return FoundFunctionElement->Value As FunctionDefine*
	}
	
	#Require "./src/compiler/Parser/Expression.rlx"
	
	define ASTNode* ParseInitializer(ASTNode* ForNode) {
		Type ForType := ForNode->ValueType
		
		i8 IsArray := ForType.IsArray
		i16 ForTypeDepth := GetPointerDepth(ForType)
		TypeInfo* ForBaseType := GetBaseType(ForType)
		
		if (ForTypeDepth = 0 && ForBaseType->Is(TYPE_KIND_STRUCTURE)) {
			i16 InitializerCapacity := 20
			ASTNode** Initializers := Alloc(InitializerCapacity * #ASTNode*) As ASTNode**
			
			i16 InitializerIndex := 0
			i8 IsFirstInitializer := true
			
			while (IsFirstInitializer || this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
				Token* FieldName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected initializer field name")
				
				this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_COLON, "Expected ':' after initializer field name")
				
				HashMapElement* FieldElement := ForBaseType~>Fields->Get(FieldName->StringValue)
				
				if (FieldElement = null) {
					FieldName->Error("Unknown struct field")
				}
				
				StructField* Field := FieldElement->Value
				i8 FieldIsStruct := GetPointerDepth(Field->ValueType) = 0 && GetBaseType(Field->ValueType)->Is(TYPE_KIND_STRUCTURE)
				i8 FieldIsArray := Field->ValueType.IsArray
				
				; Build a node for `ForNode.Field`
				
				StructAccessExpression* Access := Alloc(#StructAccessExpression)
				
				Access->Left := ForNode
				Access->Operator := Alloc(#Token)
				Access->Operator->Type := TOKEN_TYPE_OPERATOR
				Access->Operator->IntegerValue := OPERATOR_DOT
				Access->TargetField := Field
				
				if (FieldIsArray) {
					Access->Operator->IntegerValue := OPERATOR_TILDE_GREATER
				}
				
				; Parse any initializers for `ForNode.Field`
				
				if (FieldIsStruct || FieldIsArray) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected '{' for field initializer")
				}
				
				ASTNode* AccessNode := ASTNode:New(NODE_TYPE_STRUCT_ACCESS, Access, Field->ValueType)
				ASTNode* InitializerValue := this->ParseInitializer(AccessNode)
				
				if (FieldIsStruct || FieldIsArray) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}' for field initializer")
				}
				
				; If `ForNode.Field` is a struct, then we don't want to assign `ForNode.Field` to anything, since
				;  there is no value to assign, merely a block of initializers for `ForNode.Field` itself which
				;   should be directly executed
				
				if (FieldIsStruct || FieldIsArray) {
					Initializers[InitializerIndex] := InitializerValue
				}
				else {
					BinaryExpression* Assign := Alloc(#BinaryExpression)
					
					Assign->Left := AccessNode
					Assign->Operator := Alloc(#Token)
					Assign->Operator->Type := TOKEN_TYPE_OPERATOR
					Assign->Operator->IntegerValue := OPERATOR_COLON_EQUAL
					Assign->Right := InitializerValue
					
					Initializers[InitializerIndex] := ASTNode:New(NODE_TYPE_BINARY, Assign, Field->ValueType)
				}
				
				InitializerIndex += 1
				IsFirstInitializer := false
			}
			
			CodeBlock* InitializersBlock := Alloc(#CodeBlock) As CodeBlock*
			
			InitializersBlock->Statements := Initializers
			InitializersBlock->StatementCount := InitializerIndex
			
			return ASTNode:New(NODE_TYPE_EXPRESSION_BLOCK, InitializersBlock)
		}
		else if (IsArray) {
			ArrayTypeInfo* ForArrayType := GetArrayType(ForType)
			Type ElementType := ForArrayType->BaseType->AsPointer(ForTypeDepth - 1 As i16)
			
			ASTNode** ElementInitiailizers := Alloc(ForArrayType->Length * #ASTNode*)
			
			for (i16 Index := 0, Index < ForArrayType->Length, Index += 1) {
				BinaryExpression* ArrayAccess := Alloc(#BinaryExpression)
				
				ArrayAccess->Left := ForNode
				ArrayAccess->Operator := Alloc(#Token)
				ArrayAccess->Operator->Type := TOKEN_TYPE_OPERATOR
				ArrayAccess->Operator->IntegerValue := OPERATOR_OPEN_BRACKET
				ArrayAccess->Right := ASTNode:New(NODE_TYPE_INTEGER, Index, this->i32->AsNonPointer())
				
				i8 InitializerIsStruct := GetPointerDepth(ElementType) = 0 && GetBaseType(ElementType)->Is(TYPE_KIND_STRUCTURE)
				
				if (InitializerIsStruct) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected '{' for field initializer")
				}
				
				ASTNode* ArrayAccessNode := ASTNode:New(NODE_TYPE_BINARY, ArrayAccess, ElementType)
				ASTNode* ElementInitiailizer := this->ParseInitializer(ArrayAccessNode)
				
				if (InitializerIsStruct) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}' for field initializer")
					
					ElementInitiailizers[Index] := ElementInitiailizer
				}
				else {
					CheckTypes(this->void, ElementInitiailizer->ValueType, ElementType, ElementInitiailizer)
					
					BinaryExpression* ElementAssign := Alloc(#BinaryExpression)
					
					ElementAssign->Left := ArrayAccessNode
					ElementAssign->Operator := Alloc(#Token)
					ElementAssign->Operator->Type := TOKEN_TYPE_OPERATOR
					ElementAssign->Operator->IntegerValue := OPERATOR_COLON_EQUAL
					ElementAssign->Right := ElementInitiailizer
					
					ElementInitiailizers[Index] := ASTNode:New(NODE_TYPE_BINARY, ElementAssign, ElementType)
				}
				
				if !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
					break
				}
			}
			
			CodeBlock* ArrayInitializersBlock := Alloc(#CodeBlock) As CodeBlock*
			
			ArrayInitializersBlock->Statements := ElementInitiailizers
			ArrayInitializersBlock->StatementCount := (Index + 1) As i16
			
			return ASTNode:New(NODE_TYPE_EXPRESSION_BLOCK, ArrayInitializersBlock)
		}
		else {
			ASTNode* InitializerExpression := this->ParseExpression()
			
			if (InitializerExpression->NodeType = NODE_TYPE_INTEGER) {
				InitializerExpression := this->DowncastIntegerNode(InitializerExpression)
			}
			
			CheckTypes(this->void, InitializerExpression->ValueType, ForType, InitializerExpression)
			
			return InitializerExpression
		}
	}
	
	define ASTNode* TryParseVariableDeclaration(i8 ForGlobalVariable, i8 ForParameter, i8** ErrorMessage, VariableInfo** OutNewVariable) {
		; Try to parse the declaration of a single variable (which can be local, global, or a parameter)
		;  and returns an expression which will set that variable to an optional default value (if allowed)
		
		Token* MaybeAuto := this->PeekNextToken()
		
		if (ForParameter = false && MaybeAuto->Is(TOKEN_TYPE_IDENTIFIER) && MaybeAuto->StringValue->Equals("auto")) {
			this->GetNextToken()
			
			Token* AutoVariableName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for auto variable name")
			Token* AssignmentOperator := this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL, "Expected `:=` for auto variable declaration")
			
			; Add the variable early (as void*) just in case the expression somehow references the variable
			;  (and would throw a parse error)
			
			VariableInfo* AutoVariable := Alloc(#VariableInfo)
			
			AutoVariable->Name := AutoVariableName->StringValue
			AutoVariable->Type := this->void->AsPointer(1)
			AutoVariable->IsGlobal := ForGlobalVariable
			AutoVariable->IsParameter := ForParameter
			
			if (OutNewVariable != 0) {
				*OutNewVariable := AutoVariable
			}
			
			this->AddVariable(AutoVariable, AutoVariableName)
			
			; Parse the variable's initial value, and then update the variable's type using the type of the
			;  initial value
			
			ASTNode* AutoValue := this->ParseExpression()
			AutoVariable->Type := AutoValue->ValueType
			
			; Build an AST node to assign the variable to the initial value, and then return it for the caller
			;  to compile before this variable is used
			
			BinaryExpression* AutoAssign := Alloc(#BinaryExpression)
			
			AutoAssign->Left := ASTNode:New(NODE_TYPE_VARIABLE, AutoVariable, AutoVariable->Type)
			AutoAssign->Operator := AssignmentOperator
			AutoAssign->Right := AutoValue
			
			return ASTNode:New(NODE_TYPE_BINARY, AutoAssign, AutoVariable->Type)
		}
		
		i32 Before := this->Freeze()
		Type PotentialType := this->TryParseType(true, ErrorMessage)
		
		if (PotentialType != TYPE_NONE && *ErrorMessage = null) {
			; If we could parse a full type name, then we *might* be dealing with a variable declaration.
			;  But we're not sure yet.
			
			i32 DefaultValueExpressionStart := this->Freeze()
			
			if (this->NextTokenMatches(TOKEN_TYPE_IDENTIFIER)) {
				Token* NameToken := this->GetCurrentToken()
				
				; Alright, we've got `Type Name`, which is definitely a variable declaration.
				; So we build up a VariableInfo struct for it, and add it to the correct scope.
				
				VariableInfo* NewVariable := Alloc(#VariableInfo)
				
				NewVariable->Name := NameToken->StringValue
				NewVariable->Type := PotentialType
				NewVariable->IsGlobal := ForGlobalVariable
				NewVariable->IsParameter := ForParameter
				
				if (OutNewVariable != 0) {
					*OutNewVariable := NewVariable
				}
				
				this->AddVariable(NewVariable, NameToken)
				
				; If we're declaring a local/global (but not a parameter) allow for an optional default value
				;  expression after, marked by `Type Name` being followed by the `:=` operator.
				
				; Note: the parser needs to backtrack to before `Name :=` and parse the entire `Name := Value` 
				;  expression if it is present
				
				if (ForParameter = false && this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
					this->Unfreeze(DefaultValueExpressionStart)
					
					return this->ParseExpression()
				}
				else if (ForParameter = false && this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
					ASTNode* NewVariableNode := ASTNode:New(NODE_TYPE_VARIABLE, NewVariable, PotentialType)
					
					ASTNode* InitializersBlock := this->ParseInitializer(NewVariableNode)
					
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}'")
					
					return InitializersBlock
				}
				else {
					return null
				}
			}
			else {
				*ErrorMessage := "Variable names must be identifiers"
			}
		}
		
		this->Unfreeze(Before)
		
		return null
	}
	define ASTNode* TryParseVariableDeclaration(i8 ForGlobalVariable, i8 ForParameter, i8** ErrorMessage) {
		return this->TryParseVariableDeclaration(ForGlobalVariable, ForParameter, ErrorMessage, null As VariableInfo**)
	}
	
	#Require "./src/compiler/Parser/Assembly.rlx"
	#Require "./src/compiler/Parser/Statement.rlx"
	
	define FunctionDefine* ParseFunctionDefinition(HashMap* Namespace, Token* FirstToken, TypeInfo* ThisType, i8 ForMethod) {
		i8 Mode := FirstToken->Value As i8
		
		i8 ForStatic := Mode = KEYWORD_STATIC
		i8 ForDefine := Mode = KEYWORD_DEFINE || ForStatic
		i8 ForImport := Mode = KEYWORD_DLLIMPORT
		
		Type ReturnType := this->ParseType()		
		Token* NameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected function name")
		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Expected opening '(' for function parameter list")
		
		if (!ForMethod && this~>Types->Get(NameToken->StringValue) != null) {
			NameToken->Error("Name is already reserved by a type")
		}
		
		if (ForDefine) {
			; For define statements, any parameters are added as locals, meaning that this->CurrentFunction 
			;  needs to be set to prevent `this->AddLocal` inside of the parameter list parsing from crashing
			
			; `Locals` is copied onto the actual `FunctionDefine*` for this function after the parameters have 
			; been parsed, and the matching overload has been found (if it exists)
			
			FunctionDefine TempDefine
			
			TempDefine~>Locals->Initialize()
			
			this->CurrentFunction := &TempDefine
		}
		
		i8 ParameterCount := 0
		VariableInfo** ParameterList := Alloc(16 * #VariableInfo) As VariableInfo**
		
		if (ForMethod) {
			; If we are defining a method, then we need to build the `this` parameter, and insert it into the 
			;  parameter list
	
			VariableInfo* ThisParameter := Alloc(#VariableInfo)
			ThisParameter->Name := AToS("this")
			
			if (ThisType->Is(TYPE_KIND_BIT_FIELDS)) {
				ThisParameter->Type := ThisType->AsNonPointer()
			}
			else {
				ThisParameter->Type := ThisType->AsPointer(1)
			}
			
			ThisParameter->IsParameter := true
			ThisParameter->IsThis := true
			
			if (ForDefine) {
				; Only actually add `this` as a local when we are defining a full function, and 
				;  have this->CurrentFunction set
				
				this->AddLocal(ThisParameter, null)
			}
			
			ParameterList[0] := ThisParameter
			ParameterCount += 1
		}
		
		i8 Attributes := 0
		
		if !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
			; Only bother parsing parameters if we actually have any
			
			loop {
				VariableInfo* NextParameter := Alloc(#VariableInfo)
				
				; Max parameter count since I cba to expand the buffer. Todo: Fix this
				if (ParameterCount >= 16) {
					this->GetNextToken()->Error("Max parameter limit reached")
				}
				
				ParameterList[ParameterCount] := NextParameter
				
				i8 ShouldBreak := false
				
				if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
					ShouldBreak := true
					
					SourceContext* Start := this->GetCurrentTokenContext()
					
					this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected '.' for variadic marker")
					this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected '.' for variadic marker")
					
					if (ParameterCount > 4) {
						Start->Merge(this->GetCurrentTokenContext())
						Start->Error("Only >4 regular paremeters can be passed with a variable argument.")
					}
					
					Attributes |= FUNCTION_ATTRIBUTE_VARIADIC
					
					NextParameter->Type := this->void->AsPointer(1)
					NextParameter->IsParameter := true
					NextParameter->IsVariadic := true
				}
				else {
					NextParameter->Type := this->ParseType()
				}
				
				if (ForDefine) {
					Token* NextParameterNameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Parameter names must be identifiers")
					NextParameter->Name := NextParameterNameToken->StringValue
					this->AddLocal(NextParameter, NextParameterNameToken)
				}
				
				NextParameter->IsGlobal := false
				NextParameter->IsParameter := true
				NextParameter->StackOffset := (ParameterCount * 8)
				
				ParameterCount += 1
				
				if (ShouldBreak) {
					break
				}
				else if !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
					; If the next token isn't a comma, then break the loop, otherwise consume the command and 
					;  continue
					
					break
				}
			}
			
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing ')' for parameter list")
		}
		
		HashMapElement* FoundFunctionElement := Namespace->Get(NameToken->StringValue)
		
		FunctionDefine* NewDefine := null
		FunctionDefine* TailFunction := null
		
		if (FoundFunctionElement != null) {
			; This is a function overload, find the tail of the overload linked list, and check that
			;  our parameters aren't the same as any other definition's parameters
			
			FunctionDefine* NextFunction := FoundFunctionElement->Value As FunctionDefine*
			
			loop {
				; For each definition of this name
				
				if (NextFunction->ParameterCount = ParameterCount) {
					if (CheckTypeSignature(NextFunction, ParameterList)) {
						; Allow redefining a declared overload
						
						if (NextFunction->HasFullDefinition) {
							this->DuplicateDefinitionError(NameToken~>Context, NextFunction~>Context)
						}
						
						NewDefine := NextFunction
						
						break
					}
				}
				
				if !(NextFunction->Next) {
					break
				}
				
				NextFunction := NextFunction->Next
			}
			
			TailFunction := NextFunction
		}
		
		if (NewDefine = null) {
			; If we didn't find `declare`d version of this function with the same parameter type set, then
			;  allocate a new node instead of reusing the (non-existent) `declare`d one.
			
			NewDefine := Alloc(#FunctionDefine)
			
			if (TailFunction) {
				TailFunction->Next := NewDefine
			}
			else {
				Namespace->Set(NameToken->StringValue, NewDefine)
			}
			
			NewDefine->LabelNumber := this->LabelCount
			this->LabelCount += 1
		}
		
		; By here, NewDefine 100% holds a FunctionDefine struct for this function, which is added to whichever 
		;  scope it needs to be.
		
		NewDefine->Name := NameToken->StringValue
		NewDefine->ReturnType := ReturnType
		NewDefine->Attributes := Attributes
		NewDefine->Parameters := ParameterList
		NewDefine->ParameterCount := ParameterCount
		
		; `FUNCTION_IS_METHOD` when `ForStatic` is false, and
		; `FUNCTION_IS_STATIC_METHOD` when `ForStatic` is true
		; `0`/false when neither is true
		NewDefine->IsMethod := ForMethod | (ForStatic << 1) As i8
		
		if (NewDefine->IsMethod) {
			NewDefine->MethodOfTypeName := ThisType->Name
		}
		
		if (ForDefine) {
			; Only copy the variable map containing the parameter locals if it... exists.
			
			MoveMemory(NewDefine~>Locals, TempDefine~>Locals, #VariableHashMap)
		}
		
		NewDefine~>Context->Clone(FirstToken~>Context)->Merge(this->GetCurrentTokenContext())
		
		; We are done parsing the function's name, return type, and parameters. Now to just handle all of
		;  the different function body types.
		
		if (ForImport) {
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Import source must have a prior '{'")
			
			SafeString* FileName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Import source file name expected")->StringValue
			
			if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
				this->Consume(TOKEN_TYPE_IDENTIFIER, "Import source file extension expected")
			}
			
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA, "Comma expected between import source file and function names")
			
			SafeString* FunctionName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Import source function name expected")->StringValue
			
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}'")
			
			NewDefine->IsImported := true
			NewDefine->ImportFileName := FileName
			NewDefine->ImportFunctionName := FunctionName
		}
		else if (ForDefine) {
			this->CurrentFunction := NewDefine
			
			if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_X64)) {
				NewDefine->Attributes |= FUNCTION_ATTRIBUTE_USE_X64
			}

			if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_EXPORT)) {
				i8 AllowExport := this->Config->DebugMode & DEBUG_EMIT_OBJECT

				if !(AllowExport) {
					this->GetCurrentTokenContext()->Error("Exported functions are only allowed when building an object file")
				}

				NewDefine->Attributes |= FUNCTION_ATTRIBUTE_EXPORT

				if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_AS)) {
					if (this->PeekNextToken()->Is(TOKEN_TYPE_STRING)) {
						NewDefine->ExportName := this->GetNextToken()->StringValue
					}
				}
				else if (this->PeekNextToken()->Is(TOKEN_TYPE_IDENTIFIER)) {
					SafeString* ExportKind := this->PeekNextToken()->StringValue

					if (ExportKind->Equals("raw")) {
						NewDefine->ExportName := NewDefine->Name
						this->GetNextToken()
					}
				}

				NewDefine->CallCount := 2 ; lol
			}
			
			if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_ASSEMBLY)) {
				NewDefine->Attributes |= FUNCTION_ATTRIBUTE_ASSEMBY
				
				NewDefine->AssemblyBody := this->ParseAssembly(false)->AssemblyValue
			}
			else {
				i32 Length := 4
				i8* Buffer := Alloc(Length)
				
				if (this->Config->DebugMode & DEBUG_EMIT_FUNCTION_NAMES) {
					Length := NewDefine->GetStringLength()
					Buffer := ReAlloc(Buffer, Length + 1)
					
					NewDefine->StringifyInto(Buffer)
					
					NewDefine->StringBufferSize := Length
				}
				
				NewDefine->StringBuffer := Buffer
				
				NewDefine->Body := this->ParseBlock()
				
				if (NewDefine->ReturnType != this->void->AsNonPointer()) {
					if !(NewDefine->Body->HasUnconditionalReturn) {
						NewDefine~>Context->Error("Function has non-void return type, but no unconditional return statement")
					}
				}
			}
			
			NewDefine->HasFullDefinition := true
			this->CurrentFunction := null
		
			if (!ForMethod && NameToken->StringValue->Equals("Main")) {
				this->MainFunction := NewDefine
			}
		}
		
		return NewDefine
	}
	define FunctionDefine* ParseFunctionDefinition(HashMap* Namespace, Token* FirstToken) {
		return this->ParseFunctionDefinition(Namespace, FirstToken, null, false)
	}
	
	define TypeInfo* ParseCustomTypeName(Token* NameToken, TYPE_KIND Kind) {
		SafeString* Name := NameToken->StringValue
		
		TypeInfo* NewType := null
		HashMapElement* FoundTypeElement := this~>Types->Get(Name)
		
		if (FoundTypeElement) {
			; Check for a type with this name already existing
			
			NewType := FoundTypeElement->Value As TypeInfo*
			
			if !(NewType->IsIncomplete) {
				; If the type we found isn't incomplete, then error out
				
				this->DuplicateDefinitionError(NameToken~>Context, NewType->DefinedAt)
			}
			
			NewType->IsIncomplete := false
		}
		else {
			; We didn't find a type by this name, so we can add it like normal
			
			NewType := this->AddType(NameToken~>Context, Name, 0, Kind)
		}
		
		return NewType
	}

	define void ParseStructFields(TypeInfo* ForType, i8 IsUnaligned) {
		HashMap* Fields := ForType~>Fields
		HashMap* Methods := ForType~>Methods
		HashMap* StaticMethods := ForType~>StaticMethods

		this~>Types->Set("self", ForType)

		i16 NextFieldOffset := ForType->Size
		i8 InUnion := false
		i16 MaxUnionSize := 0

		i16 TotalSize := 0

		loop {
			if !(InUnion) {
				if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_UNION)) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for union body.")
					
					InUnion := true
				}
				else {
					i8 IsMethod := false
					i8 IsStaticMethod := false
					Token* MethodKeyword := this->PeekNextToken()
					
					if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD)) {
						i8 KeywordValue := MethodKeyword->Value As i8
						
						IsStaticMethod := KeywordValue = KEYWORD_STATIC
						IsMethod := IsStaticMethod || KeywordValue = KEYWORD_DECLARE || KeywordValue = KEYWORD_DEFINE
					}
					
					if (IsMethod) {
						HashMap* MethodNamespace := Methods
						TypeInfo* ThisType := ForType
						
						if (IsStaticMethod) {
							MethodNamespace := StaticMethods
						}
						
						this->ParseFunctionDefinition(MethodNamespace, MethodKeyword, ThisType, !IsStaticMethod)
						
						; Ignore commas after methods, they aren't actually needed for parsing
						this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
						
						if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
							break
						}
						
						continue
					}
				}
			}
			
			StructField* NextField := Alloc(#StructField) As StructField*
			
			NextField->ValueType := this->ParseType(true)
			
			Token* FieldNameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for struct field name")
			SafeString* FieldName := FieldNameToken->StringValue
			NextField->Name := FieldName
			NextField->DefinedAt := FieldNameToken~>Context
			
			HashMapElement* LastDefinitionElement := Fields->Get(FieldName)
			
			if (LastDefinitionElement) {
				StructField* LastDefinition := LastDefinitionElement->Value
				
				this->DuplicateDefinitionError(FieldNameToken~>Context, LastDefinition->DefinedAt)
			}
			
			Fields->Set(FieldName, NextField)
			
			i16 FieldSize := GetTypeStorageSize(NextField->ValueType)
			
			; Only align the field if it isn't a struct, array, union, and if this structure isn't unaligned 
			
			if (GetPointerDepth(NextField->ValueType) = 0 && GetBaseType(NextField->ValueType)->Is(TYPE_KIND_STRUCTURE)) {
				; Dummy branch
			}
			else if (InUnion || IsUnaligned) {
				; Dummy branch
			}
			else if (NextField->ValueType.IsArray) {
				; Dummy branch
			}
			else if (NextFieldOffset % FieldSize) {
				; Pad the field's offset to a multiple of its size
				
				NextFieldOffset += FieldSize - (NextFieldOffset % FieldSize)
			}
			
			; If we're in a union, don't change the NextFielzOffset so all union fields get overlapping offsets
			
			NextField->Offset := NextFieldOffset
			
			if (InUnion) {
				if (FieldSize > MaxUnionSize) {
					MaxUnionSize := FieldSize
				}
			}
			else {
				NextFieldOffset += FieldSize
			}
			
			TotalSize := NextFieldOffset
			
			if (InUnion && this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				InUnion := false
				NextFieldOffset += MaxUnionSize
				TotalSize := NextFieldOffset
			}
			
			; Ignore commas after fields, since they aren't needed for parsing
			this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
			
			if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				break
			}
		}

		this~>Types->Set("self", null)

		ForType->Size := TotalSize
	}
	
	define void ParseStructDefinition() {
		Token* NameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for struct name")
		
		TypeInfo* NewType := this->ParseCustomTypeName(NameToken, TYPE_KIND_STRUCTURE)
		
		NewType->InitializeAggregate()
		
		i8 IsUnaligned := this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_UNALIGNED)
		
		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for struct body")

		this->ParseStructFields(NewType, IsUnaligned)
		
		NewType->IsIncomplete := false
	}
	
	define void ParseBitsDefinition() {
		Token* NameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for bits name")
		
		TypeInfo* NewType := this->ParseCustomTypeName(NameToken, TYPE_KIND_BIT_FIELDS)
		
		HashMap* Fields := NewType~>Fields
		HashMap* Methods := NewType~>Methods
		HashMap* StaticMethods := NewType~>StaticMethods
		
		Fields->Initialize()
		Methods->Initialize()
		StaticMethods->Initialize()
		
		this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_AS, "Expected 'as' before bits backing type name")
		
		ASTNode* BackingTypeNode := this->ParseTypeNode()
		Type BackingType := BackingTypeNode->ValueType
		
		TypeInfo* BackingBase := GetBaseType(BackingType)
		i32 BackingDepth := GetPointerDepth(BackingType)
		
		if (BackingBase->Is(TYPE_KIND_STRUCTURE) || BackingDepth) {
			; Invalid types for bits backing types
			
			BackingTypeNode->Error("Bits backing type must be a plain integer type.")
		}
		
		i8 BackingTypeSize := GetTypeSize(BackingType) As i8
		i8 BackingTypeSizeBits := (BackingTypeSize * 8) As i8
		
		NewType->Size := BackingTypeSize
		
		this~>Types->Set("self", NewType)
		
		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected opening brace for bits type body.")
		
		loop {
			i8 IsMethod := false
			i8 IsStaticMethod := false
			Token* MethodKeyword := this->PeekNextToken()
			
			if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD)) {
				i8 KeywordValue := MethodKeyword->Value As i8
				
				IsStaticMethod := KeywordValue = KEYWORD_STATIC
				IsMethod := IsStaticMethod || KeywordValue = KEYWORD_DECLARE || KeywordValue = KEYWORD_DEFINE
			}
			
			if (IsMethod) {
				HashMap* MethodNamespace := Methods
				TypeInfo* ThisType := NewType
				
				if (IsStaticMethod) {
					MethodNamespace := StaticMethods
				}
				
				this->ParseFunctionDefinition(MethodNamespace, MethodKeyword, ThisType, !IsStaticMethod)
				
				; Ignore commas after methods, they aren't actually needed for parsing
				this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
				
				if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
					break
				}
				
				continue
			}
		
			StructField* NextField := Alloc(#StructField) As StructField*
			
			Type FieldType := TYPE_NONE
			
			if !(this->PeekNextToken()->Is(TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET)) {
				ASTNode* FieldTypeNode := this->ParseTypeNode()
				
				FieldType := FieldTypeNode->TypeValue
				
				if (GetPointerDepth(FieldType) = 0 && GetBaseType(FieldType)->Is(TYPE_KIND_STRUCTURE)) {
					FieldTypeNode->Error("Structures cannot be contained in `bits` types")
				}
			}
			
			Token* OpenBracket := this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET, "Expected open bracket for bit field range.")
			
			i8 StartIndex := this->Consume(TOKEN_TYPE_INTEGER, "Expected integer for bit field start index.")->Value As i8
			i8 EndIndex := StartIndex
			
			if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_COLON)) {
				EndIndex := this->Consume(TOKEN_TYPE_INTEGER, "Expected integer for bit field end index.")->Value As i8
			}
			
			i8 FieldSize := EndIndex - StartIndex
			
			Token* CloseBracket := this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected close bracket for bit field range.")
			
			OpenBracket~>Context->Merge(CloseBracket~>Context)
			
			if (FieldSize < 0 || FieldSize > BackingTypeSizeBits) {
				OpenBracket->Error("Field size can not be negative, or bigger than the backing type.")
			}
			
			SafeString* FieldName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected bit field name.")->StringValue
			
			NextField->Name := FieldName
			NextField->Offset := BackingTypeSize
			NextField->BitStartIndex := StartIndex
			NextField->BitEndIndex := EndIndex
			
			if (FieldType != TYPE_NONE) {
				NextField->ValueType := FieldType
			}
			else {
				if (FieldSize <= 8) {
					NextField->ValueType := this->i8->AsNonPointer()
				}
				else if (FieldSize <= 16) {
					NextField->ValueType := this->i16->AsNonPointer()
				}
				else if (FieldSize <= 32) {
					NextField->ValueType := this->i32->AsNonPointer()
				}
				else {
					NextField->ValueType := this->i64->AsNonPointer()
				}
			}
			
			Fields->Set(FieldName, NextField)
			
			this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
			
			if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				break
			}
		}
		
		this~>Types->Set("self", null)
	}
	
	define void ParseEnumDefinition() {
		Token* NameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for enum name")
		
		TypeInfo* BaseEnumType := this->ParseCustomTypeName(NameToken, TYPE_KIND_ENUMERATION)
		BaseEnumType->Size := 4
		HashMap* Fields := BaseEnumType~>Fields
		Fields->Initialize()

		if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_AS)) {
			ASTNode* BackingTypeNode := this->ParseTypeNode()
			Type BackingType := BackingTypeNode->ValueType
			
			TypeInfo* BackingBase := GetBaseType(BackingType)
			i32 BackingDepth := GetPointerDepth(BackingType)
			
			if (BackingBase->Is(TYPE_KIND_STRUCTURE) || BackingDepth) {
				; Invalid types for bits backing types
				
				BackingTypeNode->Error("Enum backing type must be a plain integer.")
			}

			BaseEnumType->Size := BackingBase->Size
		}

		Type EnumType := MakeType(BaseEnumType, 0)
		
		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected opening brace for enum type body")
		
		i32 NextValue := 0
		
		loop {
			Token* EnumVariableName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for enum field name")
			
			if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
				NextValue := this->Consume(TOKEN_TYPE_INTEGER, "Expected enum field value")->IntegerValue As i32
			}
			
			if (Fields->Get(EnumVariableName->StringValue)) {
				EnumVariableName->Error("Duplicate definition")
			}

			i32 Value := NextValue++
			
			StructField* MemberField := Alloc(#StructField)
			
			MemberField->DefinedAt := EnumVariableName~>Context
			MemberField->Name := EnumVariableName->StringValue
			MemberField->ValueType := EnumType
			MemberField->EnumValue := Value

			Fields->Set(EnumVariableName->StringValue, MemberField)
			
			i8* RawEnumGlobalName := Alloc(50)
			i32 Length := FormatString(RawEnumGlobalName, 50, "%s_%s", NameToken->StringValue->Buffer, EnumVariableName->StringValue->Buffer)

			RawEnumGlobalName[Length] := 0

			for (i32 Index := 0, Index < Length, Index++) {
				RawEnumGlobalName[Index] := Upper(RawEnumGlobalName[Index])
			}

			SafeString* EnumGlobalName := AToS(RawEnumGlobalName)
			
			VariableInfo* EnumVariable := Alloc(#VariableInfo)
			
			EnumVariable->Name := EnumGlobalName
			EnumVariable->Type := EnumType
			EnumVariable->LastValue := ASTNode:New(NODE_TYPE_INTEGER, Value, EnumType)
			EnumVariable->SetCount := 1
			EnumVariable->IsGlobal := true
			
			this->AddGlobal(EnumVariable, EnumVariableName)
			
			if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
				continue
			}
			else if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				break
			}
		}
		
	}
	
	define i8 ParseProgramStatement() {
		Token* NextToken := this->PeekNextToken()
		i8 NextTokenValue := NextToken->Value As i8
		
		if (NextToken->Is(TOKEN_TYPE_KEYWORD)) {
			this->GetNextToken()
			
			if (NextTokenValue <= KEYWORD_DLLIMPORT) {
				; Handles `dllimport`/`declare`/`define`
				this->ParseFunctionDefinition(this~>Functions, NextToken)
			}
			else if (NextTokenValue = KEYWORD_STRUCT) {
				this->ParseStructDefinition()
			}
			else if (NextTokenValue = KEYWORD_BITS) {
				this->ParseBitsDefinition()
			}
			else if (NextTokenValue = KEYWORD_ENUM) {
				this->ParseEnumDefinition()
			}
			else if (NextTokenValue = KEYWORD_LINUX || NextTokenValue = KEYWORD_WINDOWS) {
				i8 IgnoreBlock := true
				
				if (NextTokenValue = KEYWORD_LINUX && this->Config->OutputFormat = OUTPUT_ELF) {
					IgnoreBlock := false
				}
				else if (NextTokenValue = KEYWORD_WINDOWS && this->Config->OutputFormat = OUTPUT_PE) {
					IgnoreBlock := false
				}
				
				if (IgnoreBlock) {
					this->IgnoreBlock()
				}
				else {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected opening '{' for block")
					
					while !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
						this->ParseProgramStatement()
					}
				}
			}
			else if (NextTokenValue = KEYWORD_EXTERNAL) {
				i8 AllowExternal := this->Config->DebugMode & (DEBUG_EMIT_DYNAMIC | DEBUG_EMIT_OBJECT)

				if !(AllowExternal) {
					NextToken->Error("'--dynamic' or '--object' must be specified to reference external symbols")
				}

				if (this->Config->DebugMode & DEBUG_EMIT_DYNAMIC) {
					Token* ExternalSource := this->Consume(TOKEN_TYPE_STRING, "Expected 'external' declaration source name")

					i8 Exists := false

					for (i32 Index := 0, Index < this->ExternalSources->Count(), Index++) {
						Token* Last := this->ExternalSources->At(Index)

						if (ExternalSource->StringValue->Equals(Last->StringValue)) {
							Exists := true
							break
						}
					}

					if !(Exists) {
						this->ExternalSources->Push(ExternalSource)
					}
				}
				else {
					this->NextTokenMatches(TOKEN_TYPE_STRING)
				}

				i8 Multiple := false

				if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
					Multiple := true
				}

				loop {
					Token* SymbolName := this->PeekNextToken()

					if (SymbolName->Is(TOKEN_TYPE_STRING)) {
						this->GetNextToken()
					}
					else {
						SymbolName := null
					}

					Type ExternalType := this->ParseType(false)
					Token* ExternalName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected 'external' name")

					if !(SymbolName) {
						SymbolName := ExternalName
					}

					VariableInfo* ExternalVariable := Alloc(#VariableInfo)

					ExternalVariable->Name := ExternalName->StringValue
					ExternalVariable->ExternalSymbolName := SymbolName->StringValue
					ExternalVariable->Type := ExternalType
					ExternalVariable->IsGlobal := true
					ExternalVariable->IsExternal := true

					; Artificial because I really don't want to have to deal with this
					ExternalVariable->GetCount := 2
					ExternalVariable->SetCount := 2
					
					this->AddVariable(ExternalVariable, ExternalName)

					if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
						this->GetCurrentTokenContext()->Error("'external' variables cannot be assigned")
					}

					if !(Multiple) {
						break
					}

					if (Multiple && this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
						break
					}

					this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
				}
			}
			else {
				NextToken->Error("Unexpected token")
			}
		}
		else if (NextToken->Is(TOKEN_TYPE_IDENTIFIER)) {
			; Handles global variable declarations
			
			Token* BlameToken := NextToken
			
			i8* ErrorMessage := null
			ASTNode* DefaultValueExpression := this->TryParseVariableDeclaration(true, false, &ErrorMessage)
			
			if (ErrorMessage) {
				BlameToken~>Context->Merge(this->GetCurrentTokenContext())
				BlameToken->Error(ErrorMessage)
			}
			
			if (DefaultValueExpression != null) {
				; Handles global variable default value expressions
				
				i32 Index := GetArrayLength(this->GlobalDefaults)
				this->GlobalDefaults := ReAllocArray(this->GlobalDefaults, 1)
				
				this->GlobalDefaults[Index] := DefaultValueExpression
			}
		}
		else if (NextToken->Is(TOKEN_TYPE_EOF)) {
			return true
		}
		else {
			NextToken->Error("Unexpected token")
		}
		
		return false
	}
	
	define void ParseProgram() {
		; Parse an entire program, aka a list of `dllimport`/`declare`/`define`, `struct`/`bits`, and global
		;  variable declarations.
		
		loop {
			if (this->ParseProgramStatement()) {
				break
			}
		}
	}
}