; TODO: Add a divmod built-in, the `x / constant` with `x % constant` pattern is getting annoying.

bits Type As i64 {
	[0:47] BaseType,
	[48:49] IsArray,
	[50:63] PointerDepth
}

Type TYPE_NONE := 0 As Type

i8 GLOBAL_IS_OPTIMIZED_AWAY := 2

struct VariableInfo {
	ASTNode* LastValue,
	SafeWideString* Name,
	Type Type,
	i32 StackOffset,
	i16 GetCount,
	i16 SetCount,
	i8 IsGlobal,
	i8 IsParameter,
	i8 IsVariadic,
	i8 IsThis
}

declare i16 GetTypeStorageSize(Type)

struct VariableHashMap {
	HashMap BackingMap
	HashMap* Map
	i32 NextOffset
	
	define void Initialize() {
		this->Map := this~>BackingMap
		
		this->Map->BufferMaxCount := 100
		this->Map->Elements := Alloc(this->Map->BufferMaxCount * 8)
		
		this->NextOffset := 0
	}
	
	define VariableInfo* Get(SafeWideString* VariableName) {
		HashMapElement* FoundElement := this->Map->Get(VariableName)
		
		if (FoundElement) {
			return FoundElement->Value As VariableInfo*
		}
		
		return null
	}
	
	define void Add(VariableInfo* NewVariable, Token* SourceToken) {
		if (this->Get(NewVariable->Name)) {
			/* If we already have this name in the hashmap, then it's a duplicate definition */
			
			SourceToken->Error("Duplicate definition")
		}
		
		this->Map->Set(NewVariable->Name, NewVariable)
		
		NewVariable->StackOffset := this->NextOffset
		
		i16 NewVariableSize := GetTypeStorageSize(NewVariable->Type)
		
		if (NewVariableSize <= 8) {
			this->NextOffset += 8
		}
		else {
			i16 RoundedSize := RoundTo(NewVariableSize, 8) As i16
			
			NewVariable->StackOffset += RoundedSize
			
			this->NextOffset += RoundedSize + 8
		}
	}
}

#Require "./src/compiler/Parser/AST.rlx"
#Require "./src/compiler/Parser/Types.rlx"

i8 TYPE_REGULAR := 1
i8 TYPE_STRUCT := 2
i8 TYPE_INCOMPLETE := 4
i8 TYPE_BITS := 8
i8 TYPE_ARRAY := 16

; Holds the entire state of the parser

struct ParserState {
	BuildConfig* Config,
	LexerState* Lexer,
	
	HashMap Functions,
	
	VariableHashMap Globals,
	ASTNode** GlobalDefaults,
	
	HashMap Registers,
	HashMap Instructions,
	
	HashMap Types,
	
	/* Builtin types, actually added to the type list in CreateDefaultTypes */
	
	TypeInfo* i8,
	TypeInfo* i16,
	TypeInfo* i32,
	TypeInfo* i64,
	TypeInfo* void,
	
	FunctionDefine* CurrentFunction,
	FunctionDefine* MainFunction,
	
	i8* GlobalConstantsBuffer
	i32 GlobalConstantBufferSize
	
	i8 InLoop,
	
	i32 LabelCount
	
	declare TypeInfo* AddType(i8*, i16, i8)
	declare void SetupAssembly()
	
	static ParserState* New(BuildConfig* Config, LexerState* Lexer) {
		ParserState* this := Alloc(#ParserState)
		
		this->Config := Config
		this->Lexer := Lexer
		
		this~>Globals->Initialize()
		this~>Functions->Initialize()
		this~>Types->Initialize()
		
		this->GlobalDefaults := AllocArray(8, 0)
		this->GlobalConstantsBuffer := Alloc(4)
		
		this->i8 := this->AddType("i8", 1, TYPE_REGULAR)
		this->i16 := this->AddType("i16", 2, TYPE_REGULAR)
		this->i32 := this->AddType("i32", 4, TYPE_REGULAR)
		this->i64 := this->AddType("i64", 8, TYPE_REGULAR)
		this->void := this->AddType("void", 8, TYPE_REGULAR)
		
		this->SetupAssembly()
		
		return this
	}
	
	define TypeInfo* AddType(SafeWideString* Name, i16 Size, i8 Flags) {
		TypeInfo* NewType := Alloc(#TypeInfo)
		
		NewType->Name := Name
		NewType->Size := Size
	
		if (Flags & TYPE_STRUCT) {
			NewType->IsStructType := true
		}
		
		if (Flags & TYPE_INCOMPLETE) {
			NewType->IsIncomplete := true
		}
		
		if (Flags & TYPE_BITS) {
			NewType->IsBits := true
		}
		
		if (Flags & TYPE_REGULAR) {
			NewType->IsBuiltin := true
		}
		
		this~>Types->Set(Name, NewType)
		
		return NewType
	}
	define TypeInfo* AddType(i8* Name, i16 Size, i8 Flags) {
		return this->AddType(AToS(Name), Size, Flags)
	}
	
	declare Token* GetCurrentToken()
	
	define Type TryFindType(SafeWideString* TypeName, i16 PointerDepth, i8** ErrorMessage) {
		HashMapElement* FoundTypeInfoElement := this~>Types->Get(TypeName)
		TypeInfo* FoundTypeInfo := null
		
		if (FoundTypeInfoElement) {
			FoundTypeInfo := FoundTypeInfoElement->Value As TypeInfo*
		}
		else {
			if (PointerDepth = 0) {
				*ErrorMessage := "Undefined type (Incomplete types can only be pointed-to)"
				
				return TYPE_NONE
			}
			else {
				FoundTypeInfo := this->AddType(TypeName, 0, TYPE_STRUCT | TYPE_INCOMPLETE)
			}
		}
		
		return FoundTypeInfo->AsPointer(PointerDepth)
	}
	define Type FindType(SafeWideString* TypeName, i16 PointerDepth) {
		i8* ErrorMessage := null
		
		Type Result := this->TryFindType(TypeName, PointerDepth, &ErrorMessage)
		
		if (ErrorMessage) {
			this->GetCurrentToken()->Error(ErrorMessage)
		}
		
		return Result
	}
	
	define Type DereferencePointerType(Type TypeToDecrement, ErrorContext* BlameContext) {
		i16 PointerDepth := GetPointerDepth(TypeToDecrement)
		
		if (PointerDepth = 0) {
			BlameContext->Error("Pointer type expected")
		}
		
		return GetBaseType(TypeToDecrement)->AsPointer(PointerDepth - 1 As i16)
	}
	define Type PointerToType(Type TypeToIncrement) {
		return GetBaseType(TypeToIncrement)->AsPointer(GetPointerDepth(TypeToIncrement) + 1 As i16)
	}
	
	define Type GetNumberType(i64 Number) {
		if (Number & 0xFFFF_FFFF_8000_0000) {
			return this->i64->AsNonPointer()
		}
		else {
			return this->i32->AsNonPointer()
		}
	}
	
	define ASTNode* DowncastIntegerNode(ASTNode* Target) {
		if (Target->NodeType != NODE_TYPE_INTEGER) {
			return Target
		}
		
		i8 Size := GetNumberSize(Target->IntegerValue)
		TypeInfo* BaseType := this->i8
		
		if (Size = 2) {BaseType := this->i16}
		else if (Size = 4) {BaseType := this->i32}
		else if (Size = 8) {BaseType := this->i64}
		
		Target->ValueType := BaseType->AsNonPointer()
		
		return Target
	}
	
	define VariableInfo* FindVariable(Token* NameToken) {
		; Finds a variable, prioritizing locals over globals
		
		SafeWideString* VariableName := NameToken->StringValue
		
		FunctionDefine* CurrentFunction := this->CurrentFunction
		VariableInfo* FoundVariable := null
		
		if (CurrentFunction) {
			; If we are in a function, try to find the variable in the locals
			FoundVariable := CurrentFunction~>Locals->Get(VariableName)
		}
		
		if !(FoundVariable) {
			; If we didn't find the variable in the locals, then check the globals
			FoundVariable := this~>Globals->Get(VariableName)
			
			if (CurrentFunction) {
				CurrentFunction->UsesGlobals := true
			}
		}
		
		if !(FoundVariable) {
			; If we still haven't found the variable, then it is undefined
			
			NameToken->Error("Undefined variable")
		}
		
		; Variable has to have been found at some point for this to be reached
		
		return FoundVariable
	}
	define void AddGlobal(VariableInfo* NewGlobal, Token* BlameToken) {
		this~>Globals->Add(NewGlobal, BlameToken)
	}
	define void AddLocal(VariableInfo* NewLocal, Token* BlameToken) {
		this->CurrentFunction~>Locals->Add(NewLocal, BlameToken)
	}
	define void AddVariable(VariableInfo* NewVariable, Token* BlameToken) {
		if (NewVariable->IsGlobal) {
			this->AddGlobal(NewVariable, BlameToken)
		}
		else {
			this->AddLocal(NewVariable, BlameToken)
		}
	}
	
	define i32 Freeze() {
		return this->Lexer->TokenIndex
	}
	define void Unfreeze(i32 FrozenState) {
		this->Lexer->TokenIndex := FrozenState
	}
	define Token* GetCurrentToken() {
		return this->Lexer->GetCurrentToken()
	}
	define ErrorContext* GetCurrentTokenContext() {
		return this->Lexer->GetCurrentTokenContext()
	}
	define Token* GetNextToken() {
		return this->Lexer->GetNextToken()
	}
	define Token* PeekNextToken() {
		i32 Before := this->Freeze()
		
		Token* Result := this->Lexer->GetNextToken()
		
		this->Unfreeze(Before)
		
		return Result
	}
	define i8 NextTokenMatches(i8 TokenType, i64 TokenValue) {
		if (this->PeekNextToken()->Is(TokenType, TokenValue)) {
			this->GetNextToken()
			
			return true
		}
		
		return false
	}
	define i8 NextTokenMatches(i8 TokenType) {
		if (this->PeekNextToken()->Is(TokenType)) {
			this->GetNextToken()
			
			return true
		}
		
		return false
	}
	define Token* TryConsume(i8 TokenType, i64 TokenValue, i8* Reason, i8** ErrorMessage) {
		Token* NextToken := this->GetNextToken()
		
		if (NextToken->Is(TOKEN_TYPE_EOF, 0)) {
			*ErrorMessage := "Unexpected end of file"
		}
		else if !(NextToken->Is(TokenType, TokenValue)) {
			*ErrorMessage := Reason
		}
		
		return NextToken
	}
	define Token* TryConsume(i8 TokenType, i8* Reason, i8** ErrorMessage) {
		return this->TryConsume(TokenType, 0, Reason, ErrorMessage)
	}
	define Token* Consume(i8 TokenType, i64 TokenValue, i8* Reason) {
		i8* ErrorMessage := null
		
		Token* Result := this->TryConsume(TokenType, TokenValue, Reason, &ErrorMessage)
		
		if (ErrorMessage) {
			Result->Error(ErrorMessage)
		}
		
		return Result
	}
	define Token* Consume(i8 TokenType, i8* Reason) {
		return this->Consume(TokenType, 0, Reason)
	}
	
	define Type TryParseType(i8 AllowArrayType, i8** ErrorMessage) {
		Token* NameToken := this->TryConsume(TOKEN_TYPE_IDENTIFIER, "Type names must be identifiers", ErrorMessage)
		
		if *(ErrorMessage) {
			return TYPE_NONE
		}
		
		i8 PointerDepth := 0
		
		while (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_STAR)) {
			PointerDepth += 1
		}
		
		Type Result := this->TryFindType(NameToken->StringValue, PointerDepth, ErrorMessage)
		
		if (AllowArrayType && this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
			Token* SizeToken := this->TryConsume(TOKEN_TYPE_INTEGER, "Expected array type size", ErrorMessage)
			
			if (*ErrorMessage = null) {
				TypeInfo* ResultBase := GetBaseType(Result)
				
				if (ResultBase->IsIncomplete && PointerDepth = 0) {
					NameToken->Error("Array types must not be incomplete")
				}
				
				Result := MakeArrayType(Result, SizeToken->IntegerValue As i16)
				Result.IsArray := true
				
				this->TryConsume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}' for array type", ErrorMessage)
			}
		}
		
		return Result
	}
	define Type ParseType(i8 AllowArrayType) {
		i8* ErrorMessage := null
		Token* BlameToken := this->PeekNextToken()
		
		Type Result := this->TryParseType(AllowArrayType, &ErrorMessage)
		
		if (ErrorMessage) {
			BlameToken->Error(ErrorMessage)
		}
		
		return Result
	}
	define Type ParseType() {
		return this->ParseType(false)
	}
	define ASTNode* ParseTypeNode() {
		Token* FirstToken := this->PeekNextToken()
		Type Result := this->ParseType()
		
		ASTNode* ResultNode := ASTNode:New(NODE_TYPE_TYPE, Result As i64, Result)
		
		ResultNode~>Context->Clone(FirstToken~>Context)->Merge(this->GetCurrentTokenContext())
		
		return ResultNode
	}
	
	define FunctionDefine* LookupStaticMethod(Token* TypeNameToken, Token* StaticMethodNameToken) {
		HashMapElement* TypeElement := this~>Types->Get(TypeNameToken->StringValue)
		
		if !(TypeElement) {
			TypeNameToken->Error("Undefined type")
		}
		
		TypeInfo* TargetType := TypeElement->Value As TypeInfo*
		
		HashMapElement* FoundFunctionElement := TargetType~>StaticMethods->Get(StaticMethodNameToken->StringValue)
		
		if !(FoundFunctionElement) {
			StaticMethodNameToken->Error("Undefined static method")
		}
		
		return FoundFunctionElement->Value As FunctionDefine*
	}
	
	#Require "./src/compiler/Parser/Expression.rlx"
	
	define ASTNode* ParseInitializer(ASTNode* ForNode) {
		Type ForType := ForNode->ValueType
		
		i8 IsArray := ForType.IsArray
		i16 ForTypeDepth := GetPointerDepth(ForType)
		TypeInfo* ForBaseType := GetBaseType(ForType)
		
		if (ForTypeDepth = 0 && ForBaseType->IsStructType) {
			i16 InitializerCapacity := 20
			ASTNode** Initializers := Alloc(InitializerCapacity * #ASTNode*) As ASTNode**
			
			i16 InitializerIndex := 0
			i8 IsFirstInitializer := true
			
			while (IsFirstInitializer || this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
				Token* FieldName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected initializer field name")
				
				this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_COLON, "Expected ':' after initializer field name")
				
				HashMapElement* FieldElement := ForBaseType~>Fields->Get(FieldName->StringValue)
				
				if (FieldElement = null) {
					FieldName->Error("Unknown struct field")
				}
				
				StructField* Field := FieldElement->Value
				i8 FieldIsStruct := GetPointerDepth(Field->ValueType) = 0 && GetBaseType(Field->ValueType)->IsStructType
				i8 FieldIsArray := Field->ValueType.IsArray
				
				; Build a node for `ForNode.Field`
				
				StructAccessExpression* Access := Alloc(#StructAccessExpression)
				
				Access->Left := ForNode
				Access->Operator := Alloc(#Token)
				Access->Operator->Type := TOKEN_TYPE_OPERATOR
				Access->Operator->IntegerValue := OPERATOR_DOT
				Access->TargetField := Field
				
				if (FieldIsArray) {
					Access->Operator->IntegerValue := OPERATOR_TILDE_GREATER
				}
				
				; Parse any initializers for `ForNode.Field`
				
				if (FieldIsStruct || FieldIsArray) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected '{' for field initializer")
				}
				
				ASTNode* AccessNode := ASTNode:New(NODE_TYPE_STRUCT_ACCESS, Access, Field->ValueType)
				ASTNode* InitializerValue := this->ParseInitializer(AccessNode)
				
				if (FieldIsStruct || FieldIsArray) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}' for field initializer")
				}
				
				; If `ForNode.Field` is a struct, then we don't want to assign `ForNode.Field` to anything, since
				;  there is no value to assign, merely a block of initializers for `ForNode.Field` itself which
				;   should be directly executed
				
				if (FieldIsStruct || FieldIsArray) {
					Initializers[InitializerIndex] := InitializerValue
				}
				else {
					BinaryExpression* Assign := Alloc(#BinaryExpression)
					
					Assign->Left := AccessNode
					Assign->Operator := Alloc(#Token)
					Assign->Operator->Type := TOKEN_TYPE_OPERATOR
					Assign->Operator->IntegerValue := OPERATOR_COLON_EQUAL
					Assign->Right := InitializerValue
					
					Initializers[InitializerIndex] := ASTNode:New(NODE_TYPE_BINARY, Assign, Field->ValueType)
				}
				
				InitializerIndex += 1
				IsFirstInitializer := false
			}
			
			Block* InitializersBlock := Alloc(#Block) As Block*
			
			InitializersBlock->Statements := Initializers
			InitializersBlock->StatementCount := InitializerIndex
			
			return ASTNode:New(NODE_TYPE_EXPRESSION_BLOCK, InitializersBlock)
		}
		else if (IsArray) {
			ArrayTypeInfo* ForArrayType := GetArrayType(ForType)
			Type ElementType := ForArrayType->BaseType->AsPointer(ForTypeDepth - 1 As i16)
			
			ASTNode** ElementInitiailizers := Alloc(ForArrayType->Length * #ASTNode*)
			
			for (i16 Index := 0, Index < ForArrayType->Length, Index += 1) {
				BinaryExpression* ArrayAccess := Alloc(#BinaryExpression)
				
				ArrayAccess->Left := ForNode
				ArrayAccess->Operator := Alloc(#Token)
				ArrayAccess->Operator->Type := TOKEN_TYPE_OPERATOR
				ArrayAccess->Operator->IntegerValue := OPERATOR_OPEN_BRACKET
				ArrayAccess->Right := ASTNode:New(NODE_TYPE_INTEGER, Index, this->i32->AsNonPointer())
				
				i8 InitializerIsStruct := GetPointerDepth(ElementType) = 0 && GetBaseType(ElementType)->IsStructType
				
				if (InitializerIsStruct) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected '{' for field initializer")
				}
				
				ASTNode* ArrayAccessNode := ASTNode:New(NODE_TYPE_BINARY, ArrayAccess, ElementType)
				ASTNode* ElementInitiailizer := this->ParseInitializer(ArrayAccessNode)
				
				if (InitializerIsStruct) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}' for field initializer")
					
					ElementInitiailizers[Index] := ElementInitiailizer
				}
				else {
					CheckTypes(this->void, ElementInitiailizer->ValueType, ElementType, ElementInitiailizer)
					
					BinaryExpression* ElementAssign := Alloc(#BinaryExpression)
					
					ElementAssign->Left := ArrayAccessNode
					ElementAssign->Operator := Alloc(#Token)
					ElementAssign->Operator->Type := TOKEN_TYPE_OPERATOR
					ElementAssign->Operator->IntegerValue := OPERATOR_COLON_EQUAL
					ElementAssign->Right := ElementInitiailizer
					
					ElementInitiailizers[Index] := ASTNode:New(NODE_TYPE_BINARY, ElementAssign, ElementType)
				}
				
				if !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
					break
				}
			}
			
			Block* ArrayInitializersBlock := Alloc(#Block) As Block*
			
			ArrayInitializersBlock->Statements := ElementInitiailizers
			ArrayInitializersBlock->StatementCount := (Index + 1) As i16
			
			return ASTNode:New(NODE_TYPE_EXPRESSION_BLOCK, ArrayInitializersBlock)
		}
		else {
			ASTNode* InitializerExpression := this->ParseExpression()
			
			if (InitializerExpression->NodeType = NODE_TYPE_INTEGER) {
				InitializerExpression := this->DowncastIntegerNode(InitializerExpression)
			}
			
			CheckTypes(this->void, InitializerExpression->ValueType, ForType, InitializerExpression)
			
			return InitializerExpression
		}
	}
	
	define ASTNode* TryParseVariableDeclaration(i8 ForGlobalVariable, i8 ForParameter, i8** ErrorMessage, VariableInfo** OutNewVariable) {
		; Try to parse the declaration of a single variable (which can be local, global, or a parameter)
		;  and returns an expression which will set that variable to an optional default value (if allowed)
		
		Token* MaybeAuto := this->PeekNextToken()
		
		if (ForParameter = false && MaybeAuto->Is(TOKEN_TYPE_IDENTIFIER) && MaybeAuto->StringValue->Equals("auto")) {
			this->GetNextToken()
			
			Token* AutoVariableName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for auto variable name")
			Token* AssignmentOperator := this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL, "Expected `:=` for auto variable declaration")
			
			; Add the variable early (as void*) just in case the expression somehow references the variable
			;  (and would throw a parse error)
			
			VariableInfo* AutoVariable := Alloc(#VariableInfo)
			
			AutoVariable->Name := AutoVariableName->StringValue
			AutoVariable->Type := this->void->AsPointer(1)
			AutoVariable->IsGlobal := ForGlobalVariable
			AutoVariable->IsParameter := ForParameter
			
			if (OutNewVariable != 0) {
				*OutNewVariable := AutoVariable
			}
			
			this->AddVariable(AutoVariable, AutoVariableName)
			
			; Parse the variable's initial value, and then update the variable's type using the type of the
			;  initial value
			
			ASTNode* AutoValue := this->ParseExpression()
			AutoVariable->Type := AutoValue->ValueType
			
			; Build an AST node to assign the variable to the initial value, and then return it for the caller
			;  to compile before this variable is used
			
			BinaryExpression* AutoAssign := Alloc(#BinaryExpression)
			
			AutoAssign->Left := ASTNode:New(NODE_TYPE_VARIABLE, AutoVariable, AutoVariable->Type)
			AutoAssign->Operator := AssignmentOperator
			AutoAssign->Right := AutoValue
			
			return ASTNode:New(NODE_TYPE_BINARY, AutoAssign, AutoVariable->Type)
		}
		
		i32 Before := this->Freeze()
		Type PotentialType := this->TryParseType(true, ErrorMessage)
		
		if (PotentialType != TYPE_NONE && *ErrorMessage = null) {
			; If we could parse a full type name, then we *might* be dealing with a variable declaration.
			;  But we're not sure yet.
			
			i32 DefaultValueExpressionStart := this->Freeze()
			
			if (this->NextTokenMatches(TOKEN_TYPE_IDENTIFIER)) {
				Token* NameToken := this->GetCurrentToken()
				
				; Alright, we've got `Type Name`, which is definitely a variable declaration.
				; So we build up a VariableInfo struct for it, and add it to the correct scope.
				
				VariableInfo* NewVariable := Alloc(#VariableInfo)
				
				NewVariable->Name := NameToken->StringValue
				NewVariable->Type := PotentialType
				NewVariable->IsGlobal := ForGlobalVariable
				NewVariable->IsParameter := ForParameter
				
				if (OutNewVariable != 0) {
					*OutNewVariable := NewVariable
				}
				
				this->AddVariable(NewVariable, NameToken)
				
				; If we're declaring a local/global (but not a parameter) allow for an optional default value
				;  expression after, marked by `Type Name` being followed by the `:=` operator.
				
				; Note: the parser needs to backtrack to before `Name :=` and parse the entire `Name := Value` 
				;  expression if it is present
				
				if (ForParameter = false && this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
					this->Unfreeze(DefaultValueExpressionStart)
					
					return this->ParseExpression()
				}
				else if (ForParameter = false && this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
					ASTNode* NewVariableNode := ASTNode:New(NODE_TYPE_VARIABLE, NewVariable, PotentialType)
					
					ASTNode* InitializersBlock := this->ParseInitializer(NewVariableNode)
					
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}'")
					
					return InitializersBlock
				}
				else {
					return null
				}
			}
			else {
				*ErrorMessage := "Variable names must be identifiers"
			}
		}
		
		this->Unfreeze(Before)
		
		return null
	}
	define ASTNode* TryParseVariableDeclaration(i8 ForGlobalVariable, i8 ForParameter, i8** ErrorMessage) {
		return this->TryParseVariableDeclaration(ForGlobalVariable, ForParameter, ErrorMessage, null As VariableInfo**)
	}
	
	#Require "./src/compiler/Parser/Assembly.rlx"
	#Require "./src/compiler/Parser/Statement.rlx"
	
	define FunctionDefine* ParseFunctionDefinition(HashMap* Namespace, Token* FirstToken, TypeInfo* ThisType, i8 ForMethod) {
		i8 Mode := FirstToken->Value As i8
		
		i8 ForStatic := Mode = KEYWORD_STATIC
		i8 ForDefine := Mode = KEYWORD_DEFINE || ForStatic
		i8 ForImport := Mode = KEYWORD_DLLIMPORT
		
		Type ReturnType := this->ParseType()		
		Token* NameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected function name")
		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Expected opening '(' for function parameter list")
		
		if (ForDefine) {
			; For define statements, any parameters are added as locals, meaning that this->CurrentFunction 
			;  needs to be set to prevent `this->AddLocal` inside of the parameter list parsing from crashing
			
			; `Locals` is copied onto the actual `FunctionDefine*` for this function after the parameters have 
			; been parsed, and the matching overload has been found (if it exists)
			
			FunctionDefine TempDefine
			
			TempDefine~>Locals->Initialize()
			
			this->CurrentFunction := &TempDefine
		}
		
		i8 ParameterCount := 0
		VariableInfo** ParameterList := Alloc(16 * #VariableInfo) As VariableInfo**
		
		if (ForMethod) {
			; If we are defining a method, then we need to build the `this` parameter, and insert it into the 
			;  parameter list
	
			VariableInfo* ThisParameter := Alloc(#VariableInfo)
			ThisParameter->Name := AToS("this")
			ThisParameter->Type := ThisType->AsPointer(1)
			ThisParameter->IsParameter := true
			ThisParameter->IsThis := true
			
			if (ForDefine) {
				; Only actually add `this` as a local when we are defining a full function, and 
				;  have this->CurrentFunction set
				
				this->AddLocal(ThisParameter, null)
			}
			
			ParameterList[0] := ThisParameter
			ParameterCount += 1
		}
		
		i8 Attribute := 0
		
		if !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
			; Only bother parsing parameters if we actually have any
			
			loop {
				VariableInfo* NextParameter := Alloc(#VariableInfo)
				
				; Max parameter count since I cba to expand the buffer. Todo: Fix this
				if (ParameterCount >= 16) {
					this->GetNextToken()->Error("Max parameter limit reached")
				}
				
				ParameterList[ParameterCount] := NextParameter
				
				i8 ShouldBreak := false
				
				if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
					ShouldBreak := true
					
					ErrorContext* Start := this->GetCurrentTokenContext()
					
					this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected '.' for variadic marker")
					this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected '.' for variadic marker")
					
					if (ParameterCount > 4) {
						Start->Merge(this->GetCurrentTokenContext())
						Start->Error("Only >4 regular paremeters can be passed with a variable argument.")
					}
					
					Attribute := OPERATOR_DOT
					
					NextParameter->Type := this->void->AsPointer(1)
					NextParameter->IsParameter := true
				}
				else {
					NextParameter->Type := this->ParseType()
				}
				
				if (ForDefine) {
					Token* NextParameterNameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Parameter names must be identifiers")
					NextParameter->Name := NextParameterNameToken->StringValue
					this->AddLocal(NextParameter, NextParameterNameToken)
				}
				
				NextParameter->IsGlobal := false
				NextParameter->IsParameter := true
				NextParameter->StackOffset := (ParameterCount * 8)
				
				ParameterCount += 1
				
				if (ShouldBreak) {
					break
				}
				else if !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
					; If the next token isn't a comma, then break the loop, otherwise consume the command and 
					;  continue
					
					break
				}
			}
			
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing ')' for parameter list")
		}
		
		HashMapElement* FoundFunctionElement := Namespace->Get(NameToken->StringValue)
		
		FunctionDefine* NewDefine := null
		FunctionDefine* TailFunction := null
		
		if (FoundFunctionElement != null) {
			; This is a function overload, find the tail of the overload linked list, and check that
			;  our parameters aren't the same as any other definition's parameters
			
			FunctionDefine* NextFunction := FoundFunctionElement->Value As FunctionDefine*
			
			loop {
				; For each definition of this name
				
				if (NextFunction->ParameterCount = ParameterCount) {
					if (CheckTypeSignature(NextFunction, ParameterList)) {
						; Allow redefining a declared overload
						
						if (NextFunction->HasFullDefinition) {
							NameToken->Error("Duplicate function definition")
						}
						
						NewDefine := NextFunction
						
						break
					}
				}
				
				if !(NextFunction->Next) {
					break
				}
				
				NextFunction := NextFunction->Next
			}
			
			TailFunction := NextFunction
		}
		
		if (NewDefine = null) {
			; If we didn't find `declare`d version of this function with the same parameter type set, then
			;  allocate a new node instead of reusing the (non-existent) `declare`d one.
			
			NewDefine := Alloc(#FunctionDefine)
			
			if (TailFunction) {
				TailFunction->Next := NewDefine
			}
			else {
				Namespace->Set(NameToken->StringValue, NewDefine)
			}
			
			NewDefine->LabelNumber := this->LabelCount
			this->LabelCount += 1
		}
		
		; By here, NewDefine 100% holds a FunctionDefine struct for this function, which is added to whichever 
		;  scope it needs to be.
		
		NewDefine->Name := NameToken->StringValue
		NewDefine->ReturnType := ReturnType
		NewDefine->Attribute := Attribute
		NewDefine->Parameters := ParameterList
		NewDefine->ParameterCount := ParameterCount
		
		; `FUNCTION_IS_METHOD` when `ForStatic` is false, and
		; `FUNCTION_IS_STATIC_METHOD` when `ForStatic` is true
		; `0`/false when neither is true
		NewDefine->IsMethod := ForMethod | (ForStatic << 1) As i8
		
		if (NewDefine->IsMethod) {
			NewDefine->MethodOfTypeName := ThisType->Name
		}
		
		if (ForDefine) {
			; Only copy the variable map containing the parameter locals if it... exists.
			
			MoveMemory(NewDefine~>Locals, TempDefine~>Locals, #VariableHashMap)
		}
		
		NewDefine~>Context->Clone(FirstToken~>Context)->Merge(this->GetCurrentTokenContext())
		
		; We are done parsing the function's name, return type, and parameters. Now to just handle all of
		;  the different function body types.
		
		if (ForImport) {
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Import source must have a prior '{'")
			
			SafeWideString* FileName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Import source file name expected")->StringValue
			
			if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
				this->Consume(TOKEN_TYPE_IDENTIFIER, "Import source file extension expected")
			}
			
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA, "Comma expected between import source file and function names")
			
			SafeWideString* FunctionName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Import source function name expected")->StringValue
			
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}'")
			
			NewDefine->IsImported := true
			NewDefine->ImportFileName := FileName
			NewDefine->ImportFunctionName := FunctionName
		}
		else if (ForDefine) {
			this->CurrentFunction := NewDefine
			
			if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_ASSEMBLY)) {
				NewDefine->Attribute := KEYWORD_ASSEMBLY
				
				NewDefine->AssemblyBody := this->ParseAssembly(false)->AssemblyValue
			}
			else {
				if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_X64)) {
					NewDefine->Attribute := KEYWORD_X64
				}
				
				i32 Length := 4
				i8* Buffer := Alloc(Length)
				
				if (this->Config->DebugMode & DEBUG_EMIT_FUNCTION_NAMES) {
					Length := NewDefine->GetStringLength()
					Buffer := ReAlloc(Buffer, Length)
					
					NewDefine->StringifyInto(Buffer)
					
					NewDefine->StringBufferSize := Length
				}
				
				NewDefine->StringBuffer := Buffer
				
				NewDefine->Body := this->ParseBlock()
				
				if (NewDefine->ReturnType != this->void->AsNonPointer()) {
					if !(NewDefine->Body->HasUnconditionalReturn) {
						NewDefine~>Context->Error("Function has non-void return type, but no unconditional return statement")
					}
				}
			}
			
			NewDefine->HasFullDefinition := true
			this->CurrentFunction := null
		
			if (!ForMethod && NameToken->StringValue->Equals("Main")) {
				this->MainFunction := NewDefine
			}
		}
		
		return NewDefine
	}
	define FunctionDefine* ParseFunctionDefinition(HashMap* Namespace, Token* FirstToken) {
		return this->ParseFunctionDefinition(Namespace, FirstToken, null, false)
	}
	
	define TypeInfo* ParseCustomTypeName(Token* NameToken, i8 Flags) {
		SafeWideString* Name := NameToken->StringValue
		
		TypeInfo* NewType := null
		HashMapElement* FoundTypeElement := this~>Types->Get(Name)
		
		if (FoundTypeElement) {
			; Check for a type with this name already existing
			
			NewType := FoundTypeElement->Value As TypeInfo*
			
			if !(NewType->IsIncomplete) {
				; If the type we found isn't incomplete, then error out
				
				NameToken->Error("Duplicate struct definition")
			}
			
			NewType->IsIncomplete := false
		}
		else {
			; We didn't find a type by this name, so we can add it like normal
			
			NewType := this->AddType(Name, 0, Flags)
		}
		
		return NewType
	}
	
	define void ParseStructDefinition() {
		Token* NameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for struct name")
		
		TypeInfo* NewType := this->ParseCustomTypeName(NameToken, TYPE_STRUCT)
		
		; All of the "namespaces" a TypeInfo structure contains need to be initialized
		
		HashMap* Fields := NewType~>Fields
		HashMap* Methods := NewType~>Methods
		HashMap* StaticMethods := NewType~>StaticMethods
		
		Fields->Initialize()
		Methods->Initialize()
		StaticMethods->Initialize()
		
		i8 IsUnaligned := this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_UNALIGNED)
		
		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for struct body")
		
		i16 NextFieldOffset := 0
		i16 TotalSize := 0
		i8 InUnion := false
		i16 MaxUnionSize := 0
		
		loop {
			StructField* NextField := Alloc(#StructField) As StructField*
			
			if !(InUnion) {
				if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_UNION)) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for union body.")
					
					InUnion := true
				}
				else {
					i8 IsMethod := false
					i8 IsStaticMethod := false
					Token* MethodKeyword := this->PeekNextToken()
					
					if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD)) {
						i8 KeywordValue := MethodKeyword->Value As i8
						
						IsStaticMethod := KeywordValue = KEYWORD_STATIC
						IsMethod := IsStaticMethod || KeywordValue = KEYWORD_DECLARE || KeywordValue = KEYWORD_DEFINE
					}
					
					if (IsMethod) {
						HashMap* MethodNamespace := Methods
						TypeInfo* ThisType := NewType
						
						if (IsStaticMethod) {
							MethodNamespace := StaticMethods
						}
						
						this->ParseFunctionDefinition(MethodNamespace, MethodKeyword, ThisType, !IsStaticMethod)
						
						; Ignore commas after methods, they aren't actually needed for parsing
						this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
						
						if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
							break
						}
						
						continue
					}
				}
			}
			
			NextField->ValueType := this->ParseType(true)
			
			Token* FieldNameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for struct field name")
			SafeWideString* FieldName := FieldNameToken->StringValue
			NextField->Name := FieldName
			
			if (Fields->Get(FieldName)) {
				FieldNameToken->Error("Duplicate definition")
			}
			
			Fields->Set(FieldName, NextField)
			
			i16 FieldSize := GetTypeStorageSize(NextField->ValueType)
			
			; Only align the field if it isn't a struct, array, union, and if this structure isn't unaligned 
			
			if (GetPointerDepth(NextField->ValueType) = 0 && GetBaseType(NextField->ValueType)->IsStructType) {
				; Dummy branch
			}
			else if (InUnion || IsUnaligned) {
				; Dummy branch
			}
			else if (NextField->ValueType.IsArray) {
				; Dummy branch
			}
			else if (NextFieldOffset % FieldSize) {
				; Pad the field's offset to a multiple of its size
				
				NextFieldOffset += FieldSize - (NextFieldOffset % FieldSize)
			}
			
			; If we're in a union, don't change the NextFieldOffset so all union fields get overlapping offsets
			
			NextField->Offset := NextFieldOffset
			
			if (InUnion) {
				if (FieldSize > MaxUnionSize) {
					MaxUnionSize := FieldSize
				}
			}
			else {
				NextFieldOffset += FieldSize
			}
			
			TotalSize := NextFieldOffset
			
			if (InUnion && this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				InUnion := false
				NextFieldOffset += MaxUnionSize
				TotalSize := NextFieldOffset
			}
			
			; Ignore commas after fields, since they aren't needed for parsing
			this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
			
			if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				break
			}
		}
		
		NewType->Size := TotalSize
		NewType->IsStructType := true
		NewType->IsIncomplete := false
	}
	
	define void ParseBitsDefinition() {
		Token* NameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for struct name")
		
		TypeInfo* NewType := this->ParseCustomTypeName(NameToken, TYPE_BITS)
		
		HashMap* Fields := NewType~>Fields
		
		Fields->Initialize()
		
		this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_AS, "Expected 'as' before bits backing type name")
		
		ASTNode* BackingTypeNode := this->ParseTypeNode()
		Type BackingType := BackingTypeNode->ValueType
		
		TypeInfo* BackingBase := GetBaseType(BackingType)
		i32 BackingDepth := GetPointerDepth(BackingType)
		
		if (BackingBase->IsStructType || BackingDepth) {
			; Invalid types for bits backing types
			
			BackingTypeNode->Error("Bits backing type must be a plain integer type.")
		}
		
		i8 BackingTypeSize := GetTypeSize(BackingType) As i8
		i8 BackingTypeSizeBits := (BackingTypeSize * 8) As i8
		
		NewType->Size := BackingTypeSize
		
		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected opening brace for bits type body.")
		
		loop {
			StructField* NextField := Alloc(#StructField) As StructField*
			
			Token* OpenBracket := this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET, "Expected open bracket for bit field range.")
			
			i8 StartIndex := this->Consume(TOKEN_TYPE_INTEGER, "Expected integer for bit field start index.")->Value As i8
			i8 EndIndex := StartIndex
			
			if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_COLON)) {
				EndIndex := this->Consume(TOKEN_TYPE_INTEGER, "Expected integer for bit field end index.")->Value As i8
			}
			
			i8 FieldSize := EndIndex - StartIndex
			
			Token* CloseBracket := this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected close bracket for bit field range.")
			
			OpenBracket~>Context->Merge(CloseBracket~>Context)
			
			if (FieldSize < 0 || FieldSize > BackingTypeSizeBits) {
				OpenBracket->Error("Field size can not be negative, or bigger than the backing type.")
			}
			
			SafeWideString* FieldName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected bit field name.")->StringValue
			
			NextField->Name := FieldName
			NextField->Offset := BackingTypeSize
			NextField->BitStartIndex := StartIndex
			NextField->BitEndIndex := EndIndex
			
			if (FieldSize <= 8) {
				NextField->ValueType := this->i8->AsNonPointer()
			}
			else if (FieldSize <= 16) {
				NextField->ValueType := this->i16->AsNonPointer()
			}
			else if (FieldSize <= 32) {
				NextField->ValueType := this->i32->AsNonPointer()
			}
			else {
				NextField->ValueType := this->i64->AsNonPointer()
			}
			
			Fields->Set(FieldName, NextField)
			
			this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
			
			if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				break
			}
		}
	}
	
	define i8 ParseProgramStatement() {
		Token* NextToken := this->PeekNextToken()
		i8 NextTokenValue := NextToken->Value As i8
		
		if (NextToken->Is(TOKEN_TYPE_KEYWORD)) {
			this->GetNextToken()
			
			if (NextTokenValue <= KEYWORD_DLLIMPORT) {
				; Handles `dllimport`/`declare`/`define`
				this->ParseFunctionDefinition(this~>Functions, NextToken)
			}
			else if (NextTokenValue = KEYWORD_STRUCT) {
				this->ParseStructDefinition()
			}
			else if (NextTokenValue = KEYWORD_BITS) {
				this->ParseBitsDefinition()
			}
			else if (NextTokenValue = KEYWORD_LINUX || NextTokenValue = KEYWORD_WINDOWS) {
				i8 IgnoreBlock := true
				
				if (NextTokenValue = KEYWORD_LINUX && this->Config->OutputFormat = OUTPUT_ELF) {
					IgnoreBlock := false
				}
				else if (NextTokenValue = KEYWORD_WINDOWS && this->Config->OutputFormat = OUTPUT_PE) {
					IgnoreBlock := false
				}
				
				if (IgnoreBlock) {
					this->IgnoreBlock()
				}
				else {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected opening '{' for block")
					
					while !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
						this->ParseProgramStatement()
					}
				}
			}
			else {
				NextToken->Error("Unexpected token")
			}
		}
		else if (NextToken->Is(TOKEN_TYPE_IDENTIFIER)) {
			; Handles global variable declarations
			
			Token* BlameToken := NextToken
			
			i8* ErrorMessage := null
			ASTNode* DefaultValueExpression := this->TryParseVariableDeclaration(true, false, &ErrorMessage)
			
			if (ErrorMessage) {
				BlameToken~>Context->Merge(this->GetCurrentTokenContext())
				BlameToken->Error(ErrorMessage)
			}
			
			if (DefaultValueExpression != null) {
				; Handles global variable default value expressions
				
				i32 Index := GetArrayLength(this->GlobalDefaults)
				this->GlobalDefaults := ReAllocArray(this->GlobalDefaults, 1)
				
				this->GlobalDefaults[Index] := DefaultValueExpression
			}
		}
		else if (NextToken->Is(TOKEN_TYPE_EOF)) {
			return true
		}
		else {
			NextToken->Error("Unexpected token")
		}
		
		return false
	}
	
	define void ParseProgram() {
		; Parse an entire program, aka a list of `dllimport`/`declare`/`define`, `struct`/`bits`, and global
		;  variable declarations.
		
		loop {
			if (this->ParseProgramStatement()) {
				break
			}
		}
	}
}

define i32 ParserNextLabel(ParserState* Parser) {
	i32 Result := Parser->LabelCount
	
	Parser->LabelCount += 1
	
	return Result
}

/*
define FunctionDefine* MatchFunction(ParserState* Parser, FunctionDefine* BaseFunction, ASTNode* CallerNode) {
	CallExpression* Caller := CallerNode->CallNode
	i32 CallerParameterCount := Caller->ParameterCount
	
	FunctionDefine* Next := BaseFunction
	
	/* Running rating of the last conpatible function's "generic rating", aka how specific the parameters are (as in, i64 vs SomeStruct*) */
	i32 BestFitRating := 200000
	FunctionDefine* BestFit := 0
	
	/* TODO: Rework this to have better casting rules */
	
	loop {
		i32 NextParameterCount := Next->ParameterCount
		
		i32 ThisFunctionRating := 0
		
		i8 IS_VARIADIC := false
		
		if (Next->Attribute = OPERATOR_DOT) {
			IS_VARIADIC := true
			ThisFunctionRating := 100000
			
			NextParameterCount -= 1
		}
		
		if (NextParameterCount = CallerParameterCount || IS_VARIADIC) {
			i8 BrokeInner := false
			
			for (i32 ParameterIndex := 0, ParameterIndex < NextParameterCount, ParameterIndex += 1) {
				Type ExpectedNext := Next->Parameters[ParameterIndex]->Type
				
				ASTNode* NextNode := Parser->DowncastIntegerNode(Caller->Parameters[ParameterIndex])
				Type ActualNext := NextNode->ValueType
				
				if (CheckTypes(Parser->void, ActualNext, ExpectedNext, null)) {
					BrokeInner := true
					
					Next->TempValue := ParameterIndex
					break
				}
				
				i32 ExpectedRating := GetGenericRating(ExpectedNext)
				i32 ActualRating := GetGenericRating(ActualNext)
				
				if (ExpectedRating != ActualRating) {
					if (ActualRating > ExpectedRating) {
						ThisFunctionRating += ActualRating
					}
					else {
						ThisFunctionRating += ExpectedRating
					}
				}
			}
			
			if !(BrokeInner) {
				if (ThisFunctionRating < BestFitRating) {
					BestFitRating := ThisFunctionRating
					BestFit := Next
				}
			}
		}
		
		Next := Next->Next
		
		if !(Next) {
			break
		}
	}
	
	if (BestFit && BestFitRating < 200000) {
		return BestFit
	}
	
	ManualErrorMessagePrelude()
	
	Print("No matching overload found for:\n")
	PrettyError(CallerNode~>Context, Red | Bright)
	
	Next := BaseFunction
	
	while (Next) {
		i32 LastNonMatchingParameter := Next->TempValue
		
		if (CallerParameterCount < Next->ParameterCount) {
			Print("Is missing required parameters for overload")
		}
		else if (CallerParameterCount > Next->ParameterCount) {
			Print("Has too many paramters for overload")
		}
		else {
			Print("Parameter %i should be an ", LastNonMatchingParameter + 1)
			
			PrintType(Next->Parameters[LastNonMatchingParameter]->Type)
			
			Print(" for overload, not ")
			
			if (LastNonMatchingParameter < CallerParameterCount) {
				PrintType(Caller->Parameters[LastNonMatchingParameter]->ValueType)
			}
			else {
				Print("<none>")
			}
		}
		
		PrintNewLine()
		PrettyError(Next~>Context, Red | Bright)
		
		Next := Next->Next
	}
	
	Exit(1)
	
	return null
}

/*
==========================================
	AST Node construction helpers
==========================================
*/

define Type GetBinaryResultType(ParserState* Parser, Type LeftType, Type RightType, ErrorContext* BlameContext) {
	/* Decides the result of a binary expression with the given operand types */
	
	i8 Compatible := !CheckTypes(Parser->void, RightType, LeftType, null)
	Type BestFit := LeftType
	
	if (GetGenericRating(LeftType) < GetGenericRating(RightType)) {
		BestFit := RightType
	}
	
	TypeInfo* LeftBaseType := GetBaseType(LeftType)
	TypeInfo* RightBaseType := GetBaseType(RightType)
	
	i16 LeftDepth := GetPointerDepth(LeftType)
	i16 RightDepth := GetPointerDepth(RightType)
	
	if (Compatible) {
		return BestFit
	}
	else {
		if (LeftDepth && RightDepth) {
			; If we are dealing with two pointer types, something's wrong
			
			ManualErrorMessagePrelude()
			
			Print("Operations on the types ")
			PrintType(LeftType)
			Print(" and ")
			PrintType(RightType)
			Print(" are invalid.\n")
			
			ContextError(BlameContext, null)
		}
		else if (LeftDepth) {
			/* Eles if the left side is a pointer */
			
			if (RightBaseType->IsStructType) {
				/* And the right type is a.. struct? Then something's real funky */
				
				ContextError(BlameContext, "Invalid operation types1.")
			}
			
			/* Otherwise, right type is a normal type, so return the pointer type */
			return LeftType
		}
		else if (RightDepth) {
			/* Same as above, just in the opposite direction */
			
			if (LeftBaseType->IsStructType) {
				ContextError(BlameContext, "Invalid operation types2.")
			}
			
			return RightType
		}
		else {
			if (LeftBaseType->IsStructType || RightBaseType->IsStructType) {
				/* If both types are structs, then something even more funky is going on */
				ContextError(BlameContext, "Invalid operation types3.")
			}
			
			/* Otherwise, two normal types, just pick the bigger of the two */
			if (LeftBaseType->Size >= RightBaseType->Size) {
				return LeftType
			}
			else {
				return RightType
			}
		}
	}
	
	return LeftType
}

declare Token* ParserCurrentToken(ParserState*)
declare ASTNode** ParseParameterList(ParserState*, i8*)

define ASTNode* MakeBinary(ParserState* Parser, ASTNode* Left, Token* OperatorToken, ASTNode* Right) {
	/* Name is a bit misleading, can return a NODE_TYPE_BINARY or NODE_TYPE_STRUCT_ACCESS */
	
	i8 Operator := (OperatorToken->Value) As i8
	Type ResultType := 0
	
	Type LeftType := Left->ValueType
	Type RightType := Right->ValueType
	
	TypeInfo* LeftBaseType := GetBaseType(LeftType)
	TypeInfo* RightBaseType := GetBaseType(RightType)
	i16 LeftDepth := GetPointerDepth(LeftType)
	i16 RightDepth := GetPointerDepth(RightType)
	i16 LeftSize := GetTypeSize(LeftType)
	i16 RightSize := GetTypeSize(RightType)
	
	i8 ALLOW_INTEGER_DOWNCAST := true
	
	if (Operator = OPERATOR_AS) {
		/* OPERATOR_AS does nothing, just switches the result type of the expression */
		
		ResultType := RightType
	}
	else if (Operator = OPERATOR_LESS_LESS || Operator = OPERATOR_GREATER_GREATER) {
		Parser->DowncastIntegerNode(Right)
		
		CheckTypes(Parser->void, Right->ValueType, MakeType(Parser->i8, 0), Right)
		
		if (LeftSize < 4) {
			ResultType := MakeType(Parser->i32, 0)
		}
		else {
			ResultType := LeftType
		}
	}
	else if (Operator = OPERATOR_DOT || Operator = OPERATOR_MINUS_GREATER || Operator = OPERATOR_TILDE_GREATER) {
		/* OPERATOR_DOT and OPERATOR_MINUS_GREATER are both struct accesses */
		
		if !(LeftBaseType->IsStructType || (LeftBaseType->IsBits && Operator = OPERATOR_DOT)) {
			/* Ensure the left type is a struct, otherwise something like 1.Abc is going on */
			
			TypeError(Left, TYPE_NONE, "Invalid left side operand type")
		}
		else if (LeftBaseType->IsIncomplete) {
			/* Ensure the left type is not incomplete (otherwise we don't know what the result type would be) */
			Left->Error("Fields of incomplete structs cannot be accessed.")
		}
		else if (LeftDepth != 0 && Operator = OPERATOR_DOT) {
			OperatorToken->Error("Struct pointer fields can only be accessed with the '->'/'~>' operators.")
		}
		else {
			; Look up a field with a name given by the right side's string value
			SafeWideString* FieldName := Right->StringValue
			
			HashMapElement* TargetElement := LeftBaseType~>Fields->Get(FieldName)
			
			if (TargetElement) {
				; If we found a field with the correct name, create a `StructAccessExpression` for this expression
				
				StructField* TargetField := (TargetElement->Value) As StructField*
				
				StructAccessExpression* NewAccess := Alloc(#StructAccessExpression) As StructAccessExpression*
				
				NewAccess->Left := Left
				NewAccess->Operator := OperatorToken
				NewAccess->TargetField := TargetField
				
				ResultType := TargetField->ValueType
				
				if (Operator = OPERATOR_TILDE_GREATER && !ResultType.IsArray) {
					ResultType := Parser->PointerToType(ResultType)
				}
				
				/* Wrap it in a NODE_TYPE_STRUCT_ACCESS and return */
				
				ASTNode* StructNode := ASTNode:New(NODE_TYPE_STRUCT_ACCESS, NewAccess, ResultType)
				
				MergeContexts(Left~>Context, Right~>Context, StructNode~>Context)
				
				return StructNode
			}
			else {
				/* If we didn't find a field with that name, then error out */
				
				Right->Error("Unknown struct field")
			}
		}
	}
	else if (OPERATOR_FIRST_ASSIGNMENT <= Operator && Operator <= OPERATOR_LAST_ASSIGNMENT) {
		/* If this is an assignment do some extra type checking */
		
		if (Left->NodeType = NODE_TYPE_VARIABLE && Left->VariableValue->IsThis) {
			Left->Error("'this' can't be assigned")
		}
		
		if (LeftDepth != 0 && LeftBaseType->IsStructType && RightDepth && RightSize = 8) {
			/* If the LeftType is a struct pointer, and the right is a pointer of any type, the result is just struct-pointer type */
			
			/* This allows for stuff like `MyStruct* Test := Alloc(#MyStruct)` without ugly casting */
			
			ResultType := LeftType
		}
		else if (LeftDepth = 0 && LeftBaseType->IsStructType) {
			/* Else if the left is a literal struct type, error out */
			
			Left->Error("Local structs can't be assigned")
		}
		else if !(Left->IsStorageValue) {
			Left->Error("Left side of assignment operator must be a storage value")
		}
		else if (Left->NodeType = NODE_TYPE_UNARY) {
			; Only true for `*X := Y`, result type is whatever `*X` would be. And thanks to
			;  `*X` being parsed like normal, LeftType is already correct
			
			ResultType := LeftType
		}
		else {
			/* Otherwise, the result type is the right type */
			ResultType := LeftType
		}
	}
	else if (Operator = OPERATOR_OPEN_BRACKET) {
		/* For an array access, make sure the index type isn't a pointer/struct */
		
		if (RightDepth != 0 || RightBaseType->IsStructType) {
			Right->Error("Right side operand of '[' must not be a pointer or struct type.")
		}
		else {
			/* DecrementPointerType will ensure that LeftType is a pointer type, so we don't need to */
			
			CopyContext(ParserCurrentToken(Parser)~>Context, Right~>Context)
			
			ResultType := Parser->DereferencePointerType(LeftType, Right~>Context)
		}
	}
	else if (OPERATOR_FIRST_COMPARISON <= Operator && Operator <= OPERATOR_LAST_COMPARISON) {
		ResultType := MakeType(Parser->i8, 0)
		
		ALLOW_INTEGER_DOWNCAST := false
	}
	else {
		/* Otherwise, just follow standard binary typing rules */
		
		MergeContexts(Left~>Context, Right~>Context, OperatorToken~>Context)
		
		ResultType := GetBinaryResultType(Parser, LeftType, RightType, OperatorToken~>Context)
		
		if (Operator = OPERATOR_LOGICAL_AND || Operator = OPERATOR_LOGICAL_OR) {
			/* For && and ||, GetBinaryResultType is only called for the error messages, and the actual result type is a byte */
			ResultType := MakeType(Parser->i8, 0)
		}
	}
	
	/* If the left or right operands are integers, just elevate them to the ResultType to ensure a compile-time cast (instead of a runtime cast) */
	
	if (ALLOW_INTEGER_DOWNCAST) {
		if (Left->NodeType = NODE_TYPE_INTEGER) {
			Left->ValueType := ResultType
		}
		if (Right->NodeType = NODE_TYPE_INTEGER) {
			Right->ValueType := ResultType
		}
	}
	
	/* Allocate a result node */
	
	BinaryExpression* Result := Alloc(#BinaryExpression) As BinaryExpression*
	
	/* Populate the node */
	
	Result->Left := Left
	Result->Operator := OperatorToken
	Result->Right := Right
	
	/* Wrap it, and return it */
	ASTNode* ResultNode := ASTNode:New(NODE_TYPE_BINARY, Result, ResultType)
	MergeContexts(Left~>Context, Right~>Context, ResultNode~>Context)
	
	return ResultNode
}
define ASTNode* MakeUnary(ParserState* Parser, Token* OperatorToken, ASTNode* Operand) {
	/* Builds a NODE_TYPE_UNARY for the given operand/operator combo */
	
	UnaryExpression* Result := Alloc(#UnaryExpression) As UnaryExpression*
	
	/* Get the  */
	Type ResultType := Operand->ValueType
	i8 Operator := (OperatorToken->Value) As i8
	
	Result->Operator := OperatorToken
	Result->Operand := Operand
	
	if (Operator = OPERATOR_BANG) {
		ResultType := MakeType(Parser->i8, 0)
	}
	else if (Operator = OPERATOR_AND) {	
		if !(Operand->IsStorageValue || Operand->NodeType = NODE_TYPE_DEFINE) {
			OperatorToken->Error("Operand of the '&' operator must be a storage value.")
		}
		
		ResultType := Parser->PointerToType(ResultType)
	}
	else if (Operator = OPERATOR_STAR) {
		ResultType := Parser->DereferencePointerType(ResultType, Operand~>Context)
	}
	
	ASTNode* ResultNode := ASTNode:New(NODE_TYPE_UNARY, Result, ResultType)
	MergeContexts(OperatorToken~>Context, Operand~>Context, ResultNode~>Context)
	
	return ResultNode
}

declare i32 FreezeParser(ParserState*)
declare void UnfreezeParser(ParserState*, i32)
declare Token* ParserNextToken(ParserState*)

define ASTNode* AllocateCall(ParserState* Parser, Token* NameToken, ASTNode** Parameters, i32 ParameterCount) {
	UnfreezeParser(Parser, FreezeParser(Parser) - 1) /* Manually backtrack and consume the closing ')' for this call */
	Token* CloseParen := ParserNextToken(Parser)
	
	CallExpression* Result := Alloc(#CallExpression) As CallExpression*
	Result->Parameters := Parameters
	Result->ParameterCount := ParameterCount
	
	/* Wrap the CallExpression with a NODE_TYPE_CALL for any errors */
	ASTNode* ResultNode := ASTNode:New(NODE_TYPE_CALL, Result, TYPE_NONE)
	MergeContexts(NameToken~>Context, CloseParen~>Context, ResultNode~>Context)
	
	return ResultNode
}

define ASTNode* MakeBuiltinCall(ParserState* Parser, Token* NameToken, ASTNode** Parameters, i32 ParameterCount) {
	ASTNode* ResultNode := AllocateCall(Parser, NameToken, Parameters, ParameterCount)
	CallExpression* Result := ResultNode->CallNode
	
	SafeWideString* Name := NameToken->StringValue
	
	if (SafeStringEqualsAString(Name, "syscall")) {
		Result->BuiltinID := BUILTIN_SYSCALL
		ResultNode->ValueType := MakeType(Parser->i64, 0)
		
		if (Parser->Config->OutputFormat = OUTPUT_PE) {
			ResultNode->Warn("Windows syscall numbers change near-constantly, using the native API is a bad idea.")
		}
	}
	else if (SafeStringEqualsAString(Name, "breakpoint") && ParameterCount = 0) {
		Result->BuiltinID := BUILTIN_BREAKPOINT
		ResultNode->ValueType := MakeType(Parser->i8, 0)
	}
	else {
		NameToken->Error("Builtin function not found.")
	}

	return ResultNode
}

define ASTNode* MakeCall(ParserState* Parser, HashMap* NameSpace, Token* NameToken, ASTNode** Parameters, i32 ParameterCount) {
	ASTNode* ResultNode := AllocateCall(Parser, NameToken, Parameters, ParameterCount)
	CallExpression* Result := ResultNode->CallNode
	
	SafeWideString* Name := NameToken->StringValue
	
	HashMapElement* FoundFunction := NameSpace->Get(Name)
	
	if !(FoundFunction) {
		/* And if the function was not found, then error out */
		
		NameToken->Error("Function definition not found.")
	}
	
	/* Otherwise, convert the HashMapElement* into a FunctionDefine* */
	FunctionDefine* FoundDefine := (FoundFunction->Value) As FunctionDefine*
	
	/* And walk the FunctionDefine* linked list, looking for an overload which matches our parameters */
	FoundDefine := MatchFunction(Parser, FoundDefine, ResultNode)
	
	Result->TargetFunction := FoundDefine
	ResultNode->ValueType := FoundDefine->ReturnType
	
	return ResultNode
}