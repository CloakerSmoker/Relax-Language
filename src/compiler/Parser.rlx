; TODO: Add a divmod built-in, the `x / constant` with `x % constant` pattern is getting annoying.

bits Type As i64 {
	[0:47] BaseType,
	[48:49] IsArray,
	[50:63] PointerDepth
}

Type TYPE_NONE := 0 As Type

i8 GLOBAL_IS_OPTIMIZED_AWAY := 2

struct VariableInfo {
	SourceContext* DefinedAt,
	
	union {
		ASTNode* LastValue
		SafeString* ExternalSymbolName
	}

	SafeString* Name,
	Type Type,

	union {
		i32 StackOffset
	}
	
	union {
		ELFSymbol* Symbol
		ObjectSymbol* ObjectSymbol
	}

	i16 GetCount,
	i16 SetCount,

	; whatre flags?

	i8 IsGlobal,
	i8 IsParameter,
	i8 IsVariadic,
	i8 IsThis,
	i8 IsExternal
}

declare i16 GetTypeStorageSize(Type)

struct VariableHashMap {
	HashMap BackingMap
	HashMap* Map
	i32 NextOffset
	
	define void Initialize() {
		this->Map := this~>BackingMap
		
		this->Map->BufferMaxCount := 100
		this->Map->Elements := Alloc(this->Map->BufferMaxCount * 8)
		
		this->NextOffset := 0
	}
	
	define VariableInfo* Get(SafeString* VariableName) {
		HashMapElement* FoundElement := this->Map->Get(VariableName)
		
		if (FoundElement) {
			return FoundElement->Value As VariableInfo*
		}
		
		return null
	}
	
	define void Add(VariableInfo* NewVariable, Token* SourceToken) {
		VariableInfo* LastDefinition := this->Get(NewVariable->Name)
		
		if (LastDefinition) {
			; If we already have this name in the hashmap, then it's a duplicate definition
			
			if (LastDefinition->Type = NewVariable->Type) {
				; However, if the new definition is defining that the variable is the same type as before,
				;  we just ignore the duplicate definition. Otherwise we're enforcing a rule for no reason which just
				;   makes code harder to read.
				
				return
			}
			
			SourceToken~>Context->Notify(NOTIFY_ERROR, "Duplicate definition")
			LastDefinition->DefinedAt->Notify(NOTIFY_FATAL, "Previously defined at")
		}
		
		NewVariable->DefinedAt := SourceToken~>Context
		
		this->Map->Set(NewVariable->Name, NewVariable)
		
		NewVariable->StackOffset := this->NextOffset
		
		i16 NewVariableSize := GetTypeStorageSize(NewVariable->Type)
		
		if (NewVariableSize <= 8) {
			this->NextOffset += 8
		}
		else {
			i16 RoundedSize := RoundTo(NewVariableSize, 8) As i16
			
			NewVariable->StackOffset += RoundedSize
			
			this->NextOffset += RoundedSize + 8
		}
	}
}

#Require "./src/compiler/Parser/AST.rlx"
#Require "./src/compiler/Parser/Types.rlx"

#Require "$/PointerArray.rlx"

; Holds the entire state of the parser

struct ParserState {
	BuildConfig* Config,
	LexerState* Lexer,
	
	HashMap Functions,
	
	VariableHashMap Globals,
	ASTNode** GlobalDefaults,
	
	HashMap Registers,
	HashMap Instructions,

	TypeNamespace* RootNamespace
	TypeNamespace* CurrentNamespace

	PointerArray* Interfaces ; <TypeInfo*>

	define TypeNamespace* FindOrAddNamespace(QualifiedName* Name, i8 AllowAdding, i8 OnlyQuery) {
		TypeNamespace* Root := this->CurrentNamespace

		if (Name->Anchored) {
			Root := this->RootNamespace
		}

		for (i32 Index := 0, Index < Name->Count(), Index++) {
			Token* ChildName := Name->At(Index)
			TypeNamespace* Child := Root->FindChild(ChildName)

			if (Child = null) {
				if (AllowAdding) {
					Child := Root->AddChild(ChildName)
				}
				else if (OnlyQuery) {
					return null
				}
				else {
					ChildName~>Context->Error(FormatString("Does not name a defined child of '%qn'", Root->Name))
				}
			}

			Root := Child
		}

		return Root
	}

	define TypeNamespace* FindOrAddNamespace(QualifiedName* Name) {
		return this->FindOrAddNamespace(Name, true, false)
	}

	define TypeNamespace* TryFindNamespace(QualifiedName* Name) {
		return this->FindOrAddNamespace(Name, false, true)
	}

	define TypeNamespace* FindNamespace(QualifiedName* Name) {
		return this->FindOrAddNamespace(Name, false, false)
	}

	define TypeNamespace* EnterNamespace(QualifiedName* Name) {
		TypeNamespace* Old := this->CurrentNamespace

		this->CurrentNamespace := this->FindOrAddNamespace(Name)

		return Old
	}

	define void ExitNamespace(TypeNamespace* Old) {
		this->CurrentNamespace := Old
	}
	
	define TypeInfo* TryLookupQualifiedName(QualifiedName* Name) {
		TypeNamespace* Container := this->TryFindNamespace(Name)

		if !(Container) {
			return null
		}

		return Container->LookupEntry(Name->LocalPart)
	}

	define TypeInfo* LookupQualifiedName(QualifiedName* Name) {
		TypeNamespace* Container := this->FindNamespace(Name)

		return Container->LookupEntry(Name->LocalPart)
	}

	define void DefineQualifiedName(QualifiedName* Name, TypeInfo* Value) {
		TypeNamespace* Container := this->FindOrAddNamespace(Name)

		Container->DefineEntry(Name->LocalPart, Value)
	}
	
	HashMap NameReplacements,

	PointerArray* ExternalSources ; <Token*>
	PointerArray* ExternalDefinitions ; <VariableInfo*>
	
	/* Builtin types, actually added to the type list in CreateDefaultTypes */
	
	TypeInfo* i8,
	TypeInfo* i16,
	TypeInfo* i32,
	TypeInfo* i64,
	TypeInfo* void,
	
	FunctionDefine* CurrentFunction,
	FunctionDefine* MainFunction,
	
	i8* GlobalConstantsBuffer
	i32 GlobalConstantBufferSize
	
	i8 InLoop,
	
	i32 LabelCount
	
	declare TypeInfo* AddType(SourceContext*, QualifiedName*, i16, TYPE_KIND)
	
	declare void SetupAssembly()
	declare void SetupDerivableInterfaces()

	define TypeInfo* DefineBuiltinType(i8* RawName, i16 Size) {
		TypeInfo* NewType := Alloc(#TypeInfo)
		
		NewType->Name := AToS(RawName)
		NewType->Size := Size
		NewType->Kind := TYPE_KIND_BUILTIN

		this->RootNamespace->DefineEntry(NewType->Name, NewType)

		return NewType
	}
	
	static ParserState* New(BuildConfig* Config, LexerState* Lexer) {
		ParserState* this := Alloc(#ParserState)
		
		this->Config := Config
		this->Lexer := Lexer
		
		this~>Globals->Initialize()
		this~>Functions->Initialize()
		this~>NameReplacements->Initialize()

		this->ExternalSources := PointerArray:New()
		this->ExternalDefinitions := PointerArray:New()
		
		this->GlobalDefaults := AllocArray(8, 0)
		this->GlobalConstantsBuffer := Alloc(4)

		this->RootNamespace := TypeNamespace:NewRoot()
		this->CurrentNamespace := this->RootNamespace

		this->Interfaces := PointerArray:New()
		
		this->i8   := this->DefineBuiltinType("i8"  , 1)
		this->i16  := this->DefineBuiltinType("i16" , 2)
		this->i32  := this->DefineBuiltinType("i32" , 4)
		this->i64  := this->DefineBuiltinType("i64" , 8)
		this->void := this->DefineBuiltinType("void", 8)
		
		this->SetupAssembly()
		this->SetupDerivableInterfaces()
		
		return this
	}
	
	define TypeInfo* AddType(SourceContext* BlameContext, QualifiedName* Name, i16 Size, TYPE_KIND Kind, i8 IsIncomplete) {
		TypeInfo* NewType := Alloc(#TypeInfo)
		
		NewType->DefinedAt := BlameContext
		NewType->Name := AToS(FormatString("%qn", Name))
		NewType->Size := Size
		NewType->Kind := Kind
		NewType->IsIncomplete := IsIncomplete
	
		;this~>Types->Set(Name, NewType)

		this->DefineQualifiedName(Name, NewType)
		
		return NewType
	}
	define TypeInfo* AddType(SourceContext* BlameContext, QualifiedName* Name, i16 Size, TYPE_KIND Kind) {
		return this->AddType(BlameContext, Name, Size, Kind, false)
	}
	
	declare Token* GetCurrentToken()
	
	define Type TryFindType(QualifiedName* TypeName, i16 PointerDepth, i8** ErrorMessage) {
		;HashMapElement* FoundTypeInfoElement := this~>Types->Get(TypeName)
		TypeInfo* FoundTypeInfo := this->LookupQualifiedName(TypeName)
		
		if (FoundTypeInfo = null) {
			if (PointerDepth = 0) {
				*ErrorMessage := "Undefined type (Incomplete types can only be pointed-to)"
				
				return TYPE_NONE
			}
			else {
				FoundTypeInfo := this->AddType(TypeName~>Context, TypeName, 0, TYPE_KIND_STRUCTURE, true)
			}
		}
		
		return FoundTypeInfo->AsPointer(PointerDepth)
	}
	define Type FindType(QualifiedName* TypeName, i16 PointerDepth) {
		i8* ErrorMessage := null
		
		Type Result := this->TryFindType(TypeName, PointerDepth, &ErrorMessage)
		
		if (ErrorMessage) {
			this->GetCurrentToken()->Error(ErrorMessage)
		}
		
		return Result
	}
	
	define Type DereferencePointerType(Type TypeToDecrement, SourceContext* BlameContext) {
		i16 PointerDepth := GetPointerDepth(TypeToDecrement)
		
		if (PointerDepth = 0) {
			BlameContext->Error("Pointer type expected")
		}
		
		return GetBaseType(TypeToDecrement)->AsPointer(PointerDepth - 1 As i16)
	}
	define Type PointerToType(Type TypeToIncrement) {
		return GetBaseType(TypeToIncrement)->AsPointer(GetPointerDepth(TypeToIncrement) + 1 As i16)
	}
	
	define Type GetNumberType(i64 Number) {
		if (Number & 0xFFFF_FFFF_8000_0000) {
			return this->i64->AsNonPointer()
		}
		else {
			return this->i32->AsNonPointer()
		}
	}
	
	define ASTNode* DowncastIntegerNode(ASTNode* Target) {
		if (Target->NodeType != NODE_TYPE_INTEGER) {
			return Target
		}
		else if (GetPointerDepth(Target->ValueType) = 0 && GetBaseType(Target->ValueType)->Is(TYPE_KIND_ENUMERATION)) {
			return Target
		}
		
		i8 Size := GetNumberSize(Target->IntegerValue)
		TypeInfo* BaseType := this->i8
		
		if (Size = 2) {BaseType := this->i16}
		else if (Size = 4) {BaseType := this->i32}
		else if (Size = 8) {BaseType := this->i64}
		
		Target->ValueType := BaseType->AsNonPointer()
		
		return Target
	}
	
	define VariableInfo* TryFindVariable(Token* NameToken) {
		; Finds a variable, prioritizing locals over globals
		
		SafeString* VariableName := NameToken->StringValue
		
		FunctionDefine* CurrentFunction := this->CurrentFunction
		VariableInfo* FoundVariable := null
		
		if (CurrentFunction) {
			; If we are in a function, try to find the variable in the locals
			FoundVariable := CurrentFunction~>Locals->Get(VariableName)
		}
		
		if !(FoundVariable) {
			; If we didn't find the variable in the locals, then check the globals
			FoundVariable := this~>Globals->Get(VariableName)
			
			if (CurrentFunction) {
				CurrentFunction->UsesGlobals := true
			}
		}
		
		return FoundVariable
	}
	
	define VariableInfo* FindVariable(Token* NameToken) {
		VariableInfo* FoundVariable := this->TryFindVariable(NameToken)
		
		if !(FoundVariable) {
			; If we still haven't found the variable, then it is undefined
			
			NameToken->Error("Undefined variable")
		}
		
		; Variable has to have been found at some point for this to be reached
		
		return FoundVariable
	}

	define void DuplicateDefinitionError(SourceContext* New, SourceContext* Old) {
		if (Old) {
			New->Notify(NOTIFY_ERROR, "Name is already used")
			Old->Notify(NOTIFY_FATAL, "Previously defined here")
		}
		else {
			New->Error("Name is already used")
		}
	}

	define void AddGlobal(VariableInfo* NewGlobal, Token* BlameToken) {/*
		HashMapElement* DefinedTypeElement := this~>Types->Get(NewGlobal->Name)
		
		if (DefinedTypeElement) {
			TypeInfo* DefinedType := DefinedTypeElement->Value

			this->DuplicateDefinitionError(BlameToken~>Context, DefinedType->DefinedAt)
		}*/
		
		this~>Globals->Add(NewGlobal, BlameToken)
	}
	define void AddLocal(VariableInfo* NewLocal, Token* BlameToken) {/*
		HashMapElement* DefinedTypeElement := this~>Types->Get(NewLocal->Name)
		VariableInfo* DefinedGlobal := this~>Globals->Get(NewLocal->Name)
		
		if (DefinedTypeElement) {
			TypeInfo* DefinedType := DefinedTypeElement->Value
			
			this->DuplicateDefinitionError(BlameToken~>Context, DefinedType->DefinedAt)
		}
		else if (DefinedGlobal) {
			this->DuplicateDefinitionError(BlameToken~>Context, DefinedGlobal->DefinedAt)
		}*/
		
		this->CurrentFunction~>Locals->Add(NewLocal, BlameToken)
	}
	define void AddVariable(VariableInfo* NewVariable, Token* BlameToken) {
		if (NewVariable->IsGlobal) {
			this->AddGlobal(NewVariable, BlameToken)
		}
		else {
			this->AddLocal(NewVariable, BlameToken)
		}
	}

	define i32 AddGlobalConstantData(void* Data, i32 Size) {
		i32 Offset := this->GlobalConstantBufferSize
		this->GlobalConstantBufferSize += Size
		this->GlobalConstantsBuffer := ReAlloc(this->GlobalConstantsBuffer, this->GlobalConstantBufferSize)

		MoveMemory(this->GlobalConstantsBuffer + Offset, Data, Size)

		return Offset
	}
	
	define i32 Freeze() {
		return this->Lexer->TokenIndex
	}
	define void Unfreeze(i32 FrozenState) {
		this->Lexer->TokenIndex := FrozenState
	}
	define Token* GetCurrentToken() {
		return this->Lexer->GetCurrentToken()
	}
	define SourceContext* GetCurrentTokenContext() {
		return this->Lexer->GetCurrentTokenContext()
	}
	define Token* GetNextToken() {
		return this->Lexer->GetNextToken()
	}
	define Token* PeekNextToken() {
		i32 Before := this->Freeze()
		
		Token* Result := this->Lexer->GetNextToken()
		
		this->Unfreeze(Before)
		
		return Result
	}
	define i8 NextTokenMatches(i8 TokenType, i64 TokenValue) {
		if (this->PeekNextToken()->Is(TokenType, TokenValue)) {
			this->GetNextToken()
			
			return true
		}
		
		return false
	}
	define i8 NextTokenMatches(i8 TokenType) {
		if (this->PeekNextToken()->Is(TokenType)) {
			this->GetNextToken()
			
			return true
		}
		
		return false
	}
	define Token* TryConsume(i8 TokenType, i64 TokenValue, i8* Reason, i8** ErrorMessage) {
		Token* NextToken := this->GetNextToken()
		
		if (NextToken->Is(TOKEN_TYPE_EOF, 0)) {
			*ErrorMessage := "Unexpected end of file"
		}
		else if !(NextToken->Is(TokenType, TokenValue)) {
			*ErrorMessage := Reason
		}
		
		return NextToken
	}
	define Token* TryConsume(i8 TokenType, i8* Reason, i8** ErrorMessage) {
		return this->TryConsume(TokenType, 0, Reason, ErrorMessage)
	}
	define Token* Consume(i8 TokenType, i64 TokenValue, i8* Reason) {
		i8* ErrorMessage := null
		
		Token* Result := this->TryConsume(TokenType, TokenValue, Reason, &ErrorMessage)
		
		if (ErrorMessage) {
			Result->Error(ErrorMessage)
		}
		
		return Result
	}
	define Token* Consume(i8 TokenType, i8* Reason) {
		return this->Consume(TokenType, 0, Reason)
	}
	
	define Token* ThrowConsume(i8 TokenType, i64 TokenValue, i8* Reason) {
		;Print("TC %i %i %s\n", TokenType, TokenValue, Reason)
		
		i8* ErrorMessage := null
		Token* Result := this->TryConsume(TokenType, TokenValue, Reason, &ErrorMessage)
		
		if (ErrorMessage) {
			Throw(ErrorMessage As i64)
		}
		
		return Result
	}
	define Token* ThrowConsume(i8 TokenType, i8* Reason) {
		return this->ThrowConsume(TokenType, 0, Reason)
	}
	
	declare Type TryParseType(i8, i8, i8**)
	declare Type TryParseType(i8, i8**)
	
	define TypeInfo* TryParseFunctionPointer(i8 RequireParenthesis, i8** ErrorMessage) {
		;Print("TPFP, %i\n", RequireParenthesis)
		
		try {
			if (RequireParenthesis) {
				this->ThrowConsume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Expected open `(` for function pointer type")
			}
			
			Type ReturnType := this->TryParseType(true, false, ErrorMessage)
			if *(ErrorMessage) { return null }
			
			this->ThrowConsume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Expected open `(` for function pointer parameter types")
			if *(ErrorMessage) { return null }
			
			Type[10] ParameterTypes
			i32 ParameterCount := 0
			
			i8 Attributes := 0
			
			if !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
				loop {
					if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
						this->ThrowConsume(TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected `...` for variadic parameter marker")
						this->ThrowConsume(TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected `...` for variadic parameter marker")
						
						Attributes |= FUNCTION_ATTRIBUTE_VARIADIC
						
						ParameterTypes[ParameterCount++] := MakeType(this->void, 1)
						
						this->ThrowConsume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Variadic marker must be the last parameter")
						
						break
					}
					
					Type ParameterType := this->TryParseType(false, ErrorMessage)
					
					ParameterTypes[ParameterCount++] := ParameterType
					
					if *(ErrorMessage) { return null }
					
					if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
						continue
					}
					else if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
						break
					}
					else {
						Throw("Expected comma between function pointer parameter types, or closing `)` for parameter type list" As i64)
					}
				}
			}
			
			if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_X64)) {
				Attributes |= FUNCTION_ATTRIBUTE_USE_X64
			}  
			
			if (RequireParenthesis) {
				this->ThrowConsume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing `)` for function pointer type")
			}
			
			Type* RealParameterTypes := Alloc(ParameterCount * #Type)
			MoveMemory(RealParameterTypes, ParameterTypes, ParameterCount * #Type)
			
			TypeInfo* Result := Alloc(#TypeInfo)
			
			Result->Name := AToS("(function pointer)")
			Result->Size := 8
			Result->Kind := TYPE_KIND_FUNCTION_POINTER

			Result~>FunctionPointer->ReturnType := ReturnType
			Result~>FunctionPointer->ParameterCount := ParameterCount
			Result~>FunctionPointer->ParameterTypes := RealParameterTypes
			Result~>FunctionPointer->Attributes := Attributes
			
			return Result
		}
		catch (i8* RawErrorMessage) {
			*ErrorMessage := RawErrorMessage
		}
		
		return null
	}

	define QualifiedName* TryParseQualifiedName(i8** ErrorMessage, i8 ExpectLocalPart) {
		QualifiedName* Result := QualifiedName:New()
		Result~>Context->Clone(this->PeekNextToken()~>Context)

		if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COLON_COLON)) {
			Result->Anchored := true
		}

		loop {
			Token* Part := this->TryConsume(TOKEN_TYPE_IDENTIFIER, "Expected identifier", ErrorMessage)
			Result~>Context->Merge(Part~>Context)

			if *(ErrorMessage) {
				return null
			}

			if (ExpectLocalPart) {
				if (Result->LocalPart) {
					Result->Push(Result->LocalPart)
				}

				Result->LocalPart := Part
			}
			else {
				Result->Push(Part)
			}

			if !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COLON_COLON)) {
				break
			}
		}

		;Print("TryParseQualifiedName: %x %i %s\n", Result, Result->Count(), Result->LocalPart->StringValue->Buffer)

		;Print("TryParseQualifiedName: %qn\n", Result)

		return Result
	}

	define QualifiedName* TryParseQualifiedName(i8** ErrorMessage) {
		return this->TryParseQualifiedName(ErrorMessage, true)
	}

	define QualifiedName* ParseQualifiedName(i8 ExpectLocalPart) {
		i8* ErrorMessage := null

		QualifiedName* Result := this->TryParseQualifiedName(&ErrorMessage, ExpectLocalPart)

		if (ErrorMessage) {
			this->GetCurrentTokenContext()->Error(ErrorMessage)
		}

		return Result
	}

	define QualifiedName* ParseQualifiedName() {
		return this->ParseQualifiedName(true)
	}
	
	define Type TryParseType(i8 RequireFunctionPointerParenthesis, i8 AllowArrayType, i8** ErrorMessage) {
		i32 BeforeFunctionPointer := this->Freeze()
		TypeInfo* Base := this->TryParseFunctionPointer(RequireFunctionPointerParenthesis, ErrorMessage)
		Type Result := TYPE_NONE
		
		if *(ErrorMessage) {
			this->Unfreeze(BeforeFunctionPointer)
			*ErrorMessage := null
			
			/*
			Token* NameToken := this->TryConsume(TOKEN_TYPE_IDENTIFIER, "Type names must be identifiers", ErrorMessage)
			
			if *(ErrorMessage) {
				return TYPE_NONE
			}
			*/

			QualifiedName* Name := this->TryParseQualifiedName(ErrorMessage)

			if *(ErrorMessage) {
				return TYPE_NONE
			}
			
			i8 PointerDepth := 0
		
			while (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_STAR)) {
				PointerDepth += 1
			}
			
			Result := this->TryFindType(Name, PointerDepth, ErrorMessage)
			
			if *(ErrorMessage) {
				return TYPE_NONE
			}
		}
		else {
			i8 PointerDepth := 0
		
			while (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_STAR)) {
				PointerDepth += 1
			}
			
			Type Result := MakeType(Base, PointerDepth)
		}
		
		if (AllowArrayType && this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET)) {
			Token* SizeToken := this->TryConsume(TOKEN_TYPE_INTEGER, "Expected array type size", ErrorMessage)
			
			if (*ErrorMessage = null) {
				TypeInfo* ResultBase := GetBaseType(Result)
				
				if (ResultBase->IsIncomplete && PointerDepth = 0) {
					Name~>Context->Error("Array types must not be incomplete")
				}
				
				Result := MakeArrayType(Result, SizeToken->IntegerValue As i16)
				Result.IsArray := true
				
				this->TryConsume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected closing ']' for array type", ErrorMessage)
			}
		}
		
		return Result
	}
	define Type TryParseType(i8 AllowArrayType, i8** ErrorMessage) {
		return this->TryParseType(false, AllowArrayType, ErrorMessage)
	}
	define Type ParseType(i8 AllowArrayType) {
		i8* ErrorMessage := null
		Token* BlameToken := this->PeekNextToken()
		
		Type Result := this->TryParseType(AllowArrayType, &ErrorMessage)
		
		if (ErrorMessage) {
			this->GetCurrentTokenContext()->Error(ErrorMessage)
		}
		
		return Result
	}
	define Type ParseType() {
		return this->ParseType(false)
	}
	define ASTNode* ParseTypeNode() {
		Token* FirstToken := this->PeekNextToken()
		Type Result := this->ParseType()
		
		ASTNode* ResultNode := ASTNode:New(NODE_TYPE_TYPE, Result As i64, Result)
		
		ResultNode~>Context->Clone(FirstToken~>Context)->Merge(this->GetCurrentTokenContext())
		
		return ResultNode
	}
	
	define FunctionDefine* LookupStaticMethod(QualifiedName* TypeName, Token* StaticMethodNameToken) {
		/*HashMapElement* TypeElement := this~>Types->Get(TypeNameToken->StringValue)
		
		if !(TypeElement) {
			TypeNameToken->Error("Undefined type")
		}*/

		;TypeInfo* TargetType := TypeElement->Value As TypeInfo*

		TypeInfo* TargetType := this->LookupQualifiedName(TypeName)
		
		HashMapElement* FoundFunctionElement := TargetType~>StaticMethods->Get(StaticMethodNameToken->StringValue)
		
		if !(FoundFunctionElement) {
			StaticMethodNameToken->Error("Undefined static method")
		}
		
		return FoundFunctionElement->Value As FunctionDefine*
	}
	
	#Require "./src/compiler/Parser/Expression.rlx"
	
	define ASTNode* ParseInitializer(ASTNode* ForNode) {
		Type ForType := ForNode->ValueType
		
		i8 IsArray := ForType.IsArray
		i16 ForTypeDepth := GetPointerDepth(ForType)
		TypeInfo* ForBaseType := GetBaseType(ForType)
		
		if (ForTypeDepth = 0 && ForBaseType->Is(TYPE_KIND_STRUCTURE)) {
			i8 IsArrayStyle := true
			i32 BeforeKeyValueCheck := this->Freeze()

			if (this->NextTokenMatches(TOKEN_TYPE_IDENTIFIER) && this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_COLON)) {
				IsArrayStyle := false
			}
			
			this->Unfreeze(BeforeKeyValueCheck)
			
			i16 InitializerCapacity := 20
			ASTNode** Initializers := Alloc(InitializerCapacity * #ASTNode*) As ASTNode**
			
			i16 InitializerIndex := 0
			i8 IsFirstInitializer := true

			while (IsFirstInitializer || this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
				if (IsArrayStyle) {
					StructField* Field := ForBaseType->FieldsInOrder->At(InitializerIndex)
				}
				else {
					Token* FieldName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected initializer field name")
					
					this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_COLON, "Expected ':' after initializer field name")
					
					HashMapElement* FieldElement := ForBaseType~>Fields->Get(FieldName->StringValue)
					
					if (FieldElement = null) {
						FieldName->Error("Unknown struct field")
					}
					
					StructField* Field := FieldElement->Value
				}

				i8 FieldIsStruct := GetPointerDepth(Field->ValueType) = 0 && GetBaseType(Field->ValueType)->Is(TYPE_KIND_STRUCTURE)
				i8 FieldIsArray := Field->ValueType.IsArray
				
				; Build a node for `ForNode.Field`
				
				StructAccessExpression* Access := Alloc(#StructAccessExpression)
				
				Access->Left := ForNode
				Access->Operator := Alloc(#Token)
				Access->Operator->Type := TOKEN_TYPE_OPERATOR
				Access->Operator->IntegerValue := OPERATOR_DOT
				Access->TargetField := Field
				
				if (FieldIsArray) {
					Access->Operator->IntegerValue := OPERATOR_TILDE_GREATER
				}
				
				; Parse any initializers for `ForNode.Field`
				
				if (FieldIsStruct || FieldIsArray) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected '{' for field initializer")
				}
				
				ASTNode* AccessNode := ASTNode:New(NODE_TYPE_STRUCT_ACCESS, Access, Field->ValueType)
				ASTNode* InitializerValue := this->ParseInitializer(AccessNode)
				
				if (FieldIsStruct || FieldIsArray) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}' for field initializer")
				}
				
				; If `ForNode.Field` is a struct, then we don't want to assign `ForNode.Field` to anything, since
				;  there is no value to assign, merely a block of initializers for `ForNode.Field` itself which
				;   should be directly executed
				
				if (FieldIsStruct || FieldIsArray) {
					Initializers[InitializerIndex] := InitializerValue
				}
				else {
					BinaryExpression* Assign := Alloc(#BinaryExpression)
					
					Assign->Left := AccessNode
					Assign->Operator := Alloc(#Token)
					Assign->Operator->Type := TOKEN_TYPE_OPERATOR
					Assign->Operator->IntegerValue := OPERATOR_COLON_EQUAL
					Assign->Right := InitializerValue
					
					Initializers[InitializerIndex] := ASTNode:New(NODE_TYPE_BINARY, Assign, Field->ValueType)
				}
				
				InitializerIndex += 1
				IsFirstInitializer := false
			}
			
			CodeBlock* InitializersBlock := Alloc(#CodeBlock) As CodeBlock*
			
			InitializersBlock->Statements := Initializers
			InitializersBlock->StatementCount := InitializerIndex
			
			return ASTNode:New(NODE_TYPE_EXPRESSION_BLOCK, InitializersBlock)
		}
		else if (IsArray) {
			ArrayTypeInfo* ForArrayType := GetArrayType(ForType)
			Type ElementType := ForArrayType->BaseType->AsPointer(ForTypeDepth - 1 As i16)
			
			ASTNode** ElementInitiailizers := Alloc(ForArrayType->Length * #ASTNode*)
			
			for (i16 Index := 0, Index < ForArrayType->Length, Index += 1) {
				BinaryExpression* ArrayAccess := Alloc(#BinaryExpression)
				
				ArrayAccess->Left := ForNode
				ArrayAccess->Operator := Alloc(#Token)
				ArrayAccess->Operator->Type := TOKEN_TYPE_OPERATOR
				ArrayAccess->Operator->IntegerValue := OPERATOR_OPEN_BRACKET
				ArrayAccess->Right := ASTNode:New(NODE_TYPE_INTEGER, Index, this->i32->AsNonPointer())
				
				i8 InitializerIsStruct := GetPointerDepth(ElementType) = 0 && GetBaseType(ElementType)->Is(TYPE_KIND_STRUCTURE)
				
				if (InitializerIsStruct) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected '{' for field initializer")
				}
				
				ASTNode* ArrayAccessNode := ASTNode:New(NODE_TYPE_BINARY, ArrayAccess, ElementType)
				ASTNode* ElementInitiailizer := this->ParseInitializer(ArrayAccessNode)
				
				if (InitializerIsStruct) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}' for field initializer")
					
					ElementInitiailizers[Index] := ElementInitiailizer
				}
				else {
					CheckTypes(this->void, ElementInitiailizer->ValueType, ElementType, ElementInitiailizer)
					
					BinaryExpression* ElementAssign := Alloc(#BinaryExpression)
					
					ElementAssign->Left := ArrayAccessNode
					ElementAssign->Operator := Alloc(#Token)
					ElementAssign->Operator->Type := TOKEN_TYPE_OPERATOR
					ElementAssign->Operator->IntegerValue := OPERATOR_COLON_EQUAL
					ElementAssign->Right := ElementInitiailizer
					
					ElementInitiailizers[Index] := ASTNode:New(NODE_TYPE_BINARY, ElementAssign, ElementType)
				}
				
				if !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
					Index += 1 ; horrible hack I hate this game

					break
				}
			}
			
			CodeBlock* ArrayInitializersBlock := Alloc(#CodeBlock) As CodeBlock*
			
			ArrayInitializersBlock->Statements := ElementInitiailizers
			ArrayInitializersBlock->StatementCount := Index
			
			return ASTNode:New(NODE_TYPE_EXPRESSION_BLOCK, ArrayInitializersBlock)
		}
		else {
			ASTNode* InitializerExpression := this->ParseExpression()
			
			if (InitializerExpression->NodeType = NODE_TYPE_INTEGER) {
				InitializerExpression := this->DowncastIntegerNode(InitializerExpression)
			}
			
			CheckTypes(this->void, InitializerExpression->ValueType, ForType, InitializerExpression)
			
			return InitializerExpression
		}
	}
	
	define ASTNode* TryParseVariableDeclaration(i8 ForGlobalVariable, i8 ForParameter, i8** ErrorMessage, VariableInfo** OutNewVariable) {
		; Try to parse the declaration of a single variable (which can be local, global, or a parameter)
		;  and returns an expression which will set that variable to an optional default value (if allowed)
		
		Token* MaybeAuto := this->PeekNextToken()
		
		if (ForParameter = false && MaybeAuto->Is(TOKEN_TYPE_IDENTIFIER) && MaybeAuto->StringValue->Equals("auto")) {
			this->GetNextToken()
			
			Token* AutoVariableName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for auto variable name")
			Token* AssignmentOperator := this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL, "Expected `:=` for auto variable declaration")
			
			; Add the variable early (as void*) just in case the expression somehow references the variable
			;  (and would throw a parse error)
			
			VariableInfo* AutoVariable := Alloc(#VariableInfo)
			
			AutoVariable->Name := AutoVariableName->StringValue
			AutoVariable->Type := this->void->AsPointer(1)
			AutoVariable->IsGlobal := ForGlobalVariable
			AutoVariable->IsParameter := ForParameter
			
			if (OutNewVariable != 0) {
				*OutNewVariable := AutoVariable
			}
			
			this->AddVariable(AutoVariable, AutoVariableName)
			
			; Parse the variable's initial value, and then update the variable's type using the type of the
			;  initial value
			
			ASTNode* AutoValue := this->ParseExpression()
			AutoVariable->Type := AutoValue->ValueType
			
			; Build an AST node to assign the variable to the initial value, and then return it for the caller
			;  to compile before this variable is used
			
			BinaryExpression* AutoAssign := Alloc(#BinaryExpression)
			
			AutoAssign->Left := ASTNode:New(NODE_TYPE_VARIABLE, AutoVariable, AutoVariable->Type)
			AutoAssign->Operator := AssignmentOperator
			AutoAssign->Right := AutoValue
			
			return ASTNode:New(NODE_TYPE_BINARY, AutoAssign, AutoVariable->Type)
		}
		
		i32 Before := this->Freeze()

		SourceContext* PotentialTypeContext := Alloc(#SourceContext)
		PotentialTypeContext->Clone(this->PeekNextToken()~>Context)
		Type PotentialType := this->TryParseType(true, ErrorMessage)
		PotentialTypeContext->Merge(this->GetCurrentTokenContext())
		
		if (PotentialType != TYPE_NONE && *ErrorMessage = null) {
			; If we could parse a full type name, then we *might* be dealing with a variable declaration.
			;  But we're not sure yet.
			
			i32 DefaultValueExpressionStart := this->Freeze()
			
			if (this->NextTokenMatches(TOKEN_TYPE_IDENTIFIER)) {
				Token* NameToken := this->GetCurrentToken()
				
				; Alright, we've got `Type Name`, which is definitely a variable declaration.
				; So we build up a VariableInfo struct for it, and add it to the correct scope.
				
				VariableInfo* NewVariable := Alloc(#VariableInfo)
				
				NewVariable->Name := NameToken->StringValue
				NewVariable->Type := PotentialType
				NewVariable->IsGlobal := ForGlobalVariable
				NewVariable->IsParameter := ForParameter
				
				if (OutNewVariable != 0) {
					*OutNewVariable := NewVariable
				}
				
				this->AddVariable(NewVariable, NameToken)
				
				; If we're declaring a local/global (but not a parameter) allow for an optional default value
				;  expression after, marked by `Type Name` being followed by the `:=` operator.
				
				; Note: the parser needs to backtrack to before `Name :=` and parse the entire `Name := Value` 
				;  expression if it is present
				
				if (ForParameter = false && this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
					this->Unfreeze(DefaultValueExpressionStart)
					
					return this->ParseExpression()
				}
				else if (ForParameter = false && this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
					TypeInfo* Base := GetBaseType(PotentialType)

					if !(PotentialType.IsArray) {
						if (GetPointerDepth(PotentialType) != 0) {
							PotentialTypeContext->Error("Can't initialize a pointer")
						}
						else if (Base->IsIncomplete || !Base->Is(TYPE_KIND_STRUCTURE)) {
							PotentialTypeContext->Error("Can't initialize a non-array/incomplete/non-structure type")
						}
					}

					ASTNode* NewVariableNode := ASTNode:New(NODE_TYPE_VARIABLE, NewVariable, PotentialType)
					
					ASTNode* InitializersBlock := this->ParseInitializer(NewVariableNode)
					
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}'")
					
					return InitializersBlock
				}
				else {
					return null
				}
			}
			else {
				*ErrorMessage := "Variable names must be identifiers"
			}
		}
		
		this->Unfreeze(Before)
		
		return null
	}
	define ASTNode* TryParseVariableDeclaration(i8 ForGlobalVariable, i8 ForParameter, i8** ErrorMessage) {
		return this->TryParseVariableDeclaration(ForGlobalVariable, ForParameter, ErrorMessage, null As VariableInfo**)
	}
	
	#Require "./src/compiler/Parser/Assembly.rlx"
	#Require "./src/compiler/Parser/Statement.rlx"
	
	define FunctionDefine* ParseFunctionDefinition(HashMap* Container, Token* FirstToken, TypeInfo* ThisType, i8 Mode, i8 ForMethod) {
		i8 ForStatic := Mode = KEYWORD_STATIC
		i8 ForDeclare := Mode = KEYWORD_DECLARE
		i8 ForVirtual := Mode = KEYWORD_VIRTUAL
		i8 ForDefine := Mode = KEYWORD_DEFINE || ForStatic || ForVirtual
		i8 ForImport := Mode = KEYWORD_DLLIMPORT
		
		Type ReturnType := this->ParseType()		
		Token* NameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected function name")
		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Expected opening '(' for function parameter list")
		
		;if (!ForMethod && this~>Types->Get(NameToken->StringValue) != null) {
		;	NameToken->Error("Name is already reserved by a type")
		;}
		
		if (ForDefine) {
			; For define statements, any parameters are added as locals, meaning that this->CurrentFunction 
			;  needs to be set to prevent `this->AddLocal` inside of the parameter list parsing from crashing
			
			; `Locals` is copied onto the actual `FunctionDefine*` for this function after the parameters have 
			; been parsed, and the matching overload has been found (if it exists)
			
			FunctionDefine TempDefine
			
			TempDefine~>Locals->Initialize()
			
			this->CurrentFunction := &TempDefine
		}
		
		i8 ParameterCount := 0
		VariableInfo** ParameterList := Alloc(16 * #VariableInfo) As VariableInfo**
		
		if (ForMethod) {
			; If we are defining a method, then we need to build the `this` parameter, and insert it into the 
			;  parameter list
	
			VariableInfo* ThisParameter := Alloc(#VariableInfo)
			ThisParameter->Name := AToS("this")
			
			if (ThisType->Is(TYPE_KIND_BIT_FIELDS)) {
				ThisParameter->Type := ThisType->AsNonPointer()
			}
			else {
				ThisParameter->Type := ThisType->AsPointer(1)
			}
			
			ThisParameter->IsParameter := true
			ThisParameter->IsThis := true
			
			if (ForDefine) {
				; Only actually add `this` as a local when we are defining a full function, and 
				;  have this->CurrentFunction set
				
				this->AddLocal(ThisParameter, null)
			}
			
			ParameterList[0] := ThisParameter
			ParameterCount += 1
		}
		
		i8 Attributes := 0
		
		if !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
			; Only bother parsing parameters if we actually have any
			
			loop {
				VariableInfo* NextParameter := Alloc(#VariableInfo)
				
				; Max parameter count since I cba to expand the buffer. Todo: Fix this
				if (ParameterCount >= 16) {
					this->GetNextToken()->Error("Max parameter limit reached")
				}
				
				ParameterList[ParameterCount] := NextParameter
				
				i8 ShouldBreak := false
				
				if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
					ShouldBreak := true
					
					SourceContext* Start := this->GetCurrentTokenContext()
					
					this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected '.' for variadic marker")
					this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected '.' for variadic marker")
					
					if (ParameterCount >= 6) {
						Start->Merge(this->GetCurrentTokenContext())
						Start->Error("Only <4 regular paremeters can be passed with a variable argument.")
					}
					
					Attributes |= FUNCTION_ATTRIBUTE_VARIADIC
					
					NextParameter->Type := this->void->AsPointer(1)
					NextParameter->IsParameter := true
					NextParameter->IsVariadic := true
				}
				else {
					NextParameter->Type := this->ParseType()
				}
				
				if (ForDefine) {
					if (ForVirtual && !this->PeekNextToken()->Is(TOKEN_TYPE_IDENTIFIER)) {
						; If we're parsing a virtual method and it doesn't look
						;  like it has a default implementation, break early

						ForDefine := false
					}
					else {
						Token* NextParameterNameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Parameter names must be identifiers")
						NextParameter->Name := NextParameterNameToken->StringValue
						this->AddLocal(NextParameter, NextParameterNameToken)
					}
				}
				
				NextParameter->IsGlobal := false
				NextParameter->IsParameter := true
				NextParameter->StackOffset := (ParameterCount * 8)
				
				ParameterCount += 1
				
				if (ShouldBreak) {
					break
				}
				else if !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
					; If the next token isn't a comma, then break the loop, otherwise consume the command and 
					;  continue
					
					break
				}
			}
			
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing ')' for parameter list")
		}
		
		HashMapElement* FoundFunctionElement := Container->Get(NameToken->StringValue)
		
		FunctionDefine* NewDefine := null
		FunctionDefine* TailFunction := null
		
		if (FoundFunctionElement != null) {
			; This is a function overload, find the tail of the overload linked list, and check that
			;  our parameters aren't the same as any other definition's parameters
			
			FunctionDefine* NextFunction := FoundFunctionElement->Value As FunctionDefine*
			
			loop {
				; For each definition of this name
				
				if (NextFunction->ParameterCount = ParameterCount) {
					if (CheckTypeSignature(NextFunction, ParameterList)) {
						; Allow redefining a declared overload
						
						if ((!ForDeclare && NextFunction->HasFullDefinition) || ForVirtual) {
							this->DuplicateDefinitionError(NameToken~>Context, NextFunction~>Context)
						}
						
						NewDefine := NextFunction
						
						break
					}
				}
				
				if !(NextFunction->Next) {
					break
				}
				
				NextFunction := NextFunction->Next
			}
			
			TailFunction := NextFunction
		}

		if (ForDeclare && NewDefine != null) {
			; Ignore duplicate/redundant `declare`s

			return NewDefine
		}
		
		if (NewDefine = null) {
			; If we didn't find `declare`d version of this function with the same parameter type set, then
			;  allocate a new node instead of reusing the (non-existent) `declare`d one.
			
			NewDefine := Alloc(#FunctionDefine)
			
			if (TailFunction) {
				TailFunction->Next := NewDefine
			}
			else {
				Container->Set(NameToken->StringValue, NewDefine)
			}
			
			NewDefine->LabelNumber := this->LabelCount
			this->LabelCount += 1
		}
		
		; By here, NewDefine 100% holds a FunctionDefine struct for this function, which is added to whichever 
		;  scope it needs to be.
		
		NewDefine->Name := NameToken->StringValue
		NewDefine->ReturnType := ReturnType
		NewDefine->Attributes := Attributes
		NewDefine->Parameters := ParameterList
		NewDefine->ParameterCount := ParameterCount
		
		; `FUNCTION_IS_METHOD` when `ForStatic` is false, and
		; `FUNCTION_IS_STATIC_METHOD` when `ForStatic` is true
		; `0`/false when neither is true
		NewDefine->IsMethod := ForMethod | (ForStatic << 1) As i8
		
		if (NewDefine->IsMethod) {
			NewDefine->MethodOfTypeName := ThisType->Name
		}
		
		if (ForDefine) {
			; Only copy the variable map containing the parameter locals if it... exists.
			
			MoveMemory(NewDefine~>Locals, TempDefine~>Locals, #VariableHashMap)
		}
		
		NewDefine~>Context->Clone(FirstToken~>Context)->Merge(this->GetCurrentTokenContext())
		
		; We are done parsing the function's name, return type, and parameters. Now to just handle all of
		;  the different function body types.
		
		if (ForImport) {
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Import source must have a prior '{'")
			
			SafeString* FileName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Import source file name expected")->StringValue
			
			if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
				this->Consume(TOKEN_TYPE_IDENTIFIER, "Import source file extension expected")
			}
			
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA, "Comma expected between import source file and function names")
			
			SafeString* FunctionName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Import source function name expected")->StringValue
			
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}'")
			
			NewDefine->IsImported := true
			NewDefine->ImportFileName := FileName
			NewDefine->ImportFunctionName := FunctionName
		}
		else if (ForDefine) {
			this->CurrentFunction := NewDefine
			
			if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_X64)) {
				NewDefine->Attributes |= FUNCTION_ATTRIBUTE_USE_X64
			}

			if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_EXPORT)) {
				i32 AllowExport := this->Config->DebugMode & (DEBUG_EMIT_OBJECT | DEBUG_EMIT_NEW_OBJECT)

				if !(AllowExport) {
					this->GetCurrentTokenContext()->Error("Exported functions are only allowed when building an object file")
				}

				NewDefine->Attributes |= FUNCTION_ATTRIBUTE_EXPORT

				if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_AS)) {
					if (this->PeekNextToken()->Is(TOKEN_TYPE_STRING)) {
						NewDefine->ExportName := this->GetNextToken()->StringValue
					}
				}
				else if (this->PeekNextToken()->Is(TOKEN_TYPE_IDENTIFIER)) {
					SafeString* ExportKind := this->PeekNextToken()->StringValue

					if (ExportKind->Equals("raw")) {
						NewDefine->ExportName := NewDefine->Name
						this->GetNextToken()
					}
				}

				NewDefine->CallCount := 2 ; lol
			}

			if (ForVirtual && !this->PeekNextToken()->Is(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
				return NewDefine
			}
			
			if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_ASSEMBLY)) {
				NewDefine->Attributes |= FUNCTION_ATTRIBUTE_ASSEMBY
				
				NewDefine->AssemblyBody := this->ParseAssembly(false)->AssemblyValue
			}
			else {
				i32 Length := 4
				i8* Buffer := Alloc(Length)
				
				if (this->Config->DebugMode & DEBUG_EMIT_FUNCTION_NAMES) {
					Length := NewDefine->GetStringLength()
					Buffer := ReAlloc(Buffer, Length + 1)
					
					NewDefine->StringifyInto(Buffer)
					
					NewDefine->StringBufferSize := Length
				}
				
				NewDefine->StringBuffer := Buffer
				
				NewDefine->Body := this->ParseBlock()
				
				if (NewDefine->ReturnType != this->void->AsNonPointer()) {
					if !(NewDefine->Body->HasUnconditionalReturn) {
						NewDefine~>Context->Error("Function has non-void return type, but no unconditional return statement")
					}
				}
			}
			
			NewDefine->HasFullDefinition := true
			this->CurrentFunction := null
		
			if (!ForMethod && NameToken->StringValue->Equals("Main")) {
				this->MainFunction := NewDefine
			}
		}
		
		return NewDefine
	}
	define FunctionDefine* ParseFunctionDefinition(HashMap* Container, Token* FirstToken, TypeInfo* ThisType, i8 ForMethod) {
		return this->ParseFunctionDefinition(Container, FirstToken, ThisType, FirstToken->Value As i8, ForMethod)
	}
	define FunctionDefine* ParseFunctionDefinition(HashMap* Container, Token* FirstToken) {
		return this->ParseFunctionDefinition(Container, FirstToken, null, false)
	}
	
	define TypeInfo* ParseCustomTypeName(TYPE_KIND Kind) {
		QualifiedName* Name := this->ParseQualifiedName()
		
		TypeInfo* NewType := this->TryLookupQualifiedName(Name)
		
		if (NewType) {
			; Check for a type with this name already existing
			
			if !(NewType->IsIncomplete) {
				; If the type we found isn't incomplete, then error out
				
				this->DuplicateDefinitionError(Name~>Context, NewType->DefinedAt)
			}
			
			NewType->IsIncomplete := false
			NewType->Kind := Kind
		}
		else {
			; We didn't find a type by this name, so we can add it like normal
			
			NewType := this->AddType(Name~>Context, Name, 0, Kind)
		}

		NewType->DefinedAt := Name~>Context
		
		return NewType
	}

	declare Type ParseBitsAsType()
	declare void ParseBitsFields(TypeInfo*, i16, i16)

	define i16 ParseNestedStruct(TypeInfo* ForType, i8 IsUnaligned, i16 NextFieldOffset, void(void*, TypeInfo*, FunctionDefine*) OnMethod) {
		HashMap* Fields := ForType~>Fields
		HashMap* Methods := ForType~>Methods
		HashMap* StaticMethods := ForType~>StaticMethods

		PointerArray* FieldsInOrder := ForType->FieldsInOrder

		i8 InUnion := false
		i16 MaxUnionSize := 0

		i16 TotalSize := ForType->Size

		loop {
			i8 IsFirstUnionMember := false

			if !(InUnion) {
				if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_UNION)) {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for union body.")
					
					InUnion := true
					MaxUnionSize := 0
					IsFirstUnionMember := true
				}
				else {
					i8 IsMethod := false
					i8 IsStaticMethod := false

					i32 BeforeMethod := this->Freeze()
					Token* MethodKeyword := this->PeekNextToken()
					
					if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD)) {
						i8 KeywordValue := MethodKeyword->Value As i8
						
						IsStaticMethod := KeywordValue = KEYWORD_STATIC
						IsMethod := IsStaticMethod || KeywordValue = KEYWORD_DECLARE || KeywordValue = KEYWORD_DEFINE
					}
					
					if (IsMethod) {
						HashMap* MethodContainer := Methods
						TypeInfo* ThisType := ForType
						
						if (IsStaticMethod) {
							MethodContainer := StaticMethods
						}
						
						FunctionDefine* Method := this->ParseFunctionDefinition(MethodContainer, MethodKeyword, ThisType, !IsStaticMethod)

						if (OnMethod != null) {
							OnMethod(this, ForType, Method)
						}

						; Ignore commas after methods, they aren't actually needed for parsing
						this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
						
						if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
							break
						}
						
						continue
					}
					else {
						this->Unfreeze(BeforeMethod)
					}
				}
			}

			if (InUnion && this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_STRUCT)) {
				this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected '{' to open nested struct")
				i16 FieldSize := this->ParseNestedStruct(ForType, IsUnaligned, NextFieldOffset, OnMethod) - TotalSize
			}
			else if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_BITS)) {
				Type BackingType := this->ParseBitsAsType()
				i16 FieldSize := GetTypeSize(BackingType)

				this->ParseBitsFields(ForType, NextFieldOffset, FieldSize)
			}
			else {
				Type FieldType := this->ParseType(true)
				
				Token* FieldNameToken := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for struct field name")
				SafeString* FieldName := FieldNameToken->StringValue

				i8 Padding? := FieldName->Equals("_")

				if !(Padding?) {
					StructField* NextField := Alloc(#StructField) As StructField*

					if (!InUnion || IsFirstUnionMember) {
						FieldsInOrder->Push(NextField)
					}
					
					NextField->ValueType := FieldType

					NextField->Name := FieldName
					NextField->DefinedAt := FieldNameToken~>Context
					
					HashMapElement* LastDefinitionElement := Fields->Get(FieldName)
					
					if (LastDefinitionElement) {
						StructField* LastDefinition := LastDefinitionElement->Value
						
						this->DuplicateDefinitionError(FieldNameToken~>Context, LastDefinition->DefinedAt)
					}
					
					Fields->Set(FieldName, NextField)
				}
				
				i16 FieldSize := GetTypeStorageSize(FieldType)

				;Print("Align To %i from %i\n", FieldSize, NextFieldOffset)
				
				; Only align the field if it isn't a struct, array, union, and if this structure isn't unaligned 
				
				if (GetPointerDepth(FieldType) = 0 && GetBaseType(FieldType)->Is(TYPE_KIND_STRUCTURE)) {
					; Dummy branch
				}
				else if (InUnion || IsUnaligned) {
					; Dummy branch
				}
				else if (FieldType.IsArray) {
					; Dummy branch
				}
				else if (NextFieldOffset % FieldSize) {
					; Pad the field's offset to a multiple of its size
					
					NextFieldOffset += FieldSize - (NextFieldOffset % FieldSize)
				}
				
				; If we're in a union, don't change the NextFielzOffset so all union fields get overlapping offsets
				
				if !(Padding?) {
					NextField->Offset := NextFieldOffset
				}
			}
			
			if (InUnion) {
				if (FieldSize > MaxUnionSize) {
					MaxUnionSize := FieldSize
				}
			}
			else {
				NextFieldOffset += FieldSize
			}
			
			TotalSize := NextFieldOffset
			
			if (InUnion && this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				;Print("End union, %i + %i\n", NextFieldOffset, MaxUnionSize)

				InUnion := false
				NextFieldOffset += MaxUnionSize
				TotalSize := NextFieldOffset
			}

			; Ignore commas after fields, since they aren't needed for parsing
			this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
			
			if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				break
			}
		}

		return TotalSize
	}

	define void ParseStructFields(TypeInfo* ForType, i8 IsUnaligned, void(void*, TypeInfo*, FunctionDefine*) OnMethod) {
		this->CurrentNamespace->DefineEntry("self", ForType)
		i16 TotalSize := this->ParseNestedStruct(ForType, IsUnaligned, ForType->Size, OnMethod)
		this->CurrentNamespace->DeleteEntry("self")

		ForType->Size := TotalSize
	}

	define void ParseStructFields(TypeInfo* ForType, i8 IsUnaligned) {
		this->ParseStructFields(ForType, IsUnaligned, null)
	}
	
	define void ParseStructDefinition() {
		TypeInfo* NewType := this->ParseCustomTypeName(TYPE_KIND_STRUCTURE)
		
		NewType->InitializeAggregate()
		
		i8 IsUnaligned := this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_UNALIGNED)
		
		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for struct body")

		this->ParseStructFields(NewType, IsUnaligned)
		
		NewType->IsIncomplete := false
	}

	define void ParseBitsFields(TypeInfo* NewType, i16 ByteOffset, i16 BackingTypeSize) {
		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected opening brace for bits type body.")
		
		i8 BackingTypeSizeBits := (BackingTypeSize * 8) As i8

		HashMap* Fields := NewType~>Fields
		HashMap* Methods := NewType~>Methods
		HashMap* StaticMethods := NewType~>StaticMethods

		loop {
			i8 IsMethod := false
			i8 IsStaticMethod := false
			Token* MethodKeyword := this->PeekNextToken()
			
			if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD)) {
				i8 KeywordValue := MethodKeyword->Value As i8
				
				IsStaticMethod := KeywordValue = KEYWORD_STATIC
				IsMethod := IsStaticMethod || KeywordValue = KEYWORD_DECLARE || KeywordValue = KEYWORD_DEFINE
			}
			
			if (IsMethod) {
				HashMap* MethodContainer := Methods
				TypeInfo* ThisType := NewType
				
				if (IsStaticMethod) {
					MethodContainer := StaticMethods
				}
				
				this->ParseFunctionDefinition(MethodContainer, MethodKeyword, ThisType, !IsStaticMethod)
				
				; Ignore commas after methods, they aren't actually needed for parsing
				this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
				
				if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
					break
				}
				
				continue
			}
		
			StructField* NextField := Alloc(#StructField) As StructField*

			if (NewType->Is(TYPE_KIND_STRUCTURE)) {
				NextField->IsStructBitField := true
			}
			
			Type FieldType := TYPE_NONE
			
			if !(this->PeekNextToken()->Is(TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET)) {
				ASTNode* FieldTypeNode := this->ParseTypeNode()
				
				FieldType := FieldTypeNode->TypeValue
				
				if (GetPointerDepth(FieldType) = 0 && GetBaseType(FieldType)->Is(TYPE_KIND_STRUCTURE)) {
					FieldTypeNode->Error("Structures cannot be contained in `bits` types")
				}
			}
			
			Token* OpenBracket := this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET, "Expected open bracket for bit field range.")
			
			i8 StartIndex := this->Consume(TOKEN_TYPE_INTEGER, "Expected integer for bit field start index.")->Value As i8
			i8 EndIndex := StartIndex
			
			if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_COLON)) {
				EndIndex := this->Consume(TOKEN_TYPE_INTEGER, "Expected integer for bit field end index.")->Value As i8
			}
			
			i8 FieldSize := EndIndex - StartIndex
			
			Token* CloseBracket := this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected close bracket for bit field range.")
			
			OpenBracket~>Context->Merge(CloseBracket~>Context)
			
			if (FieldSize < 0 || FieldSize > BackingTypeSizeBits) {
				OpenBracket->Error("Field size can not be negative, or bigger than the backing type.")
			}
			
			SafeString* FieldName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected bit field name.")->StringValue
			
			NextField->Name := FieldName
			NextField->Offset := ByteOffset
			NextField->BitBackingSize := BackingTypeSize As i8
			NextField->BitStartIndex := StartIndex
			NextField->BitEndIndex := EndIndex
			
			if (FieldType != TYPE_NONE) {
				NextField->ValueType := FieldType
			}
			else {
				if (FieldSize <= 8) {
					NextField->ValueType := this->i8->AsNonPointer()
				}
				else if (FieldSize <= 16) {
					NextField->ValueType := this->i16->AsNonPointer()
				}
				else if (FieldSize <= 32) {
					NextField->ValueType := this->i32->AsNonPointer()
				}
				else {
					NextField->ValueType := this->i64->AsNonPointer()
				}
			}
			
			Fields->Set(FieldName, NextField)
			
			this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
			
			if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				break
			}
		}
	}

	define Type ParseBitsAsType() {
		this->Consume(TOKEN_TYPE_OPERATOR, OPERATOR_AS, "Expected 'as' before bits backing type name")
		
		ASTNode* BackingTypeNode := this->ParseTypeNode()
		Type BackingType := BackingTypeNode->ValueType
		
		TypeInfo* BackingBase := GetBaseType(BackingType)
		i32 BackingDepth := GetPointerDepth(BackingType)
		
		if (BackingBase->Is(TYPE_KIND_STRUCTURE) || BackingDepth) {
			; Invalid types for bits backing types
			
			BackingTypeNode->Error("Bits backing type must be a plain integer type.")
		}

		return BackingType
	}
	
	define void ParseBitsDefinition() {
		TypeInfo* NewType := this->ParseCustomTypeName(TYPE_KIND_BIT_FIELDS)
		
		HashMap* Fields := NewType~>Fields
		HashMap* Methods := NewType~>Methods
		HashMap* StaticMethods := NewType~>StaticMethods
		
		Fields->Initialize()
		Methods->Initialize()
		StaticMethods->Initialize()
		
		Type BackingType := this->ParseBitsAsType()
		
		i8 BackingTypeSize := GetTypeSize(BackingType) As i8
		NewType->Size := BackingTypeSize
		
		this->CurrentNamespace->DefineEntry("self", NewType)
		this->ParseBitsFields(NewType, 0, BackingTypeSize)
		this->CurrentNamespace->DeleteEntry("self")
	}
	
	define void ParseEnumDefinition() {
		TypeInfo* BaseEnumType := this->ParseCustomTypeName(TYPE_KIND_ENUMERATION)
		BaseEnumType->Size := 4
		HashMap* Fields := BaseEnumType~>Fields
		Fields->Initialize()

		BaseEnumType->FieldsInOrder := PointerArray:New()
		PointerArray* FieldsInOrder := BaseEnumType->FieldsInOrder

		if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_AS)) {
			ASTNode* BackingTypeNode := this->ParseTypeNode()
			Type BackingType := BackingTypeNode->ValueType
			
			TypeInfo* BackingBase := GetBaseType(BackingType)
			i32 BackingDepth := GetPointerDepth(BackingType)
			
			if (BackingBase->Is(TYPE_KIND_STRUCTURE) || BackingDepth) {
				; Invalid types for bits backing types
				
				BackingTypeNode->Error("Enum backing type must be a plain integer.")
			}

			BaseEnumType->Size := BackingBase->Size
		}

		Type EnumType := MakeType(BaseEnumType, 0)
		
		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected opening brace for enum type body")

		if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
			return
		}
		
		BaseEnumType->IsLinearEnumeration := true
		i32 NextValue := 0
		
		loop {
			Token* EnumVariableName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected identifier for enum field name")
			
			if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
				i32 NewNextValue := this->Consume(TOKEN_TYPE_INTEGER, "Expected enum field value")->IntegerValue As i32

				if (FieldsInOrder->Count() = 0) {
					BaseEnumType->EnumerationBase := NewNextValue
				}
				else if (NewNextValue != NextValue) {
					BaseEnumType->IsLinearEnumeration := false
				}

				NextValue := NewNextValue
			}
			
			if (Fields->Get(EnumVariableName->StringValue)) {
				EnumVariableName->Error("Duplicate definition")
			}

			i32 Value := NextValue++
			
			StructField* MemberField := Alloc(#StructField)
			
			MemberField->DefinedAt := EnumVariableName~>Context
			MemberField->Name := EnumVariableName->StringValue
			MemberField->ValueType := EnumType
			MemberField->EnumValue := Value

			Fields->Set(EnumVariableName->StringValue, MemberField)
			FieldsInOrder->Push(MemberField)
			
			i8* RawEnumGlobalName := Alloc(50)
			i32 Length := FormatString(RawEnumGlobalName, 50, "%s_%s", BaseEnumType->Name->Buffer, EnumVariableName->StringValue->Buffer)

			RawEnumGlobalName[Length] := 0

			for (i32 Index := 0, Index < Length, Index++) {
				RawEnumGlobalName[Index] := Upper(RawEnumGlobalName[Index])
			}

			SafeString* EnumGlobalName := AToS(RawEnumGlobalName)
			
			VariableInfo* EnumVariable := Alloc(#VariableInfo)
			
			EnumVariable->Name := EnumGlobalName
			EnumVariable->Type := EnumType
			EnumVariable->LastValue := ASTNode:New(NODE_TYPE_INTEGER, Value, EnumType)
			EnumVariable->SetCount := 1
			EnumVariable->IsGlobal := true
			
			this->AddGlobal(EnumVariable, EnumVariableName)
			
			if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
				continue
			}
			else if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				break
			}
		}

		i32 FieldCount := FieldsInOrder->Count()

		; Generate array of offsets
		i32 NamesSize := FieldCount * #i32
		i32* NameOffsets := Alloc(NamesSize)

		for (i32 Index := 0, Index < FieldCount, Index++) {
			StructField* Field := FieldsInOrder->At(Index)
			NameOffsets[Index] := this->AddGlobalConstantData(Field->Name->Buffer, Field->Name->Length + 1)

			;Print("Field %i '%s' = %x\n", Index, Field->Name->Buffer, NameOffsets[Index])
		}

		BaseEnumType->EnumerationNamesOffset := this->AddGlobalConstantData(NameOffsets, NamesSize)
	}

	define FunctionDefine* MakeDerivedMethod(SourceContext* Blame, i8* Name, Type ReturnType, i32 ParameterTypeCount, Type* ParameterTypes) {
		FunctionDefine* Definition := Alloc(#FunctionDefine)

		Definition~>Context->Clone(Blame)

		Definition->Name := AToS(Name)

		Definition->LabelNumber := this->LabelCount++

		Definition->ParameterCount := ParameterTypeCount As i16
		Definition->Parameters := Alloc(ParameterTypeCount * #VariableInfo*)

		Definition->ReturnType := ReturnType

		for (i32 Index := 0, Index < ParameterTypeCount, Index++) {
			VariableInfo* Parameter := Alloc(#VariableInfo)
			Type ParameterType := ParameterTypes[Index]

			Parameter->Name := AToS(FormatString("%s_%i", Name, Index))
			Parameter->Type := ParameterType
			Parameter->IsParameter := true

			Definition->Parameters[Index] := Parameter
		}

		return Definition
	}

	define FunctionDefine* MakeDerivedMethod(SourceContext* Blame, i8* Name, Type ReturnType, ... RawParameterTypes) {
		i32 ParameterTypeCount := RawParameterTypes[0] As i32
		Type* ParameterTypes := &RawParameterTypes[1] As Type*

		return this->MakeDerivedMethod(Blame, Name, ReturnType, ParameterTypeCount, ParameterTypes)
	}

	define SourceContext* MakeFakeContext(i8* FileName, i8* Text) {
		LexerState* FakeLexer := LexerState:Fake(Text, AToS(FileName))

		SourceContext* FakeContext := Alloc(#SourceContext)
		FakeContext->Lexer := FakeLexer
		FakeContext->LineNumber := 0
		FakeContext->PositionInSource := 0
		FakeContext->LengthInSource := StringLength(Text) As i16

		return FakeContext
	}

	define TypeInfo* MakeDerivableInterface(i8* Name, i32 MethodCount) {
		TypeInfo* NewType := Alloc(#TypeInfo)
		
		NewType->InitializeAggregate()
		NewType->DefinedAt := this->MakeFakeContext(FormatString("Internal Interface %s", Name), FormatString("interface %s {", Name))
		NewType->Name := AToS(Name)
		NewType->Size := (MethodCount * #void*) As i16
		NewType->Kind := TYPE_KIND_INTERFACE
		NewType->InterfaceInfo := InterfaceInfo:New()
		NewType->InterfaceInfo->Name := NewType->Name

		this->RootNamespace->DefineEntry(Name, NewType)

		return NewType
	}

	define FunctionDefine* AddDeriveableMethod(TypeInfo* Info, i8* Name, i8* FakeSource, Type ReturnType, ... RawParameterTypes) {
		i32 ParameterTypeCount := RawParameterTypes[0] As i32
		Type* ParameterTypes := &RawParameterTypes[1] As Type*

		SourceContext* Context := this->MakeFakeContext(Info->Name->Buffer, FakeSource)

		FunctionDefine* Method := this->MakeDerivedMethod(Context, Name, ReturnType, ParameterTypeCount, ParameterTypes)
		
		Method->IsMethod := FUNCTION_IS_INTERFACE_METHOD
		Method->MethodOfType := Info
		Method->MethodOfTypeName := Info->Name
		Method->VirtualFunctionTableSlot := Info->InterfaceInfo->Methods->Count()

		Info->InterfaceInfo->Methods->Push(Method)
		Info~>Methods->Set(Name, Method)

		return Method
	}

	TypeInfo* IAnyType
	TypeInfo* IAllocateType
	TypeInfo* INewType
	TypeInfo* IDebugType

	define void SetupDerivableInterfaces() {
		Type VoidType := this->void->AsNonPointer()
		Type ThisType := this->void->AsPointer(1)
		Type AnyType := ThisType

		;this->MakeFakeContext("IAny", "IAny")
		;this->MakeFakeContext("IAny", "define void Initialize(self* this) { derived }")

		this->IAnyType := this->MakeDerivableInterface("IAny", 2)
		this->AddDeriveableMethod(this->IAnyType, "Initialize", "virtual void Initialize(self*)", VoidType, ThisType)
		this->AddDeriveableMethod(this->IAnyType, "TypeID", "virtual i64 TypeID(self*)", this->i64->AsNonPointer(), ThisType)

		this->IAllocateType := this->MakeDerivableInterface("IAllocate", 2)
		this->AddDeriveableMethod(this->IAllocateType, "Allocate", "virtual self* Allocate()", ThisType)
		this->AddDeriveableMethod(this->IAllocateType, "Delete", "virtual void Delete(self*)", VoidType, ThisType)
		
		; INew has 0 methods, and instead generates one `:New` static method for each
		;  defined `->New` method, with the static version implicitly calling
		;   `:Allocate` and returning `this`
		this->INewType := this->MakeDerivableInterface("INew", 0)
	}

	define FunctionDefine* FindFirstFunctionByName(i8* Name) {
		HashMapElement* Element := this~>Functions->Get(Name)

		if !(Element) {
			return null
		}

		return Element->Value As FunctionDefine*
	}

	define FunctionDefine* MatchFunctionBySignature(SourceContext* Blame, FunctionDefine* First, i32 ParameterCount, Type* ParameterTypes) {
		ASTNode** Parameters := Alloc(ParameterCount * #ASTNode*)

		for (i32 Index := 0, Index < ParameterCount, Index++) {
			Parameters[Index] := ASTNode:New(NODE_TYPE_NONE, 0, ParameterTypes[Index])
		}

		return this->MatchFunctionCall(First, Parameters, ParameterCount, Blame, &InternalMatchFunctionErrors)
	}

	define FunctionDefine* FindInternalFunction(SourceContext* Blame, i8* Name, Type ReturnType, ... RawParameterTypes) {
		i32 ParameterCount := RawParameterTypes[0] As i32
		Type* ParameterTypes := &RawParameterTypes[1] As Type*

		FunctionDefine* First := this->FindFirstFunctionByName(Name)

		if !(First) {
			Blame->Error(FormatString("Could not find internal function '%s'", Name))
		}

		FunctionDefine* ParameterMatch := this->MatchFunctionBySignature(Blame, First, ParameterCount, ParameterTypes)

		if (CheckTypes(this->void, ParameterMatch->ReturnType, ReturnType, null)) {
			ParameterMatch~>Context->Error(FormatString("Internal function return type should be %t, not %t", ReturnType, ParameterMatch->ReturnType))
		}

		return ParameterMatch
	}

	FunctionDefine* Allocator
	FunctionDefine* Deleter

	define void EnsureIAllocateFunctions(SourceContext* Blame) {
		if !(this->Allocator) {
			; declare void* AllocateInstance(i64 Size, i64 TypeID)
			this->Allocator := this->FindInternalFunction(Blame, "AllocateInstance", this->void->AsPointer(1), this->i64->AsNonPointer(), this->i64->AsNonPointer())
		}

		if !(this->Deleter) {
			; declare void DeleteInstance(void* Instance, i64 Size)
			this->Deleter := this->FindInternalFunction(Blame, "DeleteInstance", this->void->AsNonPointer(), this->void->AsPointer(1), this->i64->AsNonPointer())
		}
	}

	define FunctionDefine* AddDerivedMethod(InterfaceImplementationInfo* Info, i32 Index, i8* Name, Type ReturnType, ... RawParameterTypes) {
		i32 ParameterTypeCount := RawParameterTypes[0] As i32
		Type* ParameterTypes := &RawParameterTypes[1] As Type*

		FunctionDefine* Definition := this->MakeDerivedMethod(Info->Blame, Name, ReturnType, ParameterTypeCount, ParameterTypes)

		Definition->IsMethod := FUNCTION_IS_DERIVED_METHOD

		Definition->MethodOfTypeName := Info->ForType->Name

		Definition->DerivedImplementationInfo := Info
		Definition->DerivedMethodIndex := Index

		Definition->CallCount := 2

		Info->Methods->Push(Definition)

		return Definition
	}

	define InterfaceImplementationInfo* DeriveInterfaceImplementation(SourceContext* Blame, TypeInfo* Target, TypeInfo* InterfaceType) {
		InterfaceImplementationInfo* Implementation := InterfaceImplementationInfo:New(Blame, Target, InterfaceType)

		Implementation->IsDerived := true

		Type VoidType := this->void->AsNonPointer()
		Type ThisType := Target->AsPointer(1)

		if (Implementation->ForInterface = this->IAnyType) {
			this->AddDerivedMethod(Implementation, 0, "Initialize", VoidType, ThisType)
			this->AddDerivedMethod(Implementation, 1, "TypeID", this->i64->AsNonPointer(), ThisType)
		}
		else if (Implementation->ForInterface = this->IAllocateType) {
			this->EnsureIAllocateFunctions(Blame)

			; todo: new type() as (null As Type*)->New()

			FunctionDefine* Allocate := this->AddDerivedMethod(Implementation, 0, "Allocate", ThisType)
			this->AddDerivedMethod(Implementation, 1, "Delete", VoidType, ThisType)

			Allocate->IsStaticDerive := true
			Target~>StaticMethods->Set(Allocate->Name, Allocate)
		}
		else if (Implementation->ForInterface = this->IDebugType) {

		}
		else if (Implementation->ForInterface = this->INewType) {

		}
		else {
			Blame->Error("Cannot derive implementation for this interface")
		}

		; Whoops, we forgot to register all of our derived methods. Just do it here

		i32 Count := Implementation->Methods->Count()

		for (i32 Index := 0, Index < Count, Index++) {
			FunctionDefine* Method := Implementation->Methods->At(Index)

			Target~>Methods->Set(Method->Name, Method)
		}

		return Implementation
	}

	define InterfaceImplementationInfo* AddClassInterface(TypeInfo* ContainerType, SourceContext* Blame, TypeInfo* InterfaceType, i8 IsDerived) {
		ClassInfo* Info := ContainerType->ClassInfo

		InterfaceImplementationInfo* ImplementationInfo := null

		if (IsDerived) {
			ImplementationInfo := this->DeriveInterfaceImplementation(Blame, ContainerType, InterfaceType)
		}
		else {
			ImplementationInfo := InterfaceImplementationInfo:New(Blame, ContainerType, InterfaceType)
		}

		ImplementationInfo->VirtualFunctionTableLabel := this->LabelCount++
		ImplementationInfo->SetupVirtualFunctionTableLabel := this->LabelCount++

		i32 MethodCount := InterfaceType->InterfaceInfo->Methods->Count()

		for (i32 Index := 0, Index < MethodCount, Index++) {
			ImplementationInfo->StubLabels[Index] := this->LabelCount++
		}

		Info->InterfacesInOrder->Push(ImplementationInfo)
		Info->Interfaces->InsertPointer(InterfaceType As i64, ImplementationInfo)

		InterfaceType->InterfaceInfo->ImplementedBy->InsertPointer(ContainerType As i64, ContainerType)

		StructField* Field := Alloc(#StructField)
		
		Field->DefinedAt := null
		Field->Name := AToS(FormatString("__VirtualFunctionTable_%s", InterfaceType->Name->Buffer))
		Field->ValueType := this->void->AsPointer(1)
		Field->Offset := ContainerType->Size
		ContainerType->Size += 8

		;Print("vtbl field: %s\n", Field->Name->Buffer)

		ContainerType~>Fields->Set(Field->Name, Field)
		ContainerType->FieldsInOrder->Push(Field)

		return ImplementationInfo
	}

	define void ParseClassInterface(TypeInfo* ContainerType, i8 IsDerived) {
		ClassInfo* Info := ContainerType->ClassInfo

		QualifiedName* InterfaceName := this->ParseQualifiedName()
		TypeInfo* InterfaceType := this->TryLookupQualifiedName(InterfaceName)

		if (InterfaceType->Kind != TYPE_KIND_INTERFACE) {
			InterfaceName~>Context->Error("Classes can only implement interface types")
		}
		else if (Info->Interfaces->Has(InterfaceType)) {
			InterfaceName~>Context->Error("Interface is already implemented/derived")
		}

		if (InterfaceType = this->INewType) {
			if !(IsDerived) {
				InterfaceName~>Context->Error("Cannot manually implement INew, derive this interface instead")
			}

			; Automatically derive IAllocate when implementing INew

			if !(Info->Interfaces->Has(this->IAllocateType)) {
				this->AddClassInterface(ContainerType, InterfaceName~>Context, this->IAllocateType, true)
			}
		}

		this->AddClassInterface(ContainerType, InterfaceName~>Context, InterfaceType, IsDerived)
	}

	define void OnClassMethodDefined(TypeInfo* ForType, FunctionDefine* Current) {
		ClassInfo* Info := ForType->ClassInfo
		InterfaceImplementationInfo* INewImplementation := Info->Interfaces->GetPointer(this->INewType)

		if (INewImplementation) {
			if (Current->IsMethod = FUNCTION_IS_METHOD && Current->Name->Equals("New")) {
				i32 ParameterCount := Current->ParameterCount - 1
				Type* ParameterTypes := Alloc(ParameterCount * #Type)

				for (i32 Index := 0, Index < ParameterCount, Index++) {
					VariableInfo* OriginalParameter := Current->Parameters[Index + 1]

					ParameterTypes[Index] := OriginalParameter->Type
				}

				FunctionDefine* DerivedWrapper := this->MakeDerivedMethod(Current~>Context, "New", ForType->AsPointer(1), ParameterCount, ParameterTypes)

				DerivedWrapper->IsMethod := FUNCTION_IS_DERIVED_METHOD
				DerivedWrapper->IsStaticDerive := true
				DerivedWrapper->MethodOfTypeName := ForType->Name

				DerivedWrapper->DerivedImplementationInfo := INewImplementation
				DerivedWrapper->WrappedNewMethod := Current

				HashMapElement* Last := ForType~>StaticMethods->Get("New")

				if (Last) {
					DerivedWrapper->Next := Last->Value
				}

				ForType~>StaticMethods->Set("New", DerivedWrapper)
			}
		}
	}

	define void ParseClass() {
		TypeInfo* NewType := this->ParseCustomTypeName(TYPE_KIND_STRUCTURE)
		
		NewType->InitializeAggregate()

		NewType->IsClass := true

		ClassInfo* Info := ClassInfo:New()
		NewType->ClassInfo := Info

		Info->IAnyImplementation := this->AddClassInterface(NewType, this->MakeFakeContext("Implicit Derive", "IAny"), this->IAnyType, true)

		i8 CanDerive := true

		if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_IMPLEMENTS)) {
			CanDerive := false

			loop {
				this->ParseClassInterface(NewType, false)

				if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
					break
				}
				else if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
					if (this->PeekNextToken()->Is(TOKEN_TYPE_KEYWORD, KEYWORD_DERIVES)) {
						CanDerive := true
						break
					}

					continue
				}
				else {
					this->PeekNextToken()->Error("Unexpected token in 'implements' list")
				}
			}
		}
		else if (this->PeekNextToken()->Is(TOKEN_TYPE_KEYWORD, KEYWORD_DERIVES)) {
			; dummy branch
		}
		else {
			this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for struct body")
		}

		if (CanDerive && this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_DERIVES)) {
			loop {
				this->ParseClassInterface(NewType, true)

				if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
					break
				}
				else {
					this->PeekNextToken()->Error("Unexpected token in 'derives' list")
				}
			}
		}

		this->ParseStructFields(NewType, false, &self.OnClassMethodDefined)

		HashMap* Methods := NewType~>Methods
		i32 Count := Info->InterfacesInOrder->Count()

		for (i32 Index := 0, Index < Count, Index++) {
			InterfaceImplementationInfo* ImplementationInfo := Info->InterfacesInOrder->At(Index)

			TypeInfo* InterfaceType := ImplementationInfo->ForInterface
			SourceContext* InterfaceBlame := ImplementationInfo->Blame

			PointerArray* InterfaceMethods := ImplementationInfo->ForInterfaceInfo->Methods
			i32 MethodCount := InterfaceMethods->Count()

			for (i32 MethodIndex := 0, MethodIndex < MethodCount, MethodIndex++) {
				FunctionDefine* InterfaceMethod := InterfaceMethods->At(MethodIndex)
				i8 HasDefaultImplementation := InterfaceMethod->HasFullDefinition

				HashMapElement* TargetElement := Methods->Get(InterfaceMethod->Name)
				FunctionDefine* TargetMethod := null

				if (TargetElement = null) {
					if (HasDefaultImplementation) {
						Methods->Set(InterfaceMethod->Name, InterfaceMethod)
						TargetMethod := InterfaceMethod
					}
					else {
						InterfaceBlame->Notify(NOTIFY_ERROR, "Interface not implemented")
						InterfaceMethod~>Context->Error("Method not implemented")
					}
				}
				else {
					TargetMethod := TargetElement->Value As FunctionDefine*
				}

				i32 ParameterCount := InterfaceMethod->ParameterCount

				; Build a fake parameter list with the interface method's parameter types
				;  so that we can match against a function which satisfies those types

				ASTNode** Parameters := Alloc(ParameterCount * #ASTNode*)

				for (i32 ParameterIndex := 0, ParameterIndex < ParameterCount, ParameterIndex++) {
					VariableInfo* ParameterInfo := InterfaceMethod->Parameters[ParameterIndex]
					Type ParameterType := ParameterInfo->Type

					Parameters[ParameterIndex] := ASTNode:New(NODE_TYPE_NONE, 0, ParameterType)
				}

				if (HasDefaultImplementation) {
					; If this method has a default impl, check for overrides first
					; If there's no overrides, insert the default impl and then
					;  re-match against it below.

					FunctionDefine* ImplementationMethod := this->MatchFunctionCall(TargetMethod, Parameters, ParameterCount, InterfaceMethod~>Context, null)

					if !(ImplementationMethod) {
						FunctionDefine* Tail := TargetMethod

						while (Tail->Next) {
							Tail := Tail->Next
						}

						Tail->Next := InterfaceMethod
					}
				}

				FunctionDefine* ImplementationMethod := this->MatchFunctionCall(TargetMethod, Parameters, ParameterCount, InterfaceMethod~>Context, &InterfaceMatchFunctionErrors)

				;ImplementationMethod~>Context->Warn("NUTS!")

				ImplementationInfo->Methods->Push(ImplementationMethod)

				ImplementationMethod->CallCount := 2
			}
		}
		
		NewType->IsIncomplete := false
	}

	define void ParseInterface() {
		TypeInfo* NewType := this->ParseCustomTypeName(TYPE_KIND_INTERFACE)
		
		NewType->InitializeAggregate()

		InterfaceInfo* Info := InterfaceInfo:New()
		NewType->InterfaceInfo := Info
		Info->Name := NewType->Name

		this->Interfaces->Push(NewType)

		this->AddDeriveableMethod(NewType, "TypeID", "virtual i64 TypeID()", this->i64->AsNonPointer(), NewType->AsPointer(1))

		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected '{' for interface body")

		loop {
			Token* Peek := this->PeekNextToken()

			;if (this->NextTokenMatches(TOKEN_TYPE_KEYWORD, KEYWORD_VIRTUAL)) {
			if (Peek->Is(TOKEN_TYPE_IDENTIFIER) && Peek->StringValue->Equals("virtual")) {
				this->GetNextToken()

				FunctionDefine* Method := this->ParseFunctionDefinition(NewType~>Methods, this->GetCurrentToken(), NewType, KEYWORD_VIRTUAL, true)

				Method->IsMethod := FUNCTION_IS_INTERFACE_METHOD
				Method->MethodOfType := NewType
				Method->VirtualFunctionTableSlot := Info->Methods->Count()

				NewType->Size += 8

				Info->Methods->Push(Method)
			}
			else if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				break
			}
			else {
				this->PeekNextToken()->Error("Unexpected token in interface")
			}
		}

		;Print("%S->Size = %x\n", NewType->Name, NewType->Size)
	}

	declare i8 ParseProgramStatement()

	define void ParseNamespace() {
		QualifiedName* Name := this->ParseQualifiedName(false)

		this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected '{' to open namespace")

		TypeNamespace* Old := this->EnterNamespace(Name)

		loop {
			this->ParseProgramStatement()

			if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				break
			}
		}

		this->ExitNamespace(Old)
	}
	
	define i8 ParseProgramStatement() {
		Token* NextToken := this->PeekNextToken()
		i8 NextTokenValue := NextToken->Value As i8
		
		if (NextToken->Is(TOKEN_TYPE_KEYWORD)) {
			this->GetNextToken()
			
			if (NextTokenValue <= KEYWORD_DLLIMPORT) {
				; Handles `dllimport`/`declare`/`define`
				this->ParseFunctionDefinition(this~>Functions, NextToken)
			}
			else if (NextTokenValue = KEYWORD_STRUCT) {
				this->ParseStructDefinition()
			}
			else if (NextTokenValue = KEYWORD_BITS) {
				this->ParseBitsDefinition()
			}
			else if (NextTokenValue = KEYWORD_ENUM) {
				this->ParseEnumDefinition()
			}
			else if (NextTokenValue = KEYWORD_CLASS) {
				this->ParseClass()
			}
			else if (NextTokenValue = KEYWORD_INTERFACE) {
				this->ParseInterface()
			}
			else if (NextTokenValue = KEYWORD_LINUX || NextTokenValue = KEYWORD_WINDOWS) {
				i8 IgnoreBlock := true
				
				if (NextTokenValue = KEYWORD_LINUX && this->Config->OutputFormat = OUTPUT_ELF) {
					IgnoreBlock := false
				}
				else if (NextTokenValue = KEYWORD_WINDOWS && this->Config->OutputFormat = OUTPUT_PE) {
					IgnoreBlock := false
				}
				
				if (IgnoreBlock) {
					this->IgnoreBlock()
				}
				else {
					this->Consume(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected opening '{' for block")
					
					while !(this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
						this->ParseProgramStatement()
					}
				}
			}
			else if (NextTokenValue = KEYWORD_EXTERNAL) {
				i32 AllowExternal := this->Config->DebugMode & (DEBUG_EMIT_DYNAMIC | DEBUG_EMIT_OBJECT | DEBUG_EMIT_NEW_OBJECT)

				if !(AllowExternal) {
					NextToken->Error("'--dynamic' or '--object' must be specified to reference external symbols")
				}

				if (this->Config->DebugMode & DEBUG_EMIT_DYNAMIC) {
					Token* ExternalSource := this->Consume(TOKEN_TYPE_STRING, "Expected 'external' declaration source name")

					i8 Exists := false

					for (i32 Index := 0, Index < this->ExternalSources->Count(), Index++) {
						Token* Last := this->ExternalSources->At(Index)

						if (ExternalSource->StringValue->Equals(Last->StringValue)) {
							Exists := true
							break
						}
					}

					if !(Exists) {
						this->ExternalSources->Push(ExternalSource)
					}
				}
				else {
					this->NextTokenMatches(TOKEN_TYPE_STRING)
				}

				i8 Multiple := false

				if (this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
					Multiple := true
				}

				loop {
					Token* SymbolName := this->PeekNextToken()

					if (SymbolName->Is(TOKEN_TYPE_STRING)) {
						this->GetNextToken()
					}
					else {
						SymbolName := null
					}

					Type ExternalType := this->ParseType(false)
					Token* ExternalName := this->Consume(TOKEN_TYPE_IDENTIFIER, "Expected 'external' name")

					if !(SymbolName) {
						SymbolName := ExternalName
					}

					VariableInfo* ExternalVariable := Alloc(#VariableInfo)

					ExternalVariable->Name := ExternalName->StringValue
					ExternalVariable->ExternalSymbolName := SymbolName->StringValue
					ExternalVariable->Type := ExternalType
					ExternalVariable->IsGlobal := true
					ExternalVariable->IsExternal := true

					; Artificial because I really don't want to have to deal with this
					ExternalVariable->GetCount := 2
					ExternalVariable->SetCount := 2
					
					this->AddVariable(ExternalVariable, ExternalName)

					if (this->NextTokenMatches(TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
						this->GetCurrentTokenContext()->Error("'external' variables cannot be assigned")
					}

					if !(Multiple) {
						break
					}

					if (Multiple && this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
						break
					}

					this->NextTokenMatches(TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
				}
			}
			else if (NextTokenValue = KEYWORD_NAMESPACE) {
				this->ParseNamespace()
			}
			else {
				NextToken->Error("Unexpected token")
			}
		}
		else if (NextToken->Is(TOKEN_TYPE_IDENTIFIER)) {
			if (NextToken->StringValue->Equals("class")) {
				this->GetNextToken()

				this->ParseClass()
			}
			else if (NextToken->StringValue->Equals("interface")) {
				this->GetNextToken()

				this->ParseInterface()
			}
			else {
				; Handles global variable declarations
				
				Token* BlameToken := NextToken
				
				i8* ErrorMessage := null
				ASTNode* DefaultValueExpression := this->TryParseVariableDeclaration(true, false, &ErrorMessage)
				
				if (ErrorMessage) {
					BlameToken~>Context->Merge(this->GetCurrentTokenContext())
					BlameToken->Error(ErrorMessage)
				}
				
				if (DefaultValueExpression != null) {
					; Handles global variable default value expressions
					
					i32 Index := GetArrayLength(this->GlobalDefaults)
					this->GlobalDefaults := ReAllocArray(this->GlobalDefaults, 1)
					
					this->GlobalDefaults[Index] := DefaultValueExpression
				}
			}
		}
		else if (NextToken->Is(TOKEN_TYPE_EOF)) {
			return true
		}
		else {
			NextToken->Error("Unexpected token")
		}
		
		return false
	}
	
	define void ParseProgram() {
		; Parse an entire program, aka a list of `dllimport`/`declare`/`define`, `struct`/`bits`, and global
		;  variable declarations.
		
		loop {
			if (this->ParseProgramStatement()) {
				break
			}
		}
	}
}