; TODO: Add a divmod built-in, the `x / constant` with `x % constant` pattern is getting annoying.



/*
==========================================
	Typing helper structs (Defined first since ASTNode has a Type field)
==========================================
*/

struct TypeInfo {
	SafeWideString* Name,
	HashMap Fields,
	HashMap Methods,
	HashMap StaticMethods,
	i16 Size,
	i8 IsStructType,
	i8 IsIncomplete,
	i8 IsBits,
	i8 IsBuiltin
}

bits Type As i64 {
	[0:47] BaseType,
	[48:52] PointerDepth,
	[53:54] IsArray,
	[54:63] ArraySize
}

define TypeInfo* GetBaseType(Type T) {
	return T.BaseType As TypeInfo*
}
define i16 GetTypeSize(Type T) {
	if (T.PointerDepth) {
		return 8
	}
	else {
		return GetBaseType(T)->Size
	}
}

define i32 GetTypeStorageSize(Type T) {
	i32 RegularSize := GetTypeSize(T)
	
	if (T.IsArray) {
		RegularSize := GetBaseType(T)->Size
	
		return RegularSize * (T.ArraySize As i32)
	}
	
	return RegularSize
}
define i32 GetPointerDepth(Type T) {
	return T.PointerDepth As i32
}
define i8* GetTypeName(Type T) {
	SafeWideString* BaseName := GetBaseType(T)->Name
	i32 BaseNameLength := BaseName->Length
	i32 PointerDepth := GetPointerDepth(T)
	
	i32 BufferSize := BaseNameLength + PointerDepth + 1
	
	i8* NameBuffer := Alloc(BufferSize)
	i16* BaseNameBuffer := BaseName->Buffer
	
	for (i32 BaseNameIndex := 0, BaseNameIndex < BaseNameLength, BaseNameIndex += 1) {
		NameBuffer[BaseNameIndex] := BaseNameBuffer[BaseNameIndex] As i8
	}
	
	for (i32 PointerDepthIndex := 0, PointerDepthIndex < PointerDepth, PointerDepthIndex += 1) {
		NameBuffer[BaseNameLength + PointerDepthIndex] := '*'
	}
	
	return NameBuffer
}

struct StructField {
	SafeWideString* Name,
	i16 Offset,
	Type ValueType,
	i8 BitStartIndex,
	i8 BitEndIndex
}

/*
==========================================
	AST Node type constants
==========================================
*/

i8 NODE_TYPE_NONE := 0
i8 NODE_TYPE_TOKEN := 1

i8 NODE_TYPE_UNARY := 2
i8 NODE_TYPE_BINARY := 3
i8 NODE_TYPE_CALL := 4

i8 NODE_TYPE_DEFINE := 6
i8 NODE_TYPE_DLLIMPORT := 7

i8 NODE_TYPE_IF := 8

i8 NODE_TYPE_FOR := 9
i8 NODE_TYPE_WHILE := 10
i8 NODE_TYPE_LOOP := 11
i8 NODE_TYPE_CONTINUEBREAK := 12

i8 NODE_TYPE_RETURN := 13
i8 NODE_TYPE_EXPRESSION := 14

i8 NODE_TYPE_VARIABLE := 15
i8 NODE_TYPE_INTEGER := 16
i8 NODE_TYPE_STRING := 17

i8 NODE_TYPE_TYPE := 18 /* For when an expression has an operand which is a literal type (like with 'as') */
i8 NODE_TYPE_STRUCT_ACCESS := 19
i8 NODE_TYPE_IDENTIFIER := 20

i8 NODE_TYPE_ASSEMBLY := 21

; Dedicated zero node type, to ensure that the actual ValueType of a zero (inside of a NODE_TYPE_INTEGER) 
;  doesn't get optimized into `i8`, since that's the smallest type that could hold `0`.
i8 NODE_TYPE_ZERO := 22

i8 NODE_TYPE_TRY := 23

; Since type sizes can change at parse-time inside of struct methods, the actually resolution
;  of a type's size needs to be deferred until compile-time
i8 NODE_TYPE_GET_TYPE_SIZE := 24

/*
==========================================
	True AST node types
==========================================
*/

i8 GLOBAL_IS_OPTIMIZED_AWAY := 2

struct VariableInfo {
	ASTNode* LastValue,
	SafeWideString* Name,
	Type Type,
	i32 StackOffset,
	i16 GetCount,
	i16 SetCount,
	i8 IsGlobal,
	i8 IsParameter,
	i8 IsVariadic,
	i8 IsThis
}

define VariableInfo* AllocateNewVariableInfo() {
	return Alloc(#VariableInfo) As VariableInfo*
}

declare i32 RoundTo(i32, i32)

struct VariableHashMap {
	HashMap BackingMap
	HashMap* Map
	i32 NextOffset
	
	define void Initialize() {
		this->Map := this~>BackingMap
		
		this->Map->BufferMaxCount := 100
		this->Map->Elements := Alloc(this->Map->BufferMaxCount * 8)
		
		this->NextOffset := 0
	}
	
	define VariableInfo* Get(SafeWideString* VariableName) {
		HashMapElement* FoundElement := this->Map->Get(VariableName)
		
		if (FoundElement) {
			return FoundElement->Value As VariableInfo*
		}
		
		return null
	}
	
	define void Add(VariableInfo* NewVariable, Token* SourceToken) {
		if (this->Get(NewVariable->Name)) {
			/* If we already have this name in the hashmap, then it's a duplicate definition */
			
			TokenError(SourceToken, "Duplicate definition")
		}
		
		this->Map->Set(NewVariable->Name, NewVariable)
		
		NewVariable->StackOffset := this->NextOffset
		
		i16 NewVariableSize := GetTypeStorageSize(NewVariable->Type)
		
		if (NewVariableSize <= 8) {
			this->NextOffset += 8
		}
		else {
			i16 RoundedSize := RoundTo(NewVariableSize, 8) As i16
			
			NewVariable->StackOffset += RoundedSize
			
			this->NextOffset += RoundedSize + 8
		}
	}
}

define VariableHashMap* NewVariableMap() {
	VariableHashMap* Map := Alloc(#VariableHashMap)
	
	Map->Initialize()
	
	return Map
}

struct UnaryExpression {
	Token* Operator,
	ASTNode* Operand
}

struct BinaryExpression {
	ASTNode* Left,
	Token* Operator,
	ASTNode* Right
}

struct StructAccessExpression {
	ASTNode* Left,
	Token* Operator,
	StructField* TargetField
}

struct Block {
	ASTNode** Statements,
	i16 StatementCount
}

struct IfGroup {
	ASTNode** Conditions,
	Block** Bodies,
	Block* ElseBranch,
	i16 BranchCount
}

struct ForLoop {
	ASTNode* Initializer,
	ASTNode* Condition,
	ASTNode* Step,
	Block* Body
}

struct WhileLoop {
	ASTNode* Condition,
	Block* Body
}

struct TryCatch {
	Block* Body,
	Block* CatchBody,
	VariableInfo* CatchCodeVariable
}

i8 FUNCTION_IS_METHOD := 1
i8 FUNCTION_IS_STATIC_METHOD := 2

struct FunctionDefine {
	ErrorContext Context,
	
	FunctionDefine* Next,
	SafeWideString* Name,
	
	i16 ParameterCount,
	VariableInfo** Parameters,
	
	VariableHashMap Locals,
	Type ReturnType,
	
	i8 IsImported,
	
	union {
		Block* Body,
		AssemblyBlock* AssemblyBody,
		SafeWideString* ImportFileName
	},
	union {
		i8* StringBuffer,
		SafeWideString* ImportFunctionName
	},
	
	SafeWideString* MethodOfTypeName,
	
	i8 Attribute,
	i8 HasFullDefinition,
	i32 LabelNumber,
	i32 StringBufferSize,
	
	i32 CallCount,
	i8 UsesGlobals,
	i8 IsMethod,
	
	i8 TempValue
}

i8 BUILTIN_NONE := 0
i8 BUILTIN_SYSCALL := 1
i8 BUILTIN_BREAKPOINT := 2

struct CallExpression {
	FunctionDefine* TargetFunction,
	ASTNode** Parameters,
	i32 ParameterCount,
	i8 BuiltinID
}

struct ParserState {
	BuildConfig* Config,
	TokenizerState* tState,
	
	HashMap Functions,
	
	VariableHashMap Globals,
	ASTNode** GlobalDefaults,
	
	HashMap Registers,
	HashMap Instructions,
	
	HashMap Types,
	
	/* Builtin types, actually added to the type list in CreateDefaultTypes */
	
	TypeInfo* i8,
	TypeInfo* i16,
	TypeInfo* i32,
	TypeInfo* i64,
	TypeInfo* void,
	
	FunctionDefine* CurrentFunction,
	FunctionDefine* MainFunction,
	
	i8 InLoop,
	
	i32 LabelCount
}

define i32 ParserNextLabel(ParserState* pState) {
	i32 Result := pState->LabelCount
	
	pState->LabelCount += 1
	
	return Result
}

/*
==========================================
	AST Node definition + alloc/free helpers
==========================================
*/

struct ASTNode {
	/* First two fields are the same as Token, so they can be used interchangably in error handling functions */
	
	ErrorContext Context,
	
	union {
		void* TrueNode,
		
		UnaryExpression* UnaryNode,
		BinaryExpression* BinaryNode,
		CallExpression* CallNode,
		StructAccessExpression* AccessNode,
		
		IfGroup* IfNode,
		ForLoop* ForNode,
		WhileLoop* WhileNode,
		Block* LoopBody,
		i8 IsContinue,
		
		FunctionDefine* DefineNode,
		
		ASTNode* ReturnExpression,
		
		ASTNode* ExpressionStatement,
		
		SafeWideString* StringValue,
		VariableInfo* VariableValue,
		i64 IntegerValue,
		Type TypeValue,
		i32 StringOffsetValue,
		
		AssemblyBlock* AssemblyValue,
		TryCatch* TryNode
	},
	
	void* LastVisitor
	Type ValueType
	i8 NodeType
	i8 IsStorageValue /* Signals that this node is a value that references a storage location, and can be assigned */
}

struct ASTVisitor {
	void* VisitFunction
	i64 State
	i32 NodeTypeMask
	
	define i32 IsTypeAllowed(i8 NodeType) {
		return !!(this->NodeTypeMask & (1 << NodeType))
	}
	define void AllowType(i8 NodeType) {
		this->NodeTypeMask := this->NodeTypeMask | (1 << NodeType)
	}
	
	define void SetState(i64 State) {
		this->State := State
	}
	define i64 GetState() {
		return this->State
	}
	
	define void SetVisitFunction(void* Function) {
		this->VisitFunction := Function
	}
	define void CallVisitor(ASTNode* Node, void* VisitFunction) asm {
		jmp, rdx
	}
	
	declare void VisitNodes(...),
	declare void RawVisitNodes(i64, ASTNode**),
	
	define void RawVisitBlocks(i64 Count, Block** Blocks) {
		for (i32 Index := 0, Index < Count, Index += 1) {
			Block* Next := Blocks[Index]
			
			this->RawVisitNodes(Next->StatementCount, Next->Statements)
		}
	}
	define void VisitBlocks(... Blocks) {
		this->RawVisitBlocks(Blocks[0], (Blocks + 8) As Block**)
	}
	define void VisitChildren(ASTNode* Node) {
		i8 NodeType := Node->NodeType
		
		if (NodeType = NODE_TYPE_UNARY) {
			this->VisitNodes(Node->UnaryNode->Operand)
		}
		else if (NodeType = NODE_TYPE_BINARY) {
			this->VisitNodes(Node->BinaryNode->Left, Node->BinaryNode->Right)
		}
		else if (NodeType = NODE_TYPE_CALL) {
			this->RawVisitNodes(Node->CallNode->ParameterCount, Node->CallNode->Parameters)
		}
		else if (NodeType = NODE_TYPE_STRUCT_ACCESS) {
			this->VisitNodes(Node->AccessNode->Left)
		}
		else if (NodeType = NODE_TYPE_IF) {
			this->RawVisitNodes(Node->IfNode->BranchCount, Node->IfNode->Conditions)
			this->RawVisitBlocks(Node->IfNode->BranchCount, Node->IfNode->Bodies)
			
			if (Node->IfNode->ElseBranch) {
				this->VisitBlocks(Node->IfNode->ElseBranch)
			}
		}
		else if (NodeType = NODE_TYPE_WHILE) {
			this->VisitNodes(Node->WhileNode->Condition)
			this->VisitBlocks(Node->WhileNode->Body)
		}
		else if (NodeType = NODE_TYPE_FOR) {
			this->VisitNodes(Node->ForNode->Initializer, Node->ForNode->Condition, Node->ForNode->Step)
			this->VisitBlocks(Node->ForNode->Body)
		}
		else if (NodeType = NODE_TYPE_LOOP) {
			this->VisitBlocks(Node->LoopBody)
		}
		else if (NodeType = NODE_TYPE_RETURN) {
			this->VisitNodes(Node->ReturnExpression)
		}
		else if (NodeType = NODE_TYPE_EXPRESSION) {
			this->VisitNodes(Node->ExpressionStatement)
		}
		else if (NodeType = NODE_TYPE_TRY) {
			this->VisitBlocks(Node->TryNode->Body)
			
			if (Node->TryNode->CatchBody) {
				this->VisitBlocks(Node->TryNode->CatchBody)
			}
		}
	}
	
	define void RawVisitNodes(i64 Count, ASTNode** Nodes) {
		for (i32 Index := 0, Index < Count, Index += 1) {
			ASTNode* Node := Nodes[Index]
			
			if (Node->LastVisitor = this) {
				continue
			}
			
			Node->LastVisitor := this
			
			if (this->IsTypeAllowed(Node->NodeType)) {
				this->CallVisitor(Node, this->VisitFunction)
			}
			else {
				this->VisitChildren(Node)
			}
		}
	}
	define void VisitNodes(... Nodes) {
		this->RawVisitNodes(Nodes[0], (Nodes + 8) As ASTNode**)
	}
}

define ASTNode* AllocateNewASTNode(i8 NewNodeType, void* NewNodeTrueNode, Type NewNodeValueType) {
	ASTNode* NewNode := Alloc(#ASTNode) As ASTNode*
	
	UnaryExpression* UnaryNode := NewNodeTrueNode
	BinaryExpression* BinaryNode := NewNodeTrueNode As BinaryExpression*
	StructAccessExpression* StructNode := NewNodeTrueNode As StructAccessExpression*
	
	i8 IsDereference := NewNodeType = NODE_TYPE_UNARY && UnaryNode->Operator->Value = OPERATOR_STAR
	i8 IsArrayAccess := NewNodeType = NODE_TYPE_BINARY && BinaryNode->Operator->Value = OPERATOR_OPEN_BRACKET
	i8 IsStructAccss := NewNodeType = NODE_TYPE_STRUCT_ACCESS && StructNode->Operator->Value != OPERATOR_TILDE_GREATER
	
	if (IsDereference || IsArrayAccess || IsStructAccss || NewNodeType = NODE_TYPE_VARIABLE) {
		NewNode->IsStorageValue := true
	}
	
	NewNode->NodeType := NewNodeType
	NewNode->TrueNode := NewNodeTrueNode
	NewNode->ValueType := NewNodeValueType
	
	return NewNode
}

define ASTNode* AllocateNewASTNode(i8 NewNodeType, i64 NewNodeValue, Type NewNodeValueType) {
	return AllocateNewASTNode(NewNodeType, NewNodeValue As void*, NewNodeValueType)
}

define void FreeASTNode(ASTNode* Node) {
	Free(Node As void*)
}


/*
==========================================
	Expression parser constant lookup functions
==========================================
*/

i8 NONE_ASSOCIATIVE := 0
i8 LEFT_ASSOCIATIVE := 1
i8 RIGHT_ASSOCIATIVE := 2

define i8 GetPrecedence(Token* ForOperator) {
	/* Gets the precedence for a given operator */
	
	i8 Operator := (ForOperator->Value) As i8
	
	if (Operator >= PRECEDENCE_13) {
		return 13
	}
	else if (Operator >= PRECEDENCE_12) {
		return 12
	}
	else if (Operator >= PRECEDENCE_10) {
		return 10
	}
	else if (Operator >= PRECEDENCE_9) {
		return 9
	}
	else if (Operator >= PRECEDENCE_8) {
		return 8
	}
	else if (Operator >= PRECEDENCE_7) {
		return 7
	}
	else if (Operator >= PRECEDENCE_6) {
		return 6
	}
	else if (Operator >= PRECEDENCE_4) {
		return 4
	}
	else if (Operator >= PRECEDENCE_3) {
		return 3
	}
	else if (Operator >= PRECEDENCE_2) {
		return 2
	}
	else if (Operator >= PRECEDENCE_1) {
		return 1
	}
}

define i8 GetPrefixPrecedence(Token* ForOperator) {
	/* Returns the precedence of an operator when it is used as a prefix operator */
	
	i8 Operator := (ForOperator->Value) As i8
	
	if (Operator = OPERATOR_STAR) {
		return 5
	}
	else if (Operator = OPERATOR_AND) {
		return 5
	}
	else if (Operator = OPERATOR_BANG) {
		return 11
	}
	else if (Operator = OPERATOR_MINUS || Operator = OPERATOR_TILDE) {
		return 11
	}
	else if (Operator = OPERATOR_POUND) {
		return 13
	}
	
	return 0 /* Returns 0 when the operator is not a prefix operator */
}

define i8 IsPrefixOperator(Token* ForOperator) {
	/* Used to determine if an operator can be a prefix operator in the parser */
	
	return GetPrefixPrecedence(ForOperator) != 0
}

define i8 GetAssociation(Token* ForOperator) {
	/* Returns RIGHT_ASSOCIATIVE/LEFT_ASSOCIATIVE depending on the operator passed */
	
	i8 Precedence := GetPrecedence(ForOperator)
	
	if (Precedence = 1 || Precedence = 3) {
		return RIGHT_ASSOCIATIVE
	}
	else {
		return LEFT_ASSOCIATIVE
	}
}

/*
==========================================
	Typing functions
==========================================
*/

Type TYPE_NONE := 0

i8 TYPE_REGULAR := 1
i8 TYPE_STRUCT := 2
i8 TYPE_INCOMPLETE := 4
i8 TYPE_BITS := 8
i8 TYPE_ARRAY := 16

define TypeInfo* AddType(ParserState* pState, SafeWideString* Name, i16 Size, i8 Flags) {
	/* Adds a type to pState with the given name, fields, size, structinfo, and completeness */
	
	/* Should only be called once per type name */
	TypeInfo* NewType := Alloc(#TypeInfo) As TypeInfo*
	
	NewType->Name := Name
	NewType->Size := Size

	if (Flags & TYPE_STRUCT) {
		NewType->IsStructType := true
	}
	
	if (Flags & TYPE_INCOMPLETE) {
		NewType->IsIncomplete := true
	}
	
	if (Flags & TYPE_BITS) {
		NewType->IsBits := true
	}
	
	if (Flags & TYPE_REGULAR) {
		NewType->IsBuiltin := true
	}
	
	pState~>Types->Set(Name, NewType)
	
	return NewType
}

define Type MakeType(TypeInfo* BackingType, i16 PointerDepth) {
	/* Functions as GetType except with a TypeInfo passed directly instead of being found by name */
	
	Type NewType := 0
	
	NewType.BaseType := BackingType
	NewType.PointerDepth := PointerDepth

	return NewType
}
define Type MakeType(i64 BackingType, i16 PointerDepth) {
	return MakeType(BackingType As TypeInfo*, PointerDepth)
}

define void CreateDefaultTypes(ParserState* pState) {
	/* Creates all the standard types, only called once */
	
	/* All standard types are not structs, and are not incomplete */
	pState->i8 := AddType(pState, AToS("i8"), 1, TYPE_REGULAR)
	pState->i16 := AddType(pState, AToS("i16"), 2, TYPE_REGULAR)
	pState->i32 := AddType(pState, AToS("i32"), 4, TYPE_REGULAR)
	pState->i64 := AddType(pState, AToS("i64"), 8, TYPE_REGULAR)
	pState->void := AddType(pState, AToS("void"), 8, TYPE_REGULAR)
}

define Type TryGetType(ParserState* pState, SafeWideString* TypeName, i16 PointerDepth, i8** ErrorMessage) {
	/* Finds a TypeInfo with the given name, and builds a Type with that TypeInfo and PointerDepth */
	
	HashMapElement* FoundElement := pState~>Types->Get(TypeName)
	TypeInfo* FoundTypeInfo := 0

	if (FoundElement) {
		/* We found the type with the given name, so we can now set FoundTypeInfo */
		FoundTypeInfo := (FoundElement->Value) As TypeInfo*
	}
	else {
		/*
			If we did not find a typeinfo, then this type has to be an undefined user type, which is defined somewhere else
			So, we will call AddType and add it as incomplete
		*/
		
		if (PointerDepth = 0) {
			ErrorMessage[0] := "Incomplete types can only be used with pointers"
			return 0 As Type
		}
		else {
			/* We didn't find a type with the name, build an incomplete type for it */
			FoundTypeInfo := AddType(pState, TypeName, 0, TYPE_STRUCT | TYPE_INCOMPLETE)
		}
	}
	
	return MakeType(FoundTypeInfo, PointerDepth)
}

declare i32 FreezeParser(ParserState*)
declare void UnfreezeParser(ParserState*, i32)
declare Token* ParserNextToken(ParserState*)

define Type GetType(ParserState* pState, SafeWideString* TypeName, i8 PointerDepth) {
	i8* ErrorMessage := 0
	
	i32 BeforeType := FreezeParser(pState)
	Type Result := TryGetType(pState, TypeName, PointerDepth, &ErrorMessage)
	
	if (ErrorMessage) {
		UnfreezeParser(pState, BeforeType)
		
		Token* BadToken := ParserNextToken(pState)
		
		TokenError(BadToken, ErrorMessage)
	}
	
	return Result
}

declare Token* ParserCurrentToken(ParserState*)

define Type DecrementPointerType(ParserState* pState, Type TypeToDecrement, ErrorContext* BlameContext) {
	/* Returns the type you would get from dereferencing TypeToDecrement */
	
	if (TypeToDecrement.PointerDepth = 0) {
		/* If you're dereferencing a non-pointer type, something's wrong */
		ContextError(BlameContext, "Pointer type expected")
	}
	
	return MakeType(TypeToDecrement.BaseType, (TypeToDecrement.PointerDepth) - 1 As i16)
}
define Type IncrementPointerType(ParserState* pState, Type TypeToIncrement) {
	/* Returns a type which is a pointer to the passed type */
	
	return MakeType(TypeToIncrement.BaseType, (TypeToIncrement.PointerDepth) + 1 As i16)
}

define void PrintType(Type TypeToPrint) {
	/* Prints a type, including its pointer depth */
	
	PrintSafeString(GetBaseType(TypeToPrint)->Name)
	
	i16 Depth := GetPointerDepth(TypeToPrint)
	
	for (i32 Index := 0, Index < Depth, Index += 1) {
		PrintCharacter('*')
	}
}

define i8 GetNumberSize(i64 NumberToCheck) {
	/* Returns the minimum number of bytes needed to store NumberToCheck */
	
	if (NumberToCheck & 0x7FFFFFFF80000000) {
		return 8
	}
	else if (NumberToCheck & 0x7FFF8000) {
		return 4
	}
	else if (NumberToCheck & 0x7F80) {
		return 2
	}
	else {
		return 1
	}
}

define Type GetNumberType(ParserState* pState, i64 NumberToCheck) {
	/* Returns a type for the given number (smallest type that can store the number signed) */
	
	if (NumberToCheck & 0x7FFFFFFF80000000) {
		/* If any of the upper 33 bits are set, then it's an i64 */
		
		return MakeType(pState->i64, 0)
	}
	else {
		/* Smallest type for a number is i32 for the sake of sanity (10 * 300 = 300, not 44) */
		
		return MakeType(pState->i32, 0)
	}
}

declare void ASTError(ASTNode*, i8*)

define i8 TypeError(ASTNode* AtNode, Type Expected, i8* Message) {
	if !(AtNode) {
		return 1
	}
	
	ManualErrorMessagePrelude()
	
	Print("%s", Message)
	
	if ((Expected) As i64) != 0 {
		Print(", expected ")
		PrintType(Expected)
	}
	
	Print(", got ")
	PrintType(AtNode->ValueType)
	
	ASTError(AtNode, null)
}

define i32 GetGenericRating(Type ForType) {
	TypeInfo* BaseType := GetBaseType(ForType)
	i16 PointerDepth := GetPointerDepth(ForType)
	
	i32 Result := -PointerDepth
	
	if !(BaseType->IsBuiltin) {
		Result += 10
	}
	
	return Result
}

define i8 CheckTypes(ParserState* pState, Type Source, Type Target, ASTNode* SourceNode) {
	if (SourceNode) {
		Source := SourceNode->ValueType
	}
	
	TypeInfo* SourceBase := GetBaseType(Source)
	TypeInfo* TargetBase := GetBaseType(Target)
	
	i16 SourceDepth := GetPointerDepth(Source)
	i16 TargetDepth := GetPointerDepth(Target)
	
	i16 SourceSize := GetTypeSize(Source)
	i16 TargetSize := GetTypeSize(Target)
	
	i8 SourceIsVoid := SourceBase = pState->void
	i8 TargetIsVoid := TargetBase = pState->void
	
	if (SourceDepth = TargetDepth) {
		if (SourceBase = TargetBase) {
			return 0
		}
		else if (TargetDepth = 1) {
			if (SourceIsVoid || TargetIsVoid) {
				return 0
			}
		}
		
		if (SourceBase->IsBuiltin && TargetBase->IsBuiltin) {
			if !(TargetDepth) {
				if (SourceSize <= TargetSize) {
					return 0
				}
			}
		}
		
		return TypeError(SourceNode, Target, "Incompatible types")
	}
	else if (SourceDepth && TargetIsVoid && TargetDepth = 1) {
		return 0
	}
	else if (SourceDepth || TargetDepth) {
		return TypeError(SourceNode, Target, "Incompatible pointer depths")
	}
	else if (SourceBase->IsStructType || TargetBase->IsStructType) {
		return TypeError(SourceNode, Target, "Incompatible struct type")
	}
	else if (TargetBase->IsBits || SourceBase->IsBits) {
		if (SourceSize > TargetSize) {
			return TypeError(SourceNode, Target, "Incompatible bits type size")
		}
		
		return 0
	}
}

define ASTNode* DowncastIntegerType(ParserState* pState, ASTNode* Target) {
	if (Target->NodeType != NODE_TYPE_INTEGER) {
		return Target
	}
	
	i8 Size := GetNumberSize(Target->IntegerValue)
	TypeInfo* BaseType := pState->i8
	
	if (Size = 2) {BaseType := pState->i16}
	else if (Size = 4) {BaseType := pState->i32}
	else if (Size = 8) {BaseType := pState->i64}
	
	Target->ValueType := MakeType(BaseType, 0)
	
	return Target
}

/*
==========================================
	Error message printing functions
==========================================
*/

define void ASTError(ASTNode* BadNode, i8* ErrorMessage) {
	if (ErrorMessage) {
		/* When the error message is already printed, skip switching to stderr, since the error message was already printed to stderr */
		SwapOutputStream()
	}
	
	PrintNewLine()
	
	PrettyError(BadNode~>Context, ErrorMessage, Red)
	Exit(1)
}
define void ASTWarn(ASTNode* BadNode, i8* WarnMessage) {
	PrintNewLine()
	PrettyError(BadNode~>Context, WarnMessage, Red | Green)
}

/*
==========================================
	Function overloading helpers
==========================================
*/

define i8 CheckTypeSignature(FunctionDefine* ForFunction, VariableInfo** AgainstParameters) {
	for (i32 ParameterIndex := 0, ParameterIndex < ForFunction->ParameterCount, ParameterIndex += 1) {
		Type ExpectedNext := ForFunction->Parameters[ParameterIndex]->Type
		Type ActualNext := AgainstParameters[ParameterIndex]->Type
		
		if (ActualNext != ExpectedNext) {
			return false
		}
	}
	
	return true
}

define FunctionDefine* MatchFunction(ParserState* pState, FunctionDefine* BaseFunction, ASTNode* CallerNode) {
	CallExpression* Caller := CallerNode->CallNode
	i32 CallerParameterCount := Caller->ParameterCount
	
	FunctionDefine* Next := BaseFunction
	
	/* Running rating of the last conpatible function's "generic rating", aka how specific the parameters are (as in, i64 vs SomeStruct*) */
	i32 BestFitRating := 200000
	FunctionDefine* BestFit := 0
	
	/* TODO: Rework this to have better casting rules */
	
	loop {
		i32 NextParameterCount := Next->ParameterCount
		
		i32 ThisFunctionRating := 0
		
		i8 IS_VARIADIC := false
		
		if (Next->Attribute = OPERATOR_DOT) {
			IS_VARIADIC := true
			ThisFunctionRating := 100000
			
			NextParameterCount -= 1
		}
		
		if (NextParameterCount = CallerParameterCount || IS_VARIADIC) {
			i8 BrokeInner := false
			
			for (i32 ParameterIndex := 0, ParameterIndex < NextParameterCount, ParameterIndex += 1) {
				Type ExpectedNext := Next->Parameters[ParameterIndex]->Type
				
				ASTNode* NextNode := DowncastIntegerType(pState, Caller->Parameters[ParameterIndex])
				Type ActualNext := NextNode->ValueType
				
				if (CheckTypes(pState, ActualNext, ExpectedNext, null)) {
					BrokeInner := true
					
					Next->TempValue := ParameterIndex
					break
				}
				
				i32 ExpectedRating := GetGenericRating(ExpectedNext)
				i32 ActualRating := GetGenericRating(ActualNext)
				
				if (ExpectedRating != ActualRating) {
					if (ActualRating > ExpectedRating) {
						ThisFunctionRating += ActualRating
					}
					else {
						ThisFunctionRating += ExpectedRating
					}
				}
			}
			
			if !(BrokeInner) {
				if (ThisFunctionRating < BestFitRating) {
					BestFitRating := ThisFunctionRating
					BestFit := Next
				}
			}
		}
		
		Next := Next->Next
		
		if !(Next) {
			break
		}
	}
	
	if (BestFit && BestFitRating < 200000) {
		return BestFit
	}
	
	ManualErrorMessagePrelude()
	
	Print("No matching overload found for:\n")
	PrettyError(CallerNode~>Context, Red | Bright)
	
	Next := BaseFunction
	
	while (Next) {
		i32 LastNonMatchingParameter := Next->TempValue
		
		if (CallerParameterCount < Next->ParameterCount) {
			Print("Is missing required parameters for overload")
		}
		else if (CallerParameterCount > Next->ParameterCount) {
			Print("Has too many paramters for overload")
		}
		else {
			Print("Parameter %i should be an ", LastNonMatchingParameter + 1)
			
			PrintType(Next->Parameters[LastNonMatchingParameter]->Type)
			
			Print(" for overload, not ")
			
			if (LastNonMatchingParameter < CallerParameterCount) {
				PrintType(Caller->Parameters[LastNonMatchingParameter]->ValueType)
			}
			else {
				Print("<none>")
			}
		}
		
		PrintNewLine()
		PrettyError(Next~>Context, Red | Bright)
		
		Next := Next->Next
	}
	
	Exit(1)
}

/*
==========================================
	AST Node construction helpers
==========================================
*/

define Type GetBinaryResultType(ParserState* pState, Type LeftType, Type RightType, ErrorContext* BlameContext) {
	/* Decides the result of a binary expression with the given operand types */
	
	i8 Compatible := !CheckTypes(pState, RightType, LeftType, null)
	Type BestFit := LeftType
	
	if (GetGenericRating(LeftType) < GetGenericRating(RightType)) {
		BestFit := RightType
	}
	
	TypeInfo* LeftBaseType := GetBaseType(LeftType)
	TypeInfo* RightBaseType := GetBaseType(RightType)
	
	i16 LeftDepth := GetPointerDepth(LeftType)
	i16 RightDepth := GetPointerDepth(RightType)
	
	if (Compatible) {
		return BestFit
	}
	else {
		if (LeftDepth && RightDepth) {
			; If we are dealing with two pointer types, something's wrong
			
			ManualErrorMessagePrelude()
			
			Print("Operations on the types ")
			PrintType(LeftType)
			Print(" and ")
			PrintType(RightType)
			Print(" are invalid.\n")
			
			ContextError(BlameContext, null)
		}
		else if (LeftDepth) {
			/* Eles if the left side is a pointer */
			
			if (RightBaseType->IsStructType) {
				/* And the right type is a.. struct? Then something's real funky */
				
				ContextError(BlameContext, "Invalid operation types1.")
			}
			
			/* Otherwise, right type is a normal type, so return the pointer type */
			return LeftType
		}
		else if (RightDepth) {
			/* Same as above, just in the opposite direction */
			
			if (LeftBaseType->IsStructType) {
				ContextError(BlameContext, "Invalid operation types2.")
			}
			
			return RightType
		}
		else {
			if (LeftBaseType->IsStructType || RightBaseType->IsStructType) {
				/* If both types are structs, then something even more funky is going on */
				ContextError(BlameContext, "Invalid operation types3.")
			}
			
			/* Otherwise, two normal types, just pick the bigger of the two */
			if (LeftBaseType->Size >= RightBaseType->Size) {
				return LeftType
			}
			else {
				return RightType
			}
		}
	}
}

declare Token* ParserCurrentToken(ParserState*)
declare ASTNode** ParseParameterList(ParserState*, i8*)

define ASTNode* MakeBinary(ParserState* pState, ASTNode* Left, Token* OperatorToken, ASTNode* Right) {
	/* Name is a bit misleading, can return a NODE_TYPE_BINARY or NODE_TYPE_STRUCT_ACCESS */
	
	i8 Operator := (OperatorToken->Value) As i8
	Type ResultType := 0
	
	Type LeftType := Left->ValueType
	Type RightType := Right->ValueType
	
	TypeInfo* LeftBaseType := GetBaseType(LeftType)
	TypeInfo* RightBaseType := GetBaseType(RightType)
	i16 LeftDepth := GetPointerDepth(LeftType)
	i16 RightDepth := GetPointerDepth(RightType)
	i16 LeftSize := GetTypeSize(LeftType)
	i16 RightSize := GetTypeSize(RightType)
	
	i8 ALLOW_INTEGER_DOWNCAST := true
	
	if (Operator = OPERATOR_AS) {
		/* OPERATOR_AS does nothing, just switches the result type of the expression */
		
		ResultType := RightType
	}
	else if (Operator = OPERATOR_LESS_LESS || Operator = OPERATOR_GREATER_GREATER) {
		DowncastIntegerType(pState, Right)
		
		CheckTypes(pState, Right->ValueType, MakeType(pState->i8, 0), Right)
		
		if (LeftSize < 4) {
			ResultType := MakeType(pState->i32, 0)
		}
		else {
			ResultType := LeftType
		}
	}
	else if (Operator = OPERATOR_DOT || Operator = OPERATOR_MINUS_GREATER || Operator = OPERATOR_TILDE_GREATER) {
		/* OPERATOR_DOT and OPERATOR_MINUS_GREATER are both struct accesses */
		
		if !(LeftBaseType->IsStructType || (LeftBaseType->IsBits && Operator = OPERATOR_DOT)) {
			/* Ensure the left type is a struct, otherwise something like 1.Abc is going on */
			
			TypeError(Left, 0 As Type, "Invalid left side operand type")
			
			ASTError(Left, "Left side operand of '.' and '->'/'~>' must be of a struct/struct pointer type")
		}
		else if (LeftBaseType->IsIncomplete) {
			/* Ensure the left type is not incomplete (otherwise we don't know what the result type would be) */
			ASTError(Left, "Fields of incomplete structs cannot be accessed.")
		}
		else if (LeftDepth != 0 && Operator = OPERATOR_DOT) {
			TokenError(OperatorToken, "Struct pointer fields can only be accessed with the '->'/'~>' operators.")
		}
		else {
			; Look up a field with a name given by the right side's string value
			SafeWideString* FieldName := Right->StringValue
			
			HashMapElement* TargetElement := LeftBaseType~>Fields->Get(FieldName)
			
			if (TargetElement) {
				; If we found a field with the correct name, create a `StructAccessExpression` for this expression
				
				StructField* TargetField := (TargetElement->Value) As StructField*
				
				StructAccessExpression* NewAccess := Alloc(#StructAccessExpression) As StructAccessExpression*
				
				NewAccess->Left := Left
				NewAccess->Operator := OperatorToken
				NewAccess->TargetField := TargetField
				
				ResultType := TargetField->ValueType
				
				if (Operator = OPERATOR_TILDE_GREATER && !ResultType.IsArray) {
					ResultType := IncrementPointerType(pState, ResultType)
				}
				
				/* Wrap it in a NODE_TYPE_STRUCT_ACCESS and return */
				
				ASTNode* StructNode := AllocateNewASTNode(NODE_TYPE_STRUCT_ACCESS, NewAccess As void*, ResultType)
				
				MergeContexts(Left~>Context, Right~>Context, StructNode~>Context)
				
				return StructNode
			}
			else {
				/* If we didn't find a field with that name, then error out */
				
				ASTError(Right, "Unknown struct field")
			}
		}
	}
	else if (Operator = OPERATOR_COLON_EQUAL) {
		/* If this is an assignment do some extra type checking */
		
		if (Left->NodeType = NODE_TYPE_VARIABLE && Left->VariableValue->IsThis) {
			ASTError(Left, "'this' can't be assigned")
		}
		
		if (LeftDepth != 0 && LeftBaseType->IsStructType && RightDepth && RightSize = 8) {
			/* If the LeftType is a struct pointer, and the right is a pointer of any type, the result is just struct-pointer type */
			
			/* This allows for stuff like `MyStruct* Test := Alloc(#MyStruct)` without ugly casting */
			
			ResultType := LeftType
		}
		else if (LeftDepth = 0 && LeftBaseType->IsStructType) {
			/* Else if the left is a literal struct type, error out */
			
			ASTError(Left, "Local structs can't be assigned")
		}
		else if !(Left->IsStorageValue) {
			ASTError(Left, "Left side of ':=' must be a storage value")
		}
		else if (Left->NodeType = NODE_TYPE_UNARY) {
			; Only true for `*X := Y`, result type is whatever `*X` would be. And thanks to
			;  `*X` being parsed like normal, LeftType is already correct
			
			ResultType := LeftType
		}
		else {
			/* Otherwise, the result type is the right type */
			ResultType := LeftType
		}
	}
	else if (Operator = OPERATOR_OPEN_BRACKET) {
		/* For an array access, make sure the index type isn't a pointer/struct */
		
		if (RightDepth != 0 || RightBaseType->IsStructType) {
			ASTError(Right, "Right side operand of '[' must not be a pointer or struct type.")
		}
		else {
			/* DecrementPointerType will ensure that LeftType is a pointer type, so we don't need to */
			
			CopyContext(ParserCurrentToken(pState)~>Context, Right~>Context)
			
			ResultType := DecrementPointerType(pState, LeftType, Right~>Context)
		}
	}
	else if (OPERATOR_FIRST_COMPARISON <= Operator && Operator <= OPERATOR_LAST_COMPARISON) {
		ResultType := MakeType(pState->i8, 0)
		
		ALLOW_INTEGER_DOWNCAST := false
	}
	else {
		/* Otherwise, just follow standard binary typing rules */
		
		MergeContexts(Left~>Context, Right~>Context, OperatorToken~>Context)
		
		ResultType := GetBinaryResultType(pState, LeftType, RightType, OperatorToken~>Context)
		
		if (Operator = OPERATOR_LOGICAL_AND || Operator = OPERATOR_LOGICAL_OR) {
			/* For && and ||, GetBinaryResultType is only called for the error messages, and the actual result type is a byte */
			ResultType := MakeType(pState->i8, 0)
		}
	}
	
	/* If the left or right operands are integers, just elevate them to the ResultType to ensure a compile-time cast (instead of a runtime cast) */
	
	if (ALLOW_INTEGER_DOWNCAST) {
		if (Left->NodeType = NODE_TYPE_INTEGER) {
			Left->ValueType := ResultType
		}
		if (Right->NodeType = NODE_TYPE_INTEGER) {
			Right->ValueType := ResultType
		}
	}
	
	/* Allocate a result node */
	
	BinaryExpression* Result := Alloc(#BinaryExpression) As BinaryExpression*
	
	/* Populate the node */
	
	Result->Left := Left
	Result->Operator := OperatorToken
	Result->Right := Right
	
	/* Wrap it, and return it */
	ASTNode* ResultNode := AllocateNewASTNode(NODE_TYPE_BINARY, Result As void*, ResultType)
	MergeContexts(Left~>Context, Right~>Context, ResultNode~>Context)
	
	return ResultNode
}
define ASTNode* MakeUnary(ParserState* pState, Token* OperatorToken, ASTNode* Operand) {
	/* Builds a NODE_TYPE_UNARY for the given operand/operator combo */
	
	UnaryExpression* Result := Alloc(#UnaryExpression) As UnaryExpression*
	
	/* Get the  */
	Type ResultType := Operand->ValueType
	i8 Operator := (OperatorToken->Value) As i8
	
	Result->Operator := OperatorToken
	Result->Operand := Operand
	
	if (Operator = OPERATOR_BANG) {
		ResultType := MakeType(pState->i8, 0)
	}
	else if (Operator = OPERATOR_AND) {	
		if !(Operand->IsStorageValue || Operand->NodeType = NODE_TYPE_DEFINE) {
			TokenError(OperatorToken, "Operand of the '&' operator must be a storage value.")
		}
		
		ResultType := IncrementPointerType(pState, ResultType)
	}
	else if (Operator = OPERATOR_STAR) {
		ResultType := DecrementPointerType(pState, ResultType, Operand~>Context)
	}
	
	ASTNode* ResultNode := AllocateNewASTNode(NODE_TYPE_UNARY, Result As void*, ResultType)
	MergeContexts(OperatorToken~>Context, Operand~>Context, ResultNode~>Context)
	
	return ResultNode
}

declare i32 FreezeParser(ParserState*)
declare void UnfreezeParser(ParserState*, i32)
declare Token* ParserNextToken(ParserState*)

define ASTNode* AllocateCall(ParserState* pState, Token* NameToken, ASTNode** Parameters, i32 ParameterCount) {
	UnfreezeParser(pState, FreezeParser(pState) - 1) /* Manually backtrack and consume the closing ')' for this call */
	Token* CloseParen := ParserNextToken(pState)
	
	CallExpression* Result := Alloc(#CallExpression) As CallExpression*
	Result->Parameters := Parameters
	Result->ParameterCount := ParameterCount
	
	/* Wrap the CallExpression with a NODE_TYPE_CALL for any errors */
	ASTNode* ResultNode := AllocateNewASTNode(NODE_TYPE_CALL, Result As void*, TYPE_NONE)
	MergeContexts(NameToken~>Context, CloseParen~>Context, ResultNode~>Context)
	
	return ResultNode
}

define ASTNode* MakeBuiltinCall(ParserState* pState, Token* NameToken, ASTNode** Parameters, i32 ParameterCount) {
	ASTNode* ResultNode := AllocateCall(pState, NameToken, Parameters, ParameterCount)
	CallExpression* Result := ResultNode->CallNode
	
	SafeWideString* Name := NameToken->StringValue
	
	if (SafeStringEqualsAString(Name, "syscall")) {
		Result->BuiltinID := BUILTIN_SYSCALL
		ResultNode->ValueType := MakeType(pState->i64, 0)
		
		if (pState->Config->OutputFormat = OUTPUT_PE) {
			ASTWarn(ResultNode, "Windows syscall numbers change near-constantly, using the native API is a bad idea.")
		}
	}
	else if (SafeStringEqualsAString(Name, "breakpoint") && ParameterCount = 0) {
		Result->BuiltinID := BUILTIN_BREAKPOINT
		ResultNode->ValueType := MakeType(pState->i8, 0)
	}
	else {
		TokenError(NameToken, "Builtin function not found.")
	}

	return ResultNode
}

define ASTNode* MakeCall(ParserState* pState, HashMap* NameSpace, Token* NameToken, ASTNode** Parameters, i32 ParameterCount) {
	ASTNode* ResultNode := AllocateCall(pState, NameToken, Parameters, ParameterCount)
	CallExpression* Result := ResultNode->CallNode
	
	SafeWideString* Name := NameToken->StringValue
	
	HashMapElement* FoundFunction := NameSpace->Get(Name)
	
	if !(FoundFunction) {
		/* And if the function was not found, then error out */
		
		TokenError(NameToken, "Function definition not found.")
	}
	
	/* Otherwise, convert the HashMapElement* into a FunctionDefine* */
	FunctionDefine* FoundDefine := (FoundFunction->Value) As FunctionDefine*
	
	/* And walk the FunctionDefine* linked list, looking for an overload which matches our parameters */
	FoundDefine := MatchFunction(pState, FoundDefine, ResultNode)
	
	Result->TargetFunction := FoundDefine
	ResultNode->ValueType := FoundDefine->ReturnType
	
	return ResultNode
}

/*
==========================================
	Parser + token helpers
==========================================
*/

define i32 FreezeParser(ParserState* pState) {
	/* Gets the tokenizer state in order to backtrack to said state */
	
	return pState->tState->TokenIndex
}
define void UnfreezeParser(ParserState* pState, i32 Index) {
	/* Restores the tokenizer to a given state in order to backtrack */
	
	pState->tState->TokenIndex := Index
}

define Token* ParserNextToken(ParserState* pState) {
	/* Gets the next token */
	
	return GetNextToken(pState->tState)
}

define Token* ParserCurrentToken(ParserState* pState) {
	TokenizerState* tState := pState->tState
	
	tState->TokenIndex -= 1
	
	return GetNextToken(tState)
}

define i8 TokenMatches(Token* TokenToTest, i8 TokenType, i8 TokenValue) {
	/* Compares two tokens using type/value */
	
	if (TokenType = TOKEN_TYPE_IDENTIFIER || TokenType = TOKEN_TYPE_STRING || TokenType = TOKEN_TYPE_INTEGER) {
		/* Special case for tokens containing strings, since TokenToTest->Value	is a SafeWideString* and worthless in a comparison */
		
		if (TokenToTest->Type = TokenType) {
			return true
		}
	}
	
	if (TokenToTest->Type = TokenType && TokenToTest->Value = TokenValue) {
		return true
	}
	
	return false
}

define i8 ParserNextMatches(ParserState* pState, i8 TokenType, i8 TokenValue) {
	/* Looks ahead at the next token and advances the parser (and returns true) if it matches the passed Type/Value */
	i32 FrozenState := FreezeParser(pState)
	
	Token* NextToken := ParserNextToken(pState)
	i8 Matches := TokenMatches(NextToken, TokenType, TokenValue)
	
	if !(Matches) {
		/* Backtrack if the next token didn't match */
		UnfreezeParser(pState, FrozenState)
		
		return false
	}
	
	return true
}

define Token* TryConsume(ParserState* pState, i8 TokenType, i8 TokenValue, i8* Reason, i8** ErrorMessage) {
	/* Gets the next token and ensures it is a TokenText:TokenValue token (with Reason being an error message for when the next token doesn't match) */
	
	Token* NextToken := ParserNextToken(pState)
	
	if (NextToken->Type = TOKEN_TYPE_EOF) {
		/* If we've consumed an EOF, it was clearly unexpected, and gets its own error message */
		ErrorMessage[0] := "Unexpected EOF"
	}
	
	if !(TokenMatches(NextToken, TokenType, TokenValue)) {
		ErrorMessage[0] := Reason
	}
	
	return NextToken
}
define Token* Consume(ParserState* pState, i8 TokenType, i8 TokenValue, i8* Reason) {
	i8* ErrorMessage := 0
	
	Token* Result := TryConsume(pState, TokenType, TokenValue, Reason, &ErrorMessage)
	
	if (ErrorMessage) {
		TokenError(Result, Reason)
	}
	
	return Result
}

/*
==========================================
	Actual parser + some helpers
==========================================
*/

declare void ParseProgram(ParserState*)
declare void SetupAssembly(ParserState*)

define ParserState* ParserStart(BuildConfig* Config, TokenizerState* tState) {
	/* Initializes pState and uses tState to parse a program */
	
	ParserState* P := Alloc(#ParserState) As ParserState*
	
	P->Config := Config
	P->tState := tState
	
	P~>Globals->Initialize()
	
	P->GlobalDefaults := AllocArray(8, 0)
	
	P~>Functions->Initialize()
	
	P~>Types->Initialize()
	
	CreateDefaultTypes(P)
	SetupAssembly(P)
	
	ParseProgram(P)
	
	return P
}

define VariableInfo* FindVariable(ParserState* pState, Token* NameToken) {
	/* Finds a variable, prioritizing locals over globals */
	
	SafeWideString* VariableName := NameToken->StringValue
	
	FunctionDefine* CurrentFunction := pState->CurrentFunction
	VariableInfo* FoundVariable := 0
	
	if (CurrentFunction) {
		/* If we are in a function, try to find the variable in the locals */
		FoundVariable := CurrentFunction~>Locals->Get(VariableName)
	}
	
	if !(FoundVariable) {
		/* If we didn't find the variable in the locals, then check the globals */
		FoundVariable := pState~>Globals->Get(VariableName)
		
		if (CurrentFunction) {
			CurrentFunction->UsesGlobals := true
		}
	}
	
	if !(FoundVariable) {
		/* If we still haven't found the variable, then it is undefined */
		
		TokenError(NameToken, "Undefined variable")
	}
	
	/* Variable has to have been found at some point for this to be reached */
	
	return FoundVariable
}

define void ParserAddGlobal(ParserState* pState, VariableInfo* NewGlobal, Token* SourceToken) {
	/* Adds a global variable to the current program */
	
	pState~>Globals->Add(NewGlobal, SourceToken)
}

define void ParserAddLocal(ParserState* pState, VariableInfo* NewLocal, Token* SourceToken) {
	/* Adds a local variable to the current function */
	
	pState->CurrentFunction~>Locals->Add(NewLocal, SourceToken)
}

/*
==========================================
	Actual parsing functions
==========================================
*/

define Type TryParseTypeName(ParserState* pState, i8 AllowArrayType, i8** ErrorMessage) {
	/* Parses a type name, and returns a Type struct representing that type */
	
	/* Find the base type name */
	Token* NameToken := TryConsume(pState, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE, "Type names must be identifiers", ErrorMessage)
	
	if *(ErrorMessage) {
		return 0 As Type
	}
	
	SafeWideString* Name := NameToken->StringValue
	
	i8 PointerDepth := 0
	
	/* And the pointer depth of the type */
	while (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_STAR)) {
		PointerDepth += 1
	}
	
	/* Get (and return) a type (which might be incomplete) using the parsed info */
	Type Result := TryGetType(pState, Name, PointerDepth, ErrorMessage)
	
	if (AllowArrayType && ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
		Result := IncrementPointerType(pState, Result)
		
		Token* SizeToken := TryConsume(pState, TOKEN_TYPE_INTEGER, 0, "Expected array type size", ErrorMessage)
		
		if !(*(ErrorMessage)) {
			Result.ArraySize := (SizeToken->IntegerValue) As i16
			Result.IsArray := true
		}
		
		TryConsume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}' for array type", ErrorMessage)
	}
	
	return Result
}

define Type ParseTypeName(ParserState* pState) {
	i8* ErrorMessage := 0
	i32 Frozen := FreezeParser(pState)
	
	Type Result := TryParseTypeName(pState, false, &ErrorMessage)
	
	if (ErrorMessage) {
		UnfreezeParser(pState, Frozen)
		
		Token* ErrorToken := ParserNextToken(pState)
		
		TokenError(ErrorToken, ErrorMessage)
	}
	
	return Result
}

declare FunctionDefine* ParseFunction(ParserState*, HashMap*, i8)
declare FunctionDefine* ParseFunction(ParserState*, HashMap*, i8, TypeInfo*)
declare void ParseAndAddStruct(ParserState*)
declare void ParseAndAddBits(ParserState*)
declare ASTNode* ParseExpression(ParserState*, i8)

define void ParseProgram(ParserState* pState) {
	/* Parse a whole program */
	
	loop {
		i32 FrozenState := FreezeParser(pState)
		Token* NextToken := ParserNextToken(pState)
		i8 NextType := NextToken->Type
		
		if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_DEFINE)) {
			ParseFunction(pState, pState~>Functions, KEYWORD_DEFINE)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_DECLARE)) {
			ParseFunction(pState, pState~>Functions, KEYWORD_DECLARE)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_DLLIMPORT)) {
			ParseFunction(pState, pState~>Functions, KEYWORD_DLLIMPORT)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_STRUCT)) {
			ParseAndAddStruct(pState)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_BITS)) {
			ParseAndAddBits(pState)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_EOF, TOKEN_TYPE_EOF)) {
			break
		}
		else if (NextType = TOKEN_TYPE_IDENTIFIER) {
			/* If the next token isn't an identifier, then it's definitely not a declaration */
			
			UnfreezeParser(pState, FrozenState)
			
			i8* ErrorMessage := 0
			
			Type PotentialType := TryParseTypeName(pState, true, &ErrorMessage)
			
			if ((PotentialType != 0) && (ErrorMessage = 0)) {
				/* Holds the parser state right after `Type` would have been parsed, so `PotentialType := ParseTypeName(pState)` can still be parsed as well */
				i32 DefaultValueExpressionStart := FreezeParser(pState)
				Token* PotentialName := ParserNextToken(pState)
				
				if (TokenMatches(PotentialName, TOKEN_TYPE_IDENTIFIER, 0)) {
					/* If we parsed a type name, and then found another identifier after the type name, this is a declaration */

					/* This can be wrong if you had `A * B` alone on a line, but what kind of dumbass would do that? */
					SafeWideString* NameString := PotentialName->StringValue
					
					VariableInfo* NewGlobal := AllocateNewVariableInfo()
					
					NewGlobal->Name := NameString
					NewGlobal->Type := PotentialType
					NewGlobal->IsGlobal := True
					NewGlobal->IsParameter := False
					
					ParserAddGlobal(pState, NewGlobal, PotentialName)
					
					if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
						UnfreezeParser(pState, DefaultValueExpressionStart)
						
						i32 Index := GetArrayLength(pState->GlobalDefaults)
						
						pState->GlobalDefaults := ReAllocArray(pState->GlobalDefaults, 1)
						
						(pState->GlobalDefaults)[Index] := ParseExpression(pState, 0)
					}
				}
			}
		}
		else {
			TokenError(NextToken, "Unexpected token")
		}
	}
}

define void ParseAndAddStruct(ParserState* pState) {
	/* Parses a struct type, and adds it to pState */
	
	/* Gets the type name */
	Token* NameToken := Consume(pState, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE, "Expected identifier for struct name")
	SafeWideString* Name := NameToken->StringValue
	
	/* Check if there's already a type with this name */
	HashMapElement* FoundElement := pState~>Types->Get(Name)
	TypeInfo* NewType := 0
	
	if (FoundElement) {
		/* If we did find a type, then this is either: the definition of an incomplete type, or a duplicate definition */
		
		NewType := (FoundElement->Value) As TypeInfo*
		
		if !(NewType->IsIncomplete) {
			/* If the type we found isn't incomplete, then error out */
			
			TokenError(NameToken, "Duplicate struct definition")
		}
		
		NewType->IsIncomplete := false
	}
	else {
		/* Otherwise, just add the new type as an entirely new type, which is a struct and not incomplete */
		NewType := AddType(pState, Name, 0, TYPE_STRUCT)
	}
	
	HashMap* Fields := NewType~>Fields
	HashMap* Methods := NewType~>Methods
	HashMap* StaticMethods := NewType~>StaticMethods
	
	Fields->Initialize()
	Methods->Initialize()
	StaticMethods->Initialize()
	
	i8 IsUnaligned := ParserNextMatches(pState, TOKEN_TYPE_KEYWORD, KEYWORD_UNALIGNED)
	
	/* Consumes the opening '{' */
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for struct body")
	
	i16 NextFieldOffset := 0
	i16 TotalSize := 0
	i8 InUnion := false
	i16 MaxUnionSize := 0
	
	loop {
		/* Allocate a StructField for the next field */
		StructField* NextField := Alloc(#StructField) As StructField*
		
		if !(InUnion) {
			if (ParserNextMatches(pState, TOKEN_TYPE_KEYWORD, KEYWORD_UNION)) {
				Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for union body.")
				
				InUnion := true
			}
			else {
				i8 IsStaticMethod := ParserNextMatches(pState, TOKEN_TYPE_KEYWORD, KEYWORD_STATIC)
				i8 IsMethod := IsStaticMethod || (ParserNextMatches(pState, TOKEN_TYPE_KEYWORD, KEYWORD_DEFINE) || ParserNextMatches(pState, TOKEN_TYPE_KEYWORD, KEYWORD_DECLARE))
				
				if (IsMethod) {
					HashMap* MethodNamespace := Methods
					TypeInfo* ThisType := NewType
					
					if (IsStaticMethod) {
						; Static methods take no `this` parameter, so we need to make that `ThisType`
						;  isn't present to prevent `ParseFunction` from automatically adding
						;   the `this` parameter
						
						MethodNamespace := StaticMethods
						ThisType := null
					}
					
					i8 ParseMode := ParserCurrentToken(pState)->Value As i8
					FunctionDefine* Method := ParseFunction(pState, MethodNamespace, ParseMode, ThisType)
					
					; `FUNCTION_IS_METHOD` when `IsStaticMethod` is false, and
					;  `FUNCTION_IS_STATIC_METHOD` when `IsStaticMethod` is true
					Method->IsMethod := true + IsStaticMethod
					Method->MethodOfTypeName := Name
					
					; Ignore commas after methods, they aren't actually needed for parsing
					ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
					
					if (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
						break
					}
					
					continue
				}
			}
		}
		
		/* Parse the type of the field */
		i8* ErrorMessage := 0
		NextField->ValueType := TryParseTypeName(pState, true, &ErrorMessage)
		
		if (ErrorMessage) {
			TokenError(ParserCurrentToken(pState), ErrorMessage)
		}
		
		/* Get the name of the field */
		Token* FieldNameToken := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Expected identifier for struct field name")
		SafeWideString* FieldName := (FieldNameToken->Value) As SafeWideString*
		NextField->Name := FieldName
		
		if (Fields->Get(FieldName)) {
			TokenError(FieldNameToken, "Duplicate definition")
		}
		
		Fields->Set(FieldName, NextField)
		
		i16 FieldSize := GetTypeStorageSize(NextField->ValueType)
		
		if (GetPointerDepth(NextField->ValueType) = 0 && GetBaseType(NextField->ValueType)->IsStructType) {
			/* Dummy branch */
		}
		else if (InUnion || IsUnaligned) {
			/* Dummy branch */
		}
		else if (NextField->ValueType.IsArray) {
			/* Dummy branch */
		}
		else if (NextFieldOffset % FieldSize) {
			/* Pad the field to a multiple of its size */
			NextFieldOffset += FieldSize - (NextFieldOffset % FieldSize)
		}
		/* If we're in a union, don't change the NextFieldOffset so all union fields get overlapping offsets */
		
		NextField->Offset := NextFieldOffset
		
		if (InUnion) {
			if (FieldSize > MaxUnionSize) {
				MaxUnionSize := FieldSize
			}
		}
		else {
			NextFieldOffset += FieldSize
		}
		
		TotalSize := NextFieldOffset
		
		if (InUnion && ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
			InUnion := false
			NextFieldOffset += MaxUnionSize
			TotalSize := NextFieldOffset
		}
		
		; Ignore commas after fields, since they aren't needed for parsing
		ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
		
		if (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
			break
		}
	}
	
	NewType->Size := TotalSize
	NewType->IsStructType := true
	NewType->IsIncomplete := false
}

define void ParseAndAddBits(ParserState* pState) {
	Token* NameToken := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Expected name for bits type.")
	SafeWideString* BitsName := NameToken->Value As SafeWideString*
	
	Consume(pState, TOKEN_TYPE_OPERATOR, OPERATOR_AS, "Expected 'as' before bits backing type name")
	
	i32 BeforeType := FreezeParser(pState)
	Type BackingType := ParseTypeName(pState)
	
	TypeInfo* BackingBase := GetBaseType(BackingType)
	i32 BackingDepth := GetPointerDepth(BackingType) As i32
	
	if (BackingBase->IsStructType || BackingDepth) {
		/* In this case, the error is caused by a Type, which doesn't hold an ErrorContext
			So by getting the first+last token of the Type, we can just merge them and use them for the error context.
		*/
		
		Token* LastTypeToken := ParserCurrentToken(pState)
		
		UnfreezeParser(pState, BeforeType)
		
		Token* FirstTypeToken := ParserNextToken(pState)
		
		MergeContexts(FirstTypeToken~>Context, LastTypeToken~>Context, FirstTypeToken~>Context)
		
		TokenError(FirstTypeToken, "Bits backing type must be a plain integer type.")
	}
	
	i8 BackingTypeSize := GetTypeSize(BackingType) As i8
	i8 BackingTypeSizeBits := BackingTypeSize * 8
	
	/* Check if there's already a type with this name */
	HashMapElement* FoundElement := pState~>Types->Get(BitsName)
	TypeInfo* NewType := 0
	
	if (FoundElement) {
		/* If we did find a type, then this is either: the definition of an incomplete type, or a duplicate definition */
		
		NewType := (FoundElement->Value) As TypeInfo*
		
		if !(NewType->IsIncomplete) {
			/* If the type we found isn't incomplete, then error out */
			
			TokenError(NameToken, "Duplicate type definition")
		}
		
		NewType->Size := BackingTypeSize
		NewType->IsStructType := false
		NewType->IsBits := true
		NewType->IsIncomplete := false /* And set that it is no longer incomplete */
	}
	else {
		/* Otherwise, just add the new type as an entirely new type, which is a struct and not incomplete */
		NewType := AddType(pState, BitsName, BackingTypeSize, TYPE_BITS)
	}
	
	/* Initialize a hashmap for the bit fields */
	HashMap* Fields := NewType~>Fields
	Fields->Initialize()
	
	/* Stores where the next field will be */
	i16 NextFieldOffset := 0
	
	/* Stores the total size of the bits (in bits, obviously) */
	i16 TotalSize := 0
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected opening brace for bits type body.")
	
	loop {
		StructField* NextField := Alloc(#StructField) As StructField*
		
		Token* OpenBracket := Consume(pState, TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET, "Expected open bracket for bit field range.")
		
		i8 StartIndex := Consume(pState, TOKEN_TYPE_INTEGER, 0, "Expected integer for bit field start index.")->Value As i8
		i8 EndIndex := StartIndex
		
		if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_COLON)) {
			EndIndex := Consume(pState, TOKEN_TYPE_INTEGER, 0, "Expected integer for bit field end index.")->Value As i8
		}
		
		i8 FieldSize := EndIndex - StartIndex
		
		Token* CloseBracket := Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected close bracket for bit field range.")
		
		MergeContexts(OpenBracket~>Context, CloseBracket~>Context, OpenBracket~>Context)
		
		if (FieldSize < 0 || FieldSize > BackingTypeSizeBits) {
			TokenError(OpenBracket, "Field size can not be negative, or bigger than the backing type.")
		}
		
		SafeWideString* FieldName := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Expected bit field name.")->Value
		
		NextField->Name := FieldName
		NextField->Offset := BackingTypeSize
		NextField->BitStartIndex := StartIndex
		NextField->BitEndIndex := EndIndex
		
		if (FieldSize <= 8) {
			NextField->ValueType := MakeType(pState->i8, 0)
		}
		else if (FieldSize <= 16) {
			NextField->ValueType := MakeType(pState->i16, 0)
		}
		else if (FieldSize <= 32) {
			NextField->ValueType := MakeType(pState->i32, 0)
		}
		else {
			NextField->ValueType := MakeType(pState->i64, 0)
		}
		
		Fields->Set(FieldName, NextField)
		
		if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
			/* If the next token is not a ',' break the loop */
			break
		}
	}
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing brace for bits body.")
}

declare ASTNode* ParseStatement(ParserState*)

define void ConsumeAndIgnoreBlock(ParserState* pState) {
	/* Used for linux/windows statements to ignore code for the opposite OS.
		This allows for syntax errors inside of !ThisOS code, but that doesn't really matter.
	*/
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open '{' for block.")
	
	i32 Depth := 1
	
	loop {
		Token* Next := ParserNextToken(pState)
		
		if (TokenMatches(Next, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
			Depth -= 1
		}
		else if (TokenMatches(Next, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
			Depth += 1
		}
		
		if (Depth = 0) {
			break
		}
	}
}

define Block* ParseBlock(ParserState* pState) {
	/* Parses and builds a block of statements */
	
	/* Consume the { */
	Token* OpenBrace := Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace in block")
	
	/* Set up a buffer for the statements */
	i16 StatementBufferSize := 8
	ASTNode** Statements := Alloc(StatementBufferSize * 8) As ASTNode**
	i16 StatementCount := 0
	
	i32 Depth := 1
	
	if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {		
		loop {
			/* Loop until NextMatches('}') */
			
			if (StatementCount * 8 <= StatementBufferSize) {
				/* If the buffer needs to be expanded, expand it */
				
				Statements := ReAlloc(Statements As void*, (StatementCount + 10) * 8) As ASTNode**
				StatementBufferSize += (10 * 8)
			}
			
			/* Parse a statement and put it into the statement list */
			
			i32 Start := FreezeParser(pState)
			
			Token* NextToken := ParserNextToken(pState)
			
			/* Handle `linux {` and `windows {` by ignoring both keywords, and conditionally ignoring the blocks following them */
			if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_LINUX)) {
				if (pState->Config->OutputFormat = OUTPUT_ELF) {
					Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace.")
					Depth += 1
				}
				else {
					ConsumeAndIgnoreBlock(pState)
				}
			}
			else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_WINDOWS)) {
				if (pState->Config->OutputFormat = OUTPUT_PE) {
					Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace.")
					Depth += 1
				}
				else {
					ConsumeAndIgnoreBlock(pState)
				}
			}
			else {
				UnfreezeParser(pState, Start)
				Statements[StatementCount] := ParseStatement(pState)
				StatementCount += 1
			}
			
			if (ParserNextMatches(pState, TOKEN_TYPE_EOF, 0)) {
				TokenError(OpenBrace, "Expected close brace for block")
			}
			
			i8 BreakOuter := false
			
			while (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				/* Only break the outer loop once all opening `{` for this block have been matched with a closing `}` */
				
				Depth -= 1
				
				BreakOuter := Depth = 0
				
				if (BreakOuter) {
					break
				}
			}
			
			if (BreakOuter) {
				break
			}
		}
	}
	
	/* Allocate a block structure and populate it with the statement list/count */
	Block* NewBlock := Alloc(#Block) As Block*
	NewBlock->Statements := Statements
	NewBlock->StatementCount := StatementCount
	
	return NewBlock
}

declare ASTNode* ParseAssembly(ParserState*, i8)

define VariableInfo* MakeMagicLocal(i8* Name, TypeInfo* BaseType, i8 IsParameter) {
	/* Note: All of this is technically a memory leak, but that doesn't really matter */
	
	SafeWideString* LocalName := AToS(Name)
	
	VariableInfo* ThisMagic := AllocateNewVariableInfo()
	ThisMagic->Name := LocalName
	ThisMagic->Type := MakeType(BaseType, 1)	/* TypeOf(Magic) = PointerTo(MagicStructType) */
	ThisMagic->IsParameter := IsParameter
	ThisMagic->IsThis := true
	
	return ThisMagic
}

define FunctionDefine* ParseFunction(ParserState* pState, HashMap* Namespace, i8 Mode, TypeInfo* ThisType) {
	/* Parses:
		 Define statements
		 Declare statements
		 DllImport statements
		Since (Define|Declare|DllImport) all have ~4 tokens in common, along with a (mostly) common list of parameters
	*/
	
	Token* StartToken := ParserCurrentToken(pState)
	
	i8 ForStatic := Mode = KEYWORD_STATIC
	i8 ForDefine := Mode = KEYWORD_DEFINE || ForStatic
	i8 ForImport := Mode = KEYWORD_DLLIMPORT
	
	Type ReturnType := ParseTypeName(pState)
	
	Token* NameToken := Consume(pState, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE, "Function names must be identifiers")
	SafeWideString* Name := NameToken->StringValue
	
	/* Set up a buffer for parameters */
	i8 ParameterCount := 0
	VariableInfo** ParameterList := Alloc(16 * #VariableInfo) As VariableInfo**
	
	i8 Attribute := 0
	
	HashMap* Locals := null
	
	if (ForDefine) {
		/* For define statements, the parameters are added as locals, so pState->CurrentFunction needs to be set so
			calling `ParserAddLocal` inside of the parameter list parsing loop won't crash.
			`Locals` is copied onto the actual `FunctionDefine*` for this function after the parameters have been
			parsed, and the matching overload has been found (if it exists)
		*/
		
		FunctionDefine TempDefine
		
		TempDefine~>Locals->Initialize()
		
		pState->CurrentFunction := &TempDefine
	}
	
	if (ThisType != 0) {
		/* If we are defining a method, then we need to build the `this` parameter, and set it to the first parameters */
		
		VariableInfo* ThisParameter := MakeMagicLocal("this", ThisType, true)
		
		if (ForDefine) {
			/* Only actually add `this` as a local when we are defining a full function, and have pState->CurrentFunction set */
			
			Token* MagicBlameToken := ParserCurrentToken(pState)
			
			ParserAddLocal(pState, ThisParameter, MagicBlameToken)
		}
		
		ParameterList[0] := ThisParameter
		ParameterCount += 1
	}
	
	/* Consume the parameter list opening '(' */
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Function parameter lists must start with (")
	
	if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
		/* If the next token isn't a ')', then parse the parameters (otherwise the function takes 0 parameters) */
		
		loop {
			/* Allocate a VariableInfo struct for the next parameter */
			VariableInfo* NextParameter := AllocateNewVariableInfo()
			
			/* Max parameter count since I cba to expand the buffer. Todo: Fix this */
			if (ParameterCount >= 16) {
				TokenError(ParserNextToken(pState), "Max parameter limit reached")
			}
			
			/* Insert the VariableInfo structure into the parameter list */
			ParameterList[ParameterCount] := NextParameter
			
			if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
				Token* Start := ParserCurrentToken(pState)
				
				Consume(pState, TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected '.' for variadic marker")
				Consume(pState, TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected '.' for variadic marker")
				
				MergeContexts(Start~>Context, ParserCurrentToken(pState)~>Context, Start~>Context)
				
				if (ParameterCount > 4) {
					TokenError(Start, "Only 4 regular paremeters can be passed with a variable argument.")
				}
				
				Attribute := OPERATOR_DOT
				NextParameter->Type := MakeType(pState->void, 1)
				
				if (ForDefine) {
					Token* VariadicName := Consume(pState, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE, "Parameter names must be identifiers")
					NextParameter->Name := VariadicName->StringValue
					ParserAddLocal(pState, NextParameter, VariadicName)
				}
				
				NextParameter->IsVariadic := true
				NextParameter->IsParameter := true
				NextParameter->StackOffset := (ParameterCount * 8)
				
				ParameterCount += 1
				
				break
			}
			
			/* Parse the parameter type */
			NextParameter->Type := ParseTypeName(pState)
			
			if (ForDefine) {
				/* Get the parameter name */
				Token* NextParameterNameToken := Consume(pState, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE, "Parameter names must be identifiers")
				NextParameter->Name := NextParameterNameToken->StringValue
				ParserAddLocal(pState, NextParameter, NextParameterNameToken)
			}
			
			NextParameter->IsGlobal := false
			NextParameter->IsParameter := true
			NextParameter->StackOffset := (ParameterCount * 8)
			
			/* Update the parameter count */
			ParameterCount += 1
			
			if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
				/* If the next token isn't a comma, then break the loop, otherwise consume the command and continue */
				break
			}
		}
		
		/* If the loop was broken by any token besides a ')', then there's something wrong */
		
		if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
			TokenError(ParserNextToken(pState), "Expected closing paren for parameter list")
		}
	}
	
	HashMapElement* FoundFunctionElement := Namespace->Get(Name)
	
	FunctionDefine* FoundFunction := 0
	FunctionDefine* NewDefine := 0
	i8 ActuallyFound := false
	
	if (FoundFunctionElement) {
		/* If this function already has at least one definition */
		
		FoundFunction := (FoundFunctionElement->Value) As FunctionDefine*
		
		while (FoundFunction) {
			/* Loop through all definitions, and find any which match the type signature of this definition */
			
			if (FoundFunction->ParameterCount = ParameterCount) {
				if (CheckTypeSignature(FoundFunction, ParameterList)) {
					ActuallyFound := true
					break
				}
			}
			
			if !(FoundFunction->Next) {
				break
			}
			
			/* Or, find the last definition for the function (which we append this definition onto) */
			FoundFunction := FoundFunction->Next
		}
		
		if (ActuallyFound && FoundFunction->HasFullDefinition) {
			/* If we found a definition matching the type signature, and it already has a body, then this is a duplicate definition */
			
			TokenError(NameToken, "Duplicate function definition")
		}
	}
	
	if (ActuallyFound) {
		/* If we found `declare %Name%(Exact same type signature as this definition)`, use `FoundFunction` for this definition instead of making a new `FunctionDefine` */
		
		NewDefine := FoundFunction
	}
	else {
		/* In this case, we can't reuse an existing `FunctionDefine`, so we need to allocate a new one */
		
		NewDefine := Alloc(#FunctionDefine) As FunctionDefine*
		
		if (FoundFunction) {
			/* However, if we did find a previous definition for this function, then we need to insert `NewDefine` into the linked list of this function's overloads			*/
			
			NewDefine->Next := FoundFunction->Next
			FoundFunction->Next := NewDefine
		}
		else {
			/* If this is the very first definition for this function, it needs to be inserted into the function hashmap */
			
			Namespace->Set(Name, NewDefine)
		}
		
		NewDefine->LabelNumber := ParserNextLabel(pState)
	}
	
	/* Copy info parsed from the first part of this function into `NewDefine`, which is 100% correctly set by now */
	
	/* `(define|declare|dllimport) name(params)` will all get captured into `NewDefine~>Context`, which displays nicely */
	MergeContexts(StartToken~>Context, ParserCurrentToken(pState)~>Context, NewDefine~>Context)
	NewDefine->Name := Name
	NewDefine->ReturnType := ReturnType
	NewDefine->Attribute := Attribute
	
	if (ForDefine) {
		/* If we are parsing a `define` statement, we need to copy the locals hashmap which already contains the parameters, along with size of the stack space needed for locals */
		
		MoveMemory(NewDefine~>Locals As i8*, TempDefine~>Locals As i8*, #VariableHashMap)
	}
	
	NewDefine->Parameters := ParameterList
	NewDefine->ParameterCount := ParameterCount
	
	if (ForImport) {
		Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Import source must have a prior '{'.")
		
		SafeWideString* FileName := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Import source file name expected")->Value
		
		if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
			Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Import source file extension expected")
		}
		
		Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA, "Comma expected between import source file and function names")
		
		SafeWideString* FunctionName := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Import source function name expected")->Value
		
		Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}'.")
		
		NewDefine->IsImported := true
		NewDefine->ImportFileName := FileName
		NewDefine->ImportFunctionName := FunctionName
	}
	
	/* Assume any function only has a partial definition */
	NewDefine->HasFullDefinition := false
	
	if (ForDefine) {
		pState->CurrentFunction := NewDefine
		
		if (ParserNextMatches(pState, TOKEN_TYPE_KEYWORD, KEYWORD_ASSEMBLY)) {
			NewDefine->Attribute := KEYWORD_ASSEMBLY
			
			NewDefine->AssemblyBody := ParseAssembly(pState, false)->AssemblyValue
		}
		else {
			if (ParserNextMatches(pState, TOKEN_TYPE_KEYWORD, KEYWORD_X64)) {
				NewDefine->Attribute := KEYWORD_X64
			}
			
			if (pState->Config->DebugMode & DEBUG_EMIT_FUNCTION_NAMES) {
				i32 Length := Name->Length + 1
				
				if (ThisType != null) {
					Length += ThisType->Name->Length + 1
				}
				
				i8* StringBuffer := Alloc(Length) As i8*
				i8* NameBuffer := StringBuffer
				
				if (ThisType != null) {
					for (i32 TypeNameIndex := 0, TypeNameIndex < ThisType->Name->Length, TypeNameIndex += 1) {
						NameBuffer[TypeNameIndex] := ThisType->Name->Buffer[TypeNameIndex] As i8
					}
					
					i8 Separator := '.'
					
					if (ForStatic) {
						Separator := ':'
					}
					
					NameBuffer[TypeNameIndex] := Separator
					NameBuffer += TypeNameIndex + 1
				}
				
				for (i32 NameIndex := 0, NameIndex < Name->Length, NameIndex += 1) {
					NameBuffer[NameIndex] := Name->Buffer[NameIndex] As i8
				}
				
				NewDefine->StringBuffer := StringBuffer
				NewDefine->StringBufferSize := Length
			}
			else {
				NewDefine->StringBuffer := Alloc(4) As i8*
				NewDefine->StringBufferSize := 0
			}
			
			NewDefine->Body := ParseBlock(pState)
		}
		
		NewDefine->HasFullDefinition := true
		pState->CurrentFunction := false
		
		if (ThisType = null && SafeStringEqualsAString(Name, "Main")) {
			pState->MainFunction := NewDefine
		}
	}
	
	return NewDefine
}
define FunctionDefine* ParseFunction(ParserState* pState, HashMap* Namespace, i8 Mode) {
	return ParseFunction(pState, Namespace, Mode, false As TypeInfo*)
}

declare ASTNode* ParseIf(ParserState*)
declare ASTNode* ParseFor(ParserState*)
declare ASTNode* ParseWhile(ParserState*)
declare ASTNode* ParseTry(ParserState*)

define ASTNode* ParseStatement(ParserState* pState) {
	/* Parses a single statement */
	
	/* Freeze the parser just in case the next token isn't a keyword */
	i32 FrozenState := FreezeParser(pState)
	
	Token* NextToken := ParserNextToken(pState)
	ASTNode* Result := 0
	
	if (NextToken->Type = TOKEN_TYPE_KEYWORD) {
		i8 NextKeyword := (NextToken->Value) As i8
		
		i8 IsContinue := (NextKeyword = KEYWORD_CONTINUE)
		
		if (NextKeyword = KEYWORD_BREAK || IsContinue) {
			Result := AllocateNewASTNode(NODE_TYPE_CONTINUEBREAK, IsContinue, TYPE_NONE)
			CopyContext(NextToken~>Context, Result~>Context)
			
			if !(pState->InLoop) {
				ASTError(Result, "Continue/Break must be inside loops")
			}
		}
		else if (NextKeyword = KEYWORD_RETURN) {
			/* A return is a NODE_TYPE_RETURN with a value which points to the expression to return */
			
			if (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				/* If there isn't an expression to return, just pretend it is `return 0` */
				
				Result := AllocateNewASTNode(NODE_TYPE_INTEGER, 0, MakeType(pState->i8, 0))
				Result := AllocateNewASTNode(NODE_TYPE_RETURN, Result, TYPE_NONE)
			}
			else {
				/* Parse the expression to return */
				ASTNode* ExpressionToReturn := ParseExpression(pState, 0)
				
				ExpressionToReturn := DowncastIntegerType(pState, ExpressionToReturn)
				Type ExpectedReturnType := pState->CurrentFunction->ReturnType
				
				CheckTypes(pState, 0 As Type, ExpectedReturnType, ExpressionToReturn)
				
				Result := AllocateNewASTNode(NODE_TYPE_RETURN, ExpressionToReturn As void*, TYPE_NONE)
			}
		}
		else if (NextKeyword = KEYWORD_IF) {
			Result := ParseIf(pState)
		}
		else if (NextKeyword = KEYWORD_FOR) {
			Result := ParseFor(pState)
		}
		else if (NextKeyword = KEYWORD_LOOP) {
			i8 OldInLoop := pState->InLoop
			pState->InLoop := true
			
			Result := AllocateNewASTNode(NODE_TYPE_LOOP, ParseBlock(pState) As void*, TYPE_NONE)
			
			pState->InLoop := OldInLoop
		}
		else if (NextKeyword = KEYWORD_WHILE) {
			Result := ParseWhile(pState)
		}
		else if (NextKeyword = KEYWORD_ASSEMBLY) {
			Result := ParseAssembly(pState, true)
		}
		else if (NextKeyword = KEYWORD_TRY) {
			Result := ParseTry(pState)
		}
	}
	
	if (Result = 0) {
		/* When we don't have a result yet, this is either a declaration or a expression statement */
		
		UnfreezeParser(pState, FrozenState)
		
		if (NextToken->Type = TOKEN_TYPE_IDENTIFIER) {
			/* If the next token isn't an identifier, then it's definitely not a declaration */
			
			i8* ErrorMessage := 0
			Type PotentialType := TryParseTypeName(pState, true, &ErrorMessage)
			
			if ((PotentialType != 0) && (ErrorMessage = 0)) {
				/* Holds the parser state right after `Type` would have been parsed, so `PotentialType := ParseTypeName(pState)` can still be parsed as well */
				i32 DefaultValueExpressionStart := FreezeParser(pState)
				Token* PotentialName := ParserNextToken(pState)
				
				if (TokenMatches(PotentialName, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE)) {
					/* If we parsed a type name, and then found another identifier after the type name, this is a declaration */
					/* This can be wrong if you had `A * B` alone on a line, but what kind of dumbass would do that? */
					
					SafeWideString* NameString := (PotentialName->Value) As SafeWideString*
					
					VariableInfo* NewLocal := AllocateNewVariableInfo()
					
					NewLocal->Name := NameString
					NewLocal->Type := PotentialType
					NewLocal->IsGlobal := False
					NewLocal->IsParameter := False
					
					ParserAddLocal(pState, NewLocal, PotentialName)
					
					if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
						UnfreezeParser(pState, DefaultValueExpressionStart)
					}
					else {
						/* The next token is not a `:=`, so the following tokens are not a value for this variable */
						return AllocateNewASTNode(NODE_TYPE_NONE, 0, TYPE_NONE)
					}
				}
				else {
					/* Token after the type name was not an identifier */
					UnfreezeParser(pState, FrozenState)
				}
			}
			else {
				UnfreezeParser(pState, FrozenState)
			}
		}
		
		/* This expression will either be at A) The start of the line or B) After a type name (for declarations) */
		Result := AllocateNewASTNode(NODE_TYPE_EXPRESSION, ParseExpression(pState, 0) As void*, TYPE_NONE)
	}
	
	return Result
}

define ASTNode* ParseIf(ParserState* pState) {
	IfGroup* NewIf := Alloc(#IfGroup) As IfGroup*
	
	NewIf->Conditions := Alloc(10 * #ASTNode*) As ASTNode**
	NewIf->Bodies := Alloc(10 * #Block*) As Block**
	i32 BranchCapacity := 10
	i32 BranchIndex := 0
	
	loop {
		if (BranchIndex = 0 || ParserNextMatches(pState, TOKEN_TYPE_KEYWORD, KEYWORD_IF)) {
			if (BranchCapacity <= BranchIndex) {
				BranchCapacity += 10
			
				NewIf->Conditions := ReAlloc(NewIf->Conditions, BranchCapacity * 8)
				NewIf->Bodies := ReAlloc(NewIf->Bodies, BranchCapacity * 8)
			}
			
			NewIf->Conditions[BranchIndex] := ParseExpression(pState, 0)
			NewIf->Bodies[BranchIndex] := ParseBlock(pState)
		
			BranchIndex += 1

			if !(ParserNextMatches(pState, TOKEN_TYPE_KEYWORD, KEYWORD_ELSE)) {
				break
			}
		}
		else {
			NewIf->ElseBranch := ParseBlock(pState)
			break
		}
	}
	
	NewIf->BranchCount := BranchIndex

	return AllocateNewASTNode(NODE_TYPE_IF, NewIf, TYPE_NONE)
}

define ASTNode* ParseFor(ParserState* pState) {
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Expected opening '(' for for loop.")
	
	i32 InitializerStart := FreezeParser(pState)
	
	if (ParserNextMatches(pState, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE)) {
		UnfreezeParser(pState, InitializerStart)
		
		i8* ErrorMessage := 0
		Type PotentialType := TryParseTypeName(pState, false, &ErrorMessage)
		
		if ((PotentialType != 0) && (ErrorMessage = 0)) {
			i32 ExpressionStart := FreezeParser(pState)
			Token* PotentialName := ParserNextToken(pState)
			
			if (TokenMatches(PotentialName, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE)) {
				if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
					SafeWideString* NameString := (PotentialName->Value) As SafeWideString*
					
					VariableInfo* NewLocal := AllocateNewVariableInfo()
					
					NewLocal->Name := NameString
					NewLocal->Type := PotentialType
					
					ParserAddLocal(pState, NewLocal, PotentialName)
					
					InitializerStart := ExpressionStart /* Set the initializer expression to start after the type name */
				}
			}
		}
	}
	
	UnfreezeParser(pState, InitializerStart)
	
	ForLoop* NewLoop := Alloc(#ForLoop) As ForLoop*
	
	NewLoop->Initializer := ParseExpression(pState, 0)
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA, "Expected comma after for loop initializer.")
	NewLoop->Condition := ParseExpression(pState, 0)
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA, "Expected comma after for loop condition.")
	NewLoop->Step := ParseExpression(pState, 0)
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing ')' in for loop.")
	
	i8 OldInLoop := pState->InLoop
	pState->InLoop := true
	
	NewLoop->Body := ParseBlock(pState)
	
	pState->InLoop := OldInLoop
	
	return AllocateNewASTNode(NODE_TYPE_FOR, NewLoop, TYPE_NONE)
}

define ASTNode* ParseWhile(ParserState* pState) {
	WhileLoop* NewWhile := Alloc(#WhileLoop) As WhileLoop*
	
	NewWhile->Condition := ParseExpression(pState, 0)
	
	i8 OldInLoop := pState->InLoop
	pState->InLoop := true
	
	NewWhile->Body := ParseBlock(pState)
	
	pState->InLoop := OldInLoop
	
	return AllocateNewASTNode(NODE_TYPE_WHILE, NewWhile As void*, TYPE_NONE)
}

define ASTNode* TranslateTokenToNode(ParserState* pState, Token* TokenToTranslate) {
	/* Translates a token into an AST node with an eqaul value */
	
	ASTNode* Result := 0
	
	if (TokenToTranslate->Type = TOKEN_TYPE_INTEGER) {
		/* If the token is an integer, return a NODE_TYPE_INTEGER node with a type which is correctly size for the given integer */
		
		Type ResultType := GetNumberType(pState, TokenToTranslate->IntegerValue)
		
		Result := AllocateNewASTNode(NODE_TYPE_INTEGER, TokenToTranslate->Value, ResultType)
	}
	else if (TokenToTranslate->Type = TOKEN_TYPE_IDENTIFIER) {
		/* If the token is an identifier, find the variable the identifier represents, and put it into a NODE_TYPE_VARIABLE node */
		
		Result := AllocateNewASTNode(NODE_TYPE_INTEGER, 0, MakeType(pState->i32, 0))
		
		if (SafeStringEqualsAString(TokenToTranslate->StringValue, "true")) {
			Result->IntegerValue := 1
		}
		else if (SafeStringEqualsAString(TokenToTranslate->StringValue, "false")) {
			Result->IntegerValue := 0
		}
		else if (SafeStringEqualsAString(TokenToTranslate->StringValue, "windows")) {
			Result->IntegerValue := pState->Config->OutputFormat = OUTPUT_PE
		}
		else if (SafeStringEqualsAString(TokenToTranslate->StringValue, "linux")) {
			Result->IntegerValue := pState->Config->OutputFormat = OUTPUT_ELF
		}
		else if (SafeStringEqualsAString(TokenToTranslate->StringValue, "debug")) {
			Result->IntegerValue := pState->Config->DebugMode & DEBUG_EMIT_FUNCTION_NAMES
		}
		else if (SafeStringEqualsAString(TokenToTranslate->StringValue, "null")) {
			Result->ValueType := MakeType(pState->void, 1)
			Result->NodeType := NODE_TYPE_ZERO
		}
		else {
			VariableInfo* FoundVariable := FindVariable(pState, TokenToTranslate)
			/* Using the found variable's type as the node type */
			
			Result->NodeType := NODE_TYPE_VARIABLE
			Result->IsStorageValue := true
			Result->VariableValue := FoundVariable
			Result->ValueType := FoundVariable->Type
		}
		
		CopyContext(TokenToTranslate As ErrorContext*, Result As ErrorContext*)
	}
	else {
		TokenError(TokenToTranslate, "Unexpected token")
	}
	
	CopyContext(TokenToTranslate~>Context, Result~>Context)
	
	return Result
}

define ASTNode** ParseParameterList(ParserState* pState, i8* OutParameterCount) {
	i8 ParameterIndex := *OutParameterCount
	ASTNode** Parameters := Alloc(8 * 10) As ASTNode**
	
	/* If the next token is not a ), then parse a parameter list (if it is a ')' then there are 0 parameters) */
	
	if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
		i8 IsFirstParameter := true
		
		while (IsFirstParameter || ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
			Parameters[ParameterIndex] := ParseExpression(pState, 0)
			ParameterIndex += 1
			
			IsFirstParameter := false
		}
		
		/* When we run into a token that isn't a ',' then the next token must be ')' to close the parameter group */
		
		Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing paren for function call")
	}
	
	OutParameterCount[0] := ParameterIndex
	return Parameters
}

define ASTNode* ParseExpressionOperand(ParserState* pState) {
	/* Parses and returns a single operand of an expression */
	
	Token* NextToken := ParserNextToken(pState)
	ASTNode* Result := 0
	
	if (NextToken->Type = TOKEN_TYPE_PUNCTUATION && NextToken->Value = PUNCTUATION_OPEN_PAREN) {
		/* If the next token is an (, then parse a subexpression and consume a closing ) */
		
		Result := ParseExpression(pState, 0)
		
		Token* CloseParen := Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing paren")
		
		MergeContexts(NextToken~>Context, CloseParen~>Context, Result~>Context)
	}
	else if (NextToken->Type = TOKEN_TYPE_IDENTIFIER) {
		/* Else if the next token is an identifier */
		
		/* This check is fine, since x:(y) is never valid, nor is x:y */
		i8 IsBuiltinOrStatic := ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_COLON)
		
		i8 ParameterCount := 0
		ASTNode** Parameters := null
		
		if (IsBuiltinOrStatic) {
			MergeContexts(NextToken~>Context, ParserCurrentToken(pState)~>Context, NextToken~>Context)
			
			if (ParserNextMatches(pState, TOKEN_TYPE_IDENTIFIER, 0)) {
				SafeWideString* StaticMethodType := NextToken->StringValue
				
				HashMapElement* FoundTypeElement := pState~>Types->Get(StaticMethodType)
				
				if !(FoundTypeElement) {
					TokenError(NextToken, "Unknown type")
				}
				
				TypeInfo* FoundType := FoundTypeElement->Value As TypeInfo*
				
				Token* StaticMethodNameToken := ParserCurrentToken(pState)
				MergeContexts(StaticMethodNameToken~>Context, NextToken~>Context, StaticMethodNameToken~>Context)
				
				Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Expected opening '(' for static method call")
				
				Parameters := ParseParameterList(pState, &ParameterCount)
				
				return MakeCall(pState, FoundType~>StaticMethods, StaticMethodNameToken, Parameters, ParameterCount)
			}
		}
		
		if (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)) {
			/* If the next-next token is an (, then this is a function call */
			
			Parameters := ParseParameterList(pState, &ParameterCount)
			
			/* Make a NODE_TYPE_CALL node for the function call */
			
			if (IsBuiltinOrStatic) {
				Result := MakeBuiltinCall(pState, NextToken, Parameters, ParameterCount)
			}
			else {
				Result := MakeCall(pState, pState~>Functions, NextToken, Parameters, ParameterCount)
			}
		}
		else {
			if (IsBuiltinOrStatic) {
				TokenError(NextToken, "Unexpected ':' after identifier")
			}
			
			/* Else, this isn't a function call, and is just a normal variable */
			Result := TranslateTokenToNode(pState, NextToken)
		}
	}
	else if (NextToken->Type = TOKEN_TYPE_STRING || NextToken->Type = TOKEN_TYPE_WIDE_STRING) {
		FunctionDefine* CurrentFunction := pState->CurrentFunction
		
		if !(CurrentFunction) {
			TokenError(NextToken, "Strings can only be used inside functions.")
		}
		
		i8 CharacterSize := (NextToken->Type - TOKEN_TYPE_STRING) + 1
		
		SafeWideString* StringText := NextToken->StringValue
		
		i32 Offset := CurrentFunction->StringBufferSize
		
		if (Offset % CharacterSize) {
			Offset += 1
		}
		
		i32 NewSize := Offset + (StringText->Length + 1) * CharacterSize
		
		CurrentFunction->StringBuffer := ReAlloc(CurrentFunction->StringBuffer, NewSize)
		CurrentFunction->StringBufferSize := NewSize
		
		TypeInfo* BaseType := pState->i8
		
		if (CharacterSize = 1) {
			for (i32 Index := 0, Index < (StringText->Length), Index += 1) {
				CurrentFunction->StringBuffer[Offset + Index] := StringText->Buffer[Index]
			}
		}
		else {
			BaseType := pState->i16
			MoveMemory(&CurrentFunction->StringBuffer[Offset], StringText->Buffer, StringText->Length * 2)
		}
		
		Result := AllocateNewASTNode(NODE_TYPE_STRING, Offset, MakeType(BaseType, 1))
		CopyContext(NextToken~>Context, Result~>Context)
	}
	else if (NextToken->Type = TOKEN_TYPE_INTEGER) {
		/* A literal integer, just make a NODE_TYPE_INTEGER for it */
		
		Result := TranslateTokenToNode(pState, NextToken)
	}
	else if (NextToken->Type = TOKEN_TYPE_OPERATOR && IsPrefixOperator(NextToken)) {
		/* A prefix operator, parse an expression only containing operators of a higher precedence than the prefix operator */
		
		if (NextToken->Value = OPERATOR_POUND) {
			/* Handle #TypeName by parsing a type name after the #, and setting the result to the length of TypeName as an i32 */
			
			i8 ConsumeClosingParan := ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)
			
			Type GetSizeOfType := ParseTypeName(pState)
			
			if (ConsumeClosingParan) {
				Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing ')' around type name")
			}
			
			Result := AllocateNewASTNode(NODE_TYPE_GET_TYPE_SIZE, GetSizeOfType As void, MakeType(pState->i32, 0))
			
			MergeContexts(NextToken~>Context, ParserCurrentToken(pState)~>Context, Result~>Context)
		}
		else {
			if (NextToken->Value = OPERATOR_AND) {
				i8* ErrorMessage := 0
				
				i32 Frozen := FreezeParser(pState)
				Token* MaybeFunction := TryConsume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Dummy", &ErrorMessage)
				
				if (MaybeFunction && !ErrorMessage) {
					FunctionDefine* FoundDefine := null
					Token* TailToken := MaybeFunction
					
					if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_COLON)) {
						Token* StaticMethodTypeName := MaybeFunction
						Token* StaticMethodName := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Expected static method name")
						
						HashMapElement* StaticMethodTypeElement := pState~>Types->Get(StaticMethodTypeName->StringValue)
						
						if !(StaticMethodTypeElement) {
							TokenError(StaticMethodTypeName, "Undefined type")
						}
						
						TypeInfo* TargetType := StaticMethodTypeElement->Value As TypeInfo*
						
						HashMapElement* FoundFunctionElement := TargetType~>StaticMethods->Get(StaticMethodName->StringValue)
						
						if !(FoundFunctionElement) {
							TokenError(StaticMethodName, "Undefined static method")
						}
						
						FoundDefine := FoundFunctionElement->Value As FunctionDefine*
						
						TailToken := StaticMethodName
					}
					else {
						HashMapElement* FoundFunction := pState~>Functions->Get(MaybeFunction->StringValue)
						
						if (FoundFunction) {
							FoundDefine := FoundFunction->Value As FunctionDefine*
						}
					}
					
					if (FoundDefine) {
						Result := AllocateNewASTNode(NODE_TYPE_DEFINE, FoundDefine, MakeType(pState->void, 1))
						MergeContexts(MaybeFunction~>Context, TailToken~>Context, Result~>Context)
						
						if (FoundDefine->Next != null) {
							ASTError(Result, "Getting the address of an overloaded function is not possible")
						}
					}
					else {
						UnfreezeParser(pState, Frozen)
					}
				}
				else {
					UnfreezeParser(pState, Frozen)
				}
			}
			
			if !(Result) {
				Result := ParseExpression(pState, GetPrefixPrecedence(NextToken))
			}
			
			Result := MakeUnary(pState, NextToken, Result)
		}
	}
	else {
		/* Else, this token isn't something we expected here, so error out */
		
		TokenError(NextToken, "Unexpected token in expression")
	}
	
	return Result
}

define ASTNode* ParseExpression(ParserState* pState, i8 Precedence) {
	/* Parses and returns and expression only containing operators with higher precedence than Precedence */
	
	ASTNode* Result := ParseExpressionOperand(pState)
	
	i32 FrozenState := FreezeParser(pState)
	Token* OperatorToken := ParserNextToken(pState)
	
	while (OperatorToken->Type = TOKEN_TYPE_OPERATOR && GetPrecedence(OperatorToken) >= Precedence) {
		i8 NewPrecedence := GetPrecedence(OperatorToken)
		
		if (GetAssociation(OperatorToken) = LEFT_ASSOCIATIVE) {
			NewPrecedence += 1
		}
		
		ASTNode* Operand := 0
		i8 Operator := (OperatorToken->Value) As i8
		
		i8 CouldBeMethodCall := Operator = OPERATOR_DOT || Operator = OPERATOR_MINUS_GREATER
		
		if (Operator = OPERATOR_OPEN_BRACKET) {
			/* If the next operator is [, then parse the index expression (for the right operand) and consume the closing ] */
			
			Operand := ParseExpression(pState, 0)
			
			Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected closing bracket for array access")
		}
		else if (Operator = OPERATOR_AS) {
			/* Else if the next operator is 'as' then parse a type name as the right operand */
			
			; Note: This needs a hack to give the result node a correct context, since `ParseTypeName` doesn't
			;  produce a context
			
			i32 BeforeType := FreezeParser(pState)
			ErrorContext* TypeStart := ParserNextToken(pState)~>Context
			UnfreezeParser(pState, BeforeType)
			
			Type CastToType := ParseTypeName(pState)
			
			i32 AfterType := FreezeParser(pState)
			UnfreezeParser(pState, AfterType - 1)
			ErrorContext* TypeEnd := ParserNextToken(pState)~>Context
			UnfreezeParser(pState, AfterType)
			
			Operand := AllocateNewASTNode(NODE_TYPE_TYPE, CastToType As void*, CastToType)
			MergeContexts(TypeStart, TypeEnd, Operand~>Context)
		}
		else if (CouldBeMethodCall || Operator = OPERATOR_TILDE_GREATER) {
			Token* Right := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Struct field name expected")
			
			Operand := AllocateNewASTNode(NODE_TYPE_IDENTIFIER, (Right->Value) As void*, MakeType(pState->i64, 0))
			CopyContext(Right~>Context, Operand~>Context)
		}
		else {
			/* Else, no special case, just parse and expression at the expected precedence level as the right operand */
			
			Operand := ParseExpression(pState, NewPrecedence)
		}
		
		/* Fold the left/operator/right into just the left */
		
		if (CouldBeMethodCall && ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)) {
			/* If there is a struct access (using `->` or `.`) followed by a `(`, then it is a method call */
			
			Type LeftType := Result->ValueType
			TypeInfo* LeftBase := GetBaseType(LeftType)
			i16 LeftDepth := GetPointerDepth(LeftType)
			
			/* If a local struct is accessed using `->`, it is an error. 
				Or If a pointed-to structure is accessed via `.`, it is an error .
			*/
			if (LeftDepth != 0 && Operator = OPERATOR_DOT) || (LeftDepth = 0 && Operator = OPERATOR_MINUS_GREATER) {
				TokenError(OperatorToken, "Wrong operator for left side pointer depth")
			}
			else if (LeftBase->IsStructType = 0 || LeftBase->IsIncomplete) {
				/* Or, if the accessed type is not a struct, or is incomplete, it is an error */
				
				TokenError(OperatorToken, "Can't call method on non-struct or incomplete types")
			}
			
			if (LeftDepth = 0) {
				; If `this` is a local struct, we change it to a `ThisType*` so the parameter type matches
				;  and the compiler will make sure to pass the address of `this` instead of the value.
				
				Result->ValueType := IncrementPointerType(pState, Result->ValueType)
			}
			
			/* The first parameter is `this`, so we any actual parameters are offset by 1 */
			i8 ParameterCount := 1
			ASTNode** Parameters := ParseParameterList(pState, &ParameterCount)
			
			/* Result = the left side of the struct access, which is passed as the `this` parameter */
			Parameters[0] := Result
			
			Result := MakeCall(pState, LeftBase~>Methods, Right, Parameters, ParameterCount)
		}
		else {
			Result := MakeBinary(pState, Result, OperatorToken, Operand)
		}
		
		/* Update where to restore the parser to once the expression ends */
		FrozenState := FreezeParser(pState)
		
		/* Update the next operator */
		OperatorToken := ParserNextToken(pState)
	}
	
	UnfreezeParser(pState, FrozenState)
	
	return Result
}

define ASTNode* ParseTry(ParserState* pState) {
	TryCatch* Result := Alloc(#TryCatch)
	
	Result->Body := ParseBlock(pState)
	
	if (ParserNextMatches(pState, TOKEN_TYPE_KEYWORD, KEYWORD_CATCH)) {
		if (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)) {
			i8* ErrorMessage := 0
			
			Type PotentialType := TryParseTypeName(pState, true, &ErrorMessage)
			
			if ((PotentialType != 0) && (ErrorMessage = 0)) {
				/* Holds the parser state right after `Type` would have been parsed, so `PotentialType := ParseTypeName(pState)` can still be parsed as well */
				Token* PotentialName := ParserNextToken(pState)
				
				if (TokenMatches(PotentialName, TOKEN_TYPE_IDENTIFIER, 0)) {
					/* If we parsed a type name, and then found another identifier after the type name, this is a declaration */

					/* This can be wrong if you had `A * B` alone on a line, but what kind of dumbass would do that? */
					SafeWideString* NameString := PotentialName->StringValue
					
					VariableInfo* CatchCodeVariable := AllocateNewVariableInfo()
					
					CatchCodeVariable->Name := NameString
					CatchCodeVariable->Type := PotentialType
					CatchCodeVariable->IsGlobal := False
					CatchCodeVariable->IsParameter := False
					
					ParserAddLocal(pState, CatchCodeVariable, PotentialName)
				}
			}
			else {
				ASTNode* CatchCodeNode := TranslateTokenToNode(pState, ParserNextToken(pState))
				
				if (CatchCodeNode->NodeType != NODE_TYPE_VARIABLE) {
					ASTError(CatchCodeNode, "Expected variable name")
				}
				
				CatchCodeVariable := CatchCodeNode->VariableValue
			}
			
			Result->CatchCodeVariable := CatchCodeVariable
			
			Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing ')' for 'catch ('")
		}
		
		Result->CatchBody := ParseBlock(pState)
	}
	
	return AllocateNewASTNode(NODE_TYPE_TRY, Result, TYPE_NONE)
}

#Include ./src/compiler/AssemblyParse.rlx
