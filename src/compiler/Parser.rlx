/*
==========================================
	Typing helper structs (Defined first since ASTNode has a Type field)
==========================================
*/

struct TypeInfo {
	SafeWideString* Name,
	HashMap* StructTypeFields,
	i16 Size,
	i8 IsStructType,
	i8 IsIncomplete,
	i8 IsBits,
	i8 IsBuiltin
}

bits Type As i64 {
	[0:47] BaseType,
	[48:52] PointerDepth,
	[53:54] IsArray,
	[54:63] ArraySize
}

define TypeInfo* GetBaseType(Type T) {
	return T.BaseType As TypeInfo*
}
define i16 GetTypeSize(Type T) {
	if (T.PointerDepth) {
		return 8
	}
	else {
		return GetBaseType(T)->Size
	}
}

define i32 GetTypeStorageSize(Type T) {
	i32 RegularSize := GetTypeSize(T)
	
	if (T.IsArray) {
		RegularSize := GetBaseType(T)->Size
	
		return RegularSize * (T.ArraySize As i32)
	}
	
	return RegularSize
}
define i32 GetPointerDepth(Type T) {
	return T.PointerDepth As i32
}

struct StructField {
	SafeWideString* Name,
	i16 Offset,
	Type ValueType,
	i8 BitStartIndex,
	i8 BitEndIndex
}

/*
==========================================
	AST Node type constants
==========================================
*/

i8 NODE_TYPE_NONE := 0
i8 NODE_TYPE_TOKEN := 1

i8 NODE_TYPE_UNARY := 2
i8 NODE_TYPE_BINARY := 3
i8 NODE_TYPE_CALL := 4

i8 NODE_TYPE_DEFINE := 6
i8 NODE_TYPE_DLLIMPORT := 7

i8 NODE_TYPE_IF := 8

i8 NODE_TYPE_FOR := 9
i8 NODE_TYPE_WHILE := 10
i8 NODE_TYPE_LOOP := 11
i8 NODE_TYPE_CONTINUEBREAK := 12

i8 NODE_TYPE_RETURN := 13
i8 NODE_TYPE_EXPRESSION := 14

i8 NODE_TYPE_VARIABLE := 15
i8 NODE_TYPE_INTEGER := 16
i8 NODE_TYPE_STRING := 17

i8 NODE_TYPE_TYPE := 18 /* For when an expression has an operand which is a literal type (like with 'as') */
i8 NODE_TYPE_STRUCT_ACCESS := 19
i8 NODE_TYPE_IDENTIFIER := 20

i8 NODE_TYPE_ASSEMBLY := 21

/*
==========================================
	True AST node types
==========================================
*/

struct UnaryExpression {
	Token* Operator,
	ASTNode* Operand
}

struct BinaryExpression {
	ASTNode* Left,
	Token* Operator,
	ASTNode* Right
}

struct StructAccessExpression {
	ASTNode* Left,
	Token* Operator,
	StructField* TargetField
}

struct Block {
	ASTNode** Statements,
	i16 StatementCount
}

struct IfGroup {
	ASTNode** Conditions,
	Block** Bodies,
	Block* ElseBranch,
	i16 BranchCount
}

struct ForLoop {
	ASTNode* Initializer,
	ASTNode* Condition,
	ASTNode* Step,
	Block* Body
}

struct WhileLoop {
	ASTNode* Condition,
	Block* Body
}

struct FunctionDefine {
	ErrorContext Context,
	
	SafeWideString* Name,
	
	i16 ParameterCount,
	VariableInfo** Parameters,
	
	HashMap* Locals,
	Type ReturnType,
	
	i8 IsImported,
	
	union {
		Block* Body,
		AssemblyBlock* AssemblyBody,
		SafeWideString* ImportFileName
	},
	union {
		i8* StringBuffer,
		SafeWideString* ImportFunctionName
	},
	
	i8 Attribute,
	i16 LocalOffset,
	i8 HasFullDefinition,
	i32 LabelNumber,
	i32 StringBufferSize,
	
	i32 CallCount,
	i8 UsesGlobals
}

i8 BUILTIN_NONE := 0
i8 BUILTIN_SYSCALL := 1
i8 BUILTIN_BREAKPOINT := 2
i8 BUILTIN_STATICALLOC := 3

struct CallExpression {
	FunctionDefine* TargetFunction,
	ASTNode** Parameters,
	i32 ParameterCount,
	i8 BuiltinID
}

struct ParserState {
	TokenizerState* tState,
	
	HashMap* Functions,
	
	i32 GlobalOffset,
	HashMap* Globals,
	ASTNode** GlobalDefaults,
	
	HashMap* Registers,
	HashMap* Instructions,
	
	HashMap* Types,
	
	/* Builtin types, actually added to the type list in CreateDefaultTypes */
	
	TypeInfo* i8,
	TypeInfo* i16,
	TypeInfo* i32,
	TypeInfo* i64,
	TypeInfo* void,
	
	FunctionDefine* CurrentFunction,
	
	i16 FunctionCount,
	i16 GlobalCount,
	i16 TypeCount,
	
	i8 InLoop,
	i8 OutputELF,
	
	i32 LabelCount
}

define i32 ParserNextLabel(ParserState* pState) {
	i32 Result := pState->LabelCount
	
	pState->LabelCount += 1
	
	return Result
}

/*
==========================================
	AST Node definition + alloc/free helpers
==========================================
*/

struct ASTNode {
	/* First two fields are the same as Token, so they can be used interchangably in error handling functions */
	
	ErrorContext Context,
	
	union {
		void* TrueNode,
		
		UnaryExpression* UnaryNode,
		BinaryExpression* BinaryNode,
		CallExpression* CallNode,
		StructAccessExpression* AccessNode,
		
		IfGroup* IfNode,
		ForLoop* ForNode,
		WhileLoop* WhileNode,
		Block* LoopBody,
		i8 IsContinue,
		
		FunctionDefine* DefineNode,
		
		ASTNode* ReturnExpression,
		
		ASTNode* ExpressionStatement,
		
		SafeWideString* StringValue,
		VariableInfo* VariableValue,
		i64 IntegerValue,
		Type TypeValue,
		i32 StringOffsetValue,
		
		AssemblyBlock* AssemblyValue
	},
	
	Type ValueType,
	i8 NodeType,
	i8 IsStorageValue /* Signals that this node is a value that references a storage location, and can be assigned */
}

define ASTNode* AllocateNewASTNode(i8 NewNodeType, void* NewNodeTrueNode, Type NewNodeValueType) {
	ASTNode* NewNode := Alloc(#ASTNode) As ASTNode*
	
	BinaryExpression* BinaryNode := NewNodeTrueNode As BinaryExpression*
	StructAccessExpression* StructNode := NewNodeTrueNode As StructAccessExpression*
	
	i8 IsArrayAccess := NewNodeType = NODE_TYPE_BINARY && BinaryNode->Operator->Value = OPERATOR_OPEN_BRACKET
	
	i8 IsStructAccss := NewNodeType = NODE_TYPE_STRUCT_ACCESS && StructNode->Operator->Value != OPERATOR_TILDE_GREATER
	
	if (IsArrayAccess || IsStructAccss || NewNodeType = NODE_TYPE_VARIABLE) {
		NewNode->IsStorageValue := true
	}
	
	NewNode->NodeType := NewNodeType
	NewNode->TrueNode := NewNodeTrueNode
	NewNode->ValueType := NewNodeValueType
	
	return NewNode
}
define void FreeASTNode(ASTNode* NodeToFree) {
	Free(NodeToFree As void*)
}


/*
==========================================
	Expression parser constant lookup functions
==========================================
*/

i8 NONE_ASSOCIATIVE := 0
i8 LEFT_ASSOCIATIVE := 1
i8 RIGHT_ASSOCIATIVE := 2

define i8 GetPrecedence(Token* ForOperator) {
	/* Gets the precedence for a given operator */
	
	i8 Operator := (ForOperator->Value) As i8
	
/* 	if (Operator = OPERATOR_COLON_EQUAL || Operator = OPERATOR_STAR_EQUAL) {
		return 1
	}
	else if (Operator = OPERATOR_PLUS_EQUAL || Operator = OPERATOR_MINUS_EQUAL) {
		return 1
	}
	else if (Operator = OPERATOR_LOGICAL_AND || Operator = OPERATOR_LOGICAL_OR) {
		return 2
	}
	else if (Operator = OPERATOR_BANG_EQUAL || Operator = OPERATOR_EQUAL) {
		return 3
	}
	else if (Operator = OPERATOR_GREATER_EQAUL || Operator = OPERATOR_LESS_EQAUL) {
		return 3
	}
	else if (Operator = OPERATOR_GREATER || Operator = OPERATOR_LESS) {
		return 3
	}
	else if (Operator = OPERATOR_AS) {
		return 5
	}
	else if (Operator = OPERATOR_PLUS || Operator = OPERATOR_MINUS) {
		return 7
	}
	else if (Operator = OPERATOR_STAR || Operator = OPERATOR_SLASH || Operator = OPERATOR_PERCENT) {
		return 8
	}
	else if (Operator = OPERATOR_LESS_LESS || Operator = OPERATOR_GREATER_GREATER) {
		return 8
	}
	else if (Operator = OPERATOR_AND || Operator = OPERATOR_OR || Operator = OPERATOR_XOR) {
		return 9
	}
	else if (Operator = OPERATOR_OPEN_BRACKET) {
		return 11
	}
	else if (Operator = OPERATOR_DOT || Operator = OPERATOR_MINUS_GREATER || Operator = OPERATOR_TILDE_GREATER) {
		return 12
	} */
	
	if (Operator >= PRECEDENCE_11) {
		return 11
	}
	else if (Operator >= PRECEDENCE_10) {
		return 10
	}
	else if (Operator >= PRECEDENCE_9) {
		return 9
	}
	else if (Operator >= PRECEDENCE_8) {
		return 8
	}
	else if (Operator >= PRECEDENCE_7) {
		return 7
	}
	else if (Operator >= PRECEDENCE_6) {
		return 6
	}
	else if (Operator >= PRECEDENCE_5) {
		return 5
	}
	else if (Operator >= PRECEDENCE_3) {
		return 3
	}
	else if (Operator >= PRECEDENCE_2) {
		return 2
	}
	else if (Operator >= PRECEDENCE_1) {
		return 1
	}
}

define i8 GetPrefixPrecedence(Token* ForOperator) {
	/* Returns the precedence of an operator when it is used as a prefix operator */
	
	i8 Operator := (ForOperator->Value) As i8
	
	if (Operator = OPERATOR_STAR) {
		return 4
	}
	else if (Operator = OPERATOR_AND) {
		return 4
	}
	else if (Operator = OPERATOR_BANG) {
		return 10
	}
	else if (Operator = OPERATOR_MINUS || Operator = OPERATOR_TILDE) {
		return 10
	}
	else if (Operator = OPERATOR_POUND) {
		return 12
	}
	
	return 0 /* Returns 0 when the operator is not a prefix operator */
}

define i8 IsPrefixOperator(Token* ForOperator) {
	/* Used to determine if an operator can be a prefix operator in the parser */
	
	return GetPrefixPrecedence(ForOperator) != 0
}

define i8 GetAssociation(Token* ForOperator) {
	/* Returns RIGHT_ASSOCIATIVE/LEFT_ASSOCIATIVE depending on the operator passed */
	
	i8 Precedence := GetPrecedence(ForOperator)
	
	if (Precedence = 1 || Precedence = 3) {
		return RIGHT_ASSOCIATIVE
	}
	else {
		return LEFT_ASSOCIATIVE
	}
}

/*
==========================================
	Typing functions
==========================================
*/

Type TYPE_NONE := 0

i8 TYPE_REGULAR := 1
i8 TYPE_STRUCT := 2
i8 TYPE_INCOMPLETE := 4
i8 TYPE_BITS := 8
i8 TYPE_ARRAY := 16

define TypeInfo* AddType(ParserState* pState, SafeWideString* Name, HashMap* Fields, i16 Size, i8 Flags) {
	/* Adds a type to pState with the given name, fields, size, structinfo, and completeness */
	
	/* Should only be called once per type name */
	TypeInfo* NewType := Alloc(#TypeInfo) As TypeInfo*
	
	NewType->Name := Name
	NewType->StructTypeFields := Fields
	NewType->Size := Size

	if (Flags & TYPE_STRUCT) {
		NewType->IsStructType := True
	}
	
	if (Flags & TYPE_INCOMPLETE) {
		NewType->IsIncomplete := True
	}
	
	if (Flags & TYPE_BITS) {
		NewType->IsBits := True
	}
	
	if (Flags & TYPE_REGULAR) {
		NewType->IsBuiltin := True
	}
	
	/* AWrite("Adding ")
	PrintSafeString(Name)
	AWrite(" at ")
	IWriteLine(NewType As i64) */
	
	HashMapAddValue(pState->Types, Name, NewType As void)
	
	return NewType
}

define Type MakeType(TypeInfo* BackingType, i16 PointerDepth) {
	/* Functions as GetType except with a TypeInfo passed directly instead of being found by name */
	
	Type NewType := 0
	
	NewType.BaseType := BackingType
	NewType.PointerDepth := PointerDepth

	return NewType
}

define void CreateDefaultTypes(ParserState* pState) {
	/* Creates all the standard types, only called once */
	
	/* All standard types are not structs, and are not incomplete */
	pState->i8 := AddType(pState, AToS("i8"), 0, 1, TYPE_REGULAR)
	pState->i16 := AddType(pState, AToS("i16"), 0, 2, TYPE_REGULAR)
	pState->i32 := AddType(pState, AToS("i32"), 0, 4, TYPE_REGULAR)
	pState->i64 := AddType(pState, AToS("i64"), 0, 8, TYPE_REGULAR)
	pState->void := AddType(pState, AToS("void"), 0, 8, TYPE_REGULAR)
}

define Type TryGetType(ParserState* pState, SafeWideString* TypeName, i16 PointerDepth, i8** ErrorMessage) {
	/* Finds a TypeInfo with the given name, and builds a Type with that TypeInfo and PointerDepth */
	
	HashMapElement* FoundElement := HashMapGetValue(pState->Types, TypeName)
	TypeInfo* FoundTypeInfo := 0

	if (FoundElement) {
		/* We found the type with the given name, so we can now set FoundTypeInfo */
		FoundTypeInfo := (FoundElement->Value) As TypeInfo*
	}
	else {
		/*
			If we did not find a typeinfo, then this type has to be an undefined user type, which is defined somewhere else
			So, we will call AddType and add it as incomplete
		*/
		
		if (PointerDepth = 0) {
			ErrorMessage[0] := HeapString("Incomplete types can only be used with pointers")
			return 0 As Type
		}
		else {
			/* We didn't find a type with the name, build an incomplete type for it */
			FoundTypeInfo := AddType(pState, TypeName, 0, 0, TYPE_STRUCT | TYPE_INCOMPLETE)
		}
	}
	
	return MakeType(FoundTypeInfo, PointerDepth)
}

declare i32 FreezeParser(ParserState*)
declare void UnfreezeParser(ParserState*, i32)
declare Token* ParserNextToken(ParserState*)

define Type GetType(ParserState* pState, SafeWideString* TypeName, i8 PointerDepth) {
	i8* ErrorMessage := 0
	
	i32 BeforeType := FreezeParser(pState)
	Type Result := TryGetType(pState, TypeName, PointerDepth, &ErrorMessage)
	
	if (ErrorMessage) {
		UnfreezeParser(pState, BeforeType)
		
		Token* BadToken := ParserNextToken(pState)
		
		TokenError(BadToken, ErrorMessage)
	}
	
	return Result
}

declare Token* ParserCurrentToken(ParserState*)

define Type DecrementPointerType(ParserState* pState, Type TypeToDecrement) {
	/* Returns the type you would get from dereferencing TypeToDecrement */
	
	if (TypeToDecrement.PointerDepth = 0) {
		/* If you're dereferencing a non-pointer type, something's wrong */
		TokenError(ParserCurrentToken(pState), "Pointer type expected")
	}
	
	return MakeType(TypeToDecrement.BaseType, (TypeToDecrement.PointerDepth) - 1 As i16)
}
define Type IncrementPointerType(ParserState* pState, Type TypeToIncrement) {
	/* Returns a type which is a pointer to the passed type */
	
	return MakeType(TypeToIncrement.BaseType, (TypeToIncrement.PointerDepth) + 1 As i16)
}

define void PrintType(Type TypeToPrint) {
	/* Prints a type, including its pointer depth */
	
	PrintSafeString(GetBaseType(TypeToPrint)->Name)
	
	i16 Depth := GetPointerDepth(TypeToPrint)
	
	for (i32 Index := 0, Index < Depth, Index += 1) {
		WriteCharacter('*')
	}
}

define i8 GetNumberSize(i64 NumberToCheck) {
	/* Returns the minimum number of bytes needed to store NumberToCheck */
	
	if (NumberToCheck & 0x7FFFFFFF80000000) {
		return 8
	}
	else if (NumberToCheck & 0x7FFF8000) {
		return 4
	}
	else if (NumberToCheck & 0x7F80) {
		return 2
	}
	else {
		return 1
	}
}

define Type GetNumberType(ParserState* pState, i64 NumberToCheck) {
	/* Returns a type for the given number (smallest type that can store the number signed) */
	
	if (NumberToCheck & 0x7FFFFFFF80000000) {
		/* If any of the upper 33 bits are set, then it's an i64 */
		
		return MakeType(pState->i64, 0)
	}
	else {
		/* Smallest type for a number is i32 for the sake of sanity (10 * 300 = 300, not 44) */
		
		return MakeType(pState->i32, 0)
	}
}

declare void ASTError(ASTNode*, i8*)

define i8 TypeError(ASTNode* AtNode, Type Expected, i8* Message) {
	if !(AtNode) {
		return 1
	}
	
	SwapOutputStream()
	
	WriteNewLine()
	AWrite(Message)
	
	if ((Expected) As i64) != 0 {
		AWrite(", expected ")
		PrintType(Expected)
	}
	
	AWrite(", got ")
	PrintType(AtNode->ValueType)
	
	ASTError(AtNode, 0)
}

define i8 CheckTypes(Type Source, Type Target, ASTNode* SourceNode) {
	if (SourceNode) {
		Source := SourceNode->ValueType
	}
	
	TypeInfo* SourceBase := GetBaseType(Source)
	TypeInfo* TargetBase := GetBaseType(Target)
	
	i16 SourceDepth := GetPointerDepth(Source)
	i16 TargetDepth := GetPointerDepth(Target)
	
	i16 SourceSize := GetTypeSize(Source)
	i16 TargetSize := GetTypeSize(Target)
	
	if (SourceSize = 8 && (TargetDepth <= 1 && TargetBase->IsBuiltin && TargetSize = 8)) {
		/* Allow any 8 byte type to be casted to void/void pointer/i64/i64 pointer */
		
		return 0
	}
	else if (TargetSize = 8 && (SourceDepth <= 1 && SourceBase->IsBuiltin)) {
		/* Allow any void/void pointer/i64/i64 pointer to be casted to any 8 byte type */
		
		return 0
	}
	else if (SourceDepth = TargetDepth) {
		if (SourceBase = TargetBase) {
			return 0
		}
		else if (SourceBase->IsBuiltin && TargetBase->IsBuiltin) {
			if (SourceSize <= TargetSize) {
				return 0
			}
			
			return TypeError(SourceNode, Target, "Incompatible types")
		}
		else {
			if (SourceDepth && TargetDepth) {
				if (CheckTypes(MakeType(SourceBase, 0), MakeType(TargetBase, 0), 0)) {
					return TypeError(SourceNode, Target, "Incompatible pointed-to types")
				}
				
				return 0
			}
			
			return TypeError(SourceNode, Target, "Incompatible types")
		}
	}
	else if (SourceDepth || TargetDepth) {
		if (TargetDepth && (SourceDepth = 1 && SourceBase->IsBuiltin)) {
			/* Allow for i64/void pointers to be casted to any kind of pointer  */
			
			return 0
		}
		else if (SourceDepth && (TargetDepth = 1 && TargetBase->IsBuiltin)) {
			/* Allow for any kind of pointer to be casted to a void/i64 pointer */
			
			return 0
		}
		
		return TypeError(SourceNode, Target, "Incompatible pointer depths")
	}
	else if (SourceBase->IsStructType || TargetBase->IsStructType) {
		return TypeError(SourceNode, Target, "Incompatible struct type")
	}
	else if (TargetBase->IsBits || SourceBase->IsBits) {
		if (SourceSize > TargetSize) {
			return TypeError(SourceNode, Target, "Incompatible bits type size")
		}
		
		return 0
	}
}

define ASTNode* DowncastIntegerType(ParserState* pState, ASTNode* Target) {
	if (Target->NodeType != NODE_TYPE_INTEGER) {
		return Target
	}
	
	i8 Size := GetNumberSize(Target->IntegerValue)
	TypeInfo* Base := pState->i8
	
	if (Size = 2) {Base := pState->i16}
	else if (Size = 4) {Base := pState->i32}
	else if (Size = 8) {Base := pState->i64}
	
	Target->ValueType := MakeType(Base, 0)
	
	return Target
}

/*
==========================================
	Error message printing functions
==========================================
*/

define void ASTError(ASTNode* BadNode, i8* ErrorMessage) {
	if (ErrorMessage) {
		/* When the error message is already printed, skip switching to stderr, since the error message was already printed to stderr */
		SwapOutputStream()
	}
	
	WriteNewLine()
	
	PrettyError(BadNode~>Context, ErrorMessage, Red | Bright)
	Exit(1)
}
define void ASTWarn(ASTNode* BadNode, i8* WarnMessage) {
	WriteNewLine()
	PrettyError(BadNode~>Context, WarnMessage, Red | Green)
}

/*
==========================================
	Variable struct + alloc helper + hashmap helpers
==========================================
*/

struct VariableInfo {
	SafeWideString* Name,
	Type Type,
	i32 StackOffset,
	i8 IsGlobal,
	i8 IsParameter,
	i8 IsVariadic
}

define VariableInfo* AllocateNewVariableInfo() {
	return Alloc(#VariableInfo) As VariableInfo*
}
define void HashMapAddVariable(HashMap* TargetMap, VariableInfo* TargetVariable) {
	HashMapAddValue(TargetMap, TargetVariable->Name, TargetVariable As void)
}
define VariableInfo* HashMapGetVariable(HashMap* TargetMap, SafeWideString* VariableName) {
	HashMapElement* Result := HashMapGetValue(TargetMap, VariableName)
	
	if (Result) {
		return (Result->Value) As VariableInfo*
	}
	
	return 0 As VariableInfo*
}

/*
==========================================
	AST Node construction helpers
==========================================
*/

define Type TryGetBinaryResultType(ParserState* pState, Type LeftType, Type RightType, i8** ErrorMessage) {
	/* Decides the result of a binary expression with the given operand types */
	
	TypeInfo* LeftBaseType := GetBaseType(LeftType)
	TypeInfo* RightBaseType := GetBaseType(RightType)
	
	i16 LeftDepth := LeftType.PointerDepth
	i16 RightDepth := RightType.PointerDepth
	
	if (LeftDepth && RightDepth) {
		/* If we are dealing with two pointer types, something's wrong */
		
		ErrorMessage := HeapString("Operations involving two pointers are disallowed.")
	}
	else if (LeftDepth) {
		/* Eles if the left side is a pointer */
		
		if (RightBaseType->IsStructType) {
			/* And the right type is a.. struct? Then something's real funky */
			
			ErrorMessage := HeapString("Invalid operation types1.")
		}
		
		/* Otherwise, right type is a normal type, so return the pointer type */
		return LeftType
	}
	else if (RightDepth) {
		/* Same as above, just in the opposite direction */
		
		if (LeftBaseType->IsStructType) {
			ErrorMessage := HeapString("Invalid operation types2.")
		}
		
		return RightType
	}
	else {
		if (LeftBaseType->IsStructType || RightBaseType->IsStructType) {
			/* If both types are structs, then something even more funky is going on */
			ErrorMessage := HeapString("Invalid operation types3.")
		}
		
		/* Otherwise, two normal types, just pick the bigger of the two */
		if (LeftBaseType->Size >= RightBaseType->Size) {
			return LeftType
		}
		else {
			return RightType
		}
	}
}

define Type GetBinaryResultType(ParserState* pState, Type LeftType, Type RightType, ErrorContext* BlameContext) {
	i8* ErrorMessage := 0
	
	Type Result := TryGetBinaryResultType(pState, LeftType, RightType, &ErrorMessage)
	
	if (ErrorMessage) {
		ContextError(BlameContext, ErrorMessage)
	}
	
	return Result
}

declare Token* ParserCurrentToken(ParserState*)

define ASTNode* MakeBinary(ParserState* pState, ASTNode* Left, Token* OperatorToken, ASTNode* Right) {
	/* Name is a bit misleading, can return a NODE_TYPE_BINARY or NODE_TYPE_STRUCT_ACCESS */
	
	i8 Operator := (OperatorToken->Value) As i8
	Type ResultType := 0
	
	Type LeftType := Left->ValueType
	Type RightType := Right->ValueType
	
	TypeInfo* LeftBaseType := GetBaseType(LeftType)
	TypeInfo* RightBaseType := GetBaseType(RightType)
	i16 LeftDepth := GetPointerDepth(LeftType)
	i16 RightDepth := GetPointerDepth(RightType)
	i16 LeftSize := GetTypeSize(LeftType)
	i16 RightSize := GetTypeSize(RightType)
	
	i8 ALLOW_INTEGER_DOWNCAST := true
	
	if (Operator = OPERATOR_AS) {
		/* OPERATOR_AS does nothing, just switches the result type of the expression */
		
		/* SwapOutputStream()
		PrettyError(OperatorToken As ErrorContext*, "Test123", Red | Bright)
		Exit(1) */
		
		ResultType := RightType
	}
	else if (Operator = OPERATOR_LESS_LESS || Operator = OPERATOR_GREATER_GREATER) {
		DowncastIntegerType(pState, Right)
		
		CheckTypes(Right->ValueType, MakeType(pState->i8, 0), Right)
		
		if (LeftSize < 4) {
			ResultType := MakeType(pState->i32, 0)
		}
		else {
			ResultType := LeftType
		}
	}
	else if (Operator = OPERATOR_DOT || Operator = OPERATOR_MINUS_GREATER || Operator = OPERATOR_TILDE_GREATER) {
		/* OPERATOR_DOT and OPERATOR_MINUS_GREATER are both struct accesses */
		
		if !(LeftBaseType->IsStructType || (LeftBaseType->IsBits && Operator = OPERATOR_DOT)) {
			/* Ensure the left type is a struct, otherwise something like 1.Abc is going on */
			
			TypeError(Left, 0 As Type, "Invalid left side operand type")
			
			ASTError(Left, "Left side operand of '.' and '->'/'~>' must be of a struct/struct pointer type")
		}
		else if (LeftBaseType->IsIncomplete) {
			/* Ensure the left type is not incomplete (otherwise we don't know what the result type would be) */
			ASTError(Left, "Fields of incomplete structs cannot be accessed.")
		}
		else if (LeftDepth != 0 && Operator = OPERATOR_DOT) {
			TokenError(OperatorToken, "Struct pointer fields can only be accessed with the '->'/'~>' operators.")
		}
		else {
			/* Get the right side text */
			SafeWideString* RightText := Right->StringValue
			
			/* And look up the struct field with that name */
			HashMapElement* FoundStructField := HashMapGetValue(LeftBaseType->StructTypeFields, RightText)
			
			if (FoundStructField) {
				/* Convert the HashMapElement* into a StructField* */
				StructField* TargetField := (FoundStructField->Value) As StructField*
				
				/* Build a StructAccessExpression node */
				StructAccessExpression* NewAccess := Alloc(#StructAccessExpression) As StructAccessExpression*
				
				/* Populate the StructAccessExpression node */
				NewAccess->Left := Left
				NewAccess->Operator := OperatorToken
				NewAccess->TargetField := TargetField
				
				ResultType := TargetField->ValueType
				
				if (Operator = OPERATOR_TILDE_GREATER) {
					ResultType := IncrementPointerType(pState, ResultType)
				}
				
				/* Wrap it in a NODE_TYPE_STRUCT_ACCESS and return */
				
				ASTNode* StructNode := AllocateNewASTNode(NODE_TYPE_STRUCT_ACCESS, NewAccess As void*, ResultType)
				
				MergeContexts(Left~>Context, Right~>Context, StructNode~>Context)
				
				return StructNode
			}
			else {
				/* If we didn't find a field with that name, then error out */
				
				ASTError(Right, "Unknown struct field")
			}
		}
	}
	else if (Operator = OPERATOR_COLON_EQUAL) {
		/* If this is an assignment do some extra type checking */
		
		i8 LeftNodeType := Left->NodeType
		
		if (LeftDepth != 0 && LeftBaseType->IsStructType && RightDepth && RightSize = 8) {
			/* If the LeftType is a struct pointer, and the right is a pointer of any type, the result is just struct-pointer type */
			
			/* This allows for stuff like `MyStruct* Test := Alloc(#MyStruct)` without ugly casting */
			
			ResultType := LeftType
		}
		else if (LeftDepth = 0 && LeftBaseType->IsStructType) {
			/* Else if the left is a literal struct type, error out */
			
			ASTError(Left, "Local structs cannot be assigned")
		}
		else if (LeftSize < RightSize) {
			/* Warn of the right side being truncated to fit the left */
			
			if !(Right->NodeType = NODE_TYPE_INTEGER && (LeftSize >= GetNumberSize(Right->TrueNode))) {
				/* If the right operand is a number, and the actual size of the number is less than the variable size, don't show this warning */
				
				ASTWarn(Right, "Right side operand of ':=' is bigger than left, right side will be truncated")
			}
			
			ResultType := LeftType
		}
		else if !(Left->IsStorageValue) {
			ASTError(Left, "Left side of ':=' must be a storage value")
		}
		else {
			/* Otherwise, the result type is the right type */
			ResultType := LeftType
		}
	}
	else if (Operator = OPERATOR_OPEN_BRACKET) {
		/* For an array access, make sure the index type isn't a pointer/struct */
		
		if (RightDepth != 0 || RightBaseType->IsStructType) {
			ASTError(Right, "Right side operand of '[' must not be a pointer or struct type.")
		}
		else {
			/* DecrementPointerType will ensure that LeftType is a pointer type, so we don't need to */
			
			CopyContext(ParserCurrentToken(pState)~>Context, Right~>Context)
			
			ResultType := DecrementPointerType(pState, LeftType)
		}
	}
	else if (OPERATOR_FIRST_COMPARISON <= Operator && Operator <= OPERATOR_LAST_COMPARISON) {
		ResultType := MakeType(pState->i8, 0)
		
		ALLOW_INTEGER_DOWNCAST := false
	}
	else {
		/* Otherwise, just follow standard binary typing rules */
		
		MergeContexts(Left~>Context, Right~>Context, OperatorToken~>Context)
		
		ResultType := GetBinaryResultType(pState, LeftType, RightType, OperatorToken~>Context)
		
		if (Operator = OPERATOR_LOGICAL_AND || Operator = OPERATOR_LOGICAL_OR) {
			/* For && and ||, GetBinaryResultType is only called for the error messages, and the actual result type is a byte */
			ResultType := MakeType(pState->i8, 0)
		}
	}
	
	/* If the left or right operands are integers, just elevate them to the ResultType to ensure a compile-time cast (instead of a runtime cast) */
	
	if (ALLOW_INTEGER_DOWNCAST) {
		if (Left->NodeType = NODE_TYPE_INTEGER) {
			Left->ValueType := ResultType
		}
		if (Right->NodeType = NODE_TYPE_INTEGER) {
			Right->ValueType := ResultType
		}
	}
	
	/* Allocate a result node */
	
	BinaryExpression* Result := Alloc(#BinaryExpression) As BinaryExpression*
	
	/* Populate the node */
	
	Result->Left := Left
	Result->Operator := OperatorToken
	Result->Right := Right
	
	/* Wrap it, and return it */
	ASTNode* ResultNode := AllocateNewASTNode(NODE_TYPE_BINARY, Result As void*, ResultType)
	MergeContexts(Left~>Context, Right~>Context, ResultNode~>Context)
	
	return ResultNode
}
define ASTNode* MakeUnary(ParserState* pState, Token* OperatorToken, ASTNode* Operand) {
	/* Builds a NODE_TYPE_UNARY for the given operand/operator combo */
	
	UnaryExpression* Result := Alloc(#UnaryExpression) As UnaryExpression*
	
	/* Get the  */
	Type ResultType := Operand->ValueType
	i8 Operator := (OperatorToken->Value) As i8
	
	Result->Operator := OperatorToken
	Result->Operand := Operand
	
	if (Operator = OPERATOR_BANG) {
		ResultType := MakeType(pState->i8, 0)
	}
	else if (Operator = OPERATOR_AND) {	
		if !(Operand->IsStorageValue || Operand->NodeType = NODE_TYPE_DEFINE) {
			TokenError(OperatorToken, "Operand of the '&' operator must be a storage value.")
		}
		
		ResultType := IncrementPointerType(pState, ResultType)
	}
	else if (Operator = OPERATOR_STAR) {
		ResultType := DecrementPointerType(pState, ResultType)
	}
	
	ASTNode* ResultNode := AllocateNewASTNode(NODE_TYPE_UNARY, Result As void*, ResultType)
	MergeContexts(OperatorToken~>Context, Operand~>Context, ResultNode~>Context)
	
	return ResultNode
}

declare i32 FreezeParser(ParserState*)
declare void UnfreezeParser(ParserState*, i32)
declare Token* ParserNextToken(ParserState*)

define ASTNode* MakeCall(ParserState* pState, Token* NameToken, ASTNode** Parameters, i32 ParameterCount, i8 IsBuiltin) {
	/* Builds a NODE_TYPE_CALL with the given Name/Parameters */
	
	UnfreezeParser(pState, FreezeParser(pState) - 1) /* Manually backtrack and consume the closing ')' for this call */
	Token* CloseParen := ParserNextToken(pState)
	
	SafeWideString* Name := NameToken->StringValue
	
	CallExpression* Result := Alloc(#CallExpression) As CallExpression*
	Result->Parameters := Parameters
	Result->ParameterCount := ParameterCount
	
	/* Wrap the CallExpression with a NODE_TYPE_CALL for any errors */
	ASTNode* ResultNode := AllocateNewASTNode(NODE_TYPE_CALL, Result As void*, TYPE_NONE)
	MergeContexts(NameToken~>Context, CloseParen~>Context, ResultNode~>Context)
	
	/* Find the function which is being called. */
	
	if (IsBuiltin) {
		if (SafeStringEqualsAString(Name, "syscall")) {
			Result->BuiltinID := BUILTIN_SYSCALL
			ResultNode->ValueType := MakeType(pState->i64, 0)
		}
		else if (SafeStringEqualsAString(Name, "breakpoint") && ParameterCount = 0) {
			Result->BuiltinID := BUILTIN_BREAKPOINT
			ResultNode->ValueType := MakeType(pState->i8, 0)
		}
		else if (SafeStringEqualsAString(Name, "StaticAllocate") && ParameterCount = 1 && Parameters[0]->NodeType = NODE_TYPE_INTEGER) {
			Result->BuiltinID := BUILTIN_STATICALLOC
			ResultNode->ValueType := MakeType(pState->void, 1)
			
			i32 OldOffset := pState->GlobalOffset
			
			pState->GlobalOffset += Parameters[0]->IntegerValue
			
			Parameters[0]->IntegerValue := OldOffset
		}
		else {
			TokenError(NameToken, "Builtin function not found.")
		}
	}
	else {
		HashMapElement* FoundFunction := HashMapGetValue(pState->Functions, Name)
		
		if !(FoundFunction) {
			/* And if the function was not found, then error out */
			
			TokenError(NameToken, "Function definition not found.")
		}
		
		/* Otherwise, convert the HashMapElement* into a FunctionDefine* */
		FunctionDefine* FoundDefine := (FoundFunction->Value) As FunctionDefine*
		
		FoundDefine->CallCount += 1
		
		Result->TargetFunction := FoundDefine
		ResultNode->ValueType := FoundDefine->ReturnType
		
		if (FoundDefine->Attribute = OPERATOR_DOT) {
			/* Dummy branch */
		}
		else if (FoundDefine->ParameterCount != ParameterCount) {
			/* Ensure the parameter counts match */
			ASTError(ResultNode, "Wrong number of parameters passed to function.")
		}
		
		if (FoundDefine->Attribute != OPERATOR_DOT) {
			/* TODO: Figure out how to type check a variable number of parameters */
			
			for (i32 ParameterIndex := 0, ParameterIndex < ParameterCount, ParameterIndex += 1) {
				/* And that the parameter types are compatible */
				
				VariableInfo* ExpectedParameter := FoundDefine->Parameters[ParameterIndex]
				ASTNode* ActualParameter := DowncastIntegerType(pState, Parameters[ParameterIndex])
				
				CheckTypes(ActualParameter->ValueType, ExpectedParameter->Type, ActualParameter)
			}
		}
	}
	
	return ResultNode
}

/*
==========================================
	Parser + token helpers
==========================================
*/

define i32 FreezeParser(ParserState* pState) {
	/* Gets the tokenizer state in order to backtrack to said state */
	
	return pState->tState->TokenIndex
}
define void UnfreezeParser(ParserState* pState, i32 Index) {
	/* Restores the tokenizer to a given state in order to backtrack */
	
	pState->tState->TokenIndex := Index
}

define Token* ParserNextToken(ParserState* pState) {
	/* Gets the next token */
	
	return GetNextToken(pState->tState)
}

define Token* ParserCurrentToken(ParserState* pState) {
	TokenizerState* tState := pState->tState
	
	tState->TokenIndex -= 1
	
	return GetNextToken(tState)
}

define i8 TokenMatches(Token* TokenToTest, i8 TokenType, i8 TokenValue) {
	/* Compares two tokens using type/value */
	
	if (TokenType = TOKEN_TYPE_IDENTIFIER || TokenType = TOKEN_TYPE_STRING || TokenType = TOKEN_TYPE_INTEGER) {
		/* Special case for tokens containing strings, since TokenToTest->Value	is a SafeWideString* and worthless in a comparison */
		
		if (TokenToTest->Type = TokenType) {
			return true
		}
	}
	
	if (TokenToTest->Type = TokenType && TokenToTest->Value = TokenValue) {
		return true
	}
	
	return false
}

define i8 ParserNextMatches(ParserState* pState, i8 TokenType, i8 TokenValue) {
	/* Looks ahead at the next token and advances the parser (and returns true) if it matches the passed Type/Value */
	i32 FrozenState := FreezeParser(pState)
	
	/* AWrite("Frozen at: ")
	IWriteLine(FrozenState) */
	
	Token* NextToken := ParserNextToken(pState)
	i8 Matches := TokenMatches(NextToken, TokenType, TokenValue)
	
	if !(Matches) {
		/* Backtrack if the next token didn't match */
		/* AWrite("Unfreezing from: ")
		IWriteLine(pState->tState->TokenIndex) */
		
		UnfreezeParser(pState, FrozenState)
		
		return false
	}
	
	return true
}

define Token* TryConsume(ParserState* pState, i8 TokenType, i8 TokenValue, i8* Reason, i8** ErrorMessage) {
	/* Gets the next token and ensures it is a TokenText:TokenValue token (with Reason being an error message for when the next token doesn't match) */
	
	Token* NextToken := ParserNextToken(pState)
	
	if (NextToken->Type = TOKEN_TYPE_EOF) {
		/* If we've consumed an EOF, it was clearly unexpected, and gets its own error message */
		ErrorMessage[0] := HeapString("Unexpected EOF")
	}
	
	if !(TokenMatches(NextToken, TokenType, TokenValue)) {
		/* Warning: This is technically a memory leak */
		ErrorMessage[0] := HeapString(Reason)
	}
	
	return NextToken
}
define Token* Consume(ParserState* pState, i8 TokenType, i8 TokenValue, i8* Reason) {
	i8* ErrorMessage := 0
	
	Token* Result := TryConsume(pState, TokenType, TokenValue, Reason, &ErrorMessage)
	
	if (ErrorMessage) {
		TokenError(Result, Reason)
	}
	
	return Result
}

/*
==========================================
	Actual parser + some helpers
==========================================
*/

declare void ParseProgram(ParserState*)
declare void SetupAssembly(ParserState*)

define ParserState* ParserStart(TokenizerState* tState, i8 OutputELF) {
	/* Initializes pState and uses tState to parse a program */
	
	ParserState* P := Alloc(#ParserState) As ParserState*
	P->tState := tState
	
	P->Globals := NewHashMap()
	P->GlobalOffset := 0
	P->GlobalCount := 0
	
	P->GlobalDefaults := AllocArray(8, 0)
	
	P->Functions := NewHashMap()
	P->FunctionCount := 0
	
	P->Types := NewHashMap()
	P->TypeCount := 0
	
	P->OutputELF := OutputELF
	
	CreateDefaultTypes(P)
	SetupAssembly(P)
	
	ParseProgram(P)
	
	return P
}

define VariableInfo* FindVariable(ParserState* pState, Token* NameToken) {
	/* Finds a variable, prioritizing locals over globals */
	
	SafeWideString* VariableName := NameToken->StringValue
	
	FunctionDefine* CurrentFunction := pState->CurrentFunction
	VariableInfo* FoundVariable := 0
	
	if (CurrentFunction) {
		/* If we are in a function, try to find the variable in the locals */
		FoundVariable := HashMapGetVariable(CurrentFunction->Locals, VariableName)
	}
	
	if !(FoundVariable) {
		/* If we didn't find the variable in the locals, then check the globals */
		FoundVariable := HashMapGetVariable(pState->Globals, VariableName)
		
		if (pState->CurrentFunction != 0) {
			pState->CurrentFunction->UsesGlobals := true
		}
	}
	
	if !(FoundVariable) {
		/* If we still haven't found the variable, then it is undefined */
		
		TokenError(NameToken, "Undefined variable")
	}
	
	/* Variable has to have been found at some point for this to be reached */
	
	return FoundVariable
}


declare i32 RoundTo(i32, i32)

define i32 ParserAddVariable(HashMap* ToScope, VariableInfo* NewVariable, i32 Offset, Token* SourceToken) {
	if (HashMapGetVariable(ToScope, NewVariable->Name)) {
		/* If we already have this name in the hashmap, then it's a duplicate definition */
		
		TokenError(SourceToken, "Duplicate definition")
	}
	
	HashMapAddVariable(ToScope, NewVariable)
	
	NewVariable->StackOffset := Offset
	
	i16 NewVariableSize := GetTypeStorageSize(NewVariable->Type)
	
	if (NewVariableSize <= 8) {
		return 8
	}
	else {
		i16 RoundedSize := RoundTo(NewVariableSize, 8) As i16
		
		NewVariable->StackOffset += RoundedSize
		
		return RoundedSize + 8
	}
}
define void ParserAddGlobal(ParserState* pState, VariableInfo* NewGlobal, Token* SourceToken) {
	/* Adds a global variable to the current program */
	
	pState->GlobalOffset += ParserAddVariable(pState->Globals, NewGlobal, pState->GlobalOffset, SourceToken)
}

define void ParserAddLocal(ParserState* pState, VariableInfo* NewLocal, Token* SourceToken) {
	/* Adds a local variable to the current function */
	
	FunctionDefine* CurrentFunction := pState->CurrentFunction
	CurrentFunction->LocalOffset += ParserAddVariable(CurrentFunction->Locals, NewLocal, CurrentFunction->LocalOffset, SourceToken)
}

/*
==========================================
	Actual parsing functions
==========================================
*/

define Type TryParseTypeName(ParserState* pState, i8 AllowArrayType, i8** ErrorMessage) {
	/* Parses a type name, and returns a Type struct representing that type */
	
	/* Find the base type name */
	Token* NameToken := TryConsume(pState, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE, "Type names must be identifiers", ErrorMessage)
	
	if *(ErrorMessage) {
		return 0
	}
	
	SafeWideString* Name := NameToken->StringValue
	
	i8 PointerDepth := 0
	
	/* And the pointer depth of the type */
	while (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_STAR)) {
		PointerDepth += 1
	}
	
	/* Get (and return) a type (which might be incomplete) using the parsed info */
	Type Result := TryGetType(pState, Name, PointerDepth, ErrorMessage)
	
	if (AllowArrayType && ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
		Result := IncrementPointerType(pState, Result)
		
		Token* SizeToken := TryConsume(pState, TOKEN_TYPE_INTEGER, 0, "Expected array type size", ErrorMessage)
		
		if !(*(ErrorMessage)) {
			Result.ArraySize := (SizeToken->IntegerValue) As i16
			Result.IsArray := true
		}
		
		TryConsume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}' for array type", ErrorMessage)
	}
	
	return Result
}

define Type ParseTypeName(ParserState* pState) {
	i8* ErrorMessage := 0
	i32 Frozen := FreezeParser(pState)
	
	Type Result := TryParseTypeName(pState, false, &ErrorMessage)
	
	if (ErrorMessage) {
		UnfreezeParser(pState, Frozen)
		
		Token* ErrorToken := ParserNextToken(pState)
		
		TokenError(ErrorToken, ErrorMessage)
	}
	
	return Result
}

i8 IS_NOT_IMPORT := 0
i8 IS_IMPORT := 1

declare void ParseAndAddDefine(ParserState*)
declare void ParseAndAddDeclare(ParserState*, i8)
declare void ParseAndAddStruct(ParserState*)
declare void ParseAndAddBits(ParserState*)
declare ASTNode* ParseExpression(ParserState*, i8)

define void ParseProgram(ParserState* pState) {
	/* Parse a whole program */
	
	loop {
		i32 FrozenState := FreezeParser(pState)
		Token* NextToken := ParserNextToken(pState)
		
		if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_DEFINE)) {
			ParseAndAddDefine(pState)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_DECLARE)) {
			ParseAndAddDeclare(pState, IS_NOT_IMPORT)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_DLLIMPORT)) {
			ParseAndAddDeclare(pState, IS_IMPORT)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_STRUCT)) {
			ParseAndAddStruct(pState)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_BITS)) {
			ParseAndAddBits(pState)
		}
		else if (TokenMatches(NextToken, TOKEN_TYPE_EOF, TOKEN_TYPE_EOF)) {
			break
		}
		else if (NextToken->Type = TOKEN_TYPE_IDENTIFIER) {
			/* If the next token isn't an identifier, then it's definitely not a declaration */
			
			UnfreezeParser(pState, FrozenState)
			
			i8* ErrorMessage := 0
			
			Type PotentialType := TryParseTypeName(pState, true, &ErrorMessage)
			
			if ((PotentialType != 0) && (ErrorMessage = 0)) {
				/* Holds the parser state right after `Type` would have been parsed, so `PotentialType := ParseTypeName(pState)` can still be parsed as well */
				i32 DefaultValueExpressionStart := FreezeParser(pState)
				Token* PotentialName := ParserNextToken(pState)
				
				if (TokenMatches(PotentialName, TOKEN_TYPE_IDENTIFIER, 0)) {
					/* If we parsed a type name, and then found another identifier after the type name, this is a declaration */

					/* This can be wrong if you had `A * B` alone on a line, but what kind of dumbass would do that? */
					SafeWideString* NameString := PotentialName->StringValue
					
					VariableInfo* NewGlobal := AllocateNewVariableInfo()
					
					NewGlobal->Name := NameString
					NewGlobal->Type := PotentialType
					NewGlobal->IsGlobal := True
					NewGlobal->IsParameter := False
					
					ParserAddGlobal(pState, NewGlobal, PotentialName)
					
					if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
						UnfreezeParser(pState, DefaultValueExpressionStart)
						
						i32 Index := GetArrayLength(pState->GlobalDefaults)
						
						pState->GlobalDefaults := ReAllocArray(pState->GlobalDefaults, 1)
						
						(pState->GlobalDefaults)[Index] := ParseExpression(pState, 0)
					}
				}
			}
		}
		else {
			TokenError(NextToken, "Unexpected token")
		}
	}
}

define void ParseAndAddStruct(ParserState* pState) {
	/* Parses a struct type, and adds it to pState */
	
	/* Gets the type name */
	Token* NameToken := Consume(pState, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE, "Expected identifier for struct name")
	SafeWideString* Name := (NameToken->Value) As SafeWideString*
	
	i8 IsUnaligned := ParserNextMatches(pState, TOKEN_TYPE_KEYWORD, KEYWORD_UNALIGNED)
	
	/* Consumes the opening '{' */
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for struct body")
	
	/* Creates a hashmap for the struct fields */
	HashMap* Fields := NewHashMap()
	i16 FieldCount := 0
	
	/* Stores where the next field will be */
	i16 NextFieldOffset := 0
	
	/* Stores the total size of the struct */
	i16 TotalSize := 0
	
	i8 InUnion := false
	i16 MaxUnionSize := 0
	
	loop {
		/* Allocate a StructField for the next field */
		StructField* NextField := Alloc(#StructField) As StructField*
		
		if (ParserNextMatches(pState, TOKEN_TYPE_KEYWORD, KEYWORD_UNION) && !InUnion) {
			Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace for union body.")
			
			InUnion := true
		}
		
		/* Parse the type of the field */
		i8* ErrorMessage := 0
		NextField->ValueType := TryParseTypeName(pState, true, &ErrorMessage)
		
		if (ErrorMessage) {
			TokenError(ParserCurrentToken(pState), ErrorMessage)
		}
		
		/* Get the name of the field */
		Token* FieldNameToken := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Expected identifier for struct field name")
		SafeWideString* FieldName := (FieldNameToken->Value) As SafeWideString*
		
		HashMapAddValue(Fields, FieldName, NextField As void)
		
		i16 FieldSize := GetTypeStorageSize(NextField->ValueType)
		
		NextField->Name := FieldName
		
		if (GetPointerDepth(NextField->ValueType) = 0 && GetBaseType(NextField->ValueType)->IsStructType) {
			/* Dummy branch */
		}
		else if (InUnion || IsUnaligned) {
			/* Dummy branch */
		}
		else if (NextField->ValueType.IsArray) {
			/* Dummy branch */
		}
		else if (NextFieldOffset % FieldSize) {
			/* Pad the field to a multiple of its size */
			NextFieldOffset += FieldSize - (NextFieldOffset % FieldSize)
		}
		/* If we're in a union, don't change the NextFieldOffset so all union fields get overlapping offsets */
		
		NextField->Offset := NextFieldOffset
		FieldCount += 1
		
		if (InUnion) {
			if (FieldSize > MaxUnionSize) {
				MaxUnionSize := FieldSize
			}
		}
		else {
			NextFieldOffset += FieldSize
		}
		
		TotalSize := NextFieldOffset
		
		if (InUnion && ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
			InUnion := false
			NextFieldOffset += MaxUnionSize
			TotalSize := NextFieldOffset
		}
		
		if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
			/* If the next token is not a ',' break the loop */
			break
		}
	}
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing brace for struct body")
	
	/* Check if there's already a type with this name */
	HashMapElement* FoundElement := HashMapGetValue(pState->Types, Name)
	TypeInfo* FoundType := 0
	
	if (FoundElement) {
		/* If we did find a type, then this is either: the definition of an incomplete type, or a duplicate definition */
		
		FoundType := (FoundElement->Value) As TypeInfo*
		
		if !(FoundType->IsIncomplete) {
			/* If the type we found isn't incomplete, then error out */
			
			TokenError(NameToken, "Duplicate type definition")
		}
		
		/* Otherwise, update the found type with the info we just parsed */
		FoundType->StructTypeFields := Fields
		FoundType->Size := TotalSize
		FoundType->IsStructType := true
		FoundType->IsIncomplete := false /* And set that it is no longer incomplete */
	}
	else {
		/* Otherwise, just add the new type as an entirely new type, which is a struct and not incomplete */
		AddType(pState, Name, Fields, TotalSize, TYPE_STRUCT)
	}
}

define void ParseAndAddBits(ParserState* pState) {
	Token* NameToken := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Expected name for bits type.")
	SafeWideString* BitsName := NameToken->Value As SafeWideString*
	
	Consume(pState, TOKEN_TYPE_OPERATOR, OPERATOR_AS, "Expected 'as' before bits backing type name")
	
	i32 BeforeType := FreezeParser(pState)
	Type BackingType := ParseTypeName(pState)
	
	TypeInfo* BackingBase := GetBaseType(BackingType)
	i32 BackingDepth := GetPointerDepth(BackingType) As i32
	
	if (BackingBase->IsStructType || BackingDepth) {
		/* In this case, the error is caused by a Type, which doesn't hold an ErrorContext
			So by getting the first+last token of the Type, we can just merge them and use them for the error context.
		*/
		
		Token* LastTypeToken := ParserCurrentToken(pState)
		
		UnfreezeParser(pState, BeforeType)
		
		Token* FirstTypeToken := ParserNextToken(pState)
		
		MergeContexts(FirstTypeToken~>Context, LastTypeToken~>Context, FirstTypeToken~>Context)
		
		TokenError(FirstTypeToken, "Bits backing type must be a plain integer type.")
	}
	
	i8 BackingTypeSize := GetTypeSize(BackingType) As i8
	i8 BackingTypeSizeBits := BackingTypeSize * 8
	
	/* Creates a hashmap for the bit fields */
	HashMap* Fields := NewHashMap()
	i16 FieldCount := 0
	
	/* Stores where the next field will be */
	i16 NextFieldOffset := 0
	
	/* Stores the total size of the bits (in bits, obviously) */
	i16 TotalSize := 0
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected opening brace for bits type body.")
	
	loop {
		StructField* NextField := Alloc(#StructField) As StructField*
		
		Token* OpenBracket := Consume(pState, TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET, "Expected open bracket for bit field range.")
		
		i8 StartIndex := Consume(pState, TOKEN_TYPE_INTEGER, 0, "Expected integer for bit field start index.")->Value As i8
		i8 EndIndex := StartIndex
		
		if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_COLON)) {
			EndIndex := Consume(pState, TOKEN_TYPE_INTEGER, 0, "Expected integer for bit field end index.")->Value As i8
		}
		
		i8 FieldSize := EndIndex - StartIndex
		
		Token* CloseBracket := Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected close bracket for bit field range.")
		
		MergeContexts(OpenBracket~>Context, CloseBracket~>Context, OpenBracket~>Context)
		
		if (FieldSize < 0 || FieldSize > BackingTypeSizeBits) {
			TokenError(OpenBracket, "Field size can not be negative, or bigger than the backing type.")
		}
		
		SafeWideString* FieldName := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Expected bit field name.")->Value
		
		NextField->Name := FieldName
		NextField->Offset := BackingTypeSize
		NextField->BitStartIndex := StartIndex
		NextField->BitEndIndex := EndIndex
		
		if (FieldSize <= 8) {
			NextField->ValueType := MakeType(pState->i8, 0)
		}
		else if (FieldSize <= 16) {
			NextField->ValueType := MakeType(pState->i16, 0)
		}
		else if (FieldSize <= 32) {
			NextField->ValueType := MakeType(pState->i32, 0)
		}
		else {
			NextField->ValueType := MakeType(pState->i64, 0)
		}
		
		HashMapAddValue(Fields, FieldName, NextField As void)
		
		if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
			/* If the next token is not a ',' break the loop */
			break
		}
	}
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing brace for bits body.")
	
	/* Check if there's already a type with this name */
	HashMapElement* FoundElement := HashMapGetValue(pState->Types, BitsName)
	TypeInfo* FoundType := 0
	
	if (FoundElement) {
		/* If we did find a type, then this is either: the definition of an incomplete type, or a duplicate definition */
		
		FoundType := (FoundElement->Value) As TypeInfo*
		
		if !(FoundType->IsIncomplete) {
			/* If the type we found isn't incomplete, then error out */
			
			TokenError(NameToken, "Duplicate type definition")
		}
		
		/* Otherwise, update the found type with the info we just parsed */
		FoundType->StructTypeFields := Fields
		FoundType->Size := BackingTypeSize
		FoundType->IsStructType := false
		FoundType->IsBits := true
		FoundType->IsIncomplete := false /* And set that it is no longer incomplete */
	}
	else {
		/* Otherwise, just add the new type as an entirely new type, which is a struct and not incomplete */
		AddType(pState, BitsName, Fields, BackingTypeSize, TYPE_BITS)
	}
}

define FunctionDefine* ParseFunctionInfo(ParserState* pState) {
	Type ReturnType := ParseTypeName(pState)
	
	Token* NameToken := Consume(pState, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE, "Function names must be identifiers")
	SafeWideString* Name := NameToken->StringValue
	
	HashMapElement* FoundFunctionElement := HashMapGetValue(pState->Functions, Name)
	
	FunctionDefine* NewDefine := 0
	
	if (FoundFunctionElement) {
		FunctionDefine* FoundFunction := (FoundFunctionElement->Value) As FunctionDefine*
		
		if (FoundFunction->HasFullDefinition) {
			TokenError(NameToken, "Duplicate function definition")
		}
		
		NewDefine := FoundFunction
	}
	else {
		NewDefine := Alloc(#FunctionDefine) As FunctionDefine*
		
		HashMapAddValue(pState->Functions, Name, NewDefine As void)
		
		NewDefine->LabelNumber := ParserNextLabel(pState)
		pState->FunctionCount += 1
	}
	
	NewDefine->ReturnType := ReturnType
	NewDefine->Name := Name
	NewDefine->Locals := NewHashMap()
	NewDefine->LocalOffset := 0
	
	CopyContext(NameToken~>Context, NewDefine~>Context)
	
	return NewDefine
}

declare ASTNode* ParseStatement(ParserState*)

define void ConsumeAndIgnoreBlock(ParserState* pState) {
	/* Used for linux/windows statements */
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open '{' for block.")
	
	i32 Depth := 1
	
	loop {
		Token* Next := ParserNextToken(pState)
		
		if (TokenMatches(Next, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
			Depth -= 1
		}
		else if (TokenMatches(Next, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)) {
			Depth += 1
		}
		
		if (Depth = 0) {
			break
		}
	}
}

define Block* ParseBlock(ParserState* pState) {
	/* Parses and builds a block of statements */
	
	/* Consume the { */
	Token* OpenBrace := Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace in block")
	
	/* Set up a buffer for the statements */
	i16 StatementBufferSize := 8
	ASTNode** Statements := Alloc(StatementBufferSize * 8) As ASTNode**
	i16 StatementCount := 0
	
	i32 Depth := 1
	
	if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {		
		loop {
			/* Loop until NextMatches('}') */
			
			if (StatementCount * 8 <= StatementBufferSize) {
				/* If the buffer needs to be expanded, expand it */
				
				Statements := ReAlloc(Statements As void*, (StatementCount + 10) * 8) As ASTNode**
				StatementBufferSize += (10 * 8)
			}
			
			/* Parse a statement and put it into the statement list */
			
			i32 Start := FreezeParser(pState)
			
			Token* NextToken := ParserNextToken(pState)
			
			if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_LINUX)) {
				if (pState->OutputELF) {
					Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace.")
					Depth += 1
				}
				else {
					ConsumeAndIgnoreBlock(pState)
				}
			}
			else if (TokenMatches(NextToken, TOKEN_TYPE_KEYWORD, KEYWORD_WINDOWS)) {
				if !(pState->OutputELF) {
					Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Expected open brace.")
					Depth += 1
				}
				else {
					ConsumeAndIgnoreBlock(pState)
				}
			}
			else {
				UnfreezeParser(pState, Start)
				Statements[StatementCount] := ParseStatement(pState)
				StatementCount += 1
			}
			
			if (ParserNextMatches(pState, TOKEN_TYPE_EOF, 0)) {
				TokenError(OpenBrace, "Expected close brace for block")
			}
			
			i8 BreakOuter := false
			
			while (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				Depth -= 1
				
				BreakOuter := Depth = 0
				
				if (BreakOuter) {
					break
				}
			}
			
			if (BreakOuter) {
				break
			}
		}
	}
	
	/* Allocate a block structure and populate it with the statement list/count */
	Block* NewBlock := Alloc(#Block) As Block*
	NewBlock->Statements := Statements
	NewBlock->StatementCount := StatementCount
	
	return NewBlock
}

define ASTNode* ParseAndAddDeclare(ParserState* pState, i8 IsImported) {
	FunctionDefine* NewDefine := ParseFunctionInfo(pState)
	
	Token* OpenParen := Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Function parameter lists must start with (")
	
	i8 ParameterCount := 0
	VariableInfo** ParameterList := Alloc(16 * #VariableInfo) As VariableInfo**
	
	if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
		loop {
			VariableInfo* NextParameter := AllocateNewVariableInfo()
			
			if (ParameterCount >= 16) {
				TokenError(ParserNextToken(pState), "Max parameter limit reached")
			}
			
			ParameterList[ParameterCount] := NextParameter
			
			NextParameter->Type := ParseTypeName(pState)
			NextParameter->Name := NewDefine->Name /* Dummy value, it will never be used */
			NextParameter->IsGlobal := false
			NextParameter->IsParameter := true
			NextParameter->StackOffset := (ParameterCount * 8)
			
			/* Update the parameter count */
			ParameterCount += 1
			
			if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
				/* If the next token isn't a comma, then break the loop, otherwise consume the command and continue */
				break
			}
		}
		
		Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing paren for parameter list")
	}
	
	NewDefine->Parameters := ParameterList
	NewDefine->ParameterCount := ParameterCount
	
	if (IsImported) {
		Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE, "Import source must have a prior '{'.")
		
		SafeWideString* FileName := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Import source file name expected")->Value
		
		if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
			Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Import source file extension expected")
		}
		
		Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA, "Comma expected between import source file and function names")
		
		SafeWideString* FunctionName := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Import source function name expected")->Value
		
		Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE, "Expected closing '}'.")
		
		NewDefine->IsImported := true
		NewDefine->ImportFileName := FileName
		NewDefine->ImportFunctionName := FunctionName
	}
	
	NewDefine->HasFullDefinition := false
}

declare ASTNode* ParseAssembly(ParserState*)

define ASTNode* ParseAndAddDefine(ParserState* pState) {
	/* Parses a 'define' statement */

	FunctionDefine* NewDefine := ParseFunctionInfo(pState)
	
	pState->CurrentFunction := NewDefine
	NewDefine->UsesGlobals := false
	
	/* Consume the parameter list opening '(' */
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Function parameter lists must start with (")
	
	/* Set up a buffer for parameters */
	i8 ParameterCount := 0
	VariableInfo** ParameterList := Alloc(16 * #VariableInfo) As VariableInfo**
	
	if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
		/* If the next token isn't a ')', then parse the parameters (otherwise the function takes 0 parameters) */
		
		loop {
			/* Allocate a VariableInfo struct for the next parameter */
			VariableInfo* NextParameter := AllocateNewVariableInfo()
			
			/* Max parameter count since I cba to expand the buffer. Todo: Fix this */
			if (ParameterCount >= 16) {
				TokenError(ParserNextToken(pState), "Max parameter limit reached")
			}
			
			/* Insert the VariableInfo structure into the parameter list */
			ParameterList[ParameterCount] := NextParameter
			
			if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_DOT)) {
				Token* Start := ParserCurrentToken(pState)
				
				Consume(pState, TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected '.' for variadic marker")
				Consume(pState, TOKEN_TYPE_OPERATOR, OPERATOR_DOT, "Expected '.' for variadic marker")
				
				MergeContexts(Start~>Context, ParserCurrentToken(pState)~>Context, Start~>Context)
				
				if (ParameterCount > 4) {
					TokenError(Start, "Only 4 regular paremeters can be passed with a variable argument.")
				}
				
				NewDefine->Attribute := OPERATOR_DOT
				
				Token* VariadicName := Consume(pState, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE, "Parameter names must be identifiers")
				
				NextParameter->Name := VariadicName->StringValue
				NextParameter->Type := MakeType(pState->void, 1)
				NextParameter->IsVariadic := true
				NextParameter->IsParameter := true
				NextParameter->StackOffset := (ParameterCount * 8)
				
				ParserAddLocal(pState, NextParameter, VariadicName)
				
				ParameterCount += 1
				
				break
			}
			
			/* Parse the parameter type */
			NextParameter->Type := ParseTypeName(pState)
			
			/* Get the parameter name */
			Token* NextParameterNameToken := Consume(pState, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE, "Parameter names must be identifiers")
			
			/* Populate the VariableInfo structure */
			NextParameter->Name := NextParameterNameToken->StringValue
			NextParameter->IsGlobal := false
			NextParameter->IsParameter := true
			NextParameter->StackOffset := (ParameterCount * 8)
			
			/* Add the parameter as a local */
			ParserAddLocal(pState, NextParameter, NextParameterNameToken)
			
			/* Update the parameter count */
			ParameterCount += 1
			
			if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
				/* If the next token isn't a comma, then break the loop, otherwise consume the command and continue */
				break
			}
		}
		
		/* If the loop was broken by any token besides a ')', then there's something wrong */
		
		if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
			TokenError(ParserNextToken(pState), "Expected closing paren for parameter list")
		}
	}
	
	/* Update the function's parameter list/count */
	
	NewDefine->Parameters := ParameterList
	NewDefine->ParameterCount := ParameterCount
	
	/* Parse the body of the function */
	NewDefine->HasFullDefinition := true
	
	if (ParserNextMatches(pState, TOKEN_TYPE_KEYWORD, KEYWORD_ASSEMBLY)) {
		NewDefine->Attribute := KEYWORD_ASSEMBLY
		
		NewDefine->AssemblyBody := ParseAssembly(pState)->AssemblyValue
	}
	else {
		NewDefine->StringBuffer := Alloc(4) As i8*
		NewDefine->StringBufferSize := 0
		
		NewDefine->Body := ParseBlock(pState)
	}
}

declare ASTNode* ParseIf(ParserState*)
declare ASTNode* ParseFor(ParserState*)
declare ASTNode* ParseWhile(ParserState*)

define ASTNode* ParseStatement(ParserState* pState) {
	/* Parses a single statement */
	
	/* Freeze the parser just in case the next token isn't a keyword */
	i32 FrozenState := FreezeParser(pState)
	
	Token* NextToken := ParserNextToken(pState)
	ASTNode* Result := 0
	
	if (NextToken->Type = TOKEN_TYPE_KEYWORD) {
		i8 NextKeyword := (NextToken->Value) As i8
		
		i8 IsContinue := (NextKeyword = KEYWORD_CONTINUE)
		
		if (NextKeyword = KEYWORD_BREAK || IsContinue) {
			Result := AllocateNewASTNode(NODE_TYPE_CONTINUEBREAK, IsContinue, TYPE_NONE)
			CopyContext(NextToken~>Context, Result~>Context)
			
			if !(pState->InLoop) {
				ASTError(Result, "Continue/Break must be inside loops")
			}
		}
		else if (NextKeyword = KEYWORD_RETURN) {
			/* A return is a NODE_TYPE_RETURN with a value which points to the expression to return */
			
			if (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)) {
				/* If there isn't an expression to return, just pretend it is `return 0` */
				
				Result := AllocateNewASTNode(NODE_TYPE_INTEGER, 0, MakeType(pState->i8, 0))
				Result := AllocateNewASTNode(NODE_TYPE_RETURN, Result, TYPE_NONE)
			}
			else {
				/* Parse the expression to return */
				ASTNode* ExpressionToReturn := ParseExpression(pState, 0)
				
				/* Get the type of the return expression, and the current function's return type */
				Type ActualReturnType := DowncastIntegerType(pState, ExpressionToReturn)
				Type ExpectedReturnType := pState->CurrentFunction->ReturnType
				
				CheckTypes(ActualReturnType, ExpectedReturnType, ExpressionToReturn)
				
				Result := AllocateNewASTNode(NODE_TYPE_RETURN, ExpressionToReturn As void*, TYPE_NONE)
			}
		}
		else if (NextKeyword = KEYWORD_IF) {
			Result := ParseIf(pState)
		}
		else if (NextKeyword = KEYWORD_FOR) {
			Result := ParseFor(pState)
		}
		else if (NextKeyword = KEYWORD_LOOP) {
			i8 OldInLoop := pState->InLoop
			pState->InLoop := true
			
			Result := AllocateNewASTNode(NODE_TYPE_LOOP, ParseBlock(pState) As void*, TYPE_NONE)
			
			pState->InLoop := OldInLoop
		}
		else if (NextKeyword = KEYWORD_WHILE) {
			Result := ParseWhile(pState)
		}
		else if (NextKeyword = KEYWORD_ASSEMBLY) {
			Result := ParseAssembly(pState)
		}
	}
	
	if (Result = 0) {
		/* When we don't have a result yet, this is either a declaration or a expression statement */
		
		UnfreezeParser(pState, FrozenState)
		
		if (NextToken->Type = TOKEN_TYPE_IDENTIFIER) {
			/* If the next token isn't an identifier, then it's definitely not a declaration */
			
			i8* ErrorMessage := 0
			Type PotentialType := TryParseTypeName(pState, true, &ErrorMessage)
			
			if ((PotentialType != 0) && (ErrorMessage = 0)) {
				/* Holds the parser state right after `Type` would have been parsed, so `PotentialType := ParseTypeName(pState)` can still be parsed as well */
				i32 DefaultValueExpressionStart := FreezeParser(pState)
				Token* PotentialName := ParserNextToken(pState)
				
				if (TokenMatches(PotentialName, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE)) {
					/* If we parsed a type name, and then found another identifier after the type name, this is a declaration */
					/* This can be wrong if you had `A * B` alone on a line, but what kind of dumbass would do that? */
					
					SafeWideString* NameString := (PotentialName->Value) As SafeWideString*
					
					VariableInfo* NewLocal := AllocateNewVariableInfo()
					
					NewLocal->Name := NameString
					NewLocal->Type := PotentialType
					NewLocal->IsGlobal := False
					NewLocal->IsParameter := False
					
					ParserAddLocal(pState, NewLocal, PotentialName)
					
					if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
						UnfreezeParser(pState, DefaultValueExpressionStart)
					}
					else {
						/* The next token is not a `:=`, so the following tokens are not a value for this variable */
						return AllocateNewASTNode(NODE_TYPE_NONE, 0, TYPE_NONE)
					}
				}
				else {
					/* Token after the type name was not an identifier */
					UnfreezeParser(pState, FrozenState)
				}
			}
			else {
				UnfreezeParser(pState, FrozenState)
			}
		}
		
		/* This expression will either be at A) The start of the line or B) After a type name (for declarations) */
		Result := AllocateNewASTNode(NODE_TYPE_EXPRESSION, ParseExpression(pState, 0) As void*, TYPE_NONE)
	}
	
	return Result
}

define ASTNode* ParseIf(ParserState* pState) {
	IfGroup* NewIf := Alloc(#IfGroup) As IfGroup*
	
	NewIf->Conditions := Alloc(10 * #ASTNode*) As ASTNode**
	NewIf->Bodies := Alloc(10 * #Block*) As Block**
	i32 BranchCapacity := 10
	i32 BranchIndex := 0
	
	loop {
		if (BranchIndex = 0 || ParserNextMatches(pState, TOKEN_TYPE_KEYWORD, KEYWORD_IF)) {
			if (BranchCapacity <= BranchIndex) {
				BranchCapacity += 10
			
				NewIf->Conditions := ReAlloc(NewIf->Conditions, BranchCapacity * 8)
				NewIf->Bodies := ReAlloc(NewIf->Bodies, BranchCapacity * 8)
			}
			
			NewIf->Conditions[BranchIndex] := ParseExpression(pState, 0)
			NewIf->Bodies[BranchIndex] := ParseBlock(pState)
		
			BranchIndex += 1

			if !(ParserNextMatches(pState, TOKEN_TYPE_KEYWORD, KEYWORD_ELSE)) {
				break
			}
		}
		else {
			NewIf->ElseBranch := ParseBlock(pState)
			break
		}
	}
	
	NewIf->BranchCount := BranchIndex

	return AllocateNewASTNode(NODE_TYPE_IF, NewIf, TYPE_NONE)
}

define ASTNode* ParseFor(ParserState* pState) {
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN, "Expected opening '(' for for loop.")
	
	i32 InitializerStart := FreezeParser(pState)
	
	if (ParserNextMatches(pState, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE)) {
		UnfreezeParser(pState, InitializerStart)
		
		i8* ErrorMessage := 0
		Type PotentialType := TryParseTypeName(pState, false, &ErrorMessage)
		
		if ((PotentialType != 0) && (ErrorMessage = 0)) {
			i32 ExpressionStart := FreezeParser(pState)
			Token* PotentialName := ParserNextToken(pState)
			
			if (TokenMatches(PotentialName, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_NONE)) {
				if (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_COLON_EQUAL)) {
					SafeWideString* NameString := (PotentialName->Value) As SafeWideString*
					
					VariableInfo* NewLocal := AllocateNewVariableInfo()
					
					NewLocal->Name := NameString
					NewLocal->Type := PotentialType
					
					ParserAddLocal(pState, NewLocal, PotentialName)
					
					InitializerStart := ExpressionStart /* Set the initializer expression to start after the type name */
				}
			}
		}
	}
	
	UnfreezeParser(pState, InitializerStart)
	
	ForLoop* NewLoop := Alloc(#ForLoop) As ForLoop*
	
	NewLoop->Initializer := ParseExpression(pState, 0)
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA, "Expected comma after for loop initializer.")
	NewLoop->Condition := ParseExpression(pState, 0)
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA, "Expected comma after for loop condition.")
	NewLoop->Step := ParseExpression(pState, 0)
	
	Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing ')' in for loop.")
	
	i8 OldInLoop := pState->InLoop
	pState->InLoop := true
	
	NewLoop->Body := ParseBlock(pState)
	
	pState->InLoop := OldInLoop
	
	return AllocateNewASTNode(NODE_TYPE_FOR, NewLoop, TYPE_NONE)
}

define ASTNode* ParseWhile(ParserState* pState) {
	WhileLoop* NewWhile := Alloc(#WhileLoop) As WhileLoop*
	
	NewWhile->Condition := ParseExpression(pState, 0)
	
	i8 OldInLoop := pState->InLoop
	pState->InLoop := true
	
	NewWhile->Body := ParseBlock(pState)
	
	pState->InLoop := OldInLoop
	
	return AllocateNewASTNode(NODE_TYPE_WHILE, NewWhile As void*, TYPE_NONE)
}


define ASTNode* TranslateTokenToNode(ParserState* pState, Token* TokenToTranslate) {
	/* Translates some kind of token in an AST node which contains the actual version of the token */
	
	ASTNode* Result := 0
	
	if (TokenToTranslate->Type = TOKEN_TYPE_INTEGER) {
		/* If the token is an integer, return a NODE_TYPE_INTEGER node with a type which is correctly size for the given integer */
		
		Type ResultType := GetNumberType(pState, TokenToTranslate->Value)
		
		Result := AllocateNewASTNode(NODE_TYPE_INTEGER, TokenToTranslate->Value, ResultType)
	}
	else if (TokenToTranslate->Type = TOKEN_TYPE_IDENTIFIER) {
		/* If the token is an identifier, find the variable the identifier represents, and put it into a NODE_TYPE_VARIABLE node */
		
		Result := AllocateNewASTNode(NODE_TYPE_INTEGER, 0, MakeType(pState->i32, 0))
		
		if (SafeStringEqualsAString(TokenToTranslate->Value, "true")) {
			Result->IntegerValue := 1
		}
		else if (SafeStringEqualsAString(TokenToTranslate->Value, "false")) {
			Result->IntegerValue := 0
		}
		else if (SafeStringEqualsAString(TokenToTranslate->Value, "windows")) {
			Result->IntegerValue := !pState->OutputELF
		}
		else if (SafeStringEqualsAString(TokenToTranslate->Value, "linux")) {
			Result->IntegerValue := pState->OutputELF
		}
		else {
			VariableInfo* FoundVariable := FindVariable(pState, TokenToTranslate)
			/* Using the found variable's type as the node type */
			
			Result->NodeType := NODE_TYPE_VARIABLE
			Result->IsStorageValue := true
			Result->VariableValue := FoundVariable
			Result->ValueType := FoundVariable->Type
		}
		
		CopyContext(TokenToTranslate As ErrorContext*, Result As ErrorContext*)
	}
	else {
		TokenError(TokenToTranslate, "Unexpected token")
	}
	
	CopyContext(TokenToTranslate~>Context, Result~>Context)
	
	return Result
}

define ASTNode* ParseExpressionOperand(ParserState* pState) {
	/* Parses and returns a single operand of an expression */
	
	Token* NextToken := ParserNextToken(pState)
	ASTNode* Result := 0
	
	if (NextToken->Type = TOKEN_TYPE_PUNCTUATION && NextToken->Value = PUNCTUATION_OPEN_PAREN) {
		/* If the next token is an (, then parse a subexpression and consume a closing ) */
		
		Result := ParseExpression(pState, 0)
		
		Token* CloseParen := Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing paren")
		
		MergeContexts(NextToken~>Context, CloseParen~>Context, Result~>Context)
	}
	else if (NextToken->Type = TOKEN_TYPE_IDENTIFIER) {
		/* Else if the next token is an identifier */
		
		/* This check is fine, since x:(y) is never valid, nor is x:y */
		i8 IsBuiltin := (ParserNextMatches(pState, TOKEN_TYPE_OPERATOR, OPERATOR_COLON) != 0)
		
		if (IsBuiltin) {
			MergeContexts(NextToken~>Context, ParserCurrentToken(pState)~>Context, NextToken~>Context)
		}
		
		if (ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)) {
			/* If the next-next token is an (, then this is a function call */
			
			i8 ParameterIndex := 0
			ASTNode** Parameters := Alloc(8 * 10) As ASTNode**
			
			/* If the next token is not a ), then parse a parameter list (if it is a ')' then there are 0 parameters) */
			
			if !(ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)) {
				while (ParameterIndex = 0 || ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)) {
					Parameters[ParameterIndex] := ParseExpression(pState, 0)
					ParameterIndex += 1
				}
				
				/* When we run into a token that isn't a ',' then the next token must be ')' to close the parameter group */
				
				Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing paren for function call")
			}
			
			/* Make a NODE_TYPE_CALL node for the function call */
			
			Result := MakeCall(pState, NextToken, Parameters, ParameterIndex, IsBuiltin)
			
			/* CopyContext(NextToken As ErrorContext*, Result As ErrorContext*) */
		}
		else {
			/* Else, this isn't a function call, and is just a normal variable */
			Result := TranslateTokenToNode(pState, NextToken)
		}
	}
	else if (NextToken->Type = TOKEN_TYPE_STRING) {
		FunctionDefine* CurrentFunction := pState->CurrentFunction
		
		if !(CurrentFunction) {
			TokenError(NextToken, "Strings can only be used inside functions.")
		}
		
		SafeWideString* StringText := NextToken->StringValue
		
		i32 Offset := CurrentFunction->StringBufferSize
		i32 NewSize := Offset + StringText->Length + 1
		
		CurrentFunction->StringBuffer := ReAlloc(CurrentFunction->StringBuffer, NewSize)
		CurrentFunction->StringBufferSize := NewSize
		
		for (i32 Index := 0, Index < (StringText->Length), Index += 1) {
			CurrentFunction->StringBuffer[Offset + Index] := StringText->Buffer[Index]
		}
		
		Result := AllocateNewASTNode(NODE_TYPE_STRING, Offset, MakeType(pState->i8, 1))
	}
	else if (NextToken->Type = TOKEN_TYPE_INTEGER) {
		/* A literal integer, just make a NODE_TYPE_INTEGER for it */
		
		Result := TranslateTokenToNode(pState, NextToken)
	}
	else if (NextToken->Type = TOKEN_TYPE_OPERATOR && IsPrefixOperator(NextToken)) {
		/* A prefix operator, parse an expression only containing operators of a higher precedence than the prefix operator */
		
		if (NextToken->Value = OPERATOR_POUND) {
			/* Handle #TypeName by parsing a type name after the #, and setting the result to the length of TypeName as an i32 */
			
			i8 ConsumeClosingParan := ParserNextMatches(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)
			
			Type GetSizeOfType := ParseTypeName(pState)
			
			if (ConsumeClosingParan) {
				Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN, "Expected closing ')' around type name")
			}
			
			Result := AllocateNewASTNode(NODE_TYPE_INTEGER, GetTypeSize(GetSizeOfType), MakeType(pState->i32, 0))
			
			MergeContexts(NextToken~>Context, ParserCurrentToken(pState)~>Context, Result~>Context)
		}
		else {
			if (NextToken->Value = OPERATOR_AND) {
				i8* ErrorMessage := 0
				
				i32 Frozen := FreezeParser(pState)
				Token* MaybeFunction := TryConsume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Dummy", &ErrorMessage)
				
				if (MaybeFunction && !ErrorMessage) {
					HashMapElement* FoundFunction := HashMapGetValue(pState->Functions, MaybeFunction->StringValue)
					
					if (FoundFunction) {
						FunctionDefine* FoundDefine := (FoundFunction->Value) As FunctionDefine*
						
						FoundDefine->CallCount += 1
						
						Result := AllocateNewASTNode(NODE_TYPE_DEFINE, FoundDefine, MakeType(pState->void, 1))
						MergeContexts(NextToken~>Context, MaybeFunction~>Context, Result~>Context)
					}
					else {
						UnfreezeParser(pState, Frozen)
					}
				}
				else {
					UnfreezeParser(pState, Frozen)
				}
			}
			
			if !(Result) {
				Result := ParseExpression(pState, GetPrefixPrecedence(NextToken))
			}
			
			Result := MakeUnary(pState, NextToken, Result)
		}
	}
	else {
		/* Else, this token isn't something we expected here, so error out */
		
		TokenError(NextToken, "Unexpected token in expression")
	}
	
	return Result
}

define ASTNode* ParseExpression(ParserState* pState, i8 Precedence) {
	/* Parses and returns and expression only containing operators with higher precedence than Precedence */
	
	ASTNode* Result := ParseExpressionOperand(pState)
	
	i32 FrozenState := FreezeParser(pState)
	Token* OperatorToken := ParserNextToken(pState)
	
	while (OperatorToken->Type = TOKEN_TYPE_OPERATOR && GetPrecedence(OperatorToken) >= Precedence) {
		i8 NewPrecedence := GetPrecedence(OperatorToken)
		
		if (GetAssociation(OperatorToken) = LEFT_ASSOCIATIVE) {
			NewPrecedence += 1
		}
		
		ASTNode* Operand := 0
		i8 Operator := (OperatorToken->Value) As i8
		
		if (Operator = OPERATOR_OPEN_BRACKET) {
			/* If the next operator is [, then parse the index expression (for the right operand) and consume the closing ] */
			
			Operand := ParseExpression(pState, 0)
			
			Consume(pState, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET, "Expected closing bracket for array access")
		}
		else if (Operator = OPERATOR_AS) {
			/* Else if the next operator is 'as' then parse a type name as the right operand */
			
			Type CastToType := ParseTypeName(pState)
			
			Operand := AllocateNewASTNode(NODE_TYPE_TYPE, CastToType As void*, CastToType)
		}
		else if (Operator = OPERATOR_DOT || Operator = OPERATOR_MINUS_GREATER || Operator = OPERATOR_TILDE_GREATER) {
			Token* Right := Consume(pState, TOKEN_TYPE_IDENTIFIER, 0, "Struct field name expected")
			
			Operand := AllocateNewASTNode(NODE_TYPE_IDENTIFIER, (Right->Value) As void*, MakeType(pState->i64, 0))
			CopyContext(Right~>Context, Operand~>Context)
		}
		else {
			/* Else, no special case, just parse and expression at the expected precedence level as the right operand */
			
			Operand := ParseExpression(pState, NewPrecedence)
		}
		
		/* Fold the left/operator/right into just the left */
		
		Result := MakeBinary(pState, Result, OperatorToken, Operand)
		
		/* MergeContexts(Result As ErrorContext*, Operand As ErrorContext*, StructNode As ErrorContext*) */
		
		/* Update where to restore the parser to once the expression ends */
		FrozenState := FreezeParser(pState)
		
		/* Update the next operator */
		OperatorToken := ParserNextToken(pState)
	}
	
	UnfreezeParser(pState, FrozenState)
	
	return Result
}

#Include ./src/compiler/AssemblyParse.rlx