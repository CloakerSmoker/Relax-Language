#Require "./src/lib/Memory.rlx"
#Require "./src/lib/File.rlx"

#Require "./src/lib/String.rlx"
#Require "./src/lib/Console.rlx"
#Require "./src/lib/SafeString.rlx"
#Require "./src/lib/HashMap.rlx"
#Require "./src/lib/Debug.rlx"

#Require "./src/compiler/Utility.rlx"
#Require "./src/compiler/Lexer.rlx"
#Require "./src/compiler/Parser.rlx"



;declare i8 Frob(i8*)
;
;define void Main(i64 ArgC, i8** ArgV) {
;	if (ArgC < 2) {
;		Exit(0)
;	}
;	
;	i8* Path := ArgV[1]
;	
;	Frob(Path)
;}
;
;
;define void Main(i64 ArgC, i8** ArgV) {
;	load.8, t1, ArgC
;	laod_integer.8, t2, 2
;	binary.8, t3, t1, <, t2
;	
;	conditional.1, t3, {
;		load_integer.1, t4, 0
;		call, t5, exit, [t4]
;	}, {
;		load_index.8, t6, ArgV, 1
;		set.8, Path, t6
;		
;		load.8, t7, Path
;		call.1, t8, Frob, [t7]
;	}
;}

; Var		 => IR_LOAD
; Var[Index] => IR_LOAD_INDEX (or IR_LOAD_OFFSET if possible)
; Var->Field => IR_LOAD_OFFSET
; 1			 => IR_LOAD_INTEGER
; "abc"		 => IR_LOAD_CONSTANT_ADDRESS
; Var := X	 => IR_STORE
; Var[Index] => IR_STORE_INDEX
; Var->Field => IR_STORE_OFFSET
; 1 + 2		 => IR_BINARY
; !1		 => IR_UNARY
; Fun()		 => IR_CALL
; return	 => IR_RETURN

bits TemporaryRegister As i64 {
	[0:61] PointerValue
	[62:63] IsVariable
}

struct IRVariable {
	i8* Name
	IRNode* LastValue
	i32 Offset
	i8 Size
	i8 IsGlobal
	i8 ReferenceCount
	
	static IRVariable* New(i8* Name, i32 Offset, i8 Size, i8 IsGlobal) {
		IRVariable* this := Alloc(#IRVariable)
		
		this->Name := Name
		this->Offset := Offset
		this->Size := Size
		this->IsGlobal := IsGlobal
		
		return this
	}
	define i64 ToRegister() {
		TemporaryRegister Result
		
		Result.PointerValue := this As i64
		Result.IsVariable := true
		
		return Result As i64
	}
}

struct IRLoadIndex {
	; Loads the IndexRegister-th element out of the array of IndexScale sized elements pointed to by SourceRegister 
	;  into DestinationRegister
	
	i32 SourceRegister
	i32 IndexRegister
	i32 DestinationRegister
	i8 IndexScale
}
struct IRLoadOffset {
	; Loads Size bytes from *(SourceRegister + OffsetRegister) into DestinationRegister
	
	i32 SourceRegister
	i32 OffsetRegister
	i32 DestinationRegister
	i8 Size
}
struct IRLoadInteger {
	; Loads a (Size * 8) bit integer into DestinationRegister
	
	i64 SourceValue
	i64 DestinationRegister
	i8 Size
}

struct IRLoadVariableAddress {
	; Loads the address of local variable Source into DestinationRegister
	
	IRVariable Source
	i32 DestinationRegister
}
struct IRLoadIndexAddress {
	; Loads the address of the IndexRegister-th element of the array of IndexScale elements pointed to by SourceRegister
	;  into DestinationRegister
	
	i32 SourceRegister
	i32 IndexRegister
	i32 DestinationRegister
	i8 IndexScale
}
struct IRLoadOffsetAddress {
	; Loads (SourceRegister + OffsetRegister) into DestinationRegister
	
	i32 SourceRegister
	i32 OffsetRegister
	i32 DestinationRegister
}
struct IRLoadLabelAddress {
	; Loads the address of the label identified by LabelNumber into DestinationRegister
	
	i32 LabelNumber
	i32 DestinationRegister
	
	i32 Offset
}

struct IRStoreIndirect {
	; Stores the value of SourceRegister into *DestinationRegister as a Size byte value
	
	i32 DestinationRegister
	i32 SourceRegister
	i8 Size
}
struct IRStoreIndex {
	; Stores the value of SourceRegister into the IndexRegister-th element of the array of IndexScale elements pointed to 
	;  by DestinationRegister
	
	i32 DestinationRegister
	i32 IndexRegister
	i32 SourceRegister
	i8 IndexScale
}
struct IRStoreOffset {
	; Stores the value of SourceRegister into the memory at (DestinationRegister + OffsetRegister), as a Size byte value
	
	i32 DestinationRegister
	i32 OffsetRegister
	i32 SourceRegister
	i8 Size
}

struct IRMove {
	i64 Destination
	i64 Source
	i8 Size
}

struct IRBinary {
	; Does binary operation (LeftRegister Operator RightRegister) and stores the result into DestinationRegister
	
	i64 DestinationRegister
	i64 LeftRegister
	i32 Operator
	i64 RightRegister
	i8 Size
}
struct IRUnary {
	; Does the unary operation (Operator OperandRegister) and stores the result into DestinationRegister
	
	i64 DestinationRegister
	i32 Operator
	i64 OperandRegister
	i8 Size
}

struct IRCall {
	IRFunction* TargetFunction
	i32 ParameterCount
	i32 Result
	i32* Parameters
	i8 Size
}
struct IRReturn {
	i64 ReturnValueRegister
	i8 ReturnValueSize
}
struct IRConditional {
	i64 Condition
	i32 TrueBlock
	i32 FalseBlock
	
	i8 ConditionSize
}

struct IRFunction {
	i64* Parameters
	i32 ParameterCount
}


i8 IR_BINARY                        := 1
i8 IR_HAS_TWO_OPERANDS              := 1

i8 IR_MOVE                          := 2
i8 IR_UNARY                         := 3
i8 IR_HAS_ONE_OPERAND               := 3

i8 IR_LOAD_INTEGER                  := 4
i8 IR_HAS_DESTINATION               := 4

i8 IR_LOAD_INDEX                    := 5
i8 IR_LOAD_OFFSET                   := 6

i8 IR_LOAD_VARIABLE_ADDRESS         := 7
i8 IR_LOAD_INDEX_ADDRESS            := 8
i8 IR_LOAD_OFFSET_ADDRESS           := 9
i8 IR_LOAD_LABEL_ADDRESS            := 10

i8 IR_STORE_INDIRECT                := 11
i8 IR_STORE_INDEX                   := 12
i8 IR_STORE_OFFSET                  := 13

i8 IR_RETURN                        := 14
i8 IR_CALL                          := 15
i8 IR_JUMP                          := 16
i8 IR_CONDITIONAL                   := 17
i8 IR_CONDITIONAL_NOT               := 18

i8 IR_FUNCTION                      := 19

define i8* OperatorToString(i8 Operator) {
	i8*[40] Operators {
		":=", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=",
		"&&", "||",
		"=", "!=", "<", "<=", ">", ">=",
		"as",
		"+", "-",
		"*", "/", "%",
		"&", "|", "^",
		"<<", ">>",
		"!", "~",
		"++", "--", "++", "--",
		"[",
		".", "->", "~>",
		":", "#"
	}
	
	return Operators[Operator]
}

define void IRPrint(i8* Format, ... Args) {
	i32 Length := StringLength(Format)
	i32 ArgIndex := 1
	
	for (i32 Index := 0, Index < Length, Index += 1) {
		i8 Next := Format[Index]
		
		if (Next = '%') {
			Index += 1
			Next := Format[Index]
			void NextArg := Args[ArgIndex]
			
			if (Next = 'i') {
				Print(NextArg As i64)
			}
			else if (Next = 'x') {
				PrintHex(NextArg As i64)
			}
			else if (Next = 'c') {
				PrintCharacter(NextArg As i8)
			}
			else if (Next = 's') {
				PrintString(NextArg As i8*)
			}
			else if (Next = 'l') {
				PrintLiteral(NextArg As i64)
			}
			else if (Next = 'b') {
				PrintBinary(NextArg As i64)
			}
			else if (Next = 'o') {
				Print(OperatorToString(NextArg As i8))
			}
			else if (Next = 't') {
				TemporaryRegister Register := NextArg As TemporaryRegister
				
				if (Register.IsVariable) {
					IRVariable* Variable := Register.PointerValue As IRVariable*
					
					Print("v(%s)", Variable->Name)
				}
				else {
					Print("T%i", NextArg As i64)
				}
			}
			
			ArgIndex += 1
		}
		else if (Next = '^') {
			Index += 2
			i8 Fore := GetCharacterValue(Format[Index - 1])
			i8 Back := GetCharacterValue(Format[Index])
			
			SetColor(Fore, Back)
		}
		else {
			PrintCharacter(Next)
		}
	}
}

struct IRNode {
	union {
		IRLoadIndex LoadIndexNode
		IRLoadOffset LoadOffsetNode
		IRLoadInteger LoadIntegerNode
		
		IRLoadVariableAddress LoadVariableAddressNode
		IRLoadIndexAddress LoadIndexAddressNode
		IRLoadOffsetAddress LoadOffsetAddressNode
		IRLoadLabelAddress LoadLabelAddressNode
		
		IRStoreIndirect StoreIndirectNode
		IRStoreIndex StoreIndexNode
		IRStoreOffset StoreOffsetNode
		
		IRFunction FunctionNode
		
		i64[2] Operands
		i64 Source
		i64 Operand
		
		i64 Condition
		i64 SourceValue
	}
	
	union {
		i32 CallToBlock
		i32 JumpToBlock
		i32 TrueBlock
		i32 Operator
	}
	
	i32 FalseBlock
	
	i64 Destination
	
	i8 Size
	i8 Kind
	i8 IsNotPresent
	
	define void Print() {
		if (this->Kind = IR_MOVE) {
			IRPrint("move.%i, %t, %t", this->Size, this->Destination, this->Source)
		}
		else if (this->Kind = IR_LOAD_INTEGER) {
			IRPrint("load_integer.%i, %t, %i", this->Size, this->Destination, this->SourceValue)
		}
		else if (this->Kind = IR_UNARY) {
			IRPrint("unary.%i, %t, %o, %t", this->Size, this->Destination, this->Operator, this->Operand)
		}
		else if (this->Kind = IR_BINARY) {
			IRPrint("binary.%i, %t, %t, %o, %t", this->Size, this->Destination, this~>Operands[0], this->Operator, this~>Operands[1])
		}
		else if (this->Kind = IR_JUMP) {
			IRPrint("jump, L%i", this->JumpToBlock)
		}
		else if (this->Kind = IR_CONDITIONAL) {
			IRPrint("cond.%i, %t, L%i, L%i", this->Size, this->Condition, this->TrueBlock, this->FalseBlock)
		}
		else if (this->Kind = IR_CONDITIONAL_NOT) {
			IRPrint("cond.%i, !%t, L%i, L%i", this->Size, this->Condition, this->TrueBlock, this->FalseBlock)
		}
		else if (this->Kind = IR_RETURN) {
			IRPrint("return.%i, %t", this->Size, this->Operand)
		}
		else if (this->Kind = IR_FUNCTION) {
			IRPrint("function")
			
			for (i32 Index := 0, Index < this~>FunctionNode->ParameterCount, Index++) {
				i64 NextParameter := this~>FunctionNode->Parameters[Index]
				
				IRPrint(", %t", NextParameter)
			}
		}
	}
	
	define i8 Is(i8 Kind) {
		return this->Kind = Kind
	}
	define i8 IsInCategory(i8 Category) {
		return this->Kind <= Category
	}
}

bits LoopLables As i64 {
	[0:31] ContinueLabel,
	[32:63] BreakLabel
}

struct IRBackendTraits {
	void* State
	void* MapRegister
	void* UnMapRegister
	
	void* EndFunction
	
	void* SetLabel
	void* EmitNode
	
	static IRBackendTraits* New(void* State, void* MapRegister, void* UnMapRegister, void* EmitNode, void* EndFunction) {
		IRBackendTraits* this := Alloc(#IRBackendTraits)
		
		this->State         := State
		this->MapRegister   := MapRegister
		this->UnMapRegister := UnMapRegister
		this->EmitNode      := EmitNode
		this->EndFunction   := EndFunction
		
		return this
	}
	
	define void MapRegister(i64 Register) {
		asm (rdi := this->State, rsi := Register, rax := this->MapRegister) {
			call, rax
		}
	}
	define void UnMapRegister(i64 Register) {
		asm (rdi := this->State, rsi := Register, rax := this->UnMapRegister) {
			call, rax
		}
	}
	define void EmitNode(IRNode* Node) {
		asm (rdi := this->State, rsi := Node, rax := this->EmitNode) {
			call, rax
		}
	}
	define void EndFunction() {
		asm (rdi := this->State, rax := this->EndFunction) {
			call, rax
		}
	}
}

struct IRCompilerState {
	i64 NextVirtualRegister
	i8* RegisterReferenceCounts
	
	i32 NodeCapacity
	IRNode* Nodes
	
	union {
		i32 NextNodeIndex
		i32 NodeCount
	}
	
	i32 BlockCount
	i32 BlockCapacity
	i32* BlockOffsets
	i32* BlockSizes
	i8* BlocksVisited
	
	i32 CurrentBlock
	
	HashMap LocalsToIRVariables
	
	IRBackendTraits* Backend
	
	static IRCompilerState* New(IRBackendTraits* Backend) {
		IRCompilerState* this := Alloc(#IRCompilerState)
		
		this->NextVirtualRegister := 1
		
		this->NodeCapacity := 0x500
		this->Nodes := Alloc(this->NodeCapacity * #IRNode)
		
		this->BlockCapacity := 0x200
		this->BlockOffsets := Alloc(this->BlockCapacity * #i32)
		this->BlockSizes := Alloc(this->BlockCapacity * #i32)
		this->BlocksVisited := Alloc(this->BlockCapacity * #i8)
		
		this->CurrentBlock := -1
		
		this->RegisterReferenceCounts := Alloc(0x1000)
		
		this~>LocalsToIRVariables->Initialize()
		
		this->Backend := Backend
		
		return this
	}
	
	define IRVariable* FindOrAddVariable(VariableInfo* ActualVariable) {
		if (ActualVariable->IsGlobal) {
		
		}
		else {
			HashMapElement* FoundLocalElement := this~>LocalsToIRVariables->Get(ActualVariable->Name)
			
			if (FoundLocalElement) {
				return FoundLocalElement->Value
			}
			else {
				i8* Name := CloneMemory(ActualVariable->Name->PackToString(), ActualVariable->Name->Length)
				ActualVariable->Name->UnpackFromString()
				
				IRVariable* NewVariable := IRVariable:New(Name, ActualVariable->StackOffset, GetTypeSize(ActualVariable->Type) As i8, false)
				
				this~>LocalsToIRVariables->Set(ActualVariable->Name, NewVariable)
				
				return NewVariable
			}
		}
		
		return null
	}
	
	declare IRNode* AppendNode(i8)
	
	define void EndBlock() {
		if (this->CurrentBlock >= 0) {
			i32 StartIndex := this->BlockOffsets[this->CurrentBlock]
			i32 CurrentIndex := this->NextNodeIndex
			i32 Length := CurrentIndex - StartIndex
			
			this->BlockSizes[this->CurrentBlock] := Length
		}
	}
	
	define i32 StartBlock(i32 Number) {
		this->EndBlock()
		
		this->CurrentBlock := Number
		
		this->BlockOffsets[Number] := this->NextNodeIndex
		
		return Number
	}
	
	define i32 SetLabel() {
		return this->StartBlock(this->BlockCount++)
	}
	define i32 SetLabel(i32 LabelNumber) {
		return this->StartBlock(LabelNumber)
	}
	define i32 ReserveLabel() {
		return this->BlockCount++
	}
	
	define void CompactBlock(i32 Index) {
		i32 Start := this->BlockOffsets[Index]
		i32 Size := this->BlockSizes[Index]
		
		i32 NewNodeIndex := 0
		
		IRNode* Nodes := this->Nodes[Start]
		
		for (i32 NodeIndex := 0, NodeIndex < Size, NodeIndex++) {
			IRNode* NextNode := Nodes[NodeIndex]
			
			if (NextNode->IsNotPresent) {
				continue
			}
			
			MoveMemory(Nodes[NewNodeIndex++], NextNode, #IRNode)
		}
		
		this->BlockSizes[Index] := NewNodeIndex
	}
	define void CompactBlocks() {
		for (i32 Index := 0, Index < this->BlockCount, Index++) {
			this->CompactBlock(Index)
		}
	}
	
	define void Extend(i32 ExtraNodeCount) {
		if (this->NextNodeIndex + ExtraNodeCount >= this->NodeCapacity) {
			this->NodeCapacity += 0x500
			this->Nodes := ReAlloc(this->Nodes, this->NodeCapacity * #IRNode)
		}
	}
	
	define IRNode* AppendNode(i8 Kind) {
		this->Extend(#IRNode)
		
		IRNode* Result := this->Nodes[this->NextNodeIndex++]
		
		Result->Kind := Kind
		
		return Result
	}
	define i32 GetNodeIndex(IRNode* Node) {
		i64 Offset := (Node - this->Nodes) As i64
		
		return (Offset / #IRNode) As i32
	}
	
	define i64 AllocateRegister(IRNode* ForNode) {
		return this->NextVirtualRegister++
	}
	define i64 UseRegister(i64 RawRegister) {
		TemporaryRegister Register := RawRegister As TemporaryRegister
		
		;Print("UR %x\n", RawRegister)
		
		if (Register.IsVariable) {
			IRVariable* Variable := Register.PointerValue As IRVariable*
			
			;Print("V %x\n", Variable)
			Variable->ReferenceCount += 1
			
		}
		else {
			this->RegisterReferenceCounts[RawRegister] += 1		
		}
		
		return RawRegister
	}
	define i8 GetRegisterReferenceCount(i64 RawRegister) {
		TemporaryRegister Register := RawRegister As TemporaryRegister
		
		if (Register.IsVariable) {
			IRVariable* Variable := Register.PointerValue As IRVariable*
			
			return Variable->ReferenceCount
		}
		else {
			return this->RegisterReferenceCounts[RawRegister]
		}
	}
	define void DestroyRegisterReference(i64 RawRegister) {
		TemporaryRegister Register := RawRegister As TemporaryRegister
		
		if (Register.IsVariable) {
			IRVariable* Variable := Register.PointerValue As IRVariable*
			
			Variable->ReferenceCount -= 1
		}
		else {
			this->RegisterReferenceCounts[RawRegister] -= 1
		}
	}
	
	define i64 EmitInteger(i64 Value, i8 Size) {
		IRNode* Node := this->AppendNode(IR_LOAD_INTEGER)
		
		Node->Destination := this->AllocateRegister(Node)
		Node->SourceValue := Value
		Node->Size := Size
		
		return Node->Destination
	}
	define i64 EmitUnary(i32 Operator, i64 Operand, i8 Size) {
		IRNode* Node := this->AppendNode(IR_UNARY)
		
		Node->Destination := this->AllocateRegister(Node)
		Node->Operator := Operator
		Node->Operand := this->UseRegister(Operand)
		Node->Size := Size
		
		return Node->Destination
	}
	define i64 EmitBinary(i64 Left, i32 Operator, i64 Right, i8 Size) {
		IRNode* Node := this->AppendNode(IR_BINARY)
		
		Node->Destination := this->AllocateRegister(Node)
		Node->Operator := Operator
		Node~>Operands[0] := this->UseRegister(Left)
		Node~>Operands[1] := this->UseRegister(Right)
		Node->Size := Size
		
		return Node->Destination
	}
	define void EmitJump(i32 TargetLabel) {
		IRNode* Node := this->AppendNode(IR_JUMP)
		
		Node->JumpToBlock := TargetLabel
		
		this->SetLabel()
	}
	define void EmitConditional(i64 Condition, i8 ConditionSize, i32 TrueBlock, i32 FalseBlock) {
		IRNode* Node := this->AppendNode(IR_CONDITIONAL)
		
		Node->Condition := this->UseRegister(Condition)
		Node->Size := ConditionSize
		Node->TrueBlock := TrueBlock
		Node->FalseBlock := FalseBlock
		
		this->SetLabel()
	}
	define void EmitReturn(i64 ValueRegister, i8 ValueSize) {
		IRNode* Node := this->AppendNode(IR_RETURN)
		
		Node->Operand := this->UseRegister(ValueRegister)
		Node->Size := ValueSize
		
		this->SetLabel()
	}
	define void EmitMove(i64 Destination, i64 Source, i8 Size) {
		IRNode* Node := this->AppendNode(IR_MOVE)
		
		Node->Destination := Destination
		Node->Source := this->UseRegister(Source)
		Node->Size := Size
	}
	
	define i64 CompileExpression(ASTNode* Target) {
		i8 ResultSize := GetTypeSize(Target->ValueType) As i8
		
		if (Target->NodeType = NODE_TYPE_INTEGER) {
			return this->EmitInteger(Target->IntegerValue, ResultSize)
		}
		else if (Target->NodeType = NODE_TYPE_VARIABLE) {
			return this->FindOrAddVariable(Target->VariableValue)->ToRegister()
		}
		else if (Target->NodeType = NODE_TYPE_UNARY) {
			UnaryExpression* Unary := Target->UnaryNode
			
			i64 Operand := this->CompileExpression(Unary->Operand)
			
			return this->EmitUnary(Unary->Operator->IntegerValue As i32, Operand, ResultSize)
		}
		else if (Target->NodeType = NODE_TYPE_BINARY) {
			BinaryExpression* Binary := Target->BinaryNode
			
			if (Binary->Operator->IntegerValue = OPERATOR_COLON_EQUAL) {
				ASTNode* LeftNode := Binary->Left
				i64 NewValueRegister := this->CompileExpression(Binary->Right)
				
				if (LeftNode->NodeType = NODE_TYPE_VARIABLE) {
					i64 VariableRegister := this->FindOrAddVariable(LeftNode->VariableValue)->ToRegister()
					
					this->EmitMove(VariableRegister, NewValueRegister, 4)
				}
			}
			else {
				i64 Left := this->CompileExpression(Binary->Left)
				i64 Right := this->CompileExpression(Binary->Right)
				
				return this->EmitBinary(Left, Binary->Operator->IntegerValue As i32, Right, ResultSize)
			}
		}
		
		return 0
	}
	
	declare void CompileBlock(Block*)
	
	define void CompileIf(IfGroup* Target) {
		i32 BranchCount := Target->BranchCount
		i32 HasElse := (Target->ElseBranch) != 0
		
		i32 EndLabel := this->ReserveLabel()
		i32 NextBranch := 0
		
		for (i32 BranchIndex := 0, BranchIndex < BranchCount, BranchIndex += 1) {
			if (BranchIndex != 0) {
				this->SetLabel(NextBranch)
			}
			
			NextBranch := this->ReserveLabel()
			
			ASTNode* Condition := Target->Conditions[BranchIndex]
			
			if (Condition->NodeType = NODE_TYPE_NONE) {
				continue
			}
			
			i64 ConditionRegister := this->CompileExpression(Condition)
			i32 BodyLabel := this->ReserveLabel()
			
			this->EmitConditional(ConditionRegister, GetTypeSize(Condition->ValueType) As i8, BodyLabel, NextBranch)
			
			this->SetLabel(BodyLabel)
			
			this->CompileBlock(Target->Bodies[BranchIndex])
			
			this->EmitJump(EndLabel)
		}
		
		this->SetLabel(NextBranch)
		;this->EmitJump(EndLabel)
		
		if (Target->ElseBranch) {
			this->CompileBlock(Target->ElseBranch)
			this->EmitJump(EndLabel)
		}
		
		this->SetLabel(EndLabel)
		;this->EmitJump(this->BlockCount)
	}
	
	i32 CurrentLoopContinueLabel
	i32 CurrentLoopBreakLabel
	
	define i64 EnterLoop(i32 ContinueLabel, i32 BreakLabel) {
		LoopLables Result := this->CurrentLoopContinueLabel As LoopLables
		Result.BreakLabel := this->CurrentLoopBreakLabel
		
		this->CurrentLoopContinueLabel := ContinueLabel
		this->CurrentLoopBreakLabel := BreakLabel
		
		return Result As i64
	}
	define void ExitLoop(i64 PackedLoopState) {
		LoopLables LoopState := PackedLoopState As LoopLables
		
		this->CurrentLoopContinueLabel := LoopState.ContinueLabel
		this->CurrentLoopBreakLabel := LoopState.BreakLabel
	}
	
	define void CompileLoop(Block* LoopBody) {
		i32 StartLabel := this->ReserveLabel()
		i32 EndLabel := this->ReserveLabel()
		
		this->EmitJump(StartLabel)
		i64 LoopState := this->EnterLoop(StartLabel, EndLabel)
		
		this->SetLabel(StartLabel)
		
		this->CompileBlock(LoopBody)
		
		this->EmitJump(StartLabel)
		this->SetLabel(EndLabel)
		
		this->ExitLoop(LoopState)
	}
	define void CompileWhile(WhileLoop* WhileToCompile) {
		i32 StartLabel := this->ReserveLabel()
		i32 EndLabel := this->ReserveLabel()
		i32 BodyLabel := this->ReserveLabel()
		
		this->EmitJump(StartLabel)
		i64 LoopState := this->EnterLoop(StartLabel, EndLabel)
		
		this->SetLabel(StartLabel)
		
		ASTNode* Condition := WhileToCompile->Condition
		
		i64 ConditionRegister := this->CompileExpression(Condition)
		this->EmitConditional(ConditionRegister, GetTypeSize(Condition->ValueType) As i8, BodyLabel, EndLabel)
		
		this->SetLabel(BodyLabel)
		this->CompileBlock(WhileToCompile->Body)
		
		this->EmitJump(StartLabel)
		this->SetLabel(EndLabel)
		
		this->ExitLoop(LoopState)
	}
	
	define void CompileStatement(ASTNode* Target) {
		
		if (Target->NodeType = NODE_TYPE_EXPRESSION) {
			this->CompileExpression(Target->ExpressionStatement)
		}
		else if (Target->NodeType = NODE_TYPE_RETURN) {
			i64 ReturnValueRegister := this->CompileExpression(Target->ReturnExpression)
			this->EmitReturn(ReturnValueRegister, GetTypeSize(Target->ReturnExpression->ValueType) As i8)
		}
		else if (Target->NodeType = NODE_TYPE_IF) {
			this->CompileIf(Target->IfNode)
		}
		else if (Target->NodeType = NODE_TYPE_LOOP) {
			this->CompileLoop(Target->LoopBody)
		}
		else if (Target->NodeType = NODE_TYPE_WHILE) {
			this->CompileWhile(Target->WhileNode)
		}
		else if (Target->NodeType = NODE_TYPE_CONTINUEBREAK) {
			if (Target->IsContinue) {
				this->EmitJump(this->CurrentLoopContinueLabel)
			}
			else {
				this->EmitJump(this->CurrentLoopBreakLabel)
			}
		}
	}
	
	define void CompileBlock(Block* Target) {
		for (i32 Index := 0, Index < Target->StatementCount, Index++) {
			this->CompileStatement(Target->Statements[Index])
		}
	}
	
	define void CompileFunction(FunctionDefine* Function) {
		IRNode* RawNode := this->AppendNode(IR_FUNCTION)
		IRFunction* Node  := RawNode~>FunctionNode
		
		Node->ParameterCount := Function->ParameterCount
		Node->Parameters := Alloc(Node->ParameterCount * #i64)
		
		for (i32 Index := 0, Index < Function->ParameterCount, Index++) {
			i64 ParameterRegister := this->FindOrAddVariable(Function->Parameters[Index])->ToRegister()
			
			Node->Parameters[Index] := ParameterRegister
		}
		
		this->CompileBlock(Function->Body)
	}
	
	define IRNode* GetBlockNode(i32 Index, i32 Node) {
		return this->Nodes[this->BlockOffsets[Index] + Node]
	}
	
	define void EliminateJumpChainsInBlock(i32 Index) {
		i32 Start := this->BlockOffsets[Index]
		i32 Size := this->BlockSizes[Index]
		
		if (Size != 0) {
			IRNode* Terminator := this->Nodes[Start + Size - 1]
			
			if (Terminator->Kind = IR_JUMP) {
				IRNode* JumpToFirstNode := this->GetBlockNode(Terminator->JumpToBlock, 0)
				
				while (JumpToFirstNode->Kind = IR_JUMP) {
					Terminator->JumpToBlock := JumpToFirstNode->JumpToBlock
					JumpToFirstNode := this->GetBlockNode(Terminator->JumpToBlock, 0)
				}
			}
			else if (Terminator->Kind = IR_CONDITIONAL) {
				IRNode* TrueBlockFirstNode := this->GetBlockNode(Terminator->TrueBlock, 0)
				
				while (TrueBlockFirstNode->Kind = IR_JUMP) {
					Terminator->TrueBlock := TrueBlockFirstNode->JumpToBlock
					TrueBlockFirstNode := this->GetBlockNode(Terminator->TrueBlock, 0)
				}
				
				IRNode* FalseFirstNode := this->GetBlockNode(Terminator->FalseBlock, 0)
				
				while (FalseFirstNode->Kind = IR_JUMP) {
					Terminator->FalseBlock := FalseFirstNode->JumpToBlock
					FalseFirstNode := this->GetBlockNode(Terminator->FalseBlock, 0)
				}
			}
		}
	}
	define void EliminateJumpChains() {
		for (i32 Index := 0, Index < this->BlockCount, Index++) {
			this->EliminateJumpChainsInBlock(Index)
		}
	}
	define void EliminateDeadCode()  {
		for (i32 Index := this->NodeCount - 1, Index >= 0, Index--) {
			IRNode* NextNode := this->Nodes[Index]
			
			if (NextNode->Kind = IR_LOAD_INTEGER) {
				if (this->GetRegisterReferenceCount(NextNode->Destination) = 0) {
					NextNode->IsNotPresent := true
				}
			}
			else if (NextNode->Kind = IR_UNARY || NextNode->Kind = IR_MOVE) {
				if (this->GetRegisterReferenceCount(NextNode->Destination) = 0) {
					this->DestroyRegisterReference(NextNode->Operand)
					
					NextNode->IsNotPresent := true
				}
			}
			else if (NextNode->Kind = IR_BINARY) {
				if (this->GetRegisterReferenceCount(NextNode->Destination) = 0) {
					this->DestroyRegisterReference(NextNode~>Operands[0])
					this->DestroyRegisterReference(NextNode~>Operands[1])
					
					NextNode->IsNotPresent := true
				}
			}
		}
	}
	
	define IRNode* FindLastStore(i32 InBlock, i32 FromOffset, i64 ForVariable, i8 Force) {
		; Find the last node which stores a value in the given variable
		;  if Force, then any nodes which use the given variable as an operand will not abort the search
		; Since this is used for locating dead stores, this is very important, since
		;  1 store
		;  2 use
		;  3 store
		; would tell us that the value stored @1 can't be eliminated, since @2 uses it
		
		i32 Start := this->BlockOffsets[InBlock]
		i32 Size := this->BlockSizes[InBlock]
		
		for (i32 Index := FromOffset - 1, Index >= 0, Index--) {
			IRNode* NextNode := this->Nodes[Start + Index]
			
			if (NextNode->IsNotPresent) {
				continue
			}
			
			if (NextNode->IsInCategory(IR_HAS_DESTINATION)) {
				if (NextNode->Destination = ForVariable) {
					return NextNode
				}
				else {
					if (Force) {
						continue
					}
					
					if (NextNode->IsInCategory(IR_HAS_ONE_OPERAND)) {
						if (NextNode->Operand = ForVariable) {
							return null
						}
					}
					
					if (NextNode->IsInCategory(IR_HAS_TWO_OPERANDS)) {
						if (NextNode~>Operands[1] = ForVariable) {
							return null
						}
					}
				}
			}
		}
		
		return null
	}
	define IRNode* FindLastStore(i32 InBlock, i32 FromOffset, i64 ForVariable) {
		return this->FindLastStore(InBlock, FromOffset, ForVariable, false)
	}
	
	define i8 NodesAreEqual(i32 BlockIndex, i32 LeftIndex, i32 RightIndex) {
		IRNode* Left := this->GetBlockNode(BlockIndex, LeftIndex)
		IRNode* Right := this->GetBlockNode(BlockIndex, RightIndex)
		
		if (Left->Kind != Right->Kind) {
			return false
		}
		
		if (Left->Kind = IR_LOAD_INTEGER) {
			return Left->SourceValue = Right->SourceValue
		}
		
		;Print("NodesAreEqual {") Left->Print() Print("} == {") Right->Print() Print("}\n")
		
		i8 HasOneOperand  := Left->IsInCategory(IR_HAS_ONE_OPERAND)
		i8 HasTwoOperands := Left->IsInCategory(IR_HAS_TWO_OPERANDS)
		
		if (HasOneOperand) {
			IRNode* LeftLastStore  := this->FindLastStore(BlockIndex, LeftIndex, Left->Operand, true)
			IRNode* RightLastStore := this->FindLastStore(BlockIndex, RightIndex, Right->Operand, true)
			
			if (LeftLastStore = null || RightLastStore = null) {
				return false
			}
			
			i32 LeftOperand  := this->GetNodeIndex(LeftLastStore)
			i32 RightOperand := this->GetNodeIndex(RightLastStore)
			
			;Print("\tLO: %i, RO: %i\n", LeftOperand, RightOperand)
		
			if !(this->NodesAreEqual(BlockIndex, LeftOperand, RightOperand)) {
				return false
			}
			
			if (HasTwoOperands) {
				LeftOperand := this->GetNodeIndex(this->FindLastStore(BlockIndex, LeftIndex, Left~>Operands[1], true))
				RightOperand := this->GetNodeIndex(this->FindLastStore(BlockIndex, RightIndex, Right~>Operands[1], true))
				
				if !(this->NodesAreEqual(BlockIndex, LeftOperand, RightOperand)) {
					return false
				}
			}
		
			if (Left->Kind = IR_UNARY || Left->Kind = IR_BINARY) {
				if (Left->Operator != Right->Operator) {
					return false
				}
			}
			
			return true
		}
		else {
			return false
		}
	}
	
	define IRNode* FindNodeCopy(i32 BlockIndex, i32 Offset, i32 Target) {
		for (i32 Index := Offset - 1, Index >= 0, Index--) {
			if (this->NodesAreEqual(BlockIndex, Index, Target)) {
				IRNode* NextNode := this->GetBlockNode(BlockIndex, Index)
				
				if (this->FindLastStore(BlockIndex, Offset, NextNode->Destination) > NextNode) {
					continue
				}
				
				return NextNode
			}
		}
		
		return null
	}
	
	define void EliminateSomething() {
		for (i32 BlockIndex := 0, BlockIndex < this->BlockCount, BlockIndex++) {
			i32 Start := this->BlockOffsets[BlockIndex]
			i32 Size := this->BlockSizes[BlockIndex]
			
			for (i32 NodeIndex := Size - 1, NodeIndex >= 0, NodeIndex--) {
				i32 CurrentNodeIndex := Start + NodeIndex
				
				IRNode* CurrentNode := this->Nodes[CurrentNodeIndex]
				
				if (CurrentNode->IsInCategory(IR_HAS_ONE_OPERAND)) {
					IRNode* LastNode := this->FindNodeCopy(BlockIndex, NodeIndex, CurrentNodeIndex)
					
					if (LastNode != null) {
						if (CurrentNode->IsInCategory(IR_HAS_ONE_OPERAND)) {
							this->DestroyRegisterReference(CurrentNode~>Operands[0])
						}
						
						if (CurrentNode->IsInCategory(IR_HAS_TWO_OPERANDS)) {
							;IRPrint("asoidua %t\n", CurrentNode~>Operands[1])
							this->DestroyRegisterReference(CurrentNode~>Operands[1])
						}
						
						CurrentNode->Kind := IR_MOVE
						CurrentNode->Source := this->UseRegister(LastNode->Destination)
					}
				}
			}
		}
	}
	
	define void EliminateDeadStores() {
		for (i32 BlockIndex := 0, BlockIndex < this->BlockCount, BlockIndex++) {
			i32 Start := this->BlockOffsets[BlockIndex]
			i32 Size := this->BlockSizes[BlockIndex]
			
			for (i32 Index := 0, Index < Size, Index++) {
				IRNode* NextNode := this->Nodes[Start + Index]
				
				if (NextNode->IsNotPresent || !NextNode->IsInCategory(IR_HAS_DESTINATION)) {
					continue
				}
				
				TemporaryRegister Destination := NextNode->Destination As TemporaryRegister
				
				;IRPrint("EDS %x (%t) @%i [%i, %i]\n", Destination, Destination, Index, Start, Size)
				
				if (Destination.IsVariable) {
					;Print("Look for last\n")
					IRNode* LastStore := this->FindLastStore(BlockIndex, Index, NextNode->Destination)
					
					if (LastStore != null) {
						;Print("Found last %i\n", LastStore->Kind)
						
						LastStore->IsNotPresent := true
					}
				}
			}
		}
	}
	define void EliminateExtraMoves() {
		for (i32 BlockIndex := 0, BlockIndex < this->BlockCount, BlockIndex++) {
			i32 Start := this->BlockOffsets[BlockIndex]
			i32 Size := this->BlockSizes[BlockIndex]
			
			for (i32 Index := 0, Index < Size, Index++) {
				IRNode* NextNode := this->Nodes[Start + Index]
				
				if (NextNode->IsNotPresent) {
					continue
				}
				
				if (NextNode->Kind = IR_MOVE) {
					;IRPrint("Find last store for %t for ", NextNode->Operand) NextNode->Print() Print("\n")
					
					IRNode* MoveAssigner := this->FindLastStore(BlockIndex, Index, NextNode->Operand, true)
					
					;Print("  = %x {", MoveAssigner) MoveAssigner->Print() Print("}\n")
					;Print("  RC %i\n", this->GetRegisterReferenceCount(MoveAssigner->Destination))
					
					if (this->GetRegisterReferenceCount(MoveAssigner->Destination) = 1) {
						MoveAssigner->Destination := NextNode->Destination
						
						NextNode->IsNotPresent := true
					}
				}
			}
		}
	}
	
	define void Generate(i32 Index) {
		if (this->BlocksVisited[Index]) {
			return
		}
		
		this->BlocksVisited[Index] := true
		
		i32 Start := this->BlockOffsets[Index]
		i32 Size := this->BlockSizes[Index]
		
		IRNode* FirstNode := this->Nodes[Start]
		
		for (i32 NodeIndex := 0, NodeIndex < Size, NodeIndex++) {
			IRNode* NextNode := this->Nodes[Start + NodeIndex] 
			
			if (NextNode->IsNotPresent) {
				continue
			}
			
			;Print("Generate {") NextNode->Print() Print("}\n")
			
			if (NextNode->IsInCategory(IR_HAS_DESTINATION)) {
				this->Backend->MapRegister(NextNode->Destination)
			}
			
			i8 HasOneOperand  := NextNode->IsInCategory(IR_HAS_ONE_OPERAND)
			i8 HasTwoOperands := NextNode->IsInCategory(IR_HAS_TWO_OPERANDS)
			
			if (HasOneOperand) {
				this->DestroyRegisterReference(NextNode->Operand)
				
				if (HasTwoOperands) {
					this->DestroyRegisterReference(NextNode~>Operands[1])
				}
			}
			
			this->Backend->EmitNode(NextNode)
			
			if (HasOneOperand) {
				if (this->GetRegisterReferenceCount(NextNode->Operand) = 0) {
					this->Backend->UnMapRegister(NextNode->Operand)
				}
				
				if (HasTwoOperands) {
					if (this->GetRegisterReferenceCount(NextNode~>Operands[1]) = 0) {
						this->Backend->UnMapRegister(NextNode~>Operands[1])
					}
				}
			}
		}
		
		if (Size > 0) {
			NextNode := this->Nodes[Start + Size - 1]
			
			if (NextNode->Kind = IR_JUMP) {		
				this->Generate(NextNode->JumpToBlock)
			}
			else if (NextNode->Kind = IR_CONDITIONAL) {
				this->Generate(NextNode->TrueBlock)
				this->Generate(NextNode->FalseBlock)
			}
		}
		
		if (FirstNode->Is(IR_FUNCTION)) {
			this->Backend->EndFunction()
		}
	}
	define void Generate() {
		this->Generate(0)
	}
	
	define void PrintBlocks() {
		for (i32 BlockIndex := 0, BlockIndex < this->BlockCount, BlockIndex++) {
			i32 NextBlockStart := this->BlockOffsets[BlockIndex]
			i32 NextBlockSize := this->BlockSizes[BlockIndex]
			
			Print("l%i (%i, %i) {\n", BlockIndex, NextBlockStart, NextBlockSize)
			
			for (i32 NodeIndex := 0, NodeIndex < NextBlockSize, NodeIndex++) {
				IRNode* NextNode := this->Nodes[NextBlockStart + NodeIndex]
				
				Print(" %x %i\t", NextBlockStart + NodeIndex, NextNode->IsNotPresent)
				NextNode->Print()
				Print("\n")
			}
			
			Print("}\n")
		}
	}
	define void PrintIndent(i32 Depth, i8* String) {
		for (i32 Index := 0, Index < Depth, Index++) {
			Print("%s", String)
		}
	}
	define void PrintControlFlowGraph(i32 Index) {
		if (this->BlocksVisited[Index]) {
			return
		}
		
		this->BlocksVisited[Index] := true
		
		i32 Start := this->BlockOffsets[Index]
		i32 Size := this->BlockSizes[Index]
		
		Print("\tL%i [shape=box label=\"L%i:\\l", Index, Index)
		
		for (i32 NodeIndex := 0, NodeIndex < Size, NodeIndex++) {
			IRNode* NextNode := this->Nodes[Start + NodeIndex] 
			
			if (NextNode->IsNotPresent) {
				continue
			}
			
			Print("\t")
			NextNode->Print()
			Print("\\l")
		}
		
		Print("\"];\n")
		
		if (Size > 0) {
			NextNode := this->Nodes[Start + Size - 1]
			
			if (NextNode->Kind = IR_JUMP) {
				Print("\tL%i -> L%i;\n", Index, NextNode->JumpToBlock)
				
				this->PrintControlFlowGraph(NextNode->JumpToBlock)
			}
			else if (NextNode->Kind = IR_CONDITIONAL) {
				Print("\tL%i -> L%i [label=\"true\"];\n", Index, NextNode->TrueBlock)
				Print("\tL%i -> L%i [label=\"false\"];\n", Index, NextNode->FalseBlock)
				
				this->PrintControlFlowGraph(NextNode->TrueBlock)
				this->PrintControlFlowGraph(NextNode->FalseBlock)
			}
		}
	}
	define void PrintControlFlowGraph() {
		this->PrintControlFlowGraph(0)
	}
}

#Require "./src/lib/Debug.rlx"
#Require "./src/compiler/IRx64Gen.rlx"
#Require "./src/compiler/IRx64.rlx"

#Require "./src/compiler/PEBuilder.rlx"

define void Main(i64 ArgC, i8** ArgV) {
	GetArgs(&ArgC, &ArgV)
	
	if (ArgC != 2) {
		Print("No input file\n")
		Exit(1)
	}
	
	BuildConfig* Config := Alloc(#BuildConfig)
	
	Config->DumpInfo := 0
	Config->LineEnding := LINE_ENDING_DEFAULT
	
	windows {
		Config->OutputFormat := OUTPUT_PE
	}
	linux {
		Config->OutputFormat := OUTPUT_ELF
	}
	
	i8* InputFilePath := ArgV[1]
	
	i32 SourceLength := 0
	i16* Source := OpenAndRead(InputFilePath, &SourceLength)
	
	LexerState* Lexer := LexerState:New(Config, Source, SourceLength, AToS(InputFilePath))
	Config->Lexer := Lexer
	
	ParserState* Parser := ParserState:New(Config, Lexer)
	Parser->ParseProgram()
	
	IRToX64* x64Gen := IRToX64:New()
	IRCompilerState* IR := IRCompilerState:New(x64Gen->GetTraits())
	x64Gen->IR := IR
	
	IR->SetLabel()
	
	if (Parser->MainFunction = null) {
		Print("No main function\n")
		Exit(1)
	}
	
	IR->CompileFunction(Parser->MainFunction)
	
	;i32 Left := IR->EmitInteger(20, 4)
	;i32 Right := IR->EmitInteger(192, 4)
	;
	;i32 JumpToTrue := IR->ReserveLabel()
	;i32 JumpToFalse := IR->ReserveLabel()
	;
	;IR->EmitConditional(Left, 4, JumpToTrue, JumpToFalse)
	;
	;IR->EmitInteger(1, 1)
	;IR->EmitInteger(2, 1)
	;
	;IR->SetLabel(JumpToFalse)
	;Left := IR->EmitUnary('!', Left, 4)
	;
	;IR->SetLabel(JumpToTrue)
	;IR->EmitBinary(Left, '+', Right, 4)
	
	IR->EndBlock()
	
	;Print("Blocks:\n")
	IR->PrintBlocks()
	
	; Remove instructions inside of blocks
	IR->EliminateSomething()
	IR->EliminateDeadStores()
	IR->EliminateDeadCode()
	IR->EliminateExtraMoves()
	
	IR->CompactBlocks()
	
	; Remove entire blocks
	IR->EliminateJumpChains()
	
	IR->PrintBlocks()
	
	IR->Generate()
	x64Gen->PrintCode()
	
	PEBuilder* PE := BuildBuilder()
	
	PE->ImportFixupBase := x64Gen->Generator->CodeBuffer
	PE->PE->ImageBase := 0x4000_0000
	
	AddImport(PE, AToS("User32.dll"), AToS("MessageBoxA"), 300)
	
	AddData(PE, Parser~>Globals->NextOffset)
	AddCode(PE, x64Gen->Generator->CodeBuffer, x64Gen->Generator->CodeBufferIndex, 0)
	
	FinalizeBuilder(PE)
	
	FileDelete("out_ir.exe")
	
	i64 OutputFileHandle := FileOpen("out_ir.exe", FILE_READ | FILE_WRITE | FILE_CREATE_NEW)
	FileWrite(OutputFileHandle, PE->Buffer, PE->BufferSize)
	FileClose(OutputFileHandle)
	
	;Print("digraph CFG {\n")
	;IR->PrintControlFlowGraph()
	;Print("}\n")
	
	
}

;C := A + B
;
;load_variable.4, t1, a
;load_variable.4, t2, b
;binary.4, t3, t1, +, t2
;store_variable.4, c, t3
;
;C := A[B]
;
;load_variable.8, t1, a
;load_variable.4, t2, b
;load_index.2, t3, t1, t2
;store_variable.2, c, t3
;
;C := &A[B]
;
;load_variable.8, t1, a
;load_variable.4, t2, b
;load_index_address.2, t3, t1, t2
;store_variable.8, c, t3
;
;C := &A[B]->D
;
;load_variable.8, t1, a
;load_variable.4, t2, b
;load_index.8, t3, t1, t2
;load_integer.8, t4, 20
;load_offset_address.8, t5, t3, t4
;store_variable.8, c, t5
