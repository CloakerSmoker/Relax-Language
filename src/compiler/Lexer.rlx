struct Token {
	ErrorContext Context,
	
	union {
		void* Value,
		i64 IntegerValue,
		SafeWideString* StringValue
	},
	
	i8 Type
}

struct TokenizerState {
	BuildConfig* Config,
	SafeWideString* SourceFilePath,
	HashMap* IncludedFiles,
	
	i16* Source,
	i32 SourceIndex,
	i32 SourceLength,
	
	Token** Tokens,
	i32 TokenIndex,
	i32 MaxTokenIndex,
	i32 CurrentLineNumber,
	i16 CurrentLineStart,
	i32 TokenCapacity,
	
	HashMap* Keywords
}

i8 TOKEN_TYPE_EOF := 0
i8 TOKEN_TYPE_NONE := 100
i8 TOKEN_TYPE_OPERATOR := 1
i8 TOKEN_TYPE_IDENTIFIER := 2
i8 TOKEN_TYPE_INTEGER := 3
i8 TOKEN_TYPE_STRING := 4
i8 TOKEN_TYPE_PUNCTUATION := 5
i8 TOKEN_TYPE_KEYWORD := 6
i8 TOKEN_TYPE_DEBUG_CHARACTER := 7

/* TODO: Bit shifts need to be higher precedence than bitwise operations */

i8 OPERATOR_FIRST_ASSIGNMENT := 0
i8 PRECEDENCE_1 := 0
	i8 OPERATOR_COLON_EQUAL := 0
	i8 OPERATOR_PLUS_EQUAL := 1
	i8 OPERATOR_MINUS_EQUAL := 2
	i8 OPERATOR_STAR_EQUAL := 3
	i8 OPERATOR_SLASH_EQUAL := 4
	i8 OPERATOR_PERCENT_EQUAL := 5
	i8 OPERATOR_AND_EQUAL := 6
	i8 OPERATOR_OR_EQUAL := 7
	i8 OPERATOR_XOR_EQUAL  := 8
i8 OPERATOR_LAST_ASSIGNMENT := 8

i8 PRECEDENCE_2 := 9
i8 OPERATOR_FIRST_SHORT_CIRCUIT := 9
	i8 OPERATOR_LOGICAL_AND := 9
	i8 OPERATOR_LOGICAL_OR := 10
i8 OPERATOR_LAST_SHORT_CIRCUIT := 10

i8 PRECEDENCE_3 := 11
i8 OPERATOR_FIRST_COMPARISON := 11
	i8 OPERATOR_EQUAL := 11
	i8 OPERATOR_BANG_EQUAL := 12
	i8 OPERATOR_LESS := 13
	i8 OPERATOR_LESS_EQAUL := 14
	i8 OPERATOR_GREATER := 15
	i8 OPERATOR_GREATER_EQAUL := 16
i8 OPERATOR_LAST_COMPARISON := 16

i8 PRECEDENCE_4 := 17
i8 OPERATOR_AS := 17

/* Precedence level 5 is for prefix operators *& */

i8 PRECEDENCE_6 := 18
i8 OPERATOR_PLUS := 18
i8 OPERATOR_MINUS := 19

i8 PRECEDENCE_7 := 20
i8 OPERATOR_STAR := 20
i8 OPERATOR_SLASH := 21
i8 OPERATOR_PERCENT := 22

i8 PRECEDENCE_8 := 23
i8 OPERATOR_AND := 23
i8 OPERATOR_OR := 24
i8 OPERATOR_XOR := 25

i8 PRECEDENCE_9 := 26
i8 OPERATOR_LESS_LESS := 26
i8 OPERATOR_GREATER_GREATER := 27

/* Precedence level 11 is for prefix operators !-~ */

i8 PRECEDENCE_10 := 28
i8 OPERATOR_BANG := 28
i8 OPERATOR_TILDE := 29

i8 PRECEDENCE_12 := 30
i8 OPERATOR_OPEN_BRACKET := 30

i8 PRECEDENCE_13 := 31
i8 OPERATOR_DOT := 31
i8 OPERATOR_MINUS_GREATER := 32
i8 OPERATOR_TILDE_GREATER := 33

i8 OPERATOR_COLON := 34
i8 OPERATOR_POUND := 35


i8 PUNCTUATION_OPEN_PAREN := 0
i8 PUNCTUATION_CLOSE_PAREN := 1

i8 PUNCTUATION_OPEN_BRACE := 2
i8 PUNCTUATION_CLOSE_BRACE := 3

i8 PUNCTUATION_CLOSE_BRACKET := 4

i8 PUNCTUATION_COMMA := 5
i8 PUNCTUATION_AT := 6


i8 KEYWORD_DECLARE := 0
i8 KEYWORD_DEFINE := 1
i8 KEYWORD_DLLIMPORT := 2

i8 KEYWORD_IF := 3
i8 KEYWORD_ELSE := 4

i8 KEYWORD_FOR := 5
i8 KEYWORD_WHILE := 6
i8 KEYWORD_LOOP := 7

i8 KEYWORD_CONTINUE := 8
i8 KEYWORD_BREAK := 9

i8 KEYWORD_STRUCT := 10
i8 KEYWORD_UNION := 11
i8 KEYWORD_BITS := 12
i8 KEYWORD_UNALIGNED := 13

i8 KEYWORD_RETURN := 14

i8 KEYWORD_WINDOWS := 15
i8 KEYWORD_LINUX := 16

i8 KEYWORD_ASSEMBLY := 17

define TokenizerState* NewTokenizer(BuildConfig* Config, SafeWideString* SourceFilePath, HashMap* IncludedFiles, i16* Source, i32 SourceLength) {
	TokenizerState* NewState := Alloc(#TokenizerState) As TokenizerState*
	
	NewState->Config := Config
	
	NewState->SourceFilePath := SourceFilePath
	
	NewState->IncludedFiles := IncludedFiles
	
	NewState->Source := Source
	NewState->SourceLength := SourceLength
	
	NewState->Tokens := Alloc(8 * 300) As Token**
	
	NewState->SourceIndex := 0
	NewState->TokenIndex := 0
	NewState->MaxTokenIndex := 0
	NewState->CurrentLineNumber := 1
	
	HashMap* K := NewHashMap()
	NewState->Keywords := K
	
	K->IgnoreCase := true
	
	HashMapASet(K, "declare", 	KEYWORD_DECLARE)
	HashMapASet(K, "define", 	KEYWORD_DEFINE)
	HashMapASet(K, "dllimport", KEYWORD_DLLIMPORT)
	HashMapASet(K, "if", 		KEYWORD_IF)
	HashMapASet(K, "else", 		KEYWORD_ELSE)
	HashMapASet(K, "for", 		KEYWORD_FOR)
	HashMapASet(K, "while",		KEYWORD_WHILE)
	HashMapASet(K, "loop", 		KEYWORD_LOOP)
	HashMapASet(K, "continue", 	KEYWORD_CONTINUE)
	HashMapASet(K, "break", 	KEYWORD_BREAK)
	HashMapASet(K, "struct", 	KEYWORD_STRUCT)
	HashMapASet(K, "return", 	KEYWORD_RETURN)
	HashMapASet(K, "union", 	KEYWORD_UNION)
	HashMapASet(K, "bits", 		KEYWORD_BITS)
	HashMapASet(K, "unaligned", KEYWORD_UNALIGNED)
	HashMapASet(K, "windows", 	KEYWORD_WINDOWS)
	HashMapASet(K, "linux", 	KEYWORD_LINUX)
	HashMapASet(K, "asm", 		KEYWORD_ASSEMBLY)
	
	return NewState
}
define TokenizerState* NewTokenizer(BuildConfig* Config, SafeWideString* SourceFilePath, i16* Source, i32 SourceLength) {
	return NewTokenizer(Config, SourceFilePath, NewHashMap(), Source, SourceLength)
}

define Token* PushToken(TokenizerState* tState, void* Value, i16* Source, i32 PositionInSource, i32 LengthInSource, i8 Type) {
	/* Ensure the token buffer has space for another token */
	
	if (tState->MaxTokenIndex >= tState->TokenCapacity) {
		tState->TokenCapacity += 300
		
		tState->Tokens := ReAlloc(tState->Tokens, 8 * (tState->TokenCapacity)) As Token**
	}
	
	i32 Index := tState->MaxTokenIndex
	
	Token* OutputToken := Alloc(#Token) As Token*
	
	/* Insert the token into the token list */
	(tState->Tokens)[Index] := OutputToken
	
	tState->MaxTokenIndex += 1
	
	/* Populate the token */
	OutputToken->Type := Type
	OutputToken->Value := Value
	
	OutputToken->Context.SourceFilePath := tState->SourceFilePath
	OutputToken->Context.LineNumber := tState->CurrentLineNumber
	OutputToken->Context.Source := Source
	OutputToken->Context.PositionInSource := PositionInSource
	OutputToken->Context.LengthInSource := LengthInSource
	
	return OutputToken
}
define Token* MakeToken(TokenizerState* tState, i32 PositionInSource, i8 Type, void* Value) {
	return PushToken(tState, Value, tState->Source, PositionInSource, (tState->SourceIndex) - PositionInSource, Type)
}
define Token* MakeToken(TokenizerState* tState, i32 PositionInSource, i8 Type, i64 Value) {
	return PushToken(tState, Value As void*, tState->Source, PositionInSource, (tState->SourceIndex) - PositionInSource, Type)
}

define void* MakeSafeStringToken(TokenizerState* tState, i32 StartingIndex) {
	/* Makes a SafeWideString from tState and returns it as a void* to fit into Token->Value */
	
	SafeWideString* NewSafeString := AllocateNewSafeString()

	NewSafeString->Length := tState->SourceIndex - StartingIndex
	NewSafeString->Buffer := tState->Source + (StartingIndex * 2)

	return NewSafeString As void*
}

/* Both the Token and ASTNode struct have the same first 2 fields as ErrorContext, making them safe to cast down to
	ErrorContext for PrintErrorHeader calls.
 */

define void Error(Token* AtToken, i8* Message) {
	SwapOutputStream()
	
	PrettyError(AtToken As ErrorContext*, Message, Red | Bright)
	Exit(1)
}

define void TokenError(Token* AtToken, i8* Message) {
	ContextError(AtToken~>Context, Message)
}

define i16 PeekNextCharacter(TokenizerState* tState) {
	return Lower((tState->Source)[tState->SourceIndex])
}
define void Backtrack(TokenizerState* tState) {
	i16 ThisCharacter := PeekNextCharacter(tState)
	
	tState->SourceIndex -= 1
	
	i32 LastCharacter := PeekNextCharacter(tState)
	
	if (LastCharacter = 10) {
		tState->CurrentLineNumber -= 1
	}
}
define i16 GetNextCharacter(TokenizerState* tState) {
	i16 NextCharacter := PeekNextCharacter(tState)
	tState->SourceIndex += 1
	
	if (NextCharacter = 10) {
		tState->CurrentLineNumber += 1
	}
	
	return NextCharacter
}
define i16 GetNextCharacterRaw(TokenizerState* tState) {
	i16 Result := (tState->Source)[tState->SourceIndex]
	
	GetNextCharacter(tState)
	
	return Result
}
define i8 NextCharacterMatches(TokenizerState* tState, i8 CharacterToCheck) {
	if (PeekNextCharacter(tState) = CharacterToCheck) {
		GetNextCharacter(tState)
		return 1
	}
	
	return 0
}

define i8 TokenizerAtEnd(TokenizerState* tState) {
	return (tState->SourceIndex) > (tState->SourceLength)
}

define i64 TokenizeNumber(TokenizerState* tState, i16 NextCharacter, i32 StartingIndex, i8* Success) {
	i8 NumberIsHex := false
	
	if (NextCharacterMatches(tState, 'x')) {
		/* If NextCharacter = 0 and Next-NextCharacter = 'x' */
		NumberIsHex := true
		
		NextCharacter := PeekNextCharacter(tState)
		
		/* Gather all hex characters */
		while (IsHex(NextCharacter) && (!TokenizerAtEnd(tState))) {
			NextCharacter := GetNextCharacter(tState)
		}
	}
	else {
		/* Number is not hex, gather all decimal characters */
		
		while (IsNumeric(NextCharacter) && (!TokenizerAtEnd(tState))) {
			NextCharacter := GetNextCharacter(tState)
		}
	}
	
	if !(TokenizerAtEnd(tState)) {
		Backtrack(tState)
	}
	
	/* Convert the number to string which we can then parse into a number */
	SafeWideString* AsString := MakeSafeStringToken(tState, StartingIndex + (NumberIsHex * 2)) As SafeWideString*
	
	i64 Result := WToI(AsString->Buffer, AsString->Length, 10 + (6 * NumberIsHex), Success)
	
	FreeSafeString(AsString)
	
	return Result
}

define Token* GetNextToken(TokenizerState* tState) {
	/* Gathers a single token, and sets/returns CurrentToken */
	
	i32 Index := tState->TokenIndex
	tState->TokenIndex += 1
	
	if (Index < tState->MaxTokenIndex) {
		/* If we already have a token in the token list for this index, return it instead */
		
		/* 
			AWrite("Found cached version of token[")
			IWrite(Index)
			AWrite("] @")
			IWriteLine(((tState->Tokens)[Index]) as i64)
		 */
		
		return (tState->Tokens)[Index]
	}
	
	Token* ErrorToken := 0
	
	while (!TokenizerAtEnd(tState)) {
		i32 StartingIndex := tState->SourceIndex
		i16 NextCharacter := GetNextCharacter(tState)

		if (PeekNextCharacter(tState) = '=') {
			/* If the next character is '=', check for the X= operators first */
			
			GetNextCharacter(tState)
			
			i8 NewType := TOKEN_TYPE_NONE
			
			if (NextCharacter = ':') {
				NewType := OPERATOR_COLON_EQUAL
			}
			else if (NextCharacter = '+') {
				NewType := OPERATOR_PLUS_EQUAL
			}
			else if (NextCharacter = '-') {
				NewType := OPERATOR_MINUS_EQUAL
			}
			else if (NextCharacter = '*') {
				NewType := OPERATOR_STAR_EQUAL
			}
			else if (NextCharacter = '/') {
				NewType := OPERATOR_SLASH_EQUAL
			}
			else if (NextCharacter = '%') {
				NewType := OPERATOR_PERCENT_EQUAL
			}
			else if (NextCharacter = '&') {
				NewType := OPERATOR_AND_EQUAL
			}
			else if (NextCharacter = '|') {
				NewType := OPERATOR_OR_EQUAL
			}
			else if (NextCharacter = '^') {
				NewType := OPERATOR_XOR_EQUAL
			}
			else if (NextCharacter = '<') {
				NewType := OPERATOR_LESS_EQAUL
			}
			else if (NextCharacter = '>') {
				NewType := OPERATOR_GREATER_EQAUL
			}
			else if (NextCharacter = '!') {
				NewType := OPERATOR_BANG_EQUAL
			}
			else {
				/* If we didn't match and X= operator, backtrack and continue like normal */
				Backtrack(tState)
			}
			
			if (NewType != TOKEN_TYPE_NONE) {
				/* But if we did match an X=, return the matched operator */
				return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, NewType)
			}
		}
		
		if (NextCharacter = ''') {
			/* If the next character is an open single quote, then consume a single character as an integer */
			
			i64 LiteralValue := 0
			i8* LiteralValueBytes := (&LiteralValue) As i8*
			
			for (i32 LiteralIndex := 0, LiteralIndex < 8, LiteralIndex += 1) {
				i8 LiteralCharacter := GetNextCharacterRaw(tState)				
				
				LiteralValueBytes[LiteralIndex] := LiteralCharacter
				
				if (PeekNextCharacter(tState) = ''') {
					break
				}
			}
			
			NextCharacter := GetNextCharacter(tState)
			
			if (NextCharacter != ''') {
				/* And make sure there's a close single quote */
				ErrorToken := MakeToken(tState, StartingIndex, TOKEN_TYPE_DEBUG_CHARACTER, NextCharacter)
				TokenError(ErrorToken, "Expected close single quote for character constant")
			}
			
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_INTEGER, LiteralValue)
		}
		else if (NextCharacter = '=') {
			/* Manually compare for all of the operators */
			
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_EQUAL)
		}
		else if (NextCharacter = '+') {
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_PLUS)
		}
		else if (NextCharacter = '-') {
			if (NextCharacterMatches(tState, '>')) {
				return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_MINUS_GREATER)
			}
			
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_MINUS)
		}
		else if (NextCharacter = '~') {
			if (NextCharacterMatches(tState, '>')) {
				return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_TILDE_GREATER)
			}
			
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_TILDE)
		}
		else if (NextCharacter = '*') {
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_STAR)
		}
		else if (NextCharacter = ';') {
			i32 StartingLine := tState->CurrentLineNumber
			
			while (tState->CurrentLineNumber = StartingLine && !TokenizerAtEnd(tState)) {
				GetNextCharacter(tState)
			}
		}
		else if (NextCharacter = '/') {
			if (NextCharacterMatches(tState, '*')) {
				i8 Depth := 1
				
				loop {
					NextCharacter := GetNextCharacter(tState)
					
					if (NextCharacter = '*' && PeekNextCharacter(tState) = '/') {
						GetNextCharacter(tState)
						
						Depth -= 1
					}
					else if (NextCharacter = '/' && PeekNextCharacter(tState) = '*') {
						GetNextCharacter(tState)
						
						Depth += 1
					}
					
					if (Depth = 0) {
						break
					}
					
					if (TokenizerAtEnd(tState)) {
						ErrorToken := MakeToken(tState, StartingIndex, TOKEN_TYPE_DEBUG_CHARACTER, '/')
						TokenError(ErrorToken, "Expected closing comment character")
					}
				}
				
				continue
			}
			
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_SLASH)
		}
		else if (NextCharacter = '%') {
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_PERCENT)
		}
		else if (NextCharacter = '.') {
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_DOT)
		}
		else if (NextCharacter = '<') {
			if (NextCharacterMatches(tState, '<')) {
				return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_LESS_LESS)
			}
			
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_LESS)
		}
		else if (NextCharacter = '>') {
			if (NextCharacterMatches(tState, '>')) {
				return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_GREATER_GREATER)
			}
			
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_GREATER)
		}
		else if (NextCharacter = '^') {
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_XOR)
		}
		else if (NextCharacter = '&') {
			if (NextCharacterMatches(tState, '&')) {
				return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_LOGICAL_AND)
			}
			
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_AND)
		}
		else if (NextCharacter = '|') {
			if (NextCharacterMatches(tState, '|')) {
				return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_LOGICAL_OR)
			}
			
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_OR)
		}
		else if (NextCharacter = '!') {
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_BANG)
		}
		else if (NextCharacter = ':') {
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_COLON)
		}
		else if (NextCharacter = '(') {
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_PAREN)
		}
		else if (NextCharacter = ')') {
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_PAREN)
		}
		else if (NextCharacter = '{') {
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_OPEN_BRACE)
		}
		else if (NextCharacter = '}') {
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACE)
		}
		else if (NextCharacter = '[') {
			/* [ Is an operator in order for Array->A.B[Something] to parse correctly */
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_OPEN_BRACKET)
		}
		else if (NextCharacter = ']') {
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_CLOSE_BRACKET)
		}
		else if (NextCharacter = ',') {
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_COMMA)
		}
		else if (NextCharacter = '@') {
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_PUNCTUATION, PUNCTUATION_AT)
		}
		else if (NextCharacter = '"') {
			NextCharacter := 0
			
			/* Consume all characters in the string */
			
			while ((NextCharacter != '"') && (!TokenizerAtEnd(tState))) {
				NextCharacter := GetNextCharacter(tState)
			}
			
			if (TokenizerAtEnd(tState)) {
				ErrorToken := MakeToken(tState, StartingIndex, TOKEN_TYPE_DEBUG_CHARACTER, '"')
				TokenError(ErrorToken, "Expected close quote before EOF")
			}
			
			SafeWideString* FoundString := MakeSafeStringToken(tState, StartingIndex + 1) As SafeWideString*
			FoundString->Length -= 1
			
			/* And return the string as a TOKEN_TYPE_STRING */
			return MakeToken(tState, StartingIndex, TOKEN_TYPE_STRING, FoundString As void*)
		}
		else if (IsNumeric(NextCharacter)) {
			i8 NumberIsValid := false
			
			ErrorToken := MakeToken(tState, StartingIndex, TOKEN_TYPE_INTEGER, TokenizeNumber(tState, NextCharacter, StartingIndex, &NumberIsValid))
			
			if !(NumberIsValid) {
				TokenError(ErrorToken, "Invalid numeric literal")
			}
			
			return ErrorToken
		}
		else if (IsAlpha(NextCharacter) || NextCharacter = '_') {
			if (NextCharacter = 'a') {
				if (GetNextCharacter(tState) = 's' && IsWhiteSpace(PeekNextCharacter(tState))) {
					return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_AS)
				}
				
				Backtrack(tState)
			}
			
			while (IsAlphaNumeric(NextCharacter)) {
				if (TokenizerAtEnd(tState)) {
					break
				}
				
				NextCharacter := GetNextCharacter(tState)
			}
			
			if !(TokenizerAtEnd(tState)) {
				Backtrack(tState)
			}
			
			/* Gather all alphanumeric characters in a row */
			
			SafeWideString* TokenText := MakeSafeStringToken(tState, StartingIndex) As SafeWideString*
			
			HashMapElement* FoundKeyword := HashMapGetValue(tState->Keywords, TokenText)
			
			if (FoundKeyword) {
				/* If the characters make up a keyword, then free the string and make the keyword token */
				FreeSafeString(TokenText)
				return MakeToken(tState, StartingIndex, TOKEN_TYPE_KEYWORD, FoundKeyword->Value As i8)
			}
			else {
				/* Otherwise, make an identifier token */
				return MakeToken(tState, StartingIndex, TOKEN_TYPE_IDENTIFIER, TokenText As void*)
			}
		}
		else if (NextCharacter = '#') {
			NextCharacter := PeekNextCharacter(tState)
			
			while (IsAlphaNumeric(NextCharacter) && (!TokenizerAtEnd(tState))) {
				NextCharacter := GetNextCharacter(tState)
			}

			if !(TokenizerAtEnd(tState)) {
				Backtrack(tState)
			}
			
			SafeWideString* DirectiveText := MakeSafeStringToken(tState, StartingIndex + 1) As SafeWideString*
			
			i8 IsRequire := SafeStringEqualsAString(DirectiveText, "require")
			
			if (IsRequire || SafeStringEqualsAString(DirectiveText, "include")) {
				StartingIndex := tState->SourceIndex + 1
				
				GetNextCharacter(tState)
				
				NextCharacter := PeekNextCharacter(tState)
				
				i8 ExpectCloseQuote := false
				
				if (NextCharacter = '"') {
					GetNextCharacter(tState)
					NextCharacter := PeekNextCharacter(tState)
					
					StartingIndex += ExpectCloseQuote := true
				}
				
				while (IsPath(NextCharacter, ExpectCloseQuote)) {
					NextCharacter := GetNextCharacter(tState)
				}
				
				if !(TokenizerAtEnd(tState)) {
					Backtrack(tState)
				}
				
				SafeWideString* IncludePath := MakeSafeStringToken(tState, StartingIndex) As SafeWideString*
				
				if (ExpectCloseQuote) {
					if !(NextCharacterMatches(tState, '"')) {
						ErrorToken := MakeToken(tState, StartingIndex, TOKEN_TYPE_DEBUG_CHARACTER, PeekNextCharacter(tState))
						TokenError(ErrorToken, "Expected closing quote for include/require path.")
					}
				}
				
				if (IsRequire) {
					HashMapElement* FoundFile := HashMapGetValue(tState->IncludedFiles, IncludePath)
					
					if (FoundFile) {
						continue
					}
				}
				
				HashMapAddValue(tState->IncludedFiles, IncludePath, true)
				
				Print("Including file: '")
				PrintSafeString(IncludePath)
				Print("'\n")
				
				i32 EndIndex := IncludePath->Length
				i16 OldFollowingCharacter := (IncludePath->Buffer)[EndIndex]
				
				IncludePath->Buffer[EndIndex] := 0 /* Insert a null terminator into the source */
				
				i32 IncludeFileSize := 0
				i16* IncludeFileText := OpenAndRead(WToA(IncludePath->Buffer), &IncludeFileSize)
				
				IncludePath->Buffer[EndIndex] := OldFollowingCharacter /* Restore the old character */
				
				TokenizerState* IncludeTokenizer := NewTokenizer(tState->Config, IncludePath, tState->IncludedFiles, IncludeFileText, IncludeFileSize)
				
				loop {
					Token* NextIncludeToken := GetNextToken(IncludeTokenizer)
					
					if (NextIncludeToken->Type = TOKEN_TYPE_EOF) {
						break
					}
					
					Token* IncludeToken := PushToken(tState, NextIncludeToken->Value, 0 As i16*, 0, 0, NextIncludeToken->Type)
					CopyContext(NextIncludeToken~>Context, IncludeToken~>Context)
				}
				
				; Print("Done including file\n")
				
				tState->TokenIndex -= 1
				
				return GetNextToken(tState)
			}
			else if (SafeStringEqualsAString(DirectiveText, "ImageBase")) {
				if !(IsWhiteSpace(GetNextCharacter(tState))) {
					Print("Expected whitespace after #ImageBase.")
					Exit(1)
				}
				
				i8 ImageBaseValid := false
				
				NextCharacter := GetNextCharacter(tState)
				
				i64 NewImageBase := TokenizeNumber(tState, NextCharacter, StartingIndex + 11, &ImageBaseValid)
				
				if !(ImageBaseValid && NewImageBase) {
					ErrorToken := MakeToken(tState, StartingIndex + 11, TOKEN_TYPE_DEBUG_CHARACTER, '#')
					TokenError(ErrorToken, "Invalid Image Base")
				}
				
				tState->Config->ImageBase := NewImageBase
				
				continue
			}
			else {
				tState->SourceIndex := StartingIndex + 1
				
				return MakeToken(tState, StartingIndex, TOKEN_TYPE_OPERATOR, OPERATOR_POUND)
			}
		}
		else if (NextCharacter = 0 || IsWhiteSpace(NextCharacter)) {
			/* Ignore null characters and whitespace */
			
			continue
		}
		else {
			ErrorToken := MakeToken(tState, StartingIndex, TOKEN_TYPE_DEBUG_CHARACTER, NextCharacter)
			TokenError(ErrorToken, "Unexpected character")
		}
	}
	
	return MakeToken(tState, tState->SourceLength, TOKEN_TYPE_EOF, 0)
}