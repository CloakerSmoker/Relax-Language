DllImport i64 GetCurrentProcess() {Kernel32.dll, GetCurrentProcess}
DllImport void TerminateProcess(i64, i64) {Kernel32.dll, TerminateProcess}

define void TerminateAfterUnhandledException(i64 Code) {
	windows {
		TerminateProcess(GetCurrentProcess(), Code)
	}
	linux {
		syscall:(60, Code)
	}
}

#Require "$/ExceptionBase.rlx"

struct WindowsExceptionRecord {
	i32 ExceptionCode,
	i32 ExceptionFlag,
	WindowsExceptionRecord* ExceptionRecord,
	void* ExceptionAddress,
	i32 ExceptionParameters
}

struct WindowsContextRecord {
    i64 P1Home,
    i64 P2Home,
    i64 P3Home,
    i64 P4Home,
    i64 P5Home,
    i64 P6Home,

    i32 ContextFlags,
    i32 MxCsr,

    i16 CS,
    i16 DS,
    i16 ES,
    i16 FS,
    i16 GS,
    i16 SS,
    i32 EFlags,

    i64 DR0,
    i64 DR1,
    i64 DR2,
    i64 DR3,
    i64 DR6,
    i64 DR7,

    i64 RAX,
    i64 RCX,
    i64 RDX,
    i64 RBX,
    i64* RSP,
    i64* RBP,
    i64 RSI,
    i64 RDI,
    i64 R8,
    i64 R9,
    i64 R10,
    i64 R11,
    i64 R12,
    i64 R13,
    i64 R14,
    i64 R15,
	
	void* RIP
}

struct WindowsExceptionPointers {
	WindowsExceptionRecord* ExceptionRecord,
	WindowsContextRecord* ContextRecord
}

define void PushX64Volitile() asm {
	pop, rax
	push, rbx
	push, rdi
	push, rsi
	push, r12
	push, r13
	push, r14
	push, r15
	jmp, rax
}
define void PopX64Volitile() asm {
	pop, rax
	pop, r15
	pop, r14
	pop, r13
	pop, r12
	pop, rsi
	pop, rdi
	pop, rbx
	jmp, rax
}

define i32 WindowsExceptionFilter(WindowsExceptionPointers* ExceptionInfo) x64 {
	PushX64Volitile()
	
	WindowsContextRecord* Context := ExceptionInfo->ContextRecord
	StackFrame* Handler := FindHandler(Context->RBP)
	
	Context->RDI := ExceptionInfo->ExceptionRecord->ExceptionCode
	
	if (Handler = null) {
		Context->RIP := &CallUnhandledExceptionHandler
	}
	else {
		Context->RBP := Handler As i64*
		Context->RSP := (Handler->LastFrame - 1) As i64*
		Context->RIP := Handler->ReturnAddress
	}
	
	PopX64Volitile()
	
	return -1
}

struct SigInfo {
	i32 SignalNumber
	i32 ErrorNumber
	i32 SignalCode
	i32 TrapNumber
	
	void* Address
}

struct SigContext {
	i64 R8
	i64 R9
	i64 R10
	i64 R11
	i64 R12
	i64 R13
	i64 R14
	i64 R15
	i64 RDI
	i64 RSI
	i64* RBP
	i64 RBX
	i64 RDX
	i64 RAX
	i64 RCX
	i64* RSP
	void* RIP
	i64 RFlags
}

struct SigUserContext {
	i64 Flags
	i64 linked
	i64 StackPointer
	i64 StackFlags
	i64 StackSize
	SigContext Registers
}

void* SIG_DEFAULT := 0 As void*
void* SIG_IGNORE := 1 As void*

i32 SA_SIGINFO := 0x04
i32 SA_RESTORER := 0x400_0000

struct SigAction {
	void* Handler
	i64 Flags
	void* Restorer
	i64[8] Mask
}

define void SigRestorer() asm {
	mov, rax, 15
	syscall
}

define void SigHandler(i32 SignalNumber, SigInfo* Info, SigUserContext* UserContext) {
	SigContext* Context := UserContext~>Registers
	
	StackFrame* Handler := FindHandler(Context->RBP)
	
	Context->RDI := Info->SignalNumber
	
	if (Handler = null) {
		Context->RIP := &CallUnhandledExceptionHandler
	}
	else {
		Context->RBP := Handler As i64*
		Context->RSP := (Handler->LastFrame - 1) As i64*
		Context->RIP := Handler->ReturnAddress
	}
}

SigAction SignalToExceptionHandler {
	Handler: &SigHandler, 
	Restorer: &SigRestorer, 
	Flags: SA_RESTORER | SA_SIGINFO
}

i32 SIGILL  := 4
i32 SIGBUS  := 7
i32 SIGFPE  := 8
i32 SIGSEGV := 11

DllImport i8 SetErrorMode(i32) {Kernel32.dll, SetErrorMode}
DllImport void* SetUnhandledExceptionFilter(void*) {Kernel32.dll, SetUnhandledExceptionFilter}
DllImport void* AddVectoredExceptionHandler(i32, void*) {Kernel32.dll, AddVectoredExceptionHandler}

define void* SetupExceptionTranslation() {
	windows {
		SetErrorMode(1)
		
		SetUnhandledExceptionFilter(&WindowsExceptionFilter)
		AddVectoredExceptionHandler(1, &WindowsExceptionFilter)
	}
	linux {
		syscall:(13, SIGILL, &SignalToExceptionHandler, null, 8)
		syscall:(13, SIGBUS, &SignalToExceptionHandler, null, 8)
		syscall:(13, SIGFPE, &SignalToExceptionHandler, null, 8)
		syscall:(13, SIGSEGV, &SignalToExceptionHandler, null, 8)
	}
	
	return null
}

void* DummyNameForExceptionTranslation := SetupExceptionTranslation()