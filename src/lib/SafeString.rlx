#Require ./src/lib/Memory.rlx
#Require ./src/lib/String.rlx
#Require ./src/lib/Console.rlx

struct SafeWideString {
	i32 Length,
	i16* Buffer
	
	define void Free() {
		Free(this->Buffer)
	}
	define i8 ASCIICharAt(i32 Index) {
		return this->Buffer[Index] As i8
	}
	define void Print() {
		for (i32 Index := 0, Index < this->Length, Index += 1) {
			PrintCharacter(this->ASCIICharAt(Index))
		}
	}
	define void PrintLine() {
		this->Print()
		Print("\n")
	}
}

define SafeWideString* AllocateNewSafeString() {
	return Alloc(#SafeWideString) As SafeWideString*
}
define void FreeSafeString(SafeWideString* StringToFree) {
	Free(StringToFree As void*)
}

define SafeWideString* AToS(i8* SourceString) {
	/* Converts an ASCII string to a SafeWideString (without freeing anything ever) */
	
	SafeWideString* NewString := AllocateNewSafeString()
	
	i32 Length := StringLength(SourceString)
	
	NewString->Buffer := AToW(SourceString, Length)
	NewString->Length := Length
	
	return NewString
}

define i8 SafeStringEqualsAString(SafeWideString* StringOne, i8* StringTwo) {
	/* Compares a SafeWideString and i8* ASCII string */

	i32 Index := 0
	
	loop {
		i16 Left := Lower(StringOne->Buffer[Index])
		i16 Right := Lower(StringTwo[Index])
		
		if (Index >= StringOne->Length) {
			/* Handle reaching the end of the safe string */
			
			if (Right = 0) {
				/* If the AString has also ended, then they are equal */
				return true
			}
			else {
				/* Otherwise, they aren't equal */
				return false
			}
		}
		else if (Right = 0) {
			/* If the AString ends before the SafeWideString, then they are not equal */
			return false
		}
		
		if (Left != Right) {
			return false
		}
		
		Index += 1
	}
}

define void PrintSafeString(SafeWideString* StringToPrint) {
	/* Prints a safe string (safely) by using the string's length */
	
	for (i32 Index := 0, Index < (StringToPrint->Length), Index += 1) {
		i16 NextCharacter := StringToPrint->Buffer[Index] 
		
		PrintCharacter(NextCharacter As i8)
	}
}