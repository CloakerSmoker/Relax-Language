#Require ./src/lib/Memory.rlx
#Require ./src/lib/String.rlx
#Require ./src/lib/Console.rlx

struct SafeWideString {
	i16* Buffer,
	i32 Length,
	i8 BufferIsSelfOwned
	
	static SafeWideString* New(i32 Length, i16* Buffer, i8 BufferIsSelfOwned) {
		SafeWideString* this := Alloc(#SafeWideString)
		
		this->Length := Length
		this->Buffer := Buffer
		this->BufferIsSelfOwned := BufferIsSelfOwned
		
		return this
	}
	static SafeWideString* New(i32 Length, i16* Buffer) {
		return SafeWideString:New(Length, Buffer, false) 
	}
	static SafeWideString* Adopt(i32 Length, i16* Buffer) {
		return SafeWideString:New(Length, Buffer, true)
	}
	
	define SafeWideString* Clone() {
		i16* NewBuffer := CloneMemory(this->Buffer, this->Length * 2)
		
		return SafeWideString:Adopt(this->Length, NewBuffer)
	}
	
	define void Free() {
		if (this->BufferIsSelfOwned) {
			Free(this->Buffer)
		}
		
		Free(this)
	}
	
	define i8 ASCIICharacterAt(i32 Index) {
		return this->Buffer[Index] As i8
	}
	define i8 ASCIICharacterAt(i32 Index, i8 Default) {
		if (Index >= this->Length) {
			return Default
		}
		
		return this->ASCIICharacterAt(Index)
	}
	
	define void ShiftLeft(i32 Index, i32 Length) {
		i32 StartOffset := Index * 2
		i32 EndOffset := Length * 2
		
		i16* Start := this->Buffer + StartOffset
		i16* End := Start + EndOffset
		
		i32 ShiftCharacterCount := this->Length - Index - Length
		
		MoveMemory(Start, End, ShiftCharacterCount * 2)
		
		this->Length -= Length
	}
	
	define void Remove(i32 Index, i32 Length) {
		this->ShiftLeft(Index, Length)
	}
	
	define void Replace(i32 Index, i32 Length, i8* Replacement, i32 ReplacementLength) {
		if (ReplacementLength < Length) {
			this->ShiftLeft(Index + ReplacementLength, Length - ReplacementLength)
		}
		
		for (i32 ReplacementIndex := 0, ReplacementIndex < ReplacementLength, ReplacementIndex += 1) {
			this->Buffer[Index + ReplacementIndex] := Replacement[ReplacementIndex] As i16
		}
	}
	
	define void Print() {
		for (i32 Index := 0, Index < this->Length, Index += 1) {
			PrintCharacter(this->ASCIICharacterAt(Index))
		}
	}
	define void PrintLine() {
		this->Print()
		Print("\n")
	}
	
	define i8 Equals(SafeWideString* Other) {
		return false
	}
	define i8 Equals(i8* Other) {
		i32 OtherLength := StringLength(Other)
		
		if (OtherLength != this->Length) {
			return false
		}
		
		for (i32 Index := 0, Index < OtherLength, Index += 1) {
			if (Lower(Other[Index]) != Lower(this->ASCIICharacterAt(Index))) {
				return false
			}
		}
		
		return true
	}
	
	define i8* ToString() {
		return WToA(this->Buffer, this->Length)
	}
}

define SafeWideString* AllocateNewSafeString() {
	return Alloc(#SafeWideString) As SafeWideString*
}
define void FreeSafeString(SafeWideString* StringToFree) {
	Free(StringToFree As void*)
}

define SafeWideString* AToS(i8* SourceString) {
	/* Converts an ASCII string to a SafeWideString (without freeing anything ever) */
	
	
	i32 Length := StringLength(SourceString)
	i16* Buffer := AToW(SourceString, Length)
	
	SafeWideString* NewString := SafeWideString:New(Length, Buffer)
	NewString->BufferIsSelfOwned := true
	
	return NewString
}

define i8 SafeStringEqualsAString(SafeWideString* StringOne, i8* StringTwo) {
	/* Compares a SafeWideString and i8* ASCII string */

	i32 Index := 0
	
	loop {
		i16 Left := Lower(StringOne->Buffer[Index])
		i16 Right := Lower(StringTwo[Index])
		
		if (Index >= StringOne->Length) {
			/* Handle reaching the end of the safe string */
			
			if (Right = 0) {
				/* If the AString has also ended, then they are equal */
				return true
			}
			else {
				/* Otherwise, they aren't equal */
				return false
			}
		}
		else if (Right = 0) {
			/* If the AString ends before the SafeWideString, then they are not equal */
			return false
		}
		
		if (Left != Right) {
			return false
		}
		
		Index += 1
	}
	
	return false
}

define void PrintSafeString(SafeWideString* StringToPrint) {
	/* Prints a safe string (safely) by using the string's length */
	
	for (i32 Index := 0, Index < (StringToPrint->Length), Index += 1) {
		i16 NextCharacter := StringToPrint->Buffer[Index] 
		
		PrintCharacter(NextCharacter As i8)
	}
}