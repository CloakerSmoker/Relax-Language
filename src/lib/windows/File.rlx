#Require "$/FileBase.rlx"

define i8 CallDirectoryVisitor(i8 IsDirectory, i8* FilePath, void* Function) asm {
	jmp, rdx
}

struct WindowsDirectory unaligned {
	i32 Attributes

	i64 CreationTime
	i64 LastAccessTime
	i64 LastWriteTime

	i32 FileSizeHigh
	i32 FileSizeLow

	i64 Reserved

	i8[260] Name
	i8[14] ShortName

	i32 FileType
	i32 CreatorType
	i16 Flags
}

DllImport i64 FindFirstFile(i8*, WindowsDirectory*) {Kernel32.dll, FindFirstFileA}
DllImport i8 FindNextFile(i64, WindowsDirectory*) {Kernel32.dll, FindNextFileA}
DllImport i8 FindClose(i64) {Kernel32.dll, FindClose}

#Require "$/String.rlx"

define i8 DirectoryWalk(i8* DirectoryPath, void* VisitFunction) {
    i32 DirectoryLength := StringLength(DirectoryPath)
    i8* FixedDirectoryPath := Concatenate(DirectoryPath, "\*")

    WindowsDirectory Directory
    WindowsDirectory* pDirectory := &Directory

    i64 FindHandle := FindFirstFile(FixedDirectoryPath, pDirectory)

    FixedDirectoryPath[DirectoryLength + 1] := 0

    if (FindHandle = -1) {
        Free(FixedDirectoryPath)

        return 1
    }

    loop {
        i8* FullPath := Concatenate(FixedDirectoryPath, pDirectory~>Name)

        CallDirectoryVisitor(!!(pDirectory->Attributes & 0x10), FullPath, VisitFunction)

        Free(FullPath)

        if !(FindNextFile(FindHandle, pDirectory)) {
            break
        }
    }

    Free(FixedDirectoryPath)
    FindClose(FindHandle)
}

DllImport i32 GetCurrentDirectory(i32, i8*) {Kernel32.dll, GetCurrentDirectoryA}

define i8* GetWorkingDirectory() {
	i8* Buffer := Alloc(256)

    GetCurrentDirectory(255, Buffer)

	return Buffer
}

define i8* MakeAbsolute(i8* Path) {
	if (Path[0] != '/') {
		i8* WorkingDirectory := GetWorkingDirectory()

		i32 PathLength := StringLength(Path)
		i32 WorkingDirectoryLength := StringLength(WorkingDirectory)

		i8* Absolute := Alloc(WorkingDirectoryLength + 1 + PathLength + 1)

		MoveMemory(Absolute, WorkingDirectory, WorkingDirectoryLength)
		Absolute[WorkingDirectoryLength] := '/'
		MoveMemory(&Absolute[WorkingDirectoryLength] + 1, Path, PathLength)

		Free(WorkingDirectory)

		return Absolute
	}

	return Path
}

define i8* ExpandPath(i8* Path) {
	i32 Length := StringLength(Path)

	i8* Result := Alloc(Length + 2)
	i32 ResultIndex := 0

	i8* CurrentPart := Path

	for (i32 Index := 0, Index < Length, Index++) {
		i8 AtSeperator := Path[Index] = '/'
		i8 AtEnd := Index + 1 = Length

		if (AtSeperator || AtEnd) {
			if (AtSeperator) {
				Path[Index] := 0
			}
			else {
				Path[Index + AtEnd] := 0
			}

			if (StringEquals(CurrentPart, ".")) {

			}
			else if (StringEquals(CurrentPart, "..")) {
				for (i32 ReverseIndex := ResultIndex - 1, ReverseIndex >= 0, ReverseIndex--) {
					if (Result[ReverseIndex] = '/') {
						Result[ReverseIndex] := 0
						ResultIndex := ReverseIndex
						break
					}
				}
			}
			else {
				Result[ResultIndex++] := '/'

				MoveMemory(&Result[ResultIndex], CurrentPart, StringLength(CurrentPart))
				ResultIndex += StringLength(CurrentPart)
			}

			if (AtEnd && AtSeperator) {
				Result[ResultIndex++] := '/'
				Result[ResultIndex] := 0
			}

			CurrentPart := &Path[Index + 1]
		}
	}

	return Result + 1
}

DllImport i32 GetFullPathName(i8*, i32, i8*, i8*) {Kernel32.dll, GetFullPathNameA}

define i8* GetAbsolutePath(i8* ForPath) {
	windows {
		i8* Buffer := Alloc(260)

		GetFullPathName(ForPath, 260, Buffer, null)

		return Buffer
	}
	linux {
		i8* Buffer := Alloc(260)

		MoveMemory(Buffer, ForPath, StringLength(ForPath)) ; Technically a bug

		i8* Absolute := MakeAbsolute(Buffer)

		if (Absolute != Buffer) {
			Free(Buffer)
		}

		i8* Expanded := ExpandPath(Absolute)

		Free(Absolute)

		return Expanded
	}

	return null
}
