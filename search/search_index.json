{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Relax A C-like compiled programming language. The original compiler was implemented in AutoHotkey, and is now implemented in Relax itself. Note The Relax compiler generates 64 bit machine code, and depends on certain features that only exist on 64 bit processors. This means that there is no 32 bit support. I have no plans for adding 32 bit support, considering that 32 bit machine code is actually much more complex, and would need lots of special cases compared to 64 bit code. How to use it The Relax compiler is packaged along with each commit to the repo (as of this commit onwards) as the file stable_version.exe , and is ran as: stable_version.exe [InputFile] [OutputExe] Any compilation errors will be written to stderr, with general info being written to stdout. If you don't trust the pre-compiled version, you're sadly out of luck. The source code of the Relax compiler can no longer be compiled with the original (AHK) compiler, or older versions of the self-hosted compiler. Which means that in order to generate your own modern copy of stable_version.exe , you'd need to compile the last version of the compiler which was compatible with the original (AHK) compiler. Then from there, you'd need to compile each commit which adds a new feature to the language until you can compile the most recent version of the compiler. stable_version.exe has already done this for you, as it is the running copy of the 'most modern' version of the compiler. The only guarantee in terms of what stable_version.exe can compile is that: stable_version.exe must always be able to compile the version of the source code it shares a commit with (along with all the test programs). How to write Relax code: Pretend it is C with a whole bunch of stuff #define 'd into existence. For a quick(-ish) rundown of the syntax, and some quirks, see the basic syntax page . For a full writeup of the syntax, see the full syntax page . How it works I wanted the header for this on this page, but it's long enough that you'll need to go to this page to read that. Why I did this I have lots of time to waste, and when I started this project, my only goal was to finish it. Note: This next part is outdated, but is being kept since I still think it was insane to write the original compiler in AHK I feel like I need to defend myself here, mostly because I know it's 100% insane to use AHK for a project like this. AHK was the first language I ever really mastered, and I got used to how everything works, and all of the quirks. Because of this, when I decided I wanted to write a toy language, I didn't think of doing it in a \"real\" language since I already had a language that you can easily (and quickly) prototype things in right in front of me. As for why I'd want to write a language, it's just an interesting topic. I seriously recommend checking out the basics of language design, it's a field which I didn't even know existed until I stumbled on this ungodly useful (and high quality) free book and started reading. Try your hand at a quick brainfuck interpreter, and if you like the concept, give that book I mentioned a try. Just make sure that your first project is not a full on compiled language. Working on this language has been a rollercoaster, and I blame 100% of that on my ambitions being way too high. If you decide to write your own language, do not push yourself to work on it constantly. I did that, and now I'm burnt out enough to stop writing in AHK entirely. Also, embrace things like LLVM, and pre-made linkers. At some point in this project I decided I wanted to do it all on my own. Which was an absolutely terrible idea. Reinventing every part in the car instead of just a wheel will teach you a lot, but its not fun. Not to mention LLVM can generate much better code than you will manually.","title":"Relax"},{"location":"#relax","text":"A C-like compiled programming language. The original compiler was implemented in AutoHotkey, and is now implemented in Relax itself.","title":"Relax"},{"location":"#note","text":"The Relax compiler generates 64 bit machine code, and depends on certain features that only exist on 64 bit processors. This means that there is no 32 bit support. I have no plans for adding 32 bit support, considering that 32 bit machine code is actually much more complex, and would need lots of special cases compared to 64 bit code.","title":"Note"},{"location":"#how-to-use-it","text":"The Relax compiler is packaged along with each commit to the repo (as of this commit onwards) as the file stable_version.exe , and is ran as: stable_version.exe [InputFile] [OutputExe] Any compilation errors will be written to stderr, with general info being written to stdout. If you don't trust the pre-compiled version, you're sadly out of luck. The source code of the Relax compiler can no longer be compiled with the original (AHK) compiler, or older versions of the self-hosted compiler. Which means that in order to generate your own modern copy of stable_version.exe , you'd need to compile the last version of the compiler which was compatible with the original (AHK) compiler. Then from there, you'd need to compile each commit which adds a new feature to the language until you can compile the most recent version of the compiler. stable_version.exe has already done this for you, as it is the running copy of the 'most modern' version of the compiler. The only guarantee in terms of what stable_version.exe can compile is that: stable_version.exe must always be able to compile the version of the source code it shares a commit with (along with all the test programs).","title":"How to use it"},{"location":"#how-to-write-relax-code","text":"Pretend it is C with a whole bunch of stuff #define 'd into existence. For a quick(-ish) rundown of the syntax, and some quirks, see the basic syntax page . For a full writeup of the syntax, see the full syntax page .","title":"How to write Relax code:"},{"location":"#how-it-works","text":"I wanted the header for this on this page, but it's long enough that you'll need to go to this page to read that.","title":"How it works"},{"location":"#why-i-did-this","text":"I have lots of time to waste, and when I started this project, my only goal was to finish it.","title":"Why I did this"},{"location":"#note-this-next-part-is-outdated-but-is-being-kept-since-i-still-think-it-was-insane-to-write-the-original-compiler-in-ahk","text":"I feel like I need to defend myself here, mostly because I know it's 100% insane to use AHK for a project like this. AHK was the first language I ever really mastered, and I got used to how everything works, and all of the quirks. Because of this, when I decided I wanted to write a toy language, I didn't think of doing it in a \"real\" language since I already had a language that you can easily (and quickly) prototype things in right in front of me. As for why I'd want to write a language, it's just an interesting topic. I seriously recommend checking out the basics of language design, it's a field which I didn't even know existed until I stumbled on this ungodly useful (and high quality) free book and started reading. Try your hand at a quick brainfuck interpreter, and if you like the concept, give that book I mentioned a try. Just make sure that your first project is not a full on compiled language. Working on this language has been a rollercoaster, and I blame 100% of that on my ambitions being way too high. If you decide to write your own language, do not push yourself to work on it constantly. I did that, and now I'm burnt out enough to stop writing in AHK entirely. Also, embrace things like LLVM, and pre-made linkers. At some point in this project I decided I wanted to do it all on my own. Which was an absolutely terrible idea. Reinventing every part in the car instead of just a wheel will teach you a lot, but its not fun. Not to mention LLVM can generate much better code than you will manually.","title":"Note: This next part is outdated, but is being kept since I still think it was insane to write the original compiler in AHK"},{"location":"basic-syntax/","text":"The basic syntax It looks like C, it is written like C, but it is not C. Types Instead of long historic names, Relax uses shortened type names: Integer types: Precision C Name (LanguageName) Name 8 bits char i8 16 bits short i16 32 bits long i32 64 bits long long / __int64 i64 Additionally, there is the void type, which is exactly what you'd expect it to be: a 64 bit integer (I can't remember why I made it this way). Of course, there are also pointer types, which follow C syntax of TypeName* . Additionally, you can define a structure type with the struct keyword, which can then be pointed-to like any other type. Type checking Type checking is done in the parser, so globals/locals/functions/structs must (usually) be defined above where they are used. To avoid circular references being impossible to compile, the declare statement can be used to state a function's parameters/return type before defining it. Additionally, undefined types can be used as long as they only used in pointer types, and do not have and fields referenced. General Things String literals are supported, and are replaced with an i8* to the given string. This i8* will point into the stack, so DO NOT try to free this memory. You can alter it, but poking at the memory around it is a terrible idea. If a function does not have a return in it, the return value is undefined. However, functions are not required to have a return , and will still run. The magic entry-point function is named Main , which is not expected to follow any prototype. This is to avoid having to include additional runtime code to support ArgV/ArgC. If a program requires ArgC/ArgV, this snippet will provide it: DllImport i16* GetCommandLineW() {Kernel32.dll, GetCommandLineW} DllImport i16** CommandLineToArgvW(i16*, i64*) {Shell32.dll, CommandLineToArgvW} define i32 Main() { i64 ArgC := 0 i16* CommandLine := GetCommandLineW() i16** ArgV := CommandLineToArgvW(CommandLine, &ArgC) ... } The return value of Main is considered the program's exit code. This is the list of reserved names: if , else return continue , break struct , union define , declare , dllimport for , while , loop as Assignment operators The left side of each assignment operator can be any of the following: A variable, such as A An array access, such as String[Index] A struct access, such as Something.Field or SomethingPointer->Field The assignment operators are: := += -= Binary operators Note: && and || both short-circuit, % is modulo, . is local struct field access, -> is pointer struct field access. As is explained further here + , - * , / , % = , != < , <= , > , >= & , | , ^ && , || . , -> as Unary operators Note: & is 'address of', and * is dereference, - is negation. & , * - , ! ++ and -- have been deliberately excluded, as they are a pain to parse. Casting Casting between types is usually implicit, but if you want to explicitly cast between two obviously incompatible types, the As operator does it. The format is Operand As TypeName . Array-access Array accesses are really just pointer syntax sugar, but god do they make things easier. Pointer[Index] will do the same operation as *(Pointer + (SizeOfPointedToType(Pointer) * Index)) , with much less code generated. Instead of evaluating a bunch of expressions manually, the addition and multiplication steps are both done by the CPU directly, which should be a speed up. Struct-access Struct accesses are technically also syntax sugar, but allow for much higher level code. A struct access will automatically calculate the offset of a field inside of a structure, and encode that offset directly into an instruction. Additionally, since struct fields have names, cryptic code such as *(SomeStruct + 8 As i8*) can be written as SomeStruct->Field . The operators . and -> are mostly interchangeable, however, . only works for local structs, and -> only works for pointers to structs. What next? For a full writeup of the syntax, see the full syntax page .","title":"Basic syntax"},{"location":"basic-syntax/#the-basic-syntax","text":"It looks like C, it is written like C, but it is not C.","title":"The basic syntax"},{"location":"basic-syntax/#types","text":"Instead of long historic names, Relax uses shortened type names: Integer types: Precision C Name (LanguageName) Name 8 bits char i8 16 bits short i16 32 bits long i32 64 bits long long / __int64 i64 Additionally, there is the void type, which is exactly what you'd expect it to be: a 64 bit integer (I can't remember why I made it this way). Of course, there are also pointer types, which follow C syntax of TypeName* . Additionally, you can define a structure type with the struct keyword, which can then be pointed-to like any other type.","title":"Types"},{"location":"basic-syntax/#type-checking","text":"Type checking is done in the parser, so globals/locals/functions/structs must (usually) be defined above where they are used. To avoid circular references being impossible to compile, the declare statement can be used to state a function's parameters/return type before defining it. Additionally, undefined types can be used as long as they only used in pointer types, and do not have and fields referenced.","title":"Type checking"},{"location":"basic-syntax/#general-things","text":"String literals are supported, and are replaced with an i8* to the given string. This i8* will point into the stack, so DO NOT try to free this memory. You can alter it, but poking at the memory around it is a terrible idea. If a function does not have a return in it, the return value is undefined. However, functions are not required to have a return , and will still run. The magic entry-point function is named Main , which is not expected to follow any prototype. This is to avoid having to include additional runtime code to support ArgV/ArgC. If a program requires ArgC/ArgV, this snippet will provide it: DllImport i16* GetCommandLineW() {Kernel32.dll, GetCommandLineW} DllImport i16** CommandLineToArgvW(i16*, i64*) {Shell32.dll, CommandLineToArgvW} define i32 Main() { i64 ArgC := 0 i16* CommandLine := GetCommandLineW() i16** ArgV := CommandLineToArgvW(CommandLine, &ArgC) ... } The return value of Main is considered the program's exit code. This is the list of reserved names: if , else return continue , break struct , union define , declare , dllimport for , while , loop as","title":"General Things"},{"location":"basic-syntax/#assignment-operators","text":"The left side of each assignment operator can be any of the following: A variable, such as A An array access, such as String[Index] A struct access, such as Something.Field or SomethingPointer->Field The assignment operators are: := += -=","title":"Assignment operators"},{"location":"basic-syntax/#binary-operators","text":"Note: && and || both short-circuit, % is modulo, . is local struct field access, -> is pointer struct field access. As is explained further here + , - * , / , % = , != < , <= , > , >= & , | , ^ && , || . , -> as","title":"Binary operators"},{"location":"basic-syntax/#unary-operators","text":"Note: & is 'address of', and * is dereference, - is negation. & , * - , ! ++ and -- have been deliberately excluded, as they are a pain to parse.","title":"Unary operators"},{"location":"basic-syntax/#casting","text":"Casting between types is usually implicit, but if you want to explicitly cast between two obviously incompatible types, the As operator does it. The format is Operand As TypeName .","title":"Casting"},{"location":"basic-syntax/#array-access","text":"Array accesses are really just pointer syntax sugar, but god do they make things easier. Pointer[Index] will do the same operation as *(Pointer + (SizeOfPointedToType(Pointer) * Index)) , with much less code generated. Instead of evaluating a bunch of expressions manually, the addition and multiplication steps are both done by the CPU directly, which should be a speed up.","title":"Array-access"},{"location":"basic-syntax/#struct-access","text":"Struct accesses are technically also syntax sugar, but allow for much higher level code. A struct access will automatically calculate the offset of a field inside of a structure, and encode that offset directly into an instruction. Additionally, since struct fields have names, cryptic code such as *(SomeStruct + 8 As i8*) can be written as SomeStruct->Field . The operators . and -> are mostly interchangeable, however, . only works for local structs, and -> only works for pointers to structs.","title":"Struct-access"},{"location":"basic-syntax/#what-next","text":"For a full writeup of the syntax, see the full syntax page .","title":"What next?"},{"location":"basic-tutorial/","text":"Good luck. Let's be honest here, nobody's going to use this language at all, let alone people who are new to programming. Either way, I've got time to waste. Get ready for a bad intro to low-level compiled languages. Ignore that part right above here In Relax, all variables and values have 'types'. This means that a variable can only hold one kind of thing, and that variables will only ever hold one kind of thing. Additionally, you can only use two variables when they have compatible types, so you can't do something like \"This Is My String Of Text\" * 9.2 . The way you decide what type a variable has is by 'declaring' the variable to be a certain type. In Relax you declare a variable to be a certain type by typing a 'type name' along with the variable name, for example: i64 MyVariable i8 TestVariable Additionally, you can include an 'initial value' after the declaration, like i64 MyVariable := 99 + 20 i32 MyOtherVariable := 10 Variables only need to be declared once, however, you can change a variable's value as much as you like. Great, now that we've got that down, we can move on to functions . A function is a way to wrap a bunch of lines of code which accomplish a task into a single thing . For example: You might have a function to print some text to the screen. A function has a few components: A name, which is used when 'calling' the function (calling = running it) A return type, which is what kind of value the function returns (returns = gives back to whatever is running the function) A list of parameters, and parameter types, which are values which are passed to the function to change what it does (passed = given to the function before it runs) The body of the function, which is simply lines of code that are run when the function is called. So, if we want to write a function to add two numbers, we'd start with the name and return type, along with a special word to signal we are defining a function. Which leaves us with the format: define ReturnType Name Now we'll replace ReturnType with the standard number type, which is i64 , and Name with the name of the function (we will call it Add ) define i64 Add Great, now we're getting there. Next we need a list of parameters. Remember that parameters are values given to a function, which change what it does. In this case, the parameters should be the two numbers to add, since an Add function which only does the math for 1 + 1 isn't very useful. The format for parameters is: (TypeName ParameterName, TypeName ParameterName) Where you can have as many TypeName ParameterName combos as you'd like Since we want to take two numbers, we'll replace TypeName with i64 . Then, ParameterName is the name of a variable, which will be set to whatever value is passed to this function. So, each parameter name needs to be unique. We'll go with LeftNumber and RightNumber for the names here, which leaves us with: (i64 LeftNumber, i64 RightNumber) And then we stick that onto the code from earlier and get: define i64 Add(i64 LeftNumber, i64 RightNumber) Alright, to save myself some pain and suffering, I'm just going to finish the function and explain it define i64 Add(i64 LeftNumber, i64 RightNumber) { return LeftNumber + RightNumber } return will run the code to the right of it, and give the result back to whatever is using this function. LeftNumber + RightNumber will use the two parameters, and add them. God does this tutorial suck","title":"Basic tutorial"},{"location":"basic-tutorial/#good-luck","text":"Let's be honest here, nobody's going to use this language at all, let alone people who are new to programming. Either way, I've got time to waste. Get ready for a bad intro to low-level compiled languages.","title":"Good luck."},{"location":"basic-tutorial/#ignore-that-part-right-above-here","text":"In Relax, all variables and values have 'types'. This means that a variable can only hold one kind of thing, and that variables will only ever hold one kind of thing. Additionally, you can only use two variables when they have compatible types, so you can't do something like \"This Is My String Of Text\" * 9.2 . The way you decide what type a variable has is by 'declaring' the variable to be a certain type. In Relax you declare a variable to be a certain type by typing a 'type name' along with the variable name, for example: i64 MyVariable i8 TestVariable Additionally, you can include an 'initial value' after the declaration, like i64 MyVariable := 99 + 20 i32 MyOtherVariable := 10 Variables only need to be declared once, however, you can change a variable's value as much as you like. Great, now that we've got that down, we can move on to functions . A function is a way to wrap a bunch of lines of code which accomplish a task into a single thing . For example: You might have a function to print some text to the screen. A function has a few components: A name, which is used when 'calling' the function (calling = running it) A return type, which is what kind of value the function returns (returns = gives back to whatever is running the function) A list of parameters, and parameter types, which are values which are passed to the function to change what it does (passed = given to the function before it runs) The body of the function, which is simply lines of code that are run when the function is called. So, if we want to write a function to add two numbers, we'd start with the name and return type, along with a special word to signal we are defining a function. Which leaves us with the format: define ReturnType Name Now we'll replace ReturnType with the standard number type, which is i64 , and Name with the name of the function (we will call it Add ) define i64 Add Great, now we're getting there. Next we need a list of parameters. Remember that parameters are values given to a function, which change what it does. In this case, the parameters should be the two numbers to add, since an Add function which only does the math for 1 + 1 isn't very useful. The format for parameters is: (TypeName ParameterName, TypeName ParameterName) Where you can have as many TypeName ParameterName combos as you'd like Since we want to take two numbers, we'll replace TypeName with i64 . Then, ParameterName is the name of a variable, which will be set to whatever value is passed to this function. So, each parameter name needs to be unique. We'll go with LeftNumber and RightNumber for the names here, which leaves us with: (i64 LeftNumber, i64 RightNumber) And then we stick that onto the code from earlier and get: define i64 Add(i64 LeftNumber, i64 RightNumber) Alright, to save myself some pain and suffering, I'm just going to finish the function and explain it define i64 Add(i64 LeftNumber, i64 RightNumber) { return LeftNumber + RightNumber } return will run the code to the right of it, and give the result back to whatever is using this function. LeftNumber + RightNumber will use the two parameters, and add them.","title":"Ignore that part right above here"},{"location":"basic-tutorial/#god-does-this-tutorial-suck","text":"","title":"God does this tutorial suck"},{"location":"changelog/","text":"Changelog Top of page = most recent. 1.0.0 Added Support for structure types Support for function prototypes Changed The standard version of the compiler is now the self-compiled version All pointer types are now compatible Removed Floating point types (for now) Docs changes All pages, changed to be correct with the new compiler. 1.0.0-alpha.30 Added Support for compiling to .dll files. Support for exporting functions through the export keyword (which is explained on the syntax page ) Changed Lots of operations to use slightly bigger operands, which are incredibly easier to read. All operations but function calls and register-stack dumps to not use the actual stack (which should increase speed). Fixed Having identifiers named with the same names as operators (like i32 Times := 0 ) being converted into a Tokens.OPERATOR token (and not parsing correctly). Both types of comments not working, not // and /* whatever */ should both work fine. Docs changes Changed how to use it to not mention Main.exe , which has been removed since I can never remember to update it. Added export to the full syntax page Added a list of features on the new feature list page 1.0.0-alpha.29 Added Pointer-pointer types, allowing things like i64** or void******************* . (Maybe don't use that second one though) An array-access syntax for pointers which scales the index for you, so ArgV[Index] would be equal to *(ArgV + (8 * Index)) and ArrayOfI16s[Index] would be equal to *(ArrayOfI16s + (2 * Index)) Changed The ArgV parameter to Main to be of the type i16** . The version number Binary expressions with the operators || or && to result in i8 typed values. The String module to use the array access syntax when possible. The example programs to use the new ArgV type, and to use the array access syntax. Fixed Programs with 0 global variables generating broken output files. Most error messages not have any source code shown. Some error messages having the wrong code/not enough code highlighted. *= Only working with some types. Modules which Import each other crashing the compiler. Regular AHK exceptions causing the compiler to print \"Fatal error, bailing out.\" and exit without any context. Docs Changes Edited Basic Syntax to remove the mention of not having pointer-pointer types. Added an explanation of array accesses on the basic syntax page. Added the syntax for an array access on the full syntax page. Added an explanation of pointer-pointer types on the full syntax page. Added this page to act as a changelog 1.0.0-alpha.28 (And lower) None, the change log is new as of alpha.29 .","title":"Changelog"},{"location":"changelog/#changelog","text":"Top of page = most recent.","title":"Changelog"},{"location":"changelog/#100","text":"","title":"1.0.0"},{"location":"changelog/#added","text":"Support for structure types Support for function prototypes","title":"Added"},{"location":"changelog/#changed","text":"The standard version of the compiler is now the self-compiled version All pointer types are now compatible","title":"Changed"},{"location":"changelog/#removed","text":"Floating point types (for now)","title":"Removed"},{"location":"changelog/#docs-changes","text":"All pages, changed to be correct with the new compiler.","title":"Docs changes"},{"location":"changelog/#100-alpha30","text":"","title":"1.0.0-alpha.30"},{"location":"changelog/#added_1","text":"Support for compiling to .dll files. Support for exporting functions through the export keyword (which is explained on the syntax page )","title":"Added"},{"location":"changelog/#changed_1","text":"Lots of operations to use slightly bigger operands, which are incredibly easier to read. All operations but function calls and register-stack dumps to not use the actual stack (which should increase speed).","title":"Changed"},{"location":"changelog/#fixed","text":"Having identifiers named with the same names as operators (like i32 Times := 0 ) being converted into a Tokens.OPERATOR token (and not parsing correctly). Both types of comments not working, not // and /* whatever */ should both work fine.","title":"Fixed"},{"location":"changelog/#docs-changes_1","text":"Changed how to use it to not mention Main.exe , which has been removed since I can never remember to update it. Added export to the full syntax page Added a list of features on the new feature list page","title":"Docs changes"},{"location":"changelog/#100-alpha29","text":"","title":"1.0.0-alpha.29"},{"location":"changelog/#added_2","text":"Pointer-pointer types, allowing things like i64** or void******************* . (Maybe don't use that second one though) An array-access syntax for pointers which scales the index for you, so ArgV[Index] would be equal to *(ArgV + (8 * Index)) and ArrayOfI16s[Index] would be equal to *(ArrayOfI16s + (2 * Index))","title":"Added"},{"location":"changelog/#changed_2","text":"The ArgV parameter to Main to be of the type i16** . The version number Binary expressions with the operators || or && to result in i8 typed values. The String module to use the array access syntax when possible. The example programs to use the new ArgV type, and to use the array access syntax.","title":"Changed"},{"location":"changelog/#fixed_1","text":"Programs with 0 global variables generating broken output files. Most error messages not have any source code shown. Some error messages having the wrong code/not enough code highlighted. *= Only working with some types. Modules which Import each other crashing the compiler. Regular AHK exceptions causing the compiler to print \"Fatal error, bailing out.\" and exit without any context.","title":"Fixed"},{"location":"changelog/#docs-changes_2","text":"Edited Basic Syntax to remove the mention of not having pointer-pointer types. Added an explanation of array accesses on the basic syntax page. Added the syntax for an array access on the full syntax page. Added an explanation of pointer-pointer types on the full syntax page. Added this page to act as a changelog","title":"Docs Changes"},{"location":"changelog/#100-alpha28-and-lower","text":"None, the change log is new as of alpha.29 .","title":"1.0.0-alpha.28 (And lower)"},{"location":"compiling-it/","text":"Compiling the compiler This is the only page I have enjoyed (re)writing. Rules 1) DO NOT COMMIT UNTIL ALL TESTS PASS 2) DO NOT COMMIT UNTIL ALL TESTS PASS 3) DO NOT COMMIT UNTIL ALL TESTS PASS 4) DO NOT COMMIT UNTIL YOU CAN COMPILE YOURSELF How To The Main function of the compiler is implemented in Bain.rlx , which includes all other components. The file is not named Main.rlx because that was taken by the version for the original (AHK) compiler, which had runtime code that no longer exists. So, to compile the compiler we run stable_version.exe Bain.rlx output_name.exe , simple enough, right? Wrong . Testing Since the compiler has reached a stage where it can only be compiled with the previous version of itself, it is 100% crucial that any version of the compiler can compile itself, otherwise the repo could get stranded where there are 0 versions of the compiler which can compile the source. I've made the testing process easy with some scripts through, so to actually compile the compiler, you run: python test_boostrap.py which will ensure the latest version of the source can: A) Be compiled with the previous version B) Compile itself correctly C) Compile a series of test programs correctly If any of these steps fail, test_bootstrap.py will error out. However, if none fail, the output will be written to new_stable.exe , which can then overwrite stable.version.exe and then be used to compile code which requires a new feature. For example, to implement unions I followed these steps: 1) Change Lexer.rlx and Parser.rlx to handle the union keyword, and correctly alter structure layouts based on the keyword. 2) Run test_bootstrap to ensure that my changes did not break anything. 3) Use new_stable.exe to test that I had implemented unions correctly. 4) Overwrite stable_version.exe with new_stable.exe , which now supported the union keyword. 5) Change Parser.rlx and Compiler.rlx to use unions for some things. 6) Run test_bootstrap to ensure that using unions did not break anything. 7) Replace stable_version.exe with new_stable.exe again, which resulted in: A version of stable_version.exe which supports the union keyword, along with using the union keyword in it's own implementation. 8) Add tests for the union keyword, to ensure the implementation stays correct. Now that stable_version.exe can 100% certainly compile itself correctly, it is safe to make a commit. Just in case though, step 9 would be to run test_compiler.py on stable_version.exe , which just runs the \\tests on the passed compiler, without having it recompile itself. Through these steps, a new language feature can be implemented almost seamlessly, and with minimal brain-meltage. This might be an incredibly roundabout way to implement new features in a bootstrapped compiler, but I legitimately am not smart enough to come up with another way.","title":"Compiling the compiler"},{"location":"compiling-it/#compiling-the-compiler","text":"This is the only page I have enjoyed (re)writing.","title":"Compiling the compiler"},{"location":"compiling-it/#rules","text":"1) DO NOT COMMIT UNTIL ALL TESTS PASS 2) DO NOT COMMIT UNTIL ALL TESTS PASS 3) DO NOT COMMIT UNTIL ALL TESTS PASS 4) DO NOT COMMIT UNTIL YOU CAN COMPILE YOURSELF","title":"Rules"},{"location":"compiling-it/#how-to","text":"The Main function of the compiler is implemented in Bain.rlx , which includes all other components. The file is not named Main.rlx because that was taken by the version for the original (AHK) compiler, which had runtime code that no longer exists. So, to compile the compiler we run stable_version.exe Bain.rlx output_name.exe , simple enough, right? Wrong .","title":"How To"},{"location":"compiling-it/#testing","text":"Since the compiler has reached a stage where it can only be compiled with the previous version of itself, it is 100% crucial that any version of the compiler can compile itself, otherwise the repo could get stranded where there are 0 versions of the compiler which can compile the source. I've made the testing process easy with some scripts through, so to actually compile the compiler, you run: python test_boostrap.py which will ensure the latest version of the source can: A) Be compiled with the previous version B) Compile itself correctly C) Compile a series of test programs correctly If any of these steps fail, test_bootstrap.py will error out. However, if none fail, the output will be written to new_stable.exe , which can then overwrite stable.version.exe and then be used to compile code which requires a new feature. For example, to implement unions I followed these steps: 1) Change Lexer.rlx and Parser.rlx to handle the union keyword, and correctly alter structure layouts based on the keyword. 2) Run test_bootstrap to ensure that my changes did not break anything. 3) Use new_stable.exe to test that I had implemented unions correctly. 4) Overwrite stable_version.exe with new_stable.exe , which now supported the union keyword. 5) Change Parser.rlx and Compiler.rlx to use unions for some things. 6) Run test_bootstrap to ensure that using unions did not break anything. 7) Replace stable_version.exe with new_stable.exe again, which resulted in: A version of stable_version.exe which supports the union keyword, along with using the union keyword in it's own implementation. 8) Add tests for the union keyword, to ensure the implementation stays correct. Now that stable_version.exe can 100% certainly compile itself correctly, it is safe to make a commit. Just in case though, step 9 would be to run test_compiler.py on stable_version.exe , which just runs the \\tests on the passed compiler, without having it recompile itself. Through these steps, a new language feature can be implemented almost seamlessly, and with minimal brain-meltage. This might be an incredibly roundabout way to implement new features in a bootstrapped compiler, but I legitimately am not smart enough to come up with another way.","title":"Testing"},{"location":"dumb-errors/","text":"A list stupid errors Apparently this variable is undeclared, while I am declaring it OH MY GOD. I have been forgetting to check the conditions of if statements There's just flat out no code for it don't you just hate when you can't assign your typed variable with := ?","title":"Dumb errors"},{"location":"dumb-errors/#a-list-stupid-errors","text":"Apparently this variable is undeclared, while I am declaring it OH MY GOD. I have been forgetting to check the conditions of if statements There's just flat out no code for it don't you just hate when you can't assign your typed variable with := ?","title":"A list stupid errors"},{"location":"full-syntax/","text":"The full syntax description Program The compiler expects input code to be a \"program\", a program is defined as a list of the following statements: Struct statements Declare statements DllImport statements Define statements Global declarations Directives Directives Directives follow the format: #Directive Parameter Directive is a directive name ( include is the only one implemented) Parameter is a parameter for the directive Directives are direct instructions for the compiler, and do not generate any code. The include directive will copy-paste the contents of another file into the position the directive is at. Declare Declare statements follow the format: Declare ReturnType FunctionName(ParameterTypeList) ReturnType is the type that the function is expected to return. FunctionName is the name of the function. ParameterTypeList is a list of comma-separated types , without any names, since the parameter names are not needed. Declare statements are use to tell the compiler what types FunctionName should be passed (and will return) before it has parsed the full definition of FunctionName DllImport DllImport statements follow the format: DllImport ReturnType FunctionName(ParameterTypeList) {DllFileName.dll, FunctionNameInsideDLL} ReturnType is the type that the function is expected to return. FunctionName is the name that the function will have internally, and is the name you use to call it. This name does not need to be the same as FunctionNameInsideDLL . ParameterTypeList is a list of comma-separated types , without any names, since the parameter names are not needed. DllFileName.dll is the name of the file which contains the given function. FunctionNameInsideDLL is the name of the function, as it is exported in from the DLL. Define Define statements follow the format: Define ReturnType FunctionName(ParameterList) export { Body } ReturnType is the type that the function is expected to return. FunctionName is the name that the function will have, and is the name you use to call it. ParameterList is a list of comma-separated type name pairs. Body is a list of statements . Export is optionally the word export , which will cause the function to be exported from the resulting file (if the file is a .dll ) Struct Struct statements follow the format: struct StructName { Type Name, Type Name, union { Type Name, Type Name }, Type Name } StructName is the type name the struct type should have Type is a type name for the field Name is a name for the field Global Global declarations follow the same format as regular declarations . However, global declarations make variables that are program -wide, and can be used from any function. Additionally, global declarations run just before Main is run, making them a suitable method to run setup code. Statements Statements follow multiple different formats, depending on the type of statement. Declarations Keyword statements Expression statements It is important to note that this 'statement' category does not include the program statements, which are not allowed inside of functions. All of the above statements are allowed inside of functions and other structures such as for loops or if statements . Declarations Declarations follow the format(s): TypeName VariableName TypeName VariableName := Value TypeName is the type that the variable will have. VariableName is the name the variable will have. := Value is an optional assignment to give the variable a default value. Variables that do not have a default value should be considered to have an undefined value until they are otherwise assigned. Keywords Keyword statements follow multiple different formats, depending on the keyword used. if/else if/else statements for loops break/continue statements return statements These are all of the statements implemented, there are no while loops. If If statements follow a single variable format, depending on the structure of the if statement: if (Condition) { Body } else if (OtherCondition) { Body } else { Body } if is the required keyword to start an if statement. (Condition) an expression which will be tested in order to decide if the next block will run or not. Body (in all places) is a list of statements(#statements) which will run if the prior condition resulted in a non-zero result. else if the required keyword to add another condition and body to the entire if statement. else the required keyword to add a final body to the if statement, which will only run when no other conditions are met. else if can be repeated any number of times, for any number of conditions. There can only be one else for each if statement. For For loops follow the format: for (Init, Condition, Step) { Body } Init , Condition , and Step are all expressions which run at different points. Body is a list of statements(#statements) which will run each iteration of the loop. Init can optionally be a declaration and is run before the loop first stats, and never again. Condition is checked before the loop runs an iteration, and if it is false, the loop will stop. Step is run after each iteration of the loop. Break-Continue Break and continue both follow the format: Break Continue With no extra code. The break and continue statements are only valid inside of for loops . Return Return statements follow the format: Return Value Value is any kind of expression , which will be returned to the caller. Value must evaluate to a type compatible to the return type of the current function . Expression-Statements Expression statements follow the format: Expression Expression is any kind of expression . If Expression does not call a function or set a variable, it will be eliminated by the compiler during dead-code elimination. Expression Expressions follow many formats, examples: A := B + C (2 - E) / 2 9999 + *(G) % H Any unquoted text inside an expression is treated as a variable. Quoted text is treated as an i8* typed value. Numbers are treated as the smallest possible type to hold them (ex: 58 would be an i8 , 9999 would be an i16 ) Operators are evaluated according to precedence and associativity, which is defined in Parser.rlx . Some operators may not be implemented for a given type Some expressions may be used as booleans inside of for loops or if statements . This is done by checking if the expressions results in 0 or not. Additionally, there is the format: Something[SomethingElse] Where Something is an expression which results in a pointer-type, and SomethingElse results in an integer, which will be used as an index into Something . Operators are listed on this page Types A type is simply a combination of a identifier, with any number of * s after it (each * increases the level of nested pointers) The base type names are i8 , i16 , i32 , i64 void With pointer (and pointer-pointer) types for each, like: void* - Pointer to void i16** - Pointer to a pointer to an i16 i8* - Pointer to an i8 void***************** - Pointer to a pointer to a pointer to a pointer to a pointer to a pointer to a pointer.... you get it Names Names are simply combinations of characters and numbers. Names must start with a-z, but can contain numbers after the first letter.","title":"Full syntax"},{"location":"full-syntax/#the-full-syntax-description","text":"","title":"The full syntax description"},{"location":"full-syntax/#program","text":"The compiler expects input code to be a \"program\", a program is defined as a list of the following statements: Struct statements Declare statements DllImport statements Define statements Global declarations Directives","title":"Program"},{"location":"full-syntax/#directives","text":"Directives follow the format: #Directive Parameter Directive is a directive name ( include is the only one implemented) Parameter is a parameter for the directive Directives are direct instructions for the compiler, and do not generate any code. The include directive will copy-paste the contents of another file into the position the directive is at.","title":"Directives"},{"location":"full-syntax/#declare","text":"Declare statements follow the format: Declare ReturnType FunctionName(ParameterTypeList) ReturnType is the type that the function is expected to return. FunctionName is the name of the function. ParameterTypeList is a list of comma-separated types , without any names, since the parameter names are not needed. Declare statements are use to tell the compiler what types FunctionName should be passed (and will return) before it has parsed the full definition of FunctionName","title":"Declare"},{"location":"full-syntax/#dllimport","text":"DllImport statements follow the format: DllImport ReturnType FunctionName(ParameterTypeList) {DllFileName.dll, FunctionNameInsideDLL} ReturnType is the type that the function is expected to return. FunctionName is the name that the function will have internally, and is the name you use to call it. This name does not need to be the same as FunctionNameInsideDLL . ParameterTypeList is a list of comma-separated types , without any names, since the parameter names are not needed. DllFileName.dll is the name of the file which contains the given function. FunctionNameInsideDLL is the name of the function, as it is exported in from the DLL.","title":"DllImport"},{"location":"full-syntax/#define","text":"Define statements follow the format: Define ReturnType FunctionName(ParameterList) export { Body } ReturnType is the type that the function is expected to return. FunctionName is the name that the function will have, and is the name you use to call it. ParameterList is a list of comma-separated type name pairs. Body is a list of statements . Export is optionally the word export , which will cause the function to be exported from the resulting file (if the file is a .dll )","title":"Define"},{"location":"full-syntax/#struct","text":"Struct statements follow the format: struct StructName { Type Name, Type Name, union { Type Name, Type Name }, Type Name } StructName is the type name the struct type should have Type is a type name for the field Name is a name for the field","title":"Struct"},{"location":"full-syntax/#global","text":"Global declarations follow the same format as regular declarations . However, global declarations make variables that are program -wide, and can be used from any function. Additionally, global declarations run just before Main is run, making them a suitable method to run setup code.","title":"Global"},{"location":"full-syntax/#statements","text":"Statements follow multiple different formats, depending on the type of statement. Declarations Keyword statements Expression statements It is important to note that this 'statement' category does not include the program statements, which are not allowed inside of functions. All of the above statements are allowed inside of functions and other structures such as for loops or if statements .","title":"Statements"},{"location":"full-syntax/#declarations","text":"Declarations follow the format(s): TypeName VariableName TypeName VariableName := Value TypeName is the type that the variable will have. VariableName is the name the variable will have. := Value is an optional assignment to give the variable a default value. Variables that do not have a default value should be considered to have an undefined value until they are otherwise assigned.","title":"Declarations"},{"location":"full-syntax/#keywords","text":"Keyword statements follow multiple different formats, depending on the keyword used. if/else if/else statements for loops break/continue statements return statements These are all of the statements implemented, there are no while loops.","title":"Keywords"},{"location":"full-syntax/#if","text":"If statements follow a single variable format, depending on the structure of the if statement: if (Condition) { Body } else if (OtherCondition) { Body } else { Body } if is the required keyword to start an if statement. (Condition) an expression which will be tested in order to decide if the next block will run or not. Body (in all places) is a list of statements(#statements) which will run if the prior condition resulted in a non-zero result. else if the required keyword to add another condition and body to the entire if statement. else the required keyword to add a final body to the if statement, which will only run when no other conditions are met. else if can be repeated any number of times, for any number of conditions. There can only be one else for each if statement.","title":"If"},{"location":"full-syntax/#for","text":"For loops follow the format: for (Init, Condition, Step) { Body } Init , Condition , and Step are all expressions which run at different points. Body is a list of statements(#statements) which will run each iteration of the loop. Init can optionally be a declaration and is run before the loop first stats, and never again. Condition is checked before the loop runs an iteration, and if it is false, the loop will stop. Step is run after each iteration of the loop.","title":"For"},{"location":"full-syntax/#break-continue","text":"Break and continue both follow the format: Break Continue With no extra code. The break and continue statements are only valid inside of for loops .","title":"Break-Continue"},{"location":"full-syntax/#return","text":"Return statements follow the format: Return Value Value is any kind of expression , which will be returned to the caller. Value must evaluate to a type compatible to the return type of the current function .","title":"Return"},{"location":"full-syntax/#expression-statements","text":"Expression statements follow the format: Expression Expression is any kind of expression . If Expression does not call a function or set a variable, it will be eliminated by the compiler during dead-code elimination.","title":"Expression-Statements"},{"location":"full-syntax/#expression","text":"Expressions follow many formats, examples: A := B + C (2 - E) / 2 9999 + *(G) % H Any unquoted text inside an expression is treated as a variable. Quoted text is treated as an i8* typed value. Numbers are treated as the smallest possible type to hold them (ex: 58 would be an i8 , 9999 would be an i16 ) Operators are evaluated according to precedence and associativity, which is defined in Parser.rlx . Some operators may not be implemented for a given type Some expressions may be used as booleans inside of for loops or if statements . This is done by checking if the expressions results in 0 or not. Additionally, there is the format: Something[SomethingElse] Where Something is an expression which results in a pointer-type, and SomethingElse results in an integer, which will be used as an index into Something . Operators are listed on this page","title":"Expression"},{"location":"full-syntax/#types","text":"A type is simply a combination of a identifier, with any number of * s after it (each * increases the level of nested pointers) The base type names are i8 , i16 , i32 , i64 void With pointer (and pointer-pointer) types for each, like: void* - Pointer to void i16** - Pointer to a pointer to an i16 i8* - Pointer to an i8 void***************** - Pointer to a pointer to a pointer to a pointer to a pointer to a pointer to a pointer.... you get it","title":"Types"},{"location":"full-syntax/#names","text":"Names are simply combinations of characters and numbers. Names must start with a-z, but can contain numbers after the first letter.","title":"Names"},{"location":"how-it-works/","text":"The structure The compiler is laid out in various separate stages, in the order: Lexer Parser Compiler CodeGen PEBuilder A quick rundown The lexer takes source code, makes it into an array of tokens. The parser takes an array of tokens, builds it into a tree that represents the code. The compiler takes that tree, and converts it into CPU instructions. CodeGen takes the CPU instructions that the compiler is trying to generate, and assembles them into raw machine code. PEBuilder packs the raw machine code into a .exe file. Simple enough, right? (It only took thousands of line to implement) Lexer The lexer is used to transform plain text like define i32 Main or i32 test := 99 + 2 into an array of \"tokens\". A token is like a word, and is the smallest unit that the entire compiler uses. Tokens also have different types. So, i32 test := 99 + 2 would have the tokenizer start with the character i , which it would see is: Not the start of an operator Not the start of a string, or character literal Not whitespace Not a new line Not a digit Is alphanumeric And now that the lexer has found an alphanumeric character, it will continue to consume all alphanumeric characters after the first. So, 32 would also be consumed, and added to the t token, however, \" \" is not alphanumeric, and would be the end of the t token. Next, to figure out the type of the token, the lexer checks if it is in the list of keywords (found in Lexer.rlx , LookupKeyword ), and since it is not a keyword, the token is created with the type TOKEN_TYPE_IDENTIFER , and a value of i32 . This would repeat for test , giving us the two tokens: [{Value: \"i32\", Type: TOKEN_TYPE_IDENTIFER}, {Value: \"test\", Type: TOKEN_TYPE_IDENTIFER}] Now, the lexer would see the character : , and : is defined as the first character of an operator (in Lexer.rlx 's GetNextToken ). Since : is an operator (or part of an operator), the lexer will now: Check if the next character is part of any operators (In this case the next character is = , which is part of := ) Gather all characters that are part of the operator which matches the next character ( := only has two characters, so this step is already done) Create a token of the TOKEN_TYPE_OPERATOR type, with the value of the found operator ( OPERATOR_COLON_EQUAL in this case) Now we've got: [{Value: \"i32\", Type: TOKEN_TYPE_IDENTIFER}, {Value: \"test\", Type: TOKEN_TYPE_IDENTIFER}, {Value: OPERATOR_COLON_EQUAL, Type: TOKEN_TYPE_OPERATOR}] And the next character is 9 , which the lexer would see is: Not the start of an operator Not the start of a string, or character literal Not whitespace Not a new line Is a digit Now, the lexer will gather all digits following the first, getting us 99 , and create a TOKEN_TYPE_INTEGER token, with the value 99 . Now, applying these same rules to the rest of the string, we get the following array of tokens for the output: [ {Value: \"i32\", Type: TOKEN_TYPE_IDENTIFER}, {Value: \"test\", Type: TOKEN_TYPE_IDENTIFER}, {Value: OPERATOR_COLON_EQUAL, Type: TOKEN_TYPE_OPERATOR}, {Value: 99, Type: TOKEN_TYPE_INTEGER}, {Value: OPERATOR_PLUS, Type: TOKEN_TYPE_OPERATOR}, {Value: 2, Type: TOKEN_TYPE_INTEGER} ] One thing that I haven't mentioned is that all tokens actually contain a bit more data. A pointer to the name of the file the token is from A pointer to their source text What line the token is on Where the token is in that line/how long it is All of this data is used to provide better error printouts And that's all the lexer really does. Of course, there's many-many more token types than I mentioned, and the lexer also supports hex literals, which are given the type TOKEN_TYPE_IDENTIFER . Parser The parser takes the array of tokens which the lexer outputs, and builds an abstract syntax tree out of the tokens. And abstract syntax tree (AST) is a how a given program is represented, in this case, each \"leaf\" of the AST is either a Token object (which the lexer outputs) or a ASTNode object. For example, the AST of 1 + 2 would be: { Type: NODE_TYPE_BINARY, Left: { Type: NODE_TYPE_INTEGER, Value: 1 } Operator: { Type: TOKEN_TYPE_OPERATOR, Value: OPERATOR_PLUS } Right: { Type: NODE_TYPE_INTEGER, Value: 2 } } This concept is the same throughout the entire parser, you have an AST node, which has other AST nodes inside of it, which can represent any part of a program. Additionally, AST nodes also contain the same context data as tokens for accurate error reporting. The hard part is actually building the AST. I'm not going to go into how the AST is built, due to that being a better topic for a book, not documentation. Compiler The compiler takes the AST from the parser, and walks it, calling into CodeGen.rlx to generate machine code for each AST node it visits. The AST is walked by recursively enumerating each branch of the tree, with each different branch type having a different function which will enumerate any branches it has. Statements are compiled in mostly-similar ways, with a condition being compiled, then tested, and a conditional jump to either the next statement in a chain, or out of the current statement. More specifically: If statements are compiled by compiling the condition expression, testing it with result != 0 , and conditionally jumping into the Body for the statement. After the body, a jmp to the end of the statement stops any other branches from running. If the != 0 test fails, it jmp s to the next condition and body to be checked. For loops are compiled with the initialization step first, then a label to jump back to, then the condition (and a jump out of the loop when the condition is false), and then the loop body. After the body is the step expression, and a jump back to the start of the loop. Expressions are a little less label/ jmp intensive, but more complex to understand. So, to evaluate expressions, a stack is used to hold operands until they are needed, which means that: When we compile a binary operator, we should pop two operands of the stack, and push our result onto the stack. When we compile a unary operator, we should pop one operand, and push our result onto the the stack. When we compile a function call, we should pop as many operands as the function takes as parameters, and then push the return value onto the stack. As long as all generated code to evaluate expressions follows these rules, you can always trust an expression to leave its result on the stack. If this promise of operands/results is every broken, then there has been a code misgeneration, and something is wrong. However, since it isn't broken, expressions can be compiled into a series of very basic instructions. Strings And Other Stuff The compiler handles strings by allocating StrLen(String) + 1 bytes much of stack space for each string, and encodes string literals into 64 bit integers, which when stored in the stack, will build the correctly ordered string. When a string is used, it is replaced with a pointer into the stack where the string was written. Parameters are treated exactly the same as locals. Function calls are a bit of a mess. Since the register stack uses some of the parameter registers, first the register stack has to be saved, and then the parameter registers have to be 0'd, and finally, the parameters can be compiled and moved into the parameter registers. When a function never has a return statement compiled, it will automatically return with an undefined result. This is the only difference for omitting return , since the code to return from a function is automatically generated at the end of a function either way. Signed numbers are the only kind of numbers, unsigned operations require entirely different instructions for operations, which is why I don't plan on adding unsigned types. CodeGen This one will be shorter, I promise. CodeGen is a class which generates the correct bytes for lots of common AMD64 instructions, and automatically handles linking labels and jumps for you. CodeGen keeps a buffer containing the array of assembled code, along with buffers for book keeping info such as labels and fixups, which are applied before the code is written to the output file. The backbone of CodeGen is just a few methods: EmitREX(DestinationRegister, SourceRegister, ExtraREX) Which will build a \"REX prefix\" for an instruction, which will promote the instruction to use 64 bit registers and data, along with giving it access to the new GPRs R8-R15. EmitREXOpcodeModRM(Opcode, Mode, DestinationRegister, SourceRegister, ExtraREX) Which will build a REX prefix, write the opcode, and then write a \"ModRM\" byte, which controls the operands, and operand types of an instruction. EmitREXOpcodeModRMSIB(Opcode, Mode, DestinationRegister, Scale, IndexRegister, BaseRegister, ExtraREX) Which will build a REX prefix, opcode, and ModRM byte which uses the SIB addressing mode. SIB stands for (S)cale (I)ndex (B)ase, which allows you to have address calculations like FinalAddress = GetRegisterValue(SIB.Base) + (GetRegisterValue(SIB.Index) * SIB.Scale) , which are very useful for indexing arrays. ResolveAllLabels Which will resolve all labels, and return the linked code. PEBuilder A class that handles all the dirty work of building .exe files. Most of the code is spent building the headers, and setting the correct magic numbers. The only interesting bit is how the import address table (IAT) and .reloc (relocation) section is built. The IAT is built with one structure for each Dll that functions are imported from, and 2 parallel arrays which hold the actual import data. The structure holds a pointer to the first array, the number of entries in all of the arrays, a pointer to the Dll name, and a pointer to the 2rd array. Each entry in the 1st and 2nd array is identical until the .exe file is loaded, but before that, an entry considered part of a \"hint-name table\", which is made up of an ordinal value for the imported function, or a pointer to the function's name. I do not bother with ordinal values. Once the loader reads the hint-name table, each entry in the 2nd array is overwritten with a pointer to the function it originally imported, which PEBuilder links code to jump into. The .reloc section handles what should happen when the file can't be loaded at the specified base address, and contains pointers to every location inside of the code which references a static address. So, every use of a global variable, and every use of an import function, gets an entry in the .reloc section.","title":"How it works"},{"location":"how-it-works/#the-structure","text":"The compiler is laid out in various separate stages, in the order: Lexer Parser Compiler CodeGen PEBuilder","title":"The structure"},{"location":"how-it-works/#a-quick-rundown","text":"The lexer takes source code, makes it into an array of tokens. The parser takes an array of tokens, builds it into a tree that represents the code. The compiler takes that tree, and converts it into CPU instructions. CodeGen takes the CPU instructions that the compiler is trying to generate, and assembles them into raw machine code. PEBuilder packs the raw machine code into a .exe file. Simple enough, right? (It only took thousands of line to implement)","title":"A quick rundown"},{"location":"how-it-works/#lexer","text":"The lexer is used to transform plain text like define i32 Main or i32 test := 99 + 2 into an array of \"tokens\". A token is like a word, and is the smallest unit that the entire compiler uses. Tokens also have different types. So, i32 test := 99 + 2 would have the tokenizer start with the character i , which it would see is: Not the start of an operator Not the start of a string, or character literal Not whitespace Not a new line Not a digit Is alphanumeric And now that the lexer has found an alphanumeric character, it will continue to consume all alphanumeric characters after the first. So, 32 would also be consumed, and added to the t token, however, \" \" is not alphanumeric, and would be the end of the t token. Next, to figure out the type of the token, the lexer checks if it is in the list of keywords (found in Lexer.rlx , LookupKeyword ), and since it is not a keyword, the token is created with the type TOKEN_TYPE_IDENTIFER , and a value of i32 . This would repeat for test , giving us the two tokens: [{Value: \"i32\", Type: TOKEN_TYPE_IDENTIFER}, {Value: \"test\", Type: TOKEN_TYPE_IDENTIFER}] Now, the lexer would see the character : , and : is defined as the first character of an operator (in Lexer.rlx 's GetNextToken ). Since : is an operator (or part of an operator), the lexer will now: Check if the next character is part of any operators (In this case the next character is = , which is part of := ) Gather all characters that are part of the operator which matches the next character ( := only has two characters, so this step is already done) Create a token of the TOKEN_TYPE_OPERATOR type, with the value of the found operator ( OPERATOR_COLON_EQUAL in this case) Now we've got: [{Value: \"i32\", Type: TOKEN_TYPE_IDENTIFER}, {Value: \"test\", Type: TOKEN_TYPE_IDENTIFER}, {Value: OPERATOR_COLON_EQUAL, Type: TOKEN_TYPE_OPERATOR}] And the next character is 9 , which the lexer would see is: Not the start of an operator Not the start of a string, or character literal Not whitespace Not a new line Is a digit Now, the lexer will gather all digits following the first, getting us 99 , and create a TOKEN_TYPE_INTEGER token, with the value 99 . Now, applying these same rules to the rest of the string, we get the following array of tokens for the output: [ {Value: \"i32\", Type: TOKEN_TYPE_IDENTIFER}, {Value: \"test\", Type: TOKEN_TYPE_IDENTIFER}, {Value: OPERATOR_COLON_EQUAL, Type: TOKEN_TYPE_OPERATOR}, {Value: 99, Type: TOKEN_TYPE_INTEGER}, {Value: OPERATOR_PLUS, Type: TOKEN_TYPE_OPERATOR}, {Value: 2, Type: TOKEN_TYPE_INTEGER} ] One thing that I haven't mentioned is that all tokens actually contain a bit more data. A pointer to the name of the file the token is from A pointer to their source text What line the token is on Where the token is in that line/how long it is All of this data is used to provide better error printouts And that's all the lexer really does. Of course, there's many-many more token types than I mentioned, and the lexer also supports hex literals, which are given the type TOKEN_TYPE_IDENTIFER .","title":"Lexer"},{"location":"how-it-works/#parser","text":"The parser takes the array of tokens which the lexer outputs, and builds an abstract syntax tree out of the tokens. And abstract syntax tree (AST) is a how a given program is represented, in this case, each \"leaf\" of the AST is either a Token object (which the lexer outputs) or a ASTNode object. For example, the AST of 1 + 2 would be: { Type: NODE_TYPE_BINARY, Left: { Type: NODE_TYPE_INTEGER, Value: 1 } Operator: { Type: TOKEN_TYPE_OPERATOR, Value: OPERATOR_PLUS } Right: { Type: NODE_TYPE_INTEGER, Value: 2 } } This concept is the same throughout the entire parser, you have an AST node, which has other AST nodes inside of it, which can represent any part of a program. Additionally, AST nodes also contain the same context data as tokens for accurate error reporting. The hard part is actually building the AST. I'm not going to go into how the AST is built, due to that being a better topic for a book, not documentation.","title":"Parser"},{"location":"how-it-works/#compiler","text":"The compiler takes the AST from the parser, and walks it, calling into CodeGen.rlx to generate machine code for each AST node it visits. The AST is walked by recursively enumerating each branch of the tree, with each different branch type having a different function which will enumerate any branches it has. Statements are compiled in mostly-similar ways, with a condition being compiled, then tested, and a conditional jump to either the next statement in a chain, or out of the current statement. More specifically: If statements are compiled by compiling the condition expression, testing it with result != 0 , and conditionally jumping into the Body for the statement. After the body, a jmp to the end of the statement stops any other branches from running. If the != 0 test fails, it jmp s to the next condition and body to be checked. For loops are compiled with the initialization step first, then a label to jump back to, then the condition (and a jump out of the loop when the condition is false), and then the loop body. After the body is the step expression, and a jump back to the start of the loop. Expressions are a little less label/ jmp intensive, but more complex to understand. So, to evaluate expressions, a stack is used to hold operands until they are needed, which means that: When we compile a binary operator, we should pop two operands of the stack, and push our result onto the stack. When we compile a unary operator, we should pop one operand, and push our result onto the the stack. When we compile a function call, we should pop as many operands as the function takes as parameters, and then push the return value onto the stack. As long as all generated code to evaluate expressions follows these rules, you can always trust an expression to leave its result on the stack. If this promise of operands/results is every broken, then there has been a code misgeneration, and something is wrong. However, since it isn't broken, expressions can be compiled into a series of very basic instructions.","title":"Compiler"},{"location":"how-it-works/#strings-and-other-stuff","text":"The compiler handles strings by allocating StrLen(String) + 1 bytes much of stack space for each string, and encodes string literals into 64 bit integers, which when stored in the stack, will build the correctly ordered string. When a string is used, it is replaced with a pointer into the stack where the string was written. Parameters are treated exactly the same as locals. Function calls are a bit of a mess. Since the register stack uses some of the parameter registers, first the register stack has to be saved, and then the parameter registers have to be 0'd, and finally, the parameters can be compiled and moved into the parameter registers. When a function never has a return statement compiled, it will automatically return with an undefined result. This is the only difference for omitting return , since the code to return from a function is automatically generated at the end of a function either way. Signed numbers are the only kind of numbers, unsigned operations require entirely different instructions for operations, which is why I don't plan on adding unsigned types.","title":"Strings And Other Stuff"},{"location":"how-it-works/#codegen","text":"This one will be shorter, I promise. CodeGen is a class which generates the correct bytes for lots of common AMD64 instructions, and automatically handles linking labels and jumps for you. CodeGen keeps a buffer containing the array of assembled code, along with buffers for book keeping info such as labels and fixups, which are applied before the code is written to the output file. The backbone of CodeGen is just a few methods: EmitREX(DestinationRegister, SourceRegister, ExtraREX) Which will build a \"REX prefix\" for an instruction, which will promote the instruction to use 64 bit registers and data, along with giving it access to the new GPRs R8-R15. EmitREXOpcodeModRM(Opcode, Mode, DestinationRegister, SourceRegister, ExtraREX) Which will build a REX prefix, write the opcode, and then write a \"ModRM\" byte, which controls the operands, and operand types of an instruction. EmitREXOpcodeModRMSIB(Opcode, Mode, DestinationRegister, Scale, IndexRegister, BaseRegister, ExtraREX) Which will build a REX prefix, opcode, and ModRM byte which uses the SIB addressing mode. SIB stands for (S)cale (I)ndex (B)ase, which allows you to have address calculations like FinalAddress = GetRegisterValue(SIB.Base) + (GetRegisterValue(SIB.Index) * SIB.Scale) , which are very useful for indexing arrays. ResolveAllLabels Which will resolve all labels, and return the linked code.","title":"CodeGen"},{"location":"how-it-works/#pebuilder","text":"A class that handles all the dirty work of building .exe files. Most of the code is spent building the headers, and setting the correct magic numbers. The only interesting bit is how the import address table (IAT) and .reloc (relocation) section is built. The IAT is built with one structure for each Dll that functions are imported from, and 2 parallel arrays which hold the actual import data. The structure holds a pointer to the first array, the number of entries in all of the arrays, a pointer to the Dll name, and a pointer to the 2rd array. Each entry in the 1st and 2nd array is identical until the .exe file is loaded, but before that, an entry considered part of a \"hint-name table\", which is made up of an ordinal value for the imported function, or a pointer to the function's name. I do not bother with ordinal values. Once the loader reads the hint-name table, each entry in the 2nd array is overwritten with a pointer to the function it originally imported, which PEBuilder links code to jump into. The .reloc section handles what should happen when the file can't be loaded at the specified base address, and contains pointers to every location inside of the code which references a static address. So, every use of a global variable, and every use of an import function, gets an entry in the .reloc section.","title":"PEBuilder"},{"location":"how-to-use-it/","text":"How To stable_version.exe is the compiler executable, and is run as: stable_version.exe [InputFile] [OutputExe] How to use it Run stable_version.exe with a UTF-8 encoded text (or .rlx file, the extension is unofficial, and not checked) as [InputFile] and a path to a .exe file as [OutputFile] . The compiler will run, report any errors, and write the output to [OutputFile] Of course, writing the input file is a majority of the work.","title":"How to use it"},{"location":"how-to-use-it/#how-to","text":"stable_version.exe is the compiler executable, and is run as: stable_version.exe [InputFile] [OutputExe]","title":"How To"},{"location":"how-to-use-it/#how-to-use-it","text":"Run stable_version.exe with a UTF-8 encoded text (or .rlx file, the extension is unofficial, and not checked) as [InputFile] and a path to a .exe file as [OutputFile] . The compiler will run, report any errors, and write the output to [OutputFile] Of course, writing the input file is a majority of the work.","title":"How to use it"}]}