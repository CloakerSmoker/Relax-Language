{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"(Replace with name) A compiled programming language, implemented entirely in AHK FAQ Q: What the fuck, why, dear god, why?! A: \u00af\\ (\u30c4) /\u00af Q: Wait, so this is an actual compiler? A: Yes, this script takes source code as input, tokenizes it, parses the tokens, optimizes the code a little bit, generates machine code for the parsed/optimized code, and finally builds a .exe file holding the compiled code. All without any outside tools. Every step is personally written by me. (Which probably isn't a good thing, but hey, I'm still proud) For more info, see the implementation details How to use #Include the file Interface.ahk , which will #Include all of the components of the compiler. Call (Replace with language class name).CompileToEXE with a string of code as the first parameter, and a path to an output file which the code will be compiled into. That's it. Except that most of the work is writing the string of code. How to do most of the work: (I recommend you follow these in the order 1-2-3 if you already know a C-like language, and 2-1-3 otherwise) For a quick(-ish) rundown of the syntax, and some quirks, see the basic syntax page . For a tutorial sort of thing, see the tutorial page . For a full writeup of the syntax, see the full syntax page .","title":"(Replace with name)"},{"location":"#replace-with-name","text":"A compiled programming language, implemented entirely in AHK","title":"(Replace with name)"},{"location":"#faq","text":"","title":"FAQ"},{"location":"#q-what-the-fuck-why-dear-god-why","text":"A: \u00af\\ (\u30c4) /\u00af","title":"Q: What the fuck, why, dear god, why?!"},{"location":"#q-wait-so-this-is-an-actual-compiler","text":"A: Yes, this script takes source code as input, tokenizes it, parses the tokens, optimizes the code a little bit, generates machine code for the parsed/optimized code, and finally builds a .exe file holding the compiled code. All without any outside tools. Every step is personally written by me. (Which probably isn't a good thing, but hey, I'm still proud) For more info, see the implementation details","title":"Q: Wait, so this is an actual compiler?"},{"location":"#how-to-use","text":"#Include the file Interface.ahk , which will #Include all of the components of the compiler. Call (Replace with language class name).CompileToEXE with a string of code as the first parameter, and a path to an output file which the code will be compiled into. That's it. Except that most of the work is writing the string of code.","title":"How to use"},{"location":"#how-to-do-most-of-the-work","text":"(I recommend you follow these in the order 1-2-3 if you already know a C-like language, and 2-1-3 otherwise) For a quick(-ish) rundown of the syntax, and some quirks, see the basic syntax page . For a tutorial sort of thing, see the tutorial page . For a full writeup of the syntax, see the full syntax page .","title":"How to do most of the work:"},{"location":"basic-syntax/","text":"The basic syntax It's pretty much C, but with minor changes. Although many things are borrowed from C, this is not a C compiler, and does not have all the features C has. Types Type names are changed to be more concise, and shorter. Integer types: Precision C Name (LanguageName) Name 8 bits char i8 16 bits short i16 32 bits long i32 64 bits long long / __int64 i64 Floating point types: Precision C Name (LanguageName) Name 32 bits float f32 64 bits double f64 Additionally, there is the void type, which is exactly what you'd expect it to be: a 64 bit integer (I can't remember why I made it this way). Of course, there are also pointer types, which follow C syntax of TypeName* . Pointer-pointer types are not implemented. General Things String literals are supported, and are replaced with an i8* to the given string. This i8* will point into the stack, so DO NOT try to free this memory. You can alter it, but changing the size of it, or overrunning it's length is VERY VERY BAD . If a function does not have a return, a return 0 is implicitly added. The magic entry-point function is named Main , and recieves a i64 parameter containing the number of command line arguments, along with a void* which is actually an array of i16* pointers to the individual command line arguments (Just like how in C you have ArgC and ArgV ) Main should have a return type of i32 , as the return value will be given to the Windows API ExitProcess function as the program's exit code. Now's a good time to note: If you prefix the name of a variable or function with __ , you are very likely to break something internal. The __ prefix is reserved, and I will be very unhappy with you if you use it. Assignment operators Most assignment operators act as you'd expect, except for *= . Since I really like the C syntax for pointers, but hate the C syntax to assign the value a pointer points to, the *= is used for assignment of a memory address to a new value. For example (PointerToAString + 90) *= 'H' would set the character at PointerToAString + 90 to be H . Since *= is taken, /= is also not implemented, += and -= are the only shorthand assignment operators. Additionally, since floating point number support is half-baked (at best), += and -= are not implemented for floating point numbers. So, that leaves us with the 4 assignment operators: := , *= , += , -= . Binary operators Another minor change is with the logical operators && and || . I can't think of a good way to generate code which will have these operators short-circuit, so they don't. Additionally, some operators are not implemented for floating point operands. This is mostly because I do floating point math with the (actually older than me) x87 FPU, and can't figure out the FPU instructions needed for some operators. These operators are: % (Modulo), && , and || . (You'll get an error message when you try to use them on floating point operands) Bitwise operators are allowed on all data types, simply because I think it's dumb that they aren't in some languages. If you want to mangle the floating point number format, go for it. The full list of binary operators: + , - , * , / , % (Modulo), = (regular equality, there's no == ), != , < , <= , > , >= , && , || , & , | , ^ Yes, I know there's no bit-shifts. If anyone besides me ever uses this language and wants bit-shifts, I'll implement them. Casting Casting between types is usually implicit, but if you want to explicitly cast between two obviously incompatible types, the As operator does it. The format is Operand As TypeName , just be careful with Operand , since As will take the closest thing on its left, so 1 + 2 As f32 would be parsed as 1 + (2 As f32) . This funky word operator is because I honestly fear for my mental and physical health if I have to modify the expression parser to handle C style casting. Unary operators Unary operators also have some odd bits, mostly because I forgot to implement how they work with different types. (All data types are treated like integers with unary operators) So make sure not to have something like -AFloatingPointNumber , because that'll cause some problems. 0 - AFloatingPointNumber works fine though. Oh, and AFloatingPointNumber with ++ or -- will also cause some problems. & Functions as you'd expect in C, same with * (which requires a pointer type as the operand). ++Variable and Variable++ also function as you'd expect, I made sure. ++PointerVariable is also implemented to increment PointerVariable by however big the value it points to is, ex: i64 SomeNumber := 99 i64* PointerVariable := &SomeNumber ++PointerVariable Would increment PointerVariable by 8 What next? For a tutorial sort of thing, see the tutorial page . For a full writeup of the syntax, see the full syntax page .","title":"Basic syntax"},{"location":"basic-syntax/#the-basic-syntax","text":"It's pretty much C, but with minor changes. Although many things are borrowed from C, this is not a C compiler, and does not have all the features C has.","title":"The basic syntax"},{"location":"basic-syntax/#types","text":"Type names are changed to be more concise, and shorter. Integer types: Precision C Name (LanguageName) Name 8 bits char i8 16 bits short i16 32 bits long i32 64 bits long long / __int64 i64 Floating point types: Precision C Name (LanguageName) Name 32 bits float f32 64 bits double f64 Additionally, there is the void type, which is exactly what you'd expect it to be: a 64 bit integer (I can't remember why I made it this way). Of course, there are also pointer types, which follow C syntax of TypeName* . Pointer-pointer types are not implemented.","title":"Types"},{"location":"basic-syntax/#general-things","text":"String literals are supported, and are replaced with an i8* to the given string. This i8* will point into the stack, so DO NOT try to free this memory. You can alter it, but changing the size of it, or overrunning it's length is VERY VERY BAD . If a function does not have a return, a return 0 is implicitly added. The magic entry-point function is named Main , and recieves a i64 parameter containing the number of command line arguments, along with a void* which is actually an array of i16* pointers to the individual command line arguments (Just like how in C you have ArgC and ArgV ) Main should have a return type of i32 , as the return value will be given to the Windows API ExitProcess function as the program's exit code. Now's a good time to note: If you prefix the name of a variable or function with __ , you are very likely to break something internal. The __ prefix is reserved, and I will be very unhappy with you if you use it.","title":"General Things"},{"location":"basic-syntax/#assignment-operators","text":"Most assignment operators act as you'd expect, except for *= . Since I really like the C syntax for pointers, but hate the C syntax to assign the value a pointer points to, the *= is used for assignment of a memory address to a new value. For example (PointerToAString + 90) *= 'H' would set the character at PointerToAString + 90 to be H . Since *= is taken, /= is also not implemented, += and -= are the only shorthand assignment operators. Additionally, since floating point number support is half-baked (at best), += and -= are not implemented for floating point numbers. So, that leaves us with the 4 assignment operators: := , *= , += , -= .","title":"Assignment operators"},{"location":"basic-syntax/#binary-operators","text":"Another minor change is with the logical operators && and || . I can't think of a good way to generate code which will have these operators short-circuit, so they don't. Additionally, some operators are not implemented for floating point operands. This is mostly because I do floating point math with the (actually older than me) x87 FPU, and can't figure out the FPU instructions needed for some operators. These operators are: % (Modulo), && , and || . (You'll get an error message when you try to use them on floating point operands) Bitwise operators are allowed on all data types, simply because I think it's dumb that they aren't in some languages. If you want to mangle the floating point number format, go for it. The full list of binary operators: + , - , * , / , % (Modulo), = (regular equality, there's no == ), != , < , <= , > , >= , && , || , & , | , ^ Yes, I know there's no bit-shifts. If anyone besides me ever uses this language and wants bit-shifts, I'll implement them.","title":"Binary operators"},{"location":"basic-syntax/#casting","text":"Casting between types is usually implicit, but if you want to explicitly cast between two obviously incompatible types, the As operator does it. The format is Operand As TypeName , just be careful with Operand , since As will take the closest thing on its left, so 1 + 2 As f32 would be parsed as 1 + (2 As f32) . This funky word operator is because I honestly fear for my mental and physical health if I have to modify the expression parser to handle C style casting.","title":"Casting"},{"location":"basic-syntax/#unary-operators","text":"Unary operators also have some odd bits, mostly because I forgot to implement how they work with different types. (All data types are treated like integers with unary operators) So make sure not to have something like -AFloatingPointNumber , because that'll cause some problems. 0 - AFloatingPointNumber works fine though. Oh, and AFloatingPointNumber with ++ or -- will also cause some problems. & Functions as you'd expect in C, same with * (which requires a pointer type as the operand). ++Variable and Variable++ also function as you'd expect, I made sure. ++PointerVariable is also implemented to increment PointerVariable by however big the value it points to is, ex: i64 SomeNumber := 99 i64* PointerVariable := &SomeNumber ++PointerVariable Would increment PointerVariable by 8","title":"Unary operators"},{"location":"basic-syntax/#what-next","text":"For a tutorial sort of thing, see the tutorial page . For a full writeup of the syntax, see the full syntax page .","title":"What next?"},{"location":"basic-tutorial/","text":"Good luck. Let's be honest here, nobody's going to use this language at all, let alone people who are new to programming. Either way, I've got time to waste. Get ready for a bad intro to low-level compiled languages. Ignore that part right above here In (Replace with language name) all variables and values have 'types'. This means that a variable can only hold one kind of thing, and that variables will only ever hold one kind of thing. Additionally, you can only use two variables when they have compatible types, so you can't do something like \"This Is My String Of Text\" * 9.2 . The way you decide what type a variable has is by 'declaring' the variable to be a certain type. In (language name) you declare a variable to be a certain type by typing a 'type name' along with the variable name, for example: i64 MyVariable f32 MyOtherVariable Additionally, you can include an 'initial value' after the declaration, like i64 MyVariable := 99 + 20 i32 MyOtherVariable := 10.5 Variables only need to be declared once, however, you can change a variable's value as much as you like. Great, now that we've got that down, we can move on to functions . A function is a way to wrap a bunch of lines of code which accomplish a task into a single thing . For example: You might have a function to print some text to the screen. A function has a few components: A name, which is used when 'calling' the function (calling = running it) A return type, which is what kind of value the function returns (returns = gives back to whatever is running the function) A list of parameters, and parameter types, which are values which are passed to the function to change what it does (passed = given to the function before it runs) The body of the function, which is simply lines of code that are run when the function is called. So, if we want to write a function to add two numbers, we'd start with the name and return type, along with a special word to signal we are defining a function. Which leaves us with the format: define ReturnType Name Now we'll replace ReturnType with the standard number type, which is i64 , and Name with the name of the function (we will call it Add ) define i64 Add Great, now we're getting there. Next we need a list of parameters. Remember that parameters are values given to a function, which change what it does. In this case, the parameters should be the two numbers to add, since an Add function which only does the math for 1 + 1 isn't very useful. The format for parameters is: (TypeName ParameterName, TypeName ParameterName) Where you can have as many TypeName ParameterName combos as you'd like Since we want to take two numbers, we'll replace TypeName with i64 . Then, ParameterName is the name of a variable, which will be set to whatever value is passed to this function. So, each parameter name needs to be unique. We'll go with LeftNumber and RightNumber for the names here, which leaves us with: (i64 LeftNumber, i64 RightNumber) And then we stick that onto the code from earlier and get: define i64 Add(i64 LeftNumber, i64 RightNumber) Alright, to save myself some pain and suffering, I'm just going to finish the function and explain it define i64 Add(i64 LeftNumber, i64 RightNumber) { return LeftNumber + RightNumber } return will run the code to the right of it, and give the result back to whatever is using this function. LeftNumber + RightNumber will use the two parameters, and add them. God does this tutorial suck","title":"Basic tutorial"},{"location":"basic-tutorial/#good-luck","text":"Let's be honest here, nobody's going to use this language at all, let alone people who are new to programming. Either way, I've got time to waste. Get ready for a bad intro to low-level compiled languages.","title":"Good luck."},{"location":"basic-tutorial/#ignore-that-part-right-above-here","text":"In (Replace with language name) all variables and values have 'types'. This means that a variable can only hold one kind of thing, and that variables will only ever hold one kind of thing. Additionally, you can only use two variables when they have compatible types, so you can't do something like \"This Is My String Of Text\" * 9.2 . The way you decide what type a variable has is by 'declaring' the variable to be a certain type. In (language name) you declare a variable to be a certain type by typing a 'type name' along with the variable name, for example: i64 MyVariable f32 MyOtherVariable Additionally, you can include an 'initial value' after the declaration, like i64 MyVariable := 99 + 20 i32 MyOtherVariable := 10.5 Variables only need to be declared once, however, you can change a variable's value as much as you like. Great, now that we've got that down, we can move on to functions . A function is a way to wrap a bunch of lines of code which accomplish a task into a single thing . For example: You might have a function to print some text to the screen. A function has a few components: A name, which is used when 'calling' the function (calling = running it) A return type, which is what kind of value the function returns (returns = gives back to whatever is running the function) A list of parameters, and parameter types, which are values which are passed to the function to change what it does (passed = given to the function before it runs) The body of the function, which is simply lines of code that are run when the function is called. So, if we want to write a function to add two numbers, we'd start with the name and return type, along with a special word to signal we are defining a function. Which leaves us with the format: define ReturnType Name Now we'll replace ReturnType with the standard number type, which is i64 , and Name with the name of the function (we will call it Add ) define i64 Add Great, now we're getting there. Next we need a list of parameters. Remember that parameters are values given to a function, which change what it does. In this case, the parameters should be the two numbers to add, since an Add function which only does the math for 1 + 1 isn't very useful. The format for parameters is: (TypeName ParameterName, TypeName ParameterName) Where you can have as many TypeName ParameterName combos as you'd like Since we want to take two numbers, we'll replace TypeName with i64 . Then, ParameterName is the name of a variable, which will be set to whatever value is passed to this function. So, each parameter name needs to be unique. We'll go with LeftNumber and RightNumber for the names here, which leaves us with: (i64 LeftNumber, i64 RightNumber) And then we stick that onto the code from earlier and get: define i64 Add(i64 LeftNumber, i64 RightNumber) Alright, to save myself some pain and suffering, I'm just going to finish the function and explain it define i64 Add(i64 LeftNumber, i64 RightNumber) { return LeftNumber + RightNumber } return will run the code to the right of it, and give the result back to whatever is using this function. LeftNumber + RightNumber will use the two parameters, and add them.","title":"Ignore that part right above here"},{"location":"basic-tutorial/#god-does-this-tutorial-suck","text":"","title":"God does this tutorial suck"},{"location":"details/","text":"Implementation Details Oooo, goodie, I get to explain the fun parts. Spoiler: Most of the lexer and parser follow the format described in this wonderful book (that I stopped following after the parser chapter) The optimizer and compiler themselves are all of my own design, same with CodeGen and PEBuilder . Of course, the holy bible of AMD64 parts one and three were wonderful reasources, along with the holy bible of AMD64 cheat sheet which I got most of the instruction encodings from. And you can't forget the absolute mess of deprecated things that is the MSDN page for the PE/ .exe file format along with the 25 year old article it recommends you read if you ever want to understand the format (Note: that article is still really good though). Lexer/Tokenizer Probably the most boring part, but hey, every house needs a foundation, and this is a very solid foundation. I think the last tokenizer bug I found was in October. Just a simple loop through all the characters, which consumes a single token per iteration, grouping as many characters as possible together into a single token. It uses lots of helpers, which honestly made it a breeze to write, and probably my favorite part to change, considering how simple it is. Parser The part that scares me the most. A good old fashioned recursive descent parser that handles everything but expressions. Expressions are handled by a somewhat seperate shunting yard parser, which works with Constants.ahk to get operator precendence/associativity. All kinds of functions inline/define/dllimport are stored inside of the .CurrentProgram.Functions object, which is why you can call a DllImport function just like any other, since they are treated nearly exactly the same. Yeah, that's it. The parser isn't very interesting. It parses, and that's that. Each different header in the full syntax listing is implemented as a rule in the parser, except the actual parser has a lot more rules I don't mention in the syntax. There's lots of ways the parser could be improved, like adding more helpers to increase the code density, and cleaning up the expression parser. However, it was originally written months ago, and I really don't want to fix it when there's nothing broken. Optimizer The most half-baked part. I had very high hopes for Optimizer , and I felt very cool while writing it, but it didn't work out. I felt like a real language designer until I realized that I'd need to redo it if I ever want to implement larger scale optimizations. The optimizer works a lot like the compiler, it walks the AST, and tries to replace each node it walks with a more optimized version, which sounded like a good way to do this at the time. The problem is that I wrote it to be too narrow. It only looks at one node at a time, and can't eliminate code that's after a return , since it only knows that it is trying to optimize a return , and doesn't know the outside context. This same problem applies to variables which may/may not hold constant values. All the optimizer knows is that it has a variable getting used here, it doesn't know that the variable might have been set to 1 the line before. So, overall, it was a good idea, but a bad implementation. Compiler The (second) most boring part. You wouldn't expect walking an AST and generating machine code to be boring, but after so many hours of debugging, it 100% is. Debugging compiled code isn't usually that bad, since you get a nice disassembly to look at. Except for when you're debugging code that DllCall is jumping into. Every single code generation bug until I got PEBuilder working was fixed by manually disassemling the code, and running it in my head. You ever count the stack-depth using your fingers? Well, I have. It's not fun. I like to think that this struggle made me a better programmer, but it really just made me sad. Thanks to CodeGen.ahk the actual code generation is all done behind the scenes, and inside of the compiler you get an assembly-like interface from CodeGen , which is nice. What's not as nice is the number of shims and odd-implementations I had to put in. For example, expressions used to be evaluated using the CPU stack to hold operands until use, but then I realized that the stack is in memory, and memory is slow. So, I sat there thinking and thinking. And then I had a terrrible idea. In the x87 FPU, registers work as a stack, which is a massive pain to deal with. But of course, my genius idea was to use [RCX, RDX, R8-R13] as a fake stack, which is dumped onto the real stack when another register is needed past R13 . This was a stupid excuse to avoid reading about real register allocation techniques, but it does work. Another fun one is how string literals are handled: Originally, before compiling to .exe , I'd just DllCall into the compiled code, which meant I could just use AHK to store a string in memory, and use the AHK-stored version in the compiled code. Except that wouldn't work in a context that AHK isn't setting up for me. So, I came up with a genius plan. I'd just push 8 characters of the string onto the stack, in reverse. Through lots of mental gymnastics, I figured out a way to do this as well. Except now that I compile to .exe , I can just store string literals in the .exe file (which I don't do, putting them on the stack works fine enough, I don't plan to fix it). Yeah, so the compiler is theoretically the coolest part of the entire thing, but I made lots of poor choices, and turned it into a chore to work on. CodeGen My second-favorite part. I mostly just like the fact that by calling into CodeGen , the correct magic numbers that the magic rock inside your computer understands are generated. At first, I hated AMD64 entirely. It seemed so overcomplicated (which it is), but after slowly reading through the manuals for about 6 months, I finally managed to wrap my head around it. And I abused that power as much as possible in CodeGen . CodeGen uses just a few helper methods to generate almost any instruction, with any register you could ever want to use. CodeGen even has a basic instruction selector, where you just give it some operands and it'll pick the encoding that can do an operation in the least number of bytes. Although it is a bit messy, CodeGen has classes for every register, which lets you write code that is super-close to assembly. CodeGen is even smart enough to have labels, which are resolved both forwards, and backwards (which isn't a big thing at all, I just really like it). God do I love CodeGen , it's got a cool name and everything. I even gave CodeGen a little brother, i386CodeGen which is used for generating the DOS stub in .exe files. PEBuilder PEBuilder feels like a fever dream. It's foreign to me, even though I wrote every single line of it. It took a solid 4 weeks of reading articles, taking apart other .exe files, and trying to build my own. And I can't remember a single day of that. I can remember having a working DOS stub generator, and then it's all blank until all of the sudden out.exe doesn't crash. Obviously, this is the part of the project I understand the least. I understand the parts of .exe files which I use, but nothing else; so I'm inclined to leave it as a bit of a black box until I've recovered from 4+ months of constant work on this language. Errors Big shocker, but this is actually my absolute favorite part of the project. If you haven't seen the error messages yet, try to compile define a_invalid_type_name Main() {} That, is a PrettyError() . I borrowed some of the visual style from Rust, but the implementation is my own. It's gone through a few versions, but at this point I think it's nearly bug-free (with correct input), and is a very good display of where the error is, and what the problem is. A life-saver during actual developement has been OnError(Func(\"ErrorCallstack\"), -1) , which adds a printout of the callstack to uncaught exceptions, which should really be in AHK by default. Other things Constants.ahk isn't perfectly named, but it holds the token type enum, the {OperatorString:TokenType} map, the operator precedence list, the operator precedence checks, the Token class, the Context class (which just holds info on where in the source code a token was from), the keyword value enum, the AST node type enum, and the AST node classes themselves. So, it's a boring file, but it's really the backbone of the entire project. Technically, Utility.ahk should have most/all of these things in it, but the name stuck. And I'm sick of super long files. Typing.ahk handles all of the typing rules. It's actually very boring, and really just tells you when two types are incompatible, and how to cast between two types. The compiler is split into a few categories, since the file was getting too long to debug, so things are split by what kind of node they compile.","title":"Implementation Details"},{"location":"details/#implementation-details","text":"Oooo, goodie, I get to explain the fun parts. Spoiler: Most of the lexer and parser follow the format described in this wonderful book (that I stopped following after the parser chapter) The optimizer and compiler themselves are all of my own design, same with CodeGen and PEBuilder . Of course, the holy bible of AMD64 parts one and three were wonderful reasources, along with the holy bible of AMD64 cheat sheet which I got most of the instruction encodings from. And you can't forget the absolute mess of deprecated things that is the MSDN page for the PE/ .exe file format along with the 25 year old article it recommends you read if you ever want to understand the format (Note: that article is still really good though).","title":"Implementation Details"},{"location":"details/#lexertokenizer","text":"Probably the most boring part, but hey, every house needs a foundation, and this is a very solid foundation. I think the last tokenizer bug I found was in October. Just a simple loop through all the characters, which consumes a single token per iteration, grouping as many characters as possible together into a single token. It uses lots of helpers, which honestly made it a breeze to write, and probably my favorite part to change, considering how simple it is.","title":"Lexer/Tokenizer"},{"location":"details/#parser","text":"The part that scares me the most. A good old fashioned recursive descent parser that handles everything but expressions. Expressions are handled by a somewhat seperate shunting yard parser, which works with Constants.ahk to get operator precendence/associativity. All kinds of functions inline/define/dllimport are stored inside of the .CurrentProgram.Functions object, which is why you can call a DllImport function just like any other, since they are treated nearly exactly the same. Yeah, that's it. The parser isn't very interesting. It parses, and that's that. Each different header in the full syntax listing is implemented as a rule in the parser, except the actual parser has a lot more rules I don't mention in the syntax. There's lots of ways the parser could be improved, like adding more helpers to increase the code density, and cleaning up the expression parser. However, it was originally written months ago, and I really don't want to fix it when there's nothing broken.","title":"Parser"},{"location":"details/#optimizer","text":"The most half-baked part. I had very high hopes for Optimizer , and I felt very cool while writing it, but it didn't work out. I felt like a real language designer until I realized that I'd need to redo it if I ever want to implement larger scale optimizations. The optimizer works a lot like the compiler, it walks the AST, and tries to replace each node it walks with a more optimized version, which sounded like a good way to do this at the time. The problem is that I wrote it to be too narrow. It only looks at one node at a time, and can't eliminate code that's after a return , since it only knows that it is trying to optimize a return , and doesn't know the outside context. This same problem applies to variables which may/may not hold constant values. All the optimizer knows is that it has a variable getting used here, it doesn't know that the variable might have been set to 1 the line before. So, overall, it was a good idea, but a bad implementation.","title":"Optimizer"},{"location":"details/#compiler","text":"The (second) most boring part. You wouldn't expect walking an AST and generating machine code to be boring, but after so many hours of debugging, it 100% is. Debugging compiled code isn't usually that bad, since you get a nice disassembly to look at. Except for when you're debugging code that DllCall is jumping into. Every single code generation bug until I got PEBuilder working was fixed by manually disassemling the code, and running it in my head. You ever count the stack-depth using your fingers? Well, I have. It's not fun. I like to think that this struggle made me a better programmer, but it really just made me sad. Thanks to CodeGen.ahk the actual code generation is all done behind the scenes, and inside of the compiler you get an assembly-like interface from CodeGen , which is nice. What's not as nice is the number of shims and odd-implementations I had to put in. For example, expressions used to be evaluated using the CPU stack to hold operands until use, but then I realized that the stack is in memory, and memory is slow. So, I sat there thinking and thinking. And then I had a terrrible idea. In the x87 FPU, registers work as a stack, which is a massive pain to deal with. But of course, my genius idea was to use [RCX, RDX, R8-R13] as a fake stack, which is dumped onto the real stack when another register is needed past R13 . This was a stupid excuse to avoid reading about real register allocation techniques, but it does work. Another fun one is how string literals are handled: Originally, before compiling to .exe , I'd just DllCall into the compiled code, which meant I could just use AHK to store a string in memory, and use the AHK-stored version in the compiled code. Except that wouldn't work in a context that AHK isn't setting up for me. So, I came up with a genius plan. I'd just push 8 characters of the string onto the stack, in reverse. Through lots of mental gymnastics, I figured out a way to do this as well. Except now that I compile to .exe , I can just store string literals in the .exe file (which I don't do, putting them on the stack works fine enough, I don't plan to fix it). Yeah, so the compiler is theoretically the coolest part of the entire thing, but I made lots of poor choices, and turned it into a chore to work on.","title":"Compiler"},{"location":"details/#codegen","text":"My second-favorite part. I mostly just like the fact that by calling into CodeGen , the correct magic numbers that the magic rock inside your computer understands are generated. At first, I hated AMD64 entirely. It seemed so overcomplicated (which it is), but after slowly reading through the manuals for about 6 months, I finally managed to wrap my head around it. And I abused that power as much as possible in CodeGen . CodeGen uses just a few helper methods to generate almost any instruction, with any register you could ever want to use. CodeGen even has a basic instruction selector, where you just give it some operands and it'll pick the encoding that can do an operation in the least number of bytes. Although it is a bit messy, CodeGen has classes for every register, which lets you write code that is super-close to assembly. CodeGen is even smart enough to have labels, which are resolved both forwards, and backwards (which isn't a big thing at all, I just really like it). God do I love CodeGen , it's got a cool name and everything. I even gave CodeGen a little brother, i386CodeGen which is used for generating the DOS stub in .exe files.","title":"CodeGen"},{"location":"details/#pebuilder","text":"PEBuilder feels like a fever dream. It's foreign to me, even though I wrote every single line of it. It took a solid 4 weeks of reading articles, taking apart other .exe files, and trying to build my own. And I can't remember a single day of that. I can remember having a working DOS stub generator, and then it's all blank until all of the sudden out.exe doesn't crash. Obviously, this is the part of the project I understand the least. I understand the parts of .exe files which I use, but nothing else; so I'm inclined to leave it as a bit of a black box until I've recovered from 4+ months of constant work on this language.","title":"PEBuilder"},{"location":"details/#errors","text":"Big shocker, but this is actually my absolute favorite part of the project. If you haven't seen the error messages yet, try to compile define a_invalid_type_name Main() {} That, is a PrettyError() . I borrowed some of the visual style from Rust, but the implementation is my own. It's gone through a few versions, but at this point I think it's nearly bug-free (with correct input), and is a very good display of where the error is, and what the problem is. A life-saver during actual developement has been OnError(Func(\"ErrorCallstack\"), -1) , which adds a printout of the callstack to uncaught exceptions, which should really be in AHK by default.","title":"Errors"},{"location":"details/#other-things","text":"Constants.ahk isn't perfectly named, but it holds the token type enum, the {OperatorString:TokenType} map, the operator precedence list, the operator precedence checks, the Token class, the Context class (which just holds info on where in the source code a token was from), the keyword value enum, the AST node type enum, and the AST node classes themselves. So, it's a boring file, but it's really the backbone of the entire project. Technically, Utility.ahk should have most/all of these things in it, but the name stuck. And I'm sick of super long files. Typing.ahk handles all of the typing rules. It's actually very boring, and really just tells you when two types are incompatible, and how to cast between two types. The compiler is split into a few categories, since the file was getting too long to debug, so things are split by what kind of node they compile.","title":"Other things"},{"location":"dumb-errors/","text":"A list stupid errors Big thanks to SALZKARTOFFEEEL#9805 for being the honorable judge of dumb errors. Apparently this variable is undeclared, while I am declaring it OH MY GOD. I have been forgetting to check the conditions of if statements There's just flat out no code for it don't you just hate when you can't assign your typed variable with := ?","title":"Dumb errors"},{"location":"dumb-errors/#a-list-stupid-errors","text":"","title":"A list stupid errors"},{"location":"dumb-errors/#big-thanks-to-salzkartoffeeel9805-for-being-the-honorable-judge-of-dumb-errors","text":"Apparently this variable is undeclared, while I am declaring it OH MY GOD. I have been forgetting to check the conditions of if statements There's just flat out no code for it don't you just hate when you can't assign your typed variable with := ?","title":"Big thanks to SALZKARTOFFEEEL#9805 for being the honorable judge of dumb errors."},{"location":"full-syntax/","text":"The full syntax description Program The compiler expects input code to be a \"program\", a program is defined as a list of the following statements: Import statements DllImport statements Define statements Global declarations Import Import statements follow the format: Import ModuleName Where ModuleName is the name of a built in module. The current list of built in modules is: Memory String Console DllImport DllImport statements follow the format: DllImport ReturnType FunctionName(ParameterTypeList) {DllFileName.dll, FunctionNameInsideDLL} ReturnType is the type that the function is expected to return. FunctionName is the name that the function will have internally, and is the name you use to call it. This name does not need to be the same as FunctionNameInsideDLL . ParameterTypeList is a list of comma-seperated types , without any names, since the parameter names are not needed. DllFileName.dll is the name of the file which contains the given function. FunctionNameInsideDLL is the name of the function, as it is exported in from the DLL. Define Define statements follow the format: Define ReturnType Functionname(ParameterList) { Body } ReturnType is the type that the function is expected to return. FunctionName is the name that the function will have, and is the name you use to call it. ParameterList is a list of comma-seperated type name pairs. Body is a list of statements . Global Global declarations follow the same format as regular declarations . However, global declarations make variables that are program -wide, and can be used from any function. Additionally, global declarations run just before Main is called (and ArgC/ArgV are set), making them a suitable method to run setup code. Statements Statements follow multiple different formats, depending on the type of statement. Declarations Keyword statements Expression statements It is important to note that this 'statement' category does not include the program statements, which are not allowed inside of functions. All of the above statements are allowed inside of functions and other structures such as for loops or if statements . Declarations Declarations follow the format(s): TypeName VariableName TypeName VariableName := Value TypeName is the type that the variable will have. VariableName is the name the variable will have. := Value is an optional assignment to give the variable a default value. Variables that do not have a default value should be considered to have an undefined value until they are otherwise assigned. Keywords Keyword statements follow multiple different formats, depending on the keyword used. if/else if/else statements for loops break/continue statements return statements These are all of the statements implemented, there are no while loops. If If statements follow a single variable format, depending on the structure of the if statement: if (Condition) { Body } else if (OtherCondition) { Body } else { Body } if is the required keyword to start an if statement. (Condition) an expression which will be tested in order to decide if the next block will run or not. Body (in all places) is a list of statements(#statements) which will run if the prior condition resulted in a non-zero result. else if the required keyword to add another condition and body to the entire if statement. else the required keyword to add a finaly body to the if statement, which will only run when no other conditions are met. else if can be repeated any number of times, for any number of conditions. There can only be one else for each if statement. For For loops follow the format: for (Init, Condition, Step) { Body } Init , Condition , and Step are all expressions which run at different points. Body is a list of statements(#statements) which will run each iteration of the loop. Init can optionally be a declaration and is run before the loop first stats, and never again. Condition is checked before the loop runs an iteration, and if it is false, the loop will stop. Step is run after each iteration of the loop. Break-Continue Break and continue both follow the format: Break Continue With no extra code. The break and continue statements are only valid inside of for loops . Return Return statements follow the format: Return Value Value is any kind of expression , which will be returned to the caller. Value must evaluate to a type compatible to the return type of the current function . Expression-Statements Expression statements follow the format: Expression Expression is any kind of expression . If Expression does not call a function or set a variable, it will be eliminated by the compiler during dead-code elimination. Expression Expressions follow many formats, examples: A := B + C (2 - E) / 2.5 9999 + *(G) % H Any unquoted text inside an expression is treated as a variable. Quoted text is treated as an i8* typed value. Numbers are treated as the smallest possible type to hold them (ex: 58 would be an i8 , 9999 would be an i16 ) Operands of any given operator must be a someone-similar type (ex: 2.6 * SomePointer is invalid). Operators are evaluated according to precedence and associativity, which is defined in Constants.ahk . Some operators may not be implemented for a given type Some expressions may be used as booleans inside of for loops or if statements . This is done by checking if the expressions results in 0 or not. Operator list Binary Operators Category Name Precedence Associativity Operators in category Assignment 0 Right := , += , -= , *= Logic 1 Right && , || Equality 2 Left != , = Comparison 3 Right < , <= , > , >= Unused 4 Addition 5 Left + , - Division 6 Left / , * , % Bitwise 7 Left & , | , ^ Module 8 N/A : Unary Operators Operator Prefix/Postfix ++ Both -- Both ! Prefix ~ Prefix * Prefix & Prefix","title":"Full syntax"},{"location":"full-syntax/#the-full-syntax-description","text":"","title":"The full syntax description"},{"location":"full-syntax/#program","text":"The compiler expects input code to be a \"program\", a program is defined as a list of the following statements: Import statements DllImport statements Define statements Global declarations","title":"Program"},{"location":"full-syntax/#import","text":"Import statements follow the format: Import ModuleName Where ModuleName is the name of a built in module. The current list of built in modules is: Memory String Console","title":"Import"},{"location":"full-syntax/#dllimport","text":"DllImport statements follow the format: DllImport ReturnType FunctionName(ParameterTypeList) {DllFileName.dll, FunctionNameInsideDLL} ReturnType is the type that the function is expected to return. FunctionName is the name that the function will have internally, and is the name you use to call it. This name does not need to be the same as FunctionNameInsideDLL . ParameterTypeList is a list of comma-seperated types , without any names, since the parameter names are not needed. DllFileName.dll is the name of the file which contains the given function. FunctionNameInsideDLL is the name of the function, as it is exported in from the DLL.","title":"DllImport"},{"location":"full-syntax/#define","text":"Define statements follow the format: Define ReturnType Functionname(ParameterList) { Body } ReturnType is the type that the function is expected to return. FunctionName is the name that the function will have, and is the name you use to call it. ParameterList is a list of comma-seperated type name pairs. Body is a list of statements .","title":"Define"},{"location":"full-syntax/#global","text":"Global declarations follow the same format as regular declarations . However, global declarations make variables that are program -wide, and can be used from any function. Additionally, global declarations run just before Main is called (and ArgC/ArgV are set), making them a suitable method to run setup code.","title":"Global"},{"location":"full-syntax/#statements","text":"Statements follow multiple different formats, depending on the type of statement. Declarations Keyword statements Expression statements It is important to note that this 'statement' category does not include the program statements, which are not allowed inside of functions. All of the above statements are allowed inside of functions and other structures such as for loops or if statements .","title":"Statements"},{"location":"full-syntax/#declarations","text":"Declarations follow the format(s): TypeName VariableName TypeName VariableName := Value TypeName is the type that the variable will have. VariableName is the name the variable will have. := Value is an optional assignment to give the variable a default value. Variables that do not have a default value should be considered to have an undefined value until they are otherwise assigned.","title":"Declarations"},{"location":"full-syntax/#keywords","text":"Keyword statements follow multiple different formats, depending on the keyword used. if/else if/else statements for loops break/continue statements return statements These are all of the statements implemented, there are no while loops.","title":"Keywords"},{"location":"full-syntax/#if","text":"If statements follow a single variable format, depending on the structure of the if statement: if (Condition) { Body } else if (OtherCondition) { Body } else { Body } if is the required keyword to start an if statement. (Condition) an expression which will be tested in order to decide if the next block will run or not. Body (in all places) is a list of statements(#statements) which will run if the prior condition resulted in a non-zero result. else if the required keyword to add another condition and body to the entire if statement. else the required keyword to add a finaly body to the if statement, which will only run when no other conditions are met. else if can be repeated any number of times, for any number of conditions. There can only be one else for each if statement.","title":"If"},{"location":"full-syntax/#for","text":"For loops follow the format: for (Init, Condition, Step) { Body } Init , Condition , and Step are all expressions which run at different points. Body is a list of statements(#statements) which will run each iteration of the loop. Init can optionally be a declaration and is run before the loop first stats, and never again. Condition is checked before the loop runs an iteration, and if it is false, the loop will stop. Step is run after each iteration of the loop.","title":"For"},{"location":"full-syntax/#break-continue","text":"Break and continue both follow the format: Break Continue With no extra code. The break and continue statements are only valid inside of for loops .","title":"Break-Continue"},{"location":"full-syntax/#return","text":"Return statements follow the format: Return Value Value is any kind of expression , which will be returned to the caller. Value must evaluate to a type compatible to the return type of the current function .","title":"Return"},{"location":"full-syntax/#expression-statements","text":"Expression statements follow the format: Expression Expression is any kind of expression . If Expression does not call a function or set a variable, it will be eliminated by the compiler during dead-code elimination.","title":"Expression-Statements"},{"location":"full-syntax/#expression","text":"Expressions follow many formats, examples: A := B + C (2 - E) / 2.5 9999 + *(G) % H Any unquoted text inside an expression is treated as a variable. Quoted text is treated as an i8* typed value. Numbers are treated as the smallest possible type to hold them (ex: 58 would be an i8 , 9999 would be an i16 ) Operands of any given operator must be a someone-similar type (ex: 2.6 * SomePointer is invalid). Operators are evaluated according to precedence and associativity, which is defined in Constants.ahk . Some operators may not be implemented for a given type Some expressions may be used as booleans inside of for loops or if statements . This is done by checking if the expressions results in 0 or not.","title":"Expression"},{"location":"full-syntax/#operator-list","text":"","title":"Operator list"},{"location":"full-syntax/#binary-operators","text":"Category Name Precedence Associativity Operators in category Assignment 0 Right := , += , -= , *= Logic 1 Right && , || Equality 2 Left != , = Comparison 3 Right < , <= , > , >= Unused 4 Addition 5 Left + , - Division 6 Left / , * , % Bitwise 7 Left & , | , ^ Module 8 N/A :","title":"Binary Operators"},{"location":"full-syntax/#unary-operators","text":"Operator Prefix/Postfix ++ Both -- Both ! Prefix ~ Prefix * Prefix & Prefix","title":"Unary Operators"},{"location":"module-console/","text":"The Console Module Top 10 reasons I hate the Windows Console API. DllImports Imported Function Name Imported Function Source GetStdHandle GetStdHandle, Kernel32 WriteConsole WriteConsoleW, Kernel32 SetConsoleTextAttribute SetConsoleTextAttribute, Kernel32 ReadConsole ReadConsoleW, Kernel32 Globals Full Global Name Default Value i64 Console:STDIN Console:GetStdHandle(-10) i64 Console:STDOUT Console:GetStdHandle(-11) i64 Console:STDERR Console:GetStdHandle(-12) i16 Console:Bright 0x08 i16 Console:Red 0x04 i16 Console:Green 0x02 i16 Console:Blue 0x01 Functions Function Name Return Type Parameter List Description AWrite i32 i8* AString Converts AString to a wide string, and prints it with Console:Write . AWriteLine i32 i8* AString Converts AString to a wide string, and prints it with Console:WriteLine . IWrite i32 i64 Number Converts Number to a wide string with String:IToW and prints it with Console:Write . IWriteLine i32 i64 Number Converts Number to a wide string with String:IToW and prints it with Console:WriteLine . Write i32 i16* WString Prints WString to Console:STDOUT using WriteConsole . WriteLine i32 i16* WString Prints WString using Console:Write and then \\r\\n using Console:Write . SetColor void i8 Foreground , i8 Background Changes the console text colors using SetConsoleTextAttribute . ResetColors void Resets the console text colors to white/black using Console:SetColor . TextColor void i8 Foreground Sets the console foreground color to Foreground and the background to black with Console:SetColor . ReadLine i16* Waits for the user to enter a line of input and press enter using ReadConsole . Usage Impact Console imports both String and Memory , which generate ~6 KB of code together. Console itself generates another ~4 KB of code on top of that, and has ~70 bytes of globals and imports. Console adds ~1 second to compile time.","title":"The Console Module"},{"location":"module-console/#the-console-module","text":"Top 10 reasons I hate the Windows Console API.","title":"The Console Module"},{"location":"module-console/#dllimports","text":"Imported Function Name Imported Function Source GetStdHandle GetStdHandle, Kernel32 WriteConsole WriteConsoleW, Kernel32 SetConsoleTextAttribute SetConsoleTextAttribute, Kernel32 ReadConsole ReadConsoleW, Kernel32","title":"DllImports"},{"location":"module-console/#globals","text":"Full Global Name Default Value i64 Console:STDIN Console:GetStdHandle(-10) i64 Console:STDOUT Console:GetStdHandle(-11) i64 Console:STDERR Console:GetStdHandle(-12) i16 Console:Bright 0x08 i16 Console:Red 0x04 i16 Console:Green 0x02 i16 Console:Blue 0x01","title":"Globals"},{"location":"module-console/#functions","text":"Function Name Return Type Parameter List Description AWrite i32 i8* AString Converts AString to a wide string, and prints it with Console:Write . AWriteLine i32 i8* AString Converts AString to a wide string, and prints it with Console:WriteLine . IWrite i32 i64 Number Converts Number to a wide string with String:IToW and prints it with Console:Write . IWriteLine i32 i64 Number Converts Number to a wide string with String:IToW and prints it with Console:WriteLine . Write i32 i16* WString Prints WString to Console:STDOUT using WriteConsole . WriteLine i32 i16* WString Prints WString using Console:Write and then \\r\\n using Console:Write . SetColor void i8 Foreground , i8 Background Changes the console text colors using SetConsoleTextAttribute . ResetColors void Resets the console text colors to white/black using Console:SetColor . TextColor void i8 Foreground Sets the console foreground color to Foreground and the background to black with Console:SetColor . ReadLine i16* Waits for the user to enter a line of input and press enter using ReadConsole .","title":"Functions"},{"location":"module-console/#usage-impact","text":"Console imports both String and Memory , which generate ~6 KB of code together. Console itself generates another ~4 KB of code on top of that, and has ~70 bytes of globals and imports. Console adds ~1 second to compile time.","title":"Usage Impact"},{"location":"module-memory/","text":"The Memory Module You'll never guess what this one does. DllImports Imported Function Name Imported Function Source GetProcessHeap GetProcessHeap, Kernel32 HeapAlloc HeapAlloc, Kernel32 HeapReAlloc HeapReAlloc, Kernel32 HeapFree HeapFree, Kernel32 Globals Full Global Name Default Value i64 Memory:ProcessHeap Memory:GetProcessHeap() i32 Memory:HEAP_ZERO_MEMORY 0x00000008 Functions Function Name Return Type Parameter List Description Alloc void* i64 Size Allocates Size bytes of memory on the heap, and returns a pointer to the allocated memory ReAlloc void* void* Memory , i64 NewSize Resizes Memory to NewSize and returns the new pointer to the memory Free i8 void* Memory Frees Memory Usage Impact Memory does not import any other modules, and only takes ~150 bytes of the output file for imports + generated code. Memory only exists so GetProcessHeap only needs to be called once.","title":"The Memory Module"},{"location":"module-memory/#the-memory-module","text":"You'll never guess what this one does.","title":"The Memory Module"},{"location":"module-memory/#dllimports","text":"Imported Function Name Imported Function Source GetProcessHeap GetProcessHeap, Kernel32 HeapAlloc HeapAlloc, Kernel32 HeapReAlloc HeapReAlloc, Kernel32 HeapFree HeapFree, Kernel32","title":"DllImports"},{"location":"module-memory/#globals","text":"Full Global Name Default Value i64 Memory:ProcessHeap Memory:GetProcessHeap() i32 Memory:HEAP_ZERO_MEMORY 0x00000008","title":"Globals"},{"location":"module-memory/#functions","text":"Function Name Return Type Parameter List Description Alloc void* i64 Size Allocates Size bytes of memory on the heap, and returns a pointer to the allocated memory ReAlloc void* void* Memory , i64 NewSize Resizes Memory to NewSize and returns the new pointer to the memory Free i8 void* Memory Frees Memory","title":"Functions"},{"location":"module-memory/#usage-impact","text":"Memory does not import any other modules, and only takes ~150 bytes of the output file for imports + generated code. Memory only exists so GetProcessHeap only needs to be called once.","title":"Usage Impact"},{"location":"module-string/","text":"The String Module Lots and lots of unsafe code. DllImports None Globals None Functions Function Name Return Type Parameter List Description ALen i32 i8* AString Counts how long the given ASCII string is by finding the null-terminator of the string. WLen i32 i16* WString Counts how long the given UTF-16 string is by finding the null-terminator of the string. WAEquals i8 i16* WString , i8* AString Compares the two given strings using String:WEquals after converting AString to a wide string. WEquals i8 i16* WStringOne , i16* WStringTwo Trims \\r\\n from both strings using String:WTrimNewline , and compares the two using String:WEqual . WEqual i8 i16* WStringOne , i16* WStringTwo Compares the two strings character by character, and returns 1 if the strings are equal. WTrimNewline i16* i16* WString Removes \\r\\n from the last two characters of the string, if they are there. AReverse i8* i8* AString Reverses AString character by character, leaving the null-terminator in place. WToI i64 i16* WString , i8* Success Trys to read an integer from WString , sets Succes to 1 when an integer was read, and returns it. WIsNumeric i8 i16 Character Returns if the character is in the range of '0'->'9'. IToA i8* i64 Number Converts Number to an ASCII string, including '-' if Number is negative. IToW i16* i64 Number Calls String:IToA , converts the result to a wide string with String:AToW and returns it. AToW i16* i8* AString Converts AString to a wide string, and returns the new wide string. Usage Impact String imports the Memory module, which alone is not very impactful. However, since String is entirely implemented in (Replace with language name), and many of the String: functions depend on each other, the module generates upwards of 5 KB of code, and adds around 900 MS to compile times. Yes, I know this is terrible. I blame AHK.","title":"The String Module"},{"location":"module-string/#the-string-module","text":"Lots and lots of unsafe code.","title":"The String Module"},{"location":"module-string/#dllimports","text":"None","title":"DllImports"},{"location":"module-string/#globals","text":"None","title":"Globals"},{"location":"module-string/#functions","text":"Function Name Return Type Parameter List Description ALen i32 i8* AString Counts how long the given ASCII string is by finding the null-terminator of the string. WLen i32 i16* WString Counts how long the given UTF-16 string is by finding the null-terminator of the string. WAEquals i8 i16* WString , i8* AString Compares the two given strings using String:WEquals after converting AString to a wide string. WEquals i8 i16* WStringOne , i16* WStringTwo Trims \\r\\n from both strings using String:WTrimNewline , and compares the two using String:WEqual . WEqual i8 i16* WStringOne , i16* WStringTwo Compares the two strings character by character, and returns 1 if the strings are equal. WTrimNewline i16* i16* WString Removes \\r\\n from the last two characters of the string, if they are there. AReverse i8* i8* AString Reverses AString character by character, leaving the null-terminator in place. WToI i64 i16* WString , i8* Success Trys to read an integer from WString , sets Succes to 1 when an integer was read, and returns it. WIsNumeric i8 i16 Character Returns if the character is in the range of '0'->'9'. IToA i8* i64 Number Converts Number to an ASCII string, including '-' if Number is negative. IToW i16* i64 Number Calls String:IToA , converts the result to a wide string with String:AToW and returns it. AToW i16* i8* AString Converts AString to a wide string, and returns the new wide string.","title":"Functions"},{"location":"module-string/#usage-impact","text":"String imports the Memory module, which alone is not very impactful. However, since String is entirely implemented in (Replace with language name), and many of the String: functions depend on each other, the module generates upwards of 5 KB of code, and adds around 900 MS to compile times. Yes, I know this is terrible. I blame AHK.","title":"Usage Impact"},{"location":"tutorial/","text":"So you want to write a program, eh? For if you don't know C, or have problems guessing syntax from examples See the basic tutorial before reading this. And since the basic tutorial is a mess, don't expect much more from this one. The goal: Write a nice hello world program So, we'll start with the Main function, which is automatically run when you run the output .exe file. Main always has the same definition: define i32 Main(i64 ArgC, void* ArgV) { } You can ignore the parameters for this tutorial, they might be explained later. \"But wait\" I hear you ask, \"How are we going to print 'hello world'?\". We're going to use the Console module, which is part of the painstakingly written standard library. To use the Console module, we need to import it with Import Console , so our code is now: Import Console define i32 Main(i64 ArgC, void* ArgV) { } Now, we need to get to printing. First we'll store the text we want to print into the variable Message , which will be a i8* . This is because a string of text is stored as a list of i8 values. Import Console define i32 Main(i64 ArgC, void* ArgV) { i8* Message := \"Hello world!\" } Now, we'll use the Console module's function AWrite to write Message to the console. The AWrite name stands for ASCII Write because i8* text is stored as ASCII characters, and require special treatment. In order to call AWrite , we need to prefix it with the module name, and a : character, like: Console:AWrite() Now we'll just add that, and get: Import Console define i32 Main(i64 ArgC, void* ArgV) { i8* Message := \"Hello world!\" Console:AWrite(Message) } Congrats, you just wrote hello world. You might notice that it takes ~2 seconds to compile. That is because I am an idiot. Summary So, you know the format for defining functions, declaring variables, along with setting variables, which is good. And just in case you didn't quite catch those, here they are in a list: Function definitions follow the format define ReturnType Name(ParameterList) {} Parameter lists follow the format ParameterType ParameterName, ParameterType ParameterName which can be repeated as much as you like. Function bodies are just lists of lines, including more function calls, variable declarations, and statements like if , for , and return Variable declarations follow the format TypeName VariableName with the optional := Value . Function calls follow the foramt Name(Parameters) where Parameters is a list of comma-seperated values. Function calls into modules are prefixed with ModuleName: the Main function is always declared as define i32 Main(i64 ArgC, void* ArgV) and is always the first function called.","title":"Tutorial"},{"location":"tutorial/#so-you-want-to-write-a-program-eh","text":"","title":"So you want to write a program, eh?"},{"location":"tutorial/#for-if-you-dont-know-c-or-have-problems-guessing-syntax-from-examples","text":"See the basic tutorial before reading this. And since the basic tutorial is a mess, don't expect much more from this one.","title":"For if you don't know C, or have problems guessing syntax from examples"},{"location":"tutorial/#the-goal-write-a-nice-hello-world-program","text":"So, we'll start with the Main function, which is automatically run when you run the output .exe file. Main always has the same definition: define i32 Main(i64 ArgC, void* ArgV) { } You can ignore the parameters for this tutorial, they might be explained later. \"But wait\" I hear you ask, \"How are we going to print 'hello world'?\". We're going to use the Console module, which is part of the painstakingly written standard library. To use the Console module, we need to import it with Import Console , so our code is now: Import Console define i32 Main(i64 ArgC, void* ArgV) { } Now, we need to get to printing. First we'll store the text we want to print into the variable Message , which will be a i8* . This is because a string of text is stored as a list of i8 values. Import Console define i32 Main(i64 ArgC, void* ArgV) { i8* Message := \"Hello world!\" } Now, we'll use the Console module's function AWrite to write Message to the console. The AWrite name stands for ASCII Write because i8* text is stored as ASCII characters, and require special treatment. In order to call AWrite , we need to prefix it with the module name, and a : character, like: Console:AWrite() Now we'll just add that, and get: Import Console define i32 Main(i64 ArgC, void* ArgV) { i8* Message := \"Hello world!\" Console:AWrite(Message) } Congrats, you just wrote hello world. You might notice that it takes ~2 seconds to compile. That is because I am an idiot.","title":"The goal: Write a nice hello world program"},{"location":"tutorial/#summary","text":"So, you know the format for defining functions, declaring variables, along with setting variables, which is good. And just in case you didn't quite catch those, here they are in a list: Function definitions follow the format define ReturnType Name(ParameterList) {} Parameter lists follow the format ParameterType ParameterName, ParameterType ParameterName which can be repeated as much as you like. Function bodies are just lists of lines, including more function calls, variable declarations, and statements like if , for , and return Variable declarations follow the format TypeName VariableName with the optional := Value . Function calls follow the foramt Name(Parameters) where Parameters is a list of comma-seperated values. Function calls into modules are prefixed with ModuleName: the Main function is always declared as define i32 Main(i64 ArgC, void* ArgV) and is always the first function called.","title":"Summary"},{"location":"undefined/","text":"Disclaimer I reserve the right to call any code I don't like undefined behavior. Same with any code which seems to trigger a compiler bug. Also the same with any code I can't read. Also the same with any code that's so dumb I can't believe that it didn't get caught as an error. Undefined-Behavior When you write code which does things I didn't expect. For example, overwriting a bunch of the stack by using a string literal's address in an unbounded loop. Well, not that example, since I expect it now. I'm not going to stop you from crashing your own program though. Here's a good one: &1 . 'What will it do?' you might ask, well, I've got no clue. It's undefined, and I can't be bothered to check what happens. Just don't do it. Undefined-Values When I've forgotten to set a variable to something, or you go peeking into something internal, then you've got an undefined value. This includes variables before they are initialized, or other places where I've forgotten to make an operator actually work. How to deal with undefined-anything Well, it's a: Doctor, it hurts when I do X kind of situation, just don't do X. Unless it's a perfectly normal operation which doesn't work, then maybe let me know.","title":"Undefined"},{"location":"undefined/#disclaimer","text":"I reserve the right to call any code I don't like undefined behavior. Same with any code which seems to trigger a compiler bug. Also the same with any code I can't read. Also the same with any code that's so dumb I can't believe that it didn't get caught as an error.","title":"Disclaimer"},{"location":"undefined/#undefined-behavior","text":"When you write code which does things I didn't expect. For example, overwriting a bunch of the stack by using a string literal's address in an unbounded loop. Well, not that example, since I expect it now. I'm not going to stop you from crashing your own program though. Here's a good one: &1 . 'What will it do?' you might ask, well, I've got no clue. It's undefined, and I can't be bothered to check what happens. Just don't do it.","title":"Undefined-Behavior"},{"location":"undefined/#undefined-values","text":"When I've forgotten to set a variable to something, or you go peeking into something internal, then you've got an undefined value. This includes variables before they are initialized, or other places where I've forgotten to make an operator actually work.","title":"Undefined-Values"},{"location":"undefined/#how-to-deal-with-undefined-anything","text":"Well, it's a: Doctor, it hurts when I do X kind of situation, just don't do X. Unless it's a perfectly normal operation which doesn't work, then maybe let me know.","title":"How to deal with undefined-anything"}]}