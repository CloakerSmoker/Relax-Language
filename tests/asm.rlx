#Require ./src/lib/Console.rlx

define i64 ReturnParam(i64 A, i64* B) asm {
	mov, {rsi} as i8*, di
	
	mov, rax, rdi
	mov, ax, 90
	
	mov, si, di
	mov, six, dix
	ret
}

define i32 Abc(i64 a) asm {
	mov, rax, rdi
	start:
	dec, rax
	test, rax, rax
	jnz, start
	ret
}

define i32 IncRAX() asm {
	push, rax
	lock xchg, rbx, {rsp} as i64*
	inc, rbx
	lock xchg, rbx, {rsp} as i64*
	pop, rax
	ret
}

define i32 Main() {
	i64 B := 0
	
	asm (rdi := 696968, rax := &B) {
		xchg, rax, rdi
		call, @IncRAX
		mov, {rdi} As i64*, rax
	}
	
	Print(B)
	PrintCharacter(',')
	Print(ReturnParam(9000000, &B))
	PrintCharacter(',')
	Print(B)
	PrintCharacter(',')
	Print(Abc(1))
	
	; Ensure that the unsigned displacement isn't encoded into a signed type
	;  which will be incorrect.
	
	i8[0x200] Test
	
	for (i32 Index := 0, Index < 0x100, Index++) {
		Test[Index] := 0
	}
	
	asm (rax := &Test[0x100]) {
		; Writes to 0x180 if the displacement is encoded correct
		; Writes to 0x80 otherwise
		
		mov, {rax + 0x80} As i8*, 1
	}
	
	Print(",%i%i", Test[0x80], Test[0x180])
	
	asm {mov, rax, 0}
	
	return 0
}
