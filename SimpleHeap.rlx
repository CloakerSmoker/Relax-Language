struct SimpleHeap {
	/* Backing struct stored at the start of the program break to track heap size/next allocation location */
	
	void* Start,
	void* End,
	i64 Size,
	i64 NextOffset
}

i32 DEFAULT_HEAP_SIZE := 0x500000

define SimpleHeap* SimpleHeapInit() {
	linux {
		void* ProgramBreak := syscall(12, 0)
		
		syscall(12, ProgramBreak + DEFAULT_HEAP_SIZE)
		
		SimpleHeap* Heap := ProgramBreak As SimpleHeap*
		
		Heap->Start := ProgramBreak
		Heap->End := ProgramBreak + DEFAULT_HEAP_SIZE
		Heap->Size := DEFAULT_HEAP_SIZE
		Heap->NextOffset := SimpleHeap.Size
		
		return Heap
	}
}

SimpleHeap* ProcessHeap := SimpleHeapInit()

declare void AWrite(i8*)
declare void AWriteLine(i8*)
declare void IWriteLine(i64)
declare void IWriteHexLine(i64)
declare void IWrite(i64)
declare void IWriteHex(i64)

define void SimpleHeapGrow() {	
	ProcessHeap->End := syscall(12, ProcessHeap->End + DEFAULT_HEAP_SIZE)
}

define void* SimpleHeapAlloc(i64 Size) {
	void* Result := ProcessHeap->Start + ProcessHeap->NextOffset
	
	while ((Result + Size) >= (ProcessHeap->End - 0x10000)) {		
		SimpleHeapGrow()
	}
	
	Result[0] := Size
	ProcessHeap->NextOffset += Size + 8
	
	return Result + 8
}

define void SimpleHeapCopyClear(i8* From, i8* To, i64 Size) {
/* 	AWrite("SHCC ")
	IWriteHex(From)
	AWrite(":")
	IWriteHex(To)
	AWrite("[")
	IWrite(Size)
	AWriteLine("]") */
	
	for (i64 Index := 0, Index <= Size, Index += 1) {
		To[Index] := From[Index]
		/* Todo: Put this back in, once you figure out who's using ReAlloc'd memory
		From[Index] := 'R' */
	}
}

define void* SimpleHeapReAlloc(void* Memory, i64 NewSize) {
	i64 OldSize := (Memory - 8)[0]
	
	if (OldSize > NewSize) {
		return Memory
	}
	
	void* NewMemory := SimpleHeapAlloc(NewSize)
	
/* 	AWrite("SHRA ")
	IWriteHex(Memory)
	AWrite(":")
	IWriteHex(NewMemory)
	AWrite("[")
	IWrite(NewSize)
	AWriteLine("]") */
	
	SimpleHeapCopyClear(Memory, NewMemory, OldSize)
	
	return NewMemory
}